import { importShared } from '../__federation_fn_import-6j1WaWuS.js';
import { a as getAugmentedNamespace, c as commonjsGlobal, g as getDefaultExportFromCjs } from '../_commonjsHelpers-E-ZsRS8r.js';
import { F as FilledInput, _ as _objectWithoutPropertiesLoose, u as useThemeProps, a as _inheritsLoose, f as forceReflow, T as Transition, b as useSlotProps, c as Typography$4, I as IconButton$e, d as useControlled, e as useEventCallback, g as useEnhancedEffect, h as useId, i as useForkRef, M as MenuItem$f, j as MenuList, B as ButtonBase, k as InputAdornment$5, l as useFormControl, v as visuallyHidden, m as InputLabel$i, n as FormHelperText$k, o as FormControl$n, p as TextField$n, q as Fade, r as TransitionGroup, s as useMediaQuery$1, G as Grow, t as FocusTrap, w as ownerDocument, P as Paper$2, x as Popper, y as Button$e, D as DialogActions$4, L as List, z as ListItem, C as Chip$3, A as resolveComponentProps, E as Dialog$5, H as dialogClasses, J as DialogContent$4 } from '../Dialog-pq3uXhUb.js';
import { t as blue, p as alpha, f as capitalize$1, v as reactIsExports } from '../defaultTheme-Cs5GvShw.js';
import { C as ChromePicker, D as Dropzone } from '../index-BwIXOGNx.js';
import { _ as _extends$3, f as createSvgIcon, a as generateUtilityClass, g as generateUtilityClasses, c as clsx, s as styled, b as composeClasses } from '../createSvgIcon-B_z4_1vV.js';
import { j as jsxRuntimeExports } from '../jsx-runtime-DBvYS8qm.js';
import { b as useTheme$1 } from '../useTheme-BW6JIzu-.js';
import { p as propTypesExports } from '../index-Ck0FAP3l.js';
import { r as reactExports } from '../index-BW3DHH-H.js';

const JsonConfig = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    get ConfigGeneric () { return ConfigGeneric; },
    get ConfigPanel () { return ConfigPanel; },
    get JsonConfig () { return JsonConfig$1; },
    get JsonConfigComponent () { return JsonConfigComponent; }
}, Symbol.toStringTag, { value: 'Module' }));

const PropTypes$7 = await importShared('prop-types');

const refType = PropTypes$7.oneOfType([PropTypes$7.func, PropTypes$7.object]);

// This is a generated file. Do not edit.
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;

var unicode = {
	Space_Separator: Space_Separator,
	ID_Start: ID_Start,
	ID_Continue: ID_Continue
};

var util = {
    isSpaceSeparator (c) {
        return typeof c === 'string' && unicode.Space_Separator.test(c)
    },

    isIdStartChar (c) {
        return typeof c === 'string' && (
            (c >= 'a' && c <= 'z') ||
        (c >= 'A' && c <= 'Z') ||
        (c === '$') || (c === '_') ||
        unicode.ID_Start.test(c)
        )
    },

    isIdContinueChar (c) {
        return typeof c === 'string' && (
            (c >= 'a' && c <= 'z') ||
        (c >= 'A' && c <= 'Z') ||
        (c >= '0' && c <= '9') ||
        (c === '$') || (c === '_') ||
        (c === '\u200C') || (c === '\u200D') ||
        unicode.ID_Continue.test(c)
        )
    },

    isDigit (c) {
        return typeof c === 'string' && /[0-9]/.test(c)
    },

    isHexDigit (c) {
        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)
    },
};

let source;
let parseState;
let stack;
let pos;
let line;
let column;
let token;
let key;
let root$1;

var parse = function parse (text, reviver) {
    source = String(text);
    parseState = 'start';
    stack = [];
    pos = 0;
    line = 1;
    column = 0;
    token = undefined;
    key = undefined;
    root$1 = undefined;

    do {
        token = lex();

        // This code is unreachable.
        // if (!parseStates[parseState]) {
        //     throw invalidParseState()
        // }

        parseStates[parseState]();
    } while (token.type !== 'eof')

    if (typeof reviver === 'function') {
        return internalize({'': root$1}, '', reviver)
    }

    return root$1
};

function internalize (holder, name, reviver) {
    const value = holder[name];
    if (value != null && typeof value === 'object') {
        if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                const key = String(i);
                const replacement = internalize(value, key, reviver);
                if (replacement === undefined) {
                    delete value[key];
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                    });
                }
            }
        } else {
            for (const key in value) {
                const replacement = internalize(value, key, reviver);
                if (replacement === undefined) {
                    delete value[key];
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                    });
                }
            }
        }
    }

    return reviver.call(holder, name, value)
}

let lexState;
let buffer;
let doubleQuote;
let sign;
let c;

function lex () {
    lexState = 'default';
    buffer = '';
    doubleQuote = false;
    sign = 1;

    for (;;) {
        c = peek();

        // This code is unreachable.
        // if (!lexStates[lexState]) {
        //     throw invalidLexState(lexState)
        // }

        const token = lexStates[lexState]();
        if (token) {
            return token
        }
    }
}

function peek () {
    if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos))
    }
}

function read () {
    const c = peek();

    if (c === '\n') {
        line++;
        column = 0;
    } else if (c) {
        column += c.length;
    } else {
        column++;
    }

    if (c) {
        pos += c.length;
    }

    return c
}

const lexStates = {
    default () {
        switch (c) {
        case '\t':
        case '\v':
        case '\f':
        case ' ':
        case '\u00A0':
        case '\uFEFF':
        case '\n':
        case '\r':
        case '\u2028':
        case '\u2029':
            read();
            return

        case '/':
            read();
            lexState = 'comment';
            return

        case undefined:
            read();
            return newToken('eof')
        }

        if (util.isSpaceSeparator(c)) {
            read();
            return
        }

        // This code is unreachable.
        // if (!lexStates[parseState]) {
        //     throw invalidLexState(parseState)
        // }

        return lexStates[parseState]()
    },

    comment () {
        switch (c) {
        case '*':
            read();
            lexState = 'multiLineComment';
            return

        case '/':
            read();
            lexState = 'singleLineComment';
            return
        }

        throw invalidChar(read())
    },

    multiLineComment () {
        switch (c) {
        case '*':
            read();
            lexState = 'multiLineCommentAsterisk';
            return

        case undefined:
            throw invalidChar(read())
        }

        read();
    },

    multiLineCommentAsterisk () {
        switch (c) {
        case '*':
            read();
            return

        case '/':
            read();
            lexState = 'default';
            return

        case undefined:
            throw invalidChar(read())
        }

        read();
        lexState = 'multiLineComment';
    },

    singleLineComment () {
        switch (c) {
        case '\n':
        case '\r':
        case '\u2028':
        case '\u2029':
            read();
            lexState = 'default';
            return

        case undefined:
            read();
            return newToken('eof')
        }

        read();
    },

    value () {
        switch (c) {
        case '{':
        case '[':
            return newToken('punctuator', read())

        case 'n':
            read();
            literal('ull');
            return newToken('null', null)

        case 't':
            read();
            literal('rue');
            return newToken('boolean', true)

        case 'f':
            read();
            literal('alse');
            return newToken('boolean', false)

        case '-':
        case '+':
            if (read() === '-') {
                sign = -1;
            }

            lexState = 'sign';
            return

        case '.':
            buffer = read();
            lexState = 'decimalPointLeading';
            return

        case '0':
            buffer = read();
            lexState = 'zero';
            return

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            buffer = read();
            lexState = 'decimalInteger';
            return

        case 'I':
            read();
            literal('nfinity');
            return newToken('numeric', Infinity)

        case 'N':
            read();
            literal('aN');
            return newToken('numeric', NaN)

        case '"':
        case "'":
            doubleQuote = (read() === '"');
            buffer = '';
            lexState = 'string';
            return
        }

        throw invalidChar(read())
    },

    identifierNameStartEscape () {
        if (c !== 'u') {
            throw invalidChar(read())
        }

        read();
        const u = unicodeEscape();
        switch (u) {
        case '$':
        case '_':
            break

        default:
            if (!util.isIdStartChar(u)) {
                throw invalidIdentifier()
            }

            break
        }

        buffer += u;
        lexState = 'identifierName';
    },

    identifierName () {
        switch (c) {
        case '$':
        case '_':
        case '\u200C':
        case '\u200D':
            buffer += read();
            return

        case '\\':
            read();
            lexState = 'identifierNameEscape';
            return
        }

        if (util.isIdContinueChar(c)) {
            buffer += read();
            return
        }

        return newToken('identifier', buffer)
    },

    identifierNameEscape () {
        if (c !== 'u') {
            throw invalidChar(read())
        }

        read();
        const u = unicodeEscape();
        switch (u) {
        case '$':
        case '_':
        case '\u200C':
        case '\u200D':
            break

        default:
            if (!util.isIdContinueChar(u)) {
                throw invalidIdentifier()
            }

            break
        }

        buffer += u;
        lexState = 'identifierName';
    },

    sign () {
        switch (c) {
        case '.':
            buffer = read();
            lexState = 'decimalPointLeading';
            return

        case '0':
            buffer = read();
            lexState = 'zero';
            return

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            buffer = read();
            lexState = 'decimalInteger';
            return

        case 'I':
            read();
            literal('nfinity');
            return newToken('numeric', sign * Infinity)

        case 'N':
            read();
            literal('aN');
            return newToken('numeric', NaN)
        }

        throw invalidChar(read())
    },

    zero () {
        switch (c) {
        case '.':
            buffer += read();
            lexState = 'decimalPoint';
            return

        case 'e':
        case 'E':
            buffer += read();
            lexState = 'decimalExponent';
            return

        case 'x':
        case 'X':
            buffer += read();
            lexState = 'hexadecimal';
            return
        }

        return newToken('numeric', sign * 0)
    },

    decimalInteger () {
        switch (c) {
        case '.':
            buffer += read();
            lexState = 'decimalPoint';
            return

        case 'e':
        case 'E':
            buffer += read();
            lexState = 'decimalExponent';
            return
        }

        if (util.isDigit(c)) {
            buffer += read();
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    decimalPointLeading () {
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalFraction';
            return
        }

        throw invalidChar(read())
    },

    decimalPoint () {
        switch (c) {
        case 'e':
        case 'E':
            buffer += read();
            lexState = 'decimalExponent';
            return
        }

        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalFraction';
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    decimalFraction () {
        switch (c) {
        case 'e':
        case 'E':
            buffer += read();
            lexState = 'decimalExponent';
            return
        }

        if (util.isDigit(c)) {
            buffer += read();
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    decimalExponent () {
        switch (c) {
        case '+':
        case '-':
            buffer += read();
            lexState = 'decimalExponentSign';
            return
        }

        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalExponentInteger';
            return
        }

        throw invalidChar(read())
    },

    decimalExponentSign () {
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalExponentInteger';
            return
        }

        throw invalidChar(read())
    },

    decimalExponentInteger () {
        if (util.isDigit(c)) {
            buffer += read();
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    hexadecimal () {
        if (util.isHexDigit(c)) {
            buffer += read();
            lexState = 'hexadecimalInteger';
            return
        }

        throw invalidChar(read())
    },

    hexadecimalInteger () {
        if (util.isHexDigit(c)) {
            buffer += read();
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    string () {
        switch (c) {
        case '\\':
            read();
            buffer += escape$1();
            return

        case '"':
            if (doubleQuote) {
                read();
                return newToken('string', buffer)
            }

            buffer += read();
            return

        case "'":
            if (!doubleQuote) {
                read();
                return newToken('string', buffer)
            }

            buffer += read();
            return

        case '\n':
        case '\r':
            throw invalidChar(read())

        case '\u2028':
        case '\u2029':
            separatorChar(c);
            break

        case undefined:
            throw invalidChar(read())
        }

        buffer += read();
    },

    start () {
        switch (c) {
        case '{':
        case '[':
            return newToken('punctuator', read())

        // This code is unreachable since the default lexState handles eof.
        // case undefined:
        //     return newToken('eof')
        }

        lexState = 'value';
    },

    beforePropertyName () {
        switch (c) {
        case '$':
        case '_':
            buffer = read();
            lexState = 'identifierName';
            return

        case '\\':
            read();
            lexState = 'identifierNameStartEscape';
            return

        case '}':
            return newToken('punctuator', read())

        case '"':
        case "'":
            doubleQuote = (read() === '"');
            lexState = 'string';
            return
        }

        if (util.isIdStartChar(c)) {
            buffer += read();
            lexState = 'identifierName';
            return
        }

        throw invalidChar(read())
    },

    afterPropertyName () {
        if (c === ':') {
            return newToken('punctuator', read())
        }

        throw invalidChar(read())
    },

    beforePropertyValue () {
        lexState = 'value';
    },

    afterPropertyValue () {
        switch (c) {
        case ',':
        case '}':
            return newToken('punctuator', read())
        }

        throw invalidChar(read())
    },

    beforeArrayValue () {
        if (c === ']') {
            return newToken('punctuator', read())
        }

        lexState = 'value';
    },

    afterArrayValue () {
        switch (c) {
        case ',':
        case ']':
            return newToken('punctuator', read())
        }

        throw invalidChar(read())
    },

    end () {
        // This code is unreachable since it's handled by the default lexState.
        // if (c === undefined) {
        //     read()
        //     return newToken('eof')
        // }

        throw invalidChar(read())
    },
};

function newToken (type, value) {
    return {
        type,
        value,
        line,
        column,
    }
}

function literal (s) {
    for (const c of s) {
        const p = peek();

        if (p !== c) {
            throw invalidChar(read())
        }

        read();
    }
}

function escape$1 () {
    const c = peek();
    switch (c) {
    case 'b':
        read();
        return '\b'

    case 'f':
        read();
        return '\f'

    case 'n':
        read();
        return '\n'

    case 'r':
        read();
        return '\r'

    case 't':
        read();
        return '\t'

    case 'v':
        read();
        return '\v'

    case '0':
        read();
        if (util.isDigit(peek())) {
            throw invalidChar(read())
        }

        return '\0'

    case 'x':
        read();
        return hexEscape()

    case 'u':
        read();
        return unicodeEscape()

    case '\n':
    case '\u2028':
    case '\u2029':
        read();
        return ''

    case '\r':
        read();
        if (peek() === '\n') {
            read();
        }

        return ''

    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        throw invalidChar(read())

    case undefined:
        throw invalidChar(read())
    }

    return read()
}

function hexEscape () {
    let buffer = '';
    let c = peek();

    if (!util.isHexDigit(c)) {
        throw invalidChar(read())
    }

    buffer += read();

    c = peek();
    if (!util.isHexDigit(c)) {
        throw invalidChar(read())
    }

    buffer += read();

    return String.fromCodePoint(parseInt(buffer, 16))
}

function unicodeEscape () {
    let buffer = '';
    let count = 4;

    while (count-- > 0) {
        const c = peek();
        if (!util.isHexDigit(c)) {
            throw invalidChar(read())
        }

        buffer += read();
    }

    return String.fromCodePoint(parseInt(buffer, 16))
}

const parseStates = {
    start () {
        if (token.type === 'eof') {
            throw invalidEOF()
        }

        push();
    },

    beforePropertyName () {
        switch (token.type) {
        case 'identifier':
        case 'string':
            key = token.value;
            parseState = 'afterPropertyName';
            return

        case 'punctuator':
            // This code is unreachable since it's handled by the lexState.
            // if (token.value !== '}') {
            //     throw invalidToken()
            // }

            pop();
            return

        case 'eof':
            throw invalidEOF()
        }

        // This code is unreachable since it's handled by the lexState.
        // throw invalidToken()
    },

    afterPropertyName () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator' || token.value !== ':') {
        //     throw invalidToken()
        // }

        if (token.type === 'eof') {
            throw invalidEOF()
        }

        parseState = 'beforePropertyValue';
    },

    beforePropertyValue () {
        if (token.type === 'eof') {
            throw invalidEOF()
        }

        push();
    },

    beforeArrayValue () {
        if (token.type === 'eof') {
            throw invalidEOF()
        }

        if (token.type === 'punctuator' && token.value === ']') {
            pop();
            return
        }

        push();
    },

    afterPropertyValue () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }

        if (token.type === 'eof') {
            throw invalidEOF()
        }

        switch (token.value) {
        case ',':
            parseState = 'beforePropertyName';
            return

        case '}':
            pop();
        }

        // This code is unreachable since it's handled by the lexState.
        // throw invalidToken()
    },

    afterArrayValue () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }

        if (token.type === 'eof') {
            throw invalidEOF()
        }

        switch (token.value) {
        case ',':
            parseState = 'beforeArrayValue';
            return

        case ']':
            pop();
        }

        // This code is unreachable since it's handled by the lexState.
        // throw invalidToken()
    },

    end () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'eof') {
        //     throw invalidToken()
        // }
    },
};

function push () {
    let value;

    switch (token.type) {
    case 'punctuator':
        switch (token.value) {
        case '{':
            value = {};
            break

        case '[':
            value = [];
            break
        }

        break

    case 'null':
    case 'boolean':
    case 'numeric':
    case 'string':
        value = token.value;
        break

    // This code is unreachable.
    // default:
    //     throw invalidToken()
    }

    if (root$1 === undefined) {
        root$1 = value;
    } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
            parent.push(value);
        } else {
            Object.defineProperty(parent, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true,
            });
        }
    }

    if (value !== null && typeof value === 'object') {
        stack.push(value);

        if (Array.isArray(value)) {
            parseState = 'beforeArrayValue';
        } else {
            parseState = 'beforePropertyName';
        }
    } else {
        const current = stack[stack.length - 1];
        if (current == null) {
            parseState = 'end';
        } else if (Array.isArray(current)) {
            parseState = 'afterArrayValue';
        } else {
            parseState = 'afterPropertyValue';
        }
    }
}

function pop () {
    stack.pop();

    const current = stack[stack.length - 1];
    if (current == null) {
        parseState = 'end';
    } else if (Array.isArray(current)) {
        parseState = 'afterArrayValue';
    } else {
        parseState = 'afterPropertyValue';
    }
}

// This code is unreachable.
// function invalidParseState () {
//     return new Error(`JSON5: invalid parse state '${parseState}'`)
// }

// This code is unreachable.
// function invalidLexState (state) {
//     return new Error(`JSON5: invalid lex state '${state}'`)
// }

function invalidChar (c) {
    if (c === undefined) {
        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
    }

    return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
}

function invalidEOF () {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
}

// This code is unreachable.
// function invalidToken () {
//     if (token.type === 'eof') {
//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
//     }

//     const c = String.fromCodePoint(token.value.codePointAt(0))
//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
// }

function invalidIdentifier () {
    column -= 5;
    return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`)
}

function separatorChar (c) {
    console.warn(`JSON5: '${formatChar(c)}' in strings is not valid ECMAScript; consider escaping`);
}

function formatChar (c) {
    const replacements = {
        "'": "\\'",
        '"': '\\"',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        '\v': '\\v',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029',
    };

    if (replacements[c]) {
        return replacements[c]
    }

    if (c < ' ') {
        const hexString = c.charCodeAt(0).toString(16);
        return '\\x' + ('00' + hexString).substring(hexString.length)
    }

    return c
}

function syntaxError (message) {
    const err = new SyntaxError(message);
    err.lineNumber = line;
    err.columnNumber = column;
    return err
}

var stringify = function stringify (value, replacer, space) {
    const stack = [];
    let indent = '';
    let propertyList;
    let replacerFunc;
    let gap = '';
    let quote;

    if (
        replacer != null &&
        typeof replacer === 'object' &&
        !Array.isArray(replacer)
    ) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
    }

    if (typeof replacer === 'function') {
        replacerFunc = replacer;
    } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer) {
            let item;

            if (typeof v === 'string') {
                item = v;
            } else if (
                typeof v === 'number' ||
                v instanceof String ||
                v instanceof Number
            ) {
                item = String(v);
            }

            if (item !== undefined && propertyList.indexOf(item) < 0) {
                propertyList.push(item);
            }
        }
    }

    if (space instanceof Number) {
        space = Number(space);
    } else if (space instanceof String) {
        space = String(space);
    }

    if (typeof space === 'number') {
        if (space > 0) {
            space = Math.min(10, Math.floor(space));
            gap = '          '.substr(0, space);
        }
    } else if (typeof space === 'string') {
        gap = space.substr(0, 10);
    }

    return serializeProperty('', {'': value})

    function serializeProperty (key, holder) {
        let value = holder[key];
        if (value != null) {
            if (typeof value.toJSON5 === 'function') {
                value = value.toJSON5(key);
            } else if (typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }
        }

        if (replacerFunc) {
            value = replacerFunc.call(holder, key, value);
        }

        if (value instanceof Number) {
            value = Number(value);
        } else if (value instanceof String) {
            value = String(value);
        } else if (value instanceof Boolean) {
            value = value.valueOf();
        }

        switch (value) {
        case null: return 'null'
        case true: return 'true'
        case false: return 'false'
        }

        if (typeof value === 'string') {
            return quoteString(value)
        }

        if (typeof value === 'number') {
            return String(value)
        }

        if (typeof value === 'object') {
            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)
        }

        return undefined
    }

    function quoteString (value) {
        const quotes = {
            "'": 0.1,
            '"': 0.2,
        };

        const replacements = {
            "'": "\\'",
            '"': '\\"',
            '\\': '\\\\',
            '\b': '\\b',
            '\f': '\\f',
            '\n': '\\n',
            '\r': '\\r',
            '\t': '\\t',
            '\v': '\\v',
            '\0': '\\0',
            '\u2028': '\\u2028',
            '\u2029': '\\u2029',
        };

        let product = '';

        for (let i = 0; i < value.length; i++) {
            const c = value[i];
            switch (c) {
            case "'":
            case '"':
                quotes[c]++;
                product += c;
                continue

            case '\0':
                if (util.isDigit(value[i + 1])) {
                    product += '\\x00';
                    continue
                }
            }

            if (replacements[c]) {
                product += replacements[c];
                continue
            }

            if (c < ' ') {
                let hexString = c.charCodeAt(0).toString(16);
                product += '\\x' + ('00' + hexString).substring(hexString.length);
                continue
            }

            product += c;
        }

        const quoteChar = quote || Object.keys(quotes).reduce((a, b) => (quotes[a] < quotes[b]) ? a : b);

        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);

        return quoteChar + product + quoteChar
    }

    function serializeObject (value) {
        if (stack.indexOf(value) >= 0) {
            throw TypeError('Converting circular structure to JSON5')
        }

        stack.push(value);

        let stepback = indent;
        indent = indent + gap;

        let keys = propertyList || Object.keys(value);
        let partial = [];
        for (const key of keys) {
            const propertyString = serializeProperty(key, value);
            if (propertyString !== undefined) {
                let member = serializeKey(key) + ':';
                if (gap !== '') {
                    member += ' ';
                }
                member += propertyString;
                partial.push(member);
            }
        }

        let final;
        if (partial.length === 0) {
            final = '{}';
        } else {
            let properties;
            if (gap === '') {
                properties = partial.join(',');
                final = '{' + properties + '}';
            } else {
                let separator = ',\n' + indent;
                properties = partial.join(separator);
                final = '{\n' + indent + properties + ',\n' + stepback + '}';
            }
        }

        stack.pop();
        indent = stepback;
        return final
    }

    function serializeKey (key) {
        if (key.length === 0) {
            return quoteString(key)
        }

        const firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
            return quoteString(key)
        }

        for (let i = firstChar.length; i < key.length; i++) {
            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
                return quoteString(key)
            }
        }

        return key
    }

    function serializeArray (value) {
        if (stack.indexOf(value) >= 0) {
            throw TypeError('Converting circular structure to JSON5')
        }

        stack.push(value);

        let stepback = indent;
        indent = indent + gap;

        let partial = [];
        for (let i = 0; i < value.length; i++) {
            const propertyString = serializeProperty(String(i), value);
            partial.push((propertyString !== undefined) ? propertyString : 'null');
        }

        let final;
        if (partial.length === 0) {
            final = '[]';
        } else {
            if (gap === '') {
                let properties = partial.join(',');
                final = '[' + properties + ']';
            } else {
                let separator = ',\n' + indent;
                let properties = partial.join(separator);
                final = '[\n' + indent + properties + ',\n' + stepback + ']';
            }
        }

        stack.pop();
        indent = stepback;
        return final
    }
};

const JSON5 = {
    parse,
    stringify,
};

var lib$1 = JSON5;

var md5 = {exports: {}};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var core = {exports: {}};

const __viteBrowserExternal = {};

const __viteBrowserExternal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0 = /*@__PURE__*/getAugmentedNamespace(__viteBrowserExternal$1);

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core.exports;
	hasRequiredCore = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory();
			}
		}(commonjsGlobal, function () {

			/*globals window, global, require*/

			/**
			 * CryptoJS core components.
			 */
			var CryptoJS = CryptoJS || (function (Math, undefined$1) {

			    var crypto;

			    // Native crypto from window (Browser)
			    if (typeof window !== 'undefined' && window.crypto) {
			        crypto = window.crypto;
			    }

			    // Native crypto in web worker (Browser)
			    if (typeof self !== 'undefined' && self.crypto) {
			        crypto = self.crypto;
			    }

			    // Native crypto from worker
			    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
			        crypto = globalThis.crypto;
			    }

			    // Native (experimental IE 11) crypto from window (Browser)
			    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
			        crypto = window.msCrypto;
			    }

			    // Native crypto from global (NodeJS)
			    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
			        crypto = commonjsGlobal.crypto;
			    }

			    // Native crypto import via require (NodeJS)
			    if (!crypto && typeof commonjsRequire === 'function') {
			        try {
			            crypto = require$$0;
			        } catch (err) {}
			    }

			    /*
			     * Cryptographically secure pseudorandom number generator
			     *
			     * As Math.random() is cryptographically not safe to use
			     */
			    var cryptoSecureRandomInt = function () {
			        if (crypto) {
			            // Use getRandomValues method (Browser)
			            if (typeof crypto.getRandomValues === 'function') {
			                try {
			                    return crypto.getRandomValues(new Uint32Array(1))[0];
			                } catch (err) {}
			            }

			            // Use randomBytes method (NodeJS)
			            if (typeof crypto.randomBytes === 'function') {
			                try {
			                    return crypto.randomBytes(4).readInt32LE();
			                } catch (err) {}
			            }
			        }

			        throw new Error('Native crypto module could not be used to get secure random number.');
			    };

			    /*
			     * Local polyfill of Object.create

			     */
			    var create = Object.create || (function () {
			        function F() {}

			        return function (obj) {
			            var subtype;

			            F.prototype = obj;

			            subtype = new F();

			            F.prototype = null;

			            return subtype;
			        };
			    }());

			    /**
			     * CryptoJS namespace.
			     */
			    var C = {};

			    /**
			     * Library namespace.
			     */
			    var C_lib = C.lib = {};

			    /**
			     * Base object for prototypal inheritance.
			     */
			    var Base = C_lib.Base = (function () {


			        return {
			            /**
			             * Creates a new object that inherits from this object.
			             *
			             * @param {Object} overrides Properties to copy into the new object.
			             *
			             * @return {Object} The new object.
			             *
			             * @static
			             *
			             * @example
			             *
			             *     var MyType = CryptoJS.lib.Base.extend({
			             *         field: 'value',
			             *
			             *         method: function () {
			             *         }
			             *     });
			             */
			            extend: function (overrides) {
			                // Spawn
			                var subtype = create(this);

			                // Augment
			                if (overrides) {
			                    subtype.mixIn(overrides);
			                }

			                // Create default initializer
			                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
			                    subtype.init = function () {
			                        subtype.$super.init.apply(this, arguments);
			                    };
			                }

			                // Initializer's prototype is the subtype object
			                subtype.init.prototype = subtype;

			                // Reference supertype
			                subtype.$super = this;

			                return subtype;
			            },

			            /**
			             * Extends this object and runs the init method.
			             * Arguments to create() will be passed to init().
			             *
			             * @return {Object} The new object.
			             *
			             * @static
			             *
			             * @example
			             *
			             *     var instance = MyType.create();
			             */
			            create: function () {
			                var instance = this.extend();
			                instance.init.apply(instance, arguments);

			                return instance;
			            },

			            /**
			             * Initializes a newly created object.
			             * Override this method to add some logic when your objects are created.
			             *
			             * @example
			             *
			             *     var MyType = CryptoJS.lib.Base.extend({
			             *         init: function () {
			             *             // ...
			             *         }
			             *     });
			             */
			            init: function () {
			            },

			            /**
			             * Copies properties into this object.
			             *
			             * @param {Object} properties The properties to mix in.
			             *
			             * @example
			             *
			             *     MyType.mixIn({
			             *         field: 'value'
			             *     });
			             */
			            mixIn: function (properties) {
			                for (var propertyName in properties) {
			                    if (properties.hasOwnProperty(propertyName)) {
			                        this[propertyName] = properties[propertyName];
			                    }
			                }

			                // IE won't copy toString using the loop above
			                if (properties.hasOwnProperty('toString')) {
			                    this.toString = properties.toString;
			                }
			            },

			            /**
			             * Creates a copy of this object.
			             *
			             * @return {Object} The clone.
			             *
			             * @example
			             *
			             *     var clone = instance.clone();
			             */
			            clone: function () {
			                return this.init.prototype.extend(this);
			            }
			        };
			    }());

			    /**
			     * An array of 32-bit words.
			     *
			     * @property {Array} words The array of 32-bit words.
			     * @property {number} sigBytes The number of significant bytes in this word array.
			     */
			    var WordArray = C_lib.WordArray = Base.extend({
			        /**
			         * Initializes a newly created word array.
			         *
			         * @param {Array} words (Optional) An array of 32-bit words.
			         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.lib.WordArray.create();
			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
			         */
			        init: function (words, sigBytes) {
			            words = this.words = words || [];

			            if (sigBytes != undefined$1) {
			                this.sigBytes = sigBytes;
			            } else {
			                this.sigBytes = words.length * 4;
			            }
			        },

			        /**
			         * Converts this word array to a string.
			         *
			         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
			         *
			         * @return {string} The stringified word array.
			         *
			         * @example
			         *
			         *     var string = wordArray + '';
			         *     var string = wordArray.toString();
			         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
			         */
			        toString: function (encoder) {
			            return (encoder || Hex).stringify(this);
			        },

			        /**
			         * Concatenates a word array to this word array.
			         *
			         * @param {WordArray} wordArray The word array to append.
			         *
			         * @return {WordArray} This word array.
			         *
			         * @example
			         *
			         *     wordArray1.concat(wordArray2);
			         */
			        concat: function (wordArray) {
			            // Shortcuts
			            var thisWords = this.words;
			            var thatWords = wordArray.words;
			            var thisSigBytes = this.sigBytes;
			            var thatSigBytes = wordArray.sigBytes;

			            // Clamp excess bits
			            this.clamp();

			            // Concat
			            if (thisSigBytes % 4) {
			                // Copy one byte at a time
			                for (var i = 0; i < thatSigBytes; i++) {
			                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
			                }
			            } else {
			                // Copy one word at a time
			                for (var j = 0; j < thatSigBytes; j += 4) {
			                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
			                }
			            }
			            this.sigBytes += thatSigBytes;

			            // Chainable
			            return this;
			        },

			        /**
			         * Removes insignificant bits.
			         *
			         * @example
			         *
			         *     wordArray.clamp();
			         */
			        clamp: function () {
			            // Shortcuts
			            var words = this.words;
			            var sigBytes = this.sigBytes;

			            // Clamp
			            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
			            words.length = Math.ceil(sigBytes / 4);
			        },

			        /**
			         * Creates a copy of this word array.
			         *
			         * @return {WordArray} The clone.
			         *
			         * @example
			         *
			         *     var clone = wordArray.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone.words = this.words.slice(0);

			            return clone;
			        },

			        /**
			         * Creates a word array filled with random bytes.
			         *
			         * @param {number} nBytes The number of random bytes to generate.
			         *
			         * @return {WordArray} The random word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.lib.WordArray.random(16);
			         */
			        random: function (nBytes) {
			            var words = [];

			            for (var i = 0; i < nBytes; i += 4) {
			                words.push(cryptoSecureRandomInt());
			            }

			            return new WordArray.init(words, nBytes);
			        }
			    });

			    /**
			     * Encoder namespace.
			     */
			    var C_enc = C.enc = {};

			    /**
			     * Hex encoding strategy.
			     */
			    var Hex = C_enc.Hex = {
			        /**
			         * Converts a word array to a hex string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The hex string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var hexChars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                hexChars.push((bite >>> 4).toString(16));
			                hexChars.push((bite & 0x0f).toString(16));
			            }

			            return hexChars.join('');
			        },

			        /**
			         * Converts a hex string to a word array.
			         *
			         * @param {string} hexStr The hex string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
			         */
			        parse: function (hexStr) {
			            // Shortcut
			            var hexStrLength = hexStr.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < hexStrLength; i += 2) {
			                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
			            }

			            return new WordArray.init(words, hexStrLength / 2);
			        }
			    };

			    /**
			     * Latin1 encoding strategy.
			     */
			    var Latin1 = C_enc.Latin1 = {
			        /**
			         * Converts a word array to a Latin1 string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The Latin1 string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var latin1Chars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                latin1Chars.push(String.fromCharCode(bite));
			            }

			            return latin1Chars.join('');
			        },

			        /**
			         * Converts a Latin1 string to a word array.
			         *
			         * @param {string} latin1Str The Latin1 string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
			         */
			        parse: function (latin1Str) {
			            // Shortcut
			            var latin1StrLength = latin1Str.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < latin1StrLength; i++) {
			                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
			            }

			            return new WordArray.init(words, latin1StrLength);
			        }
			    };

			    /**
			     * UTF-8 encoding strategy.
			     */
			    var Utf8 = C_enc.Utf8 = {
			        /**
			         * Converts a word array to a UTF-8 string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The UTF-8 string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            try {
			                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
			            } catch (e) {
			                throw new Error('Malformed UTF-8 data');
			            }
			        },

			        /**
			         * Converts a UTF-8 string to a word array.
			         *
			         * @param {string} utf8Str The UTF-8 string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
			         */
			        parse: function (utf8Str) {
			            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
			        }
			    };

			    /**
			     * Abstract buffered block algorithm template.
			     *
			     * The property blockSize must be implemented in a concrete subtype.
			     *
			     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
			     */
			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
			        /**
			         * Resets this block algorithm's data buffer to its initial state.
			         *
			         * @example
			         *
			         *     bufferedBlockAlgorithm.reset();
			         */
			        reset: function () {
			            // Initial values
			            this._data = new WordArray.init();
			            this._nDataBytes = 0;
			        },

			        /**
			         * Adds new data to this block algorithm's buffer.
			         *
			         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
			         *
			         * @example
			         *
			         *     bufferedBlockAlgorithm._append('data');
			         *     bufferedBlockAlgorithm._append(wordArray);
			         */
			        _append: function (data) {
			            // Convert string to WordArray, else assume WordArray already
			            if (typeof data == 'string') {
			                data = Utf8.parse(data);
			            }

			            // Append
			            this._data.concat(data);
			            this._nDataBytes += data.sigBytes;
			        },

			        /**
			         * Processes available data blocks.
			         *
			         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
			         *
			         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
			         *
			         * @return {WordArray} The processed data.
			         *
			         * @example
			         *
			         *     var processedData = bufferedBlockAlgorithm._process();
			         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
			         */
			        _process: function (doFlush) {
			            var processedWords;

			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;
			            var dataSigBytes = data.sigBytes;
			            var blockSize = this.blockSize;
			            var blockSizeBytes = blockSize * 4;

			            // Count blocks ready
			            var nBlocksReady = dataSigBytes / blockSizeBytes;
			            if (doFlush) {
			                // Round up to include partial blocks
			                nBlocksReady = Math.ceil(nBlocksReady);
			            } else {
			                // Round down to include only full blocks,
			                // less the number of blocks that must remain in the buffer
			                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
			            }

			            // Count words ready
			            var nWordsReady = nBlocksReady * blockSize;

			            // Count bytes ready
			            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

			            // Process blocks
			            if (nWordsReady) {
			                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
			                    // Perform concrete-algorithm logic
			                    this._doProcessBlock(dataWords, offset);
			                }

			                // Remove processed words
			                processedWords = dataWords.splice(0, nWordsReady);
			                data.sigBytes -= nBytesReady;
			            }

			            // Return processed words
			            return new WordArray.init(processedWords, nBytesReady);
			        },

			        /**
			         * Creates a copy of this object.
			         *
			         * @return {Object} The clone.
			         *
			         * @example
			         *
			         *     var clone = bufferedBlockAlgorithm.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone._data = this._data.clone();

			            return clone;
			        },

			        _minBufferSize: 0
			    });

			    /**
			     * Abstract hasher template.
			     *
			     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
			     */
			    C_lib.Hasher = BufferedBlockAlgorithm.extend({
			        /**
			         * Configuration options.
			         */
			        cfg: Base.extend(),

			        /**
			         * Initializes a newly created hasher.
			         *
			         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
			         *
			         * @example
			         *
			         *     var hasher = CryptoJS.algo.SHA256.create();
			         */
			        init: function (cfg) {
			            // Apply config defaults
			            this.cfg = this.cfg.extend(cfg);

			            // Set initial values
			            this.reset();
			        },

			        /**
			         * Resets this hasher to its initial state.
			         *
			         * @example
			         *
			         *     hasher.reset();
			         */
			        reset: function () {
			            // Reset data buffer
			            BufferedBlockAlgorithm.reset.call(this);

			            // Perform concrete-hasher logic
			            this._doReset();
			        },

			        /**
			         * Updates this hasher with a message.
			         *
			         * @param {WordArray|string} messageUpdate The message to append.
			         *
			         * @return {Hasher} This hasher.
			         *
			         * @example
			         *
			         *     hasher.update('message');
			         *     hasher.update(wordArray);
			         */
			        update: function (messageUpdate) {
			            // Append
			            this._append(messageUpdate);

			            // Update the hash
			            this._process();

			            // Chainable
			            return this;
			        },

			        /**
			         * Finalizes the hash computation.
			         * Note that the finalize operation is effectively a destructive, read-once operation.
			         *
			         * @param {WordArray|string} messageUpdate (Optional) A final message update.
			         *
			         * @return {WordArray} The hash.
			         *
			         * @example
			         *
			         *     var hash = hasher.finalize();
			         *     var hash = hasher.finalize('message');
			         *     var hash = hasher.finalize(wordArray);
			         */
			        finalize: function (messageUpdate) {
			            // Final message update
			            if (messageUpdate) {
			                this._append(messageUpdate);
			            }

			            // Perform concrete-hasher logic
			            var hash = this._doFinalize();

			            return hash;
			        },

			        blockSize: 512/32,

			        /**
			         * Creates a shortcut function to a hasher's object interface.
			         *
			         * @param {Hasher} hasher The hasher to create a helper for.
			         *
			         * @return {Function} The shortcut function.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
			         */
			        _createHelper: function (hasher) {
			            return function (message, cfg) {
			                return new hasher.init(cfg).finalize(message);
			            };
			        },

			        /**
			         * Creates a shortcut function to the HMAC's object interface.
			         *
			         * @param {Hasher} hasher The hasher to use in this HMAC helper.
			         *
			         * @return {Function} The shortcut function.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
			         */
			        _createHmacHelper: function (hasher) {
			            return function (message, key) {
			                return new C_algo.HMAC.init(hasher, key).finalize(message);
			            };
			        }
			    });

			    /**
			     * Algorithm namespace.
			     */
			    var C_algo = C.algo = {};

			    return C;
			}(Math));


			return CryptoJS;

		})); 
	} (core));
	return core.exports;
}

(function (module, exports) {
(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(requireCore());
		}
	}(commonjsGlobal, function (CryptoJS) {

		(function (Math) {
		    // Shortcuts
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var Hasher = C_lib.Hasher;
		    var C_algo = C.algo;

		    // Constants table
		    var T = [];

		    // Compute constants
		    (function () {
		        for (var i = 0; i < 64; i++) {
		            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
		        }
		    }());

		    /**
		     * MD5 hash algorithm.
		     */
		    var MD5 = C_algo.MD5 = Hasher.extend({
		        _doReset: function () {
		            this._hash = new WordArray.init([
		                0x67452301, 0xefcdab89,
		                0x98badcfe, 0x10325476
		            ]);
		        },

		        _doProcessBlock: function (M, offset) {
		            // Swap endian
		            for (var i = 0; i < 16; i++) {
		                // Shortcuts
		                var offset_i = offset + i;
		                var M_offset_i = M[offset_i];

		                M[offset_i] = (
		                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
		                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
		                );
		            }

		            // Shortcuts
		            var H = this._hash.words;

		            var M_offset_0  = M[offset + 0];
		            var M_offset_1  = M[offset + 1];
		            var M_offset_2  = M[offset + 2];
		            var M_offset_3  = M[offset + 3];
		            var M_offset_4  = M[offset + 4];
		            var M_offset_5  = M[offset + 5];
		            var M_offset_6  = M[offset + 6];
		            var M_offset_7  = M[offset + 7];
		            var M_offset_8  = M[offset + 8];
		            var M_offset_9  = M[offset + 9];
		            var M_offset_10 = M[offset + 10];
		            var M_offset_11 = M[offset + 11];
		            var M_offset_12 = M[offset + 12];
		            var M_offset_13 = M[offset + 13];
		            var M_offset_14 = M[offset + 14];
		            var M_offset_15 = M[offset + 15];

		            // Working variables
		            var a = H[0];
		            var b = H[1];
		            var c = H[2];
		            var d = H[3];

		            // Computation
		            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
		            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
		            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
		            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
		            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
		            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
		            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
		            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
		            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
		            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
		            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
		            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
		            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
		            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
		            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
		            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

		            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
		            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
		            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
		            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
		            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
		            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
		            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
		            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
		            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
		            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
		            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
		            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
		            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
		            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
		            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
		            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

		            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
		            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
		            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
		            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
		            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
		            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
		            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
		            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
		            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
		            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
		            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
		            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
		            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
		            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
		            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
		            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

		            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
		            d = II(d, a, b, c, M_offset_7,  10, T[49]);
		            c = II(c, d, a, b, M_offset_14, 15, T[50]);
		            b = II(b, c, d, a, M_offset_5,  21, T[51]);
		            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
		            d = II(d, a, b, c, M_offset_3,  10, T[53]);
		            c = II(c, d, a, b, M_offset_10, 15, T[54]);
		            b = II(b, c, d, a, M_offset_1,  21, T[55]);
		            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
		            d = II(d, a, b, c, M_offset_15, 10, T[57]);
		            c = II(c, d, a, b, M_offset_6,  15, T[58]);
		            b = II(b, c, d, a, M_offset_13, 21, T[59]);
		            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
		            d = II(d, a, b, c, M_offset_11, 10, T[61]);
		            c = II(c, d, a, b, M_offset_2,  15, T[62]);
		            b = II(b, c, d, a, M_offset_9,  21, T[63]);

		            // Intermediate hash value
		            H[0] = (H[0] + a) | 0;
		            H[1] = (H[1] + b) | 0;
		            H[2] = (H[2] + c) | 0;
		            H[3] = (H[3] + d) | 0;
		        },

		        _doFinalize: function () {
		            // Shortcuts
		            var data = this._data;
		            var dataWords = data.words;

		            var nBitsTotal = this._nDataBytes * 8;
		            var nBitsLeft = data.sigBytes * 8;

		            // Add padding
		            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

		            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
		            var nBitsTotalL = nBitsTotal;
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
		                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
		                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
		            );
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
		                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
		                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
		            );

		            data.sigBytes = (dataWords.length + 1) * 4;

		            // Hash final blocks
		            this._process();

		            // Shortcuts
		            var hash = this._hash;
		            var H = hash.words;

		            // Swap endian
		            for (var i = 0; i < 4; i++) {
		                // Shortcut
		                var H_i = H[i];

		                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
		                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
		            }

		            // Return final computed hash
		            return hash;
		        },

		        clone: function () {
		            var clone = Hasher.clone.call(this);
		            clone._hash = this._hash.clone();

		            return clone;
		        }
		    });

		    function FF(a, b, c, d, x, s, t) {
		        var n = a + ((b & c) | (~b & d)) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }

		    function GG(a, b, c, d, x, s, t) {
		        var n = a + ((b & d) | (c & ~d)) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }

		    function HH(a, b, c, d, x, s, t) {
		        var n = a + (b ^ c ^ d) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }

		    function II(a, b, c, d, x, s, t) {
		        var n = a + (c ^ (b | ~d)) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }

		    /**
		     * Shortcut function to the hasher's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     *
		     * @return {WordArray} The hash.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hash = CryptoJS.MD5('message');
		     *     var hash = CryptoJS.MD5(wordArray);
		     */
		    C.MD5 = Hasher._createHelper(MD5);

		    /**
		     * Shortcut function to the HMAC's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     * @param {WordArray|string} key The secret key.
		     *
		     * @return {WordArray} The HMAC.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hmac = CryptoJS.HmacMD5(message, key);
		     */
		    C.HmacMD5 = Hasher._createHmacHelper(MD5);
		}(Math));


		return CryptoJS.MD5;

	})); 
} (md5));

var md5Exports = md5.exports;
const MD5 = /*@__PURE__*/getDefaultExportFromCjs(md5Exports);

const React$24 = await importShared('react');
const {Component: Component$1} = React$24;

const {Grid2: Grid2$2,Button: Button$d} = await importShared('@mui/material');

const {Info:IconInfo$2,Warning:IconWarning$2,Error:IconError$2,Key:IconAuth,Send:IconSend$1,Public:IconWeb,Search:IconSearch,MenuBook:IconMenuBook,Help:IconHelp,UploadFile:IconUploadFile,Edit:IconEdit,Person:IconPerson,Group:IconGroup,Delete:IconDelete$1,Refresh:IconRefresh$1,Add:IconAdd,LinkOff:IconLinkOff,Link:LinkIcon$1,Save,OpenInNew} = await importShared('@mui/icons-material');

const {DialogConfirm: DialogConfirm$5,Icon: Icon$4,Utils: Utils$e,I18n: I18n$F} = await importShared('@iobroker/adapter-react-v5');

const DEFAULT_SM_SIZE = window.innerWidth <= 600 ? 12 : undefined;
// because this class is used in react-components, do not include here any foreign files like from '../../helpers/utils.ts'
function isObject$2(it) {
    // This is necessary because:
    // typeof null === 'object'
    // typeof [] === 'object'
    // [] instanceof Object === true
    return Object.prototype.toString.call(it) === '[object Object]'; // this code is 25% faster than below one
    // return it && typeof it === 'object' && !(it instanceof Array);
}
class ConfigGeneric extends Component$1 {
    static DIFFERENT_VALUE = '__different__';
    static DIFFERENT_LABEL = 'ra___different__';
    static NONE_VALUE = '';
    static NONE_LABEL = 'ra_none';
    defaultValue;
    isError;
    lang;
    defaultSendToDone;
    sendToTimeout;
    noPlaceRequired;
    constructor(props) {
        super(props);
        // @ts-expect-error of course, as we just
        this.state = {
            confirmDialog: false,
            confirmNewValue: null,
            confirmAttr: null,
            confirmData: null,
            confirmCallback: null,
        };
        this.isError = {};
        if (props.schema) {
            if (props.custom) {
                this.defaultValue = props.schema.defaultFunc
                    ? this.executeCustom(props.schema.defaultFunc, props.data, props.customObj, props.oContext.instanceObj, props.arrayIndex, props.globalData)
                    : props.schema.default;
            }
            else if (props.schema.type !== 'state') {
                this.defaultValue = props.schema.defaultFunc
                    ? this.execute(props.schema.defaultFunc, props.schema.default, props.data, props.arrayIndex, props.globalData)
                    : props.schema.default;
            }
        }
        this.lang = I18n$F.getLanguage();
    }
    componentDidMount() {
        if (this.props.oContext.registerOnForceUpdate) {
            this.props.oContext.registerOnForceUpdate(this.props.attr, this.onUpdate);
        }
        const LIKE_SELECT = ['select', 'autocomplete', 'autocompleteSendTo'];
        // init default value
        if (this.defaultValue !== undefined) {
            const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
            if (value === undefined ||
                (LIKE_SELECT.includes(this.props.schema.type) && (value === '' || value === null))) {
                setTimeout(() => {
                    if (this.props.custom) {
                        this.props.onChange(this.props.attr, this.defaultValue, () => setTimeout(() => this.props.oContext.forceUpdate([this.props.attr], this.props.data), 100));
                    }
                    else {
                        ConfigGeneric.setValue(this.props.data, this.props.attr, this.defaultValue);
                        this.props.onChange(this.props.data, undefined, () => this.props.oContext.forceUpdate([this.props.attr], this.props.data));
                    }
                }, 100);
            }
        }
        else if (this.props.schema.defaultSendTo) {
            this.sendTo();
        }
    }
    sendTo() {
        if (this.props.alive) {
            this.defaultSendToDone = true;
            let data = this.props.schema.data;
            if (data === undefined && this.props.schema.jsonData) {
                const dataStr = this.getPattern(this.props.schema.jsonData, null, true);
                try {
                    data = JSON.parse(dataStr);
                }
                catch {
                    console.error(`Cannot parse json data: ${dataStr}`);
                }
            }
            else {
                data = {
                    attr: this.props.attr,
                    value: ConfigGeneric.getValue(this.props.data, this.props.attr),
                };
            }
            if (data === undefined) {
                data = null;
            }
            void this.props.oContext.socket
                .sendTo(`${this.props.oContext.adapterName}.${this.props.oContext.instance}`, this.props.schema.defaultSendTo, data)
                .then((value) => {
                if (value !== null && value !== undefined) {
                    if (this.props.custom) {
                        this.props.onChange(this.props.attr, value, () => this.props.oContext.forceUpdate([this.props.attr], this.props.data));
                    }
                    else {
                        ConfigGeneric.setValue(this.props.data, this.props.attr, value);
                        this.props.onChange(this.props.data, undefined, () => this.props.oContext.forceUpdate([this.props.attr], this.props.data));
                    }
                }
            });
        }
        else {
            this.defaultSendToDone = false;
            if (!this.props.schema.allowSaveWithError) {
                // show error, that instance did not start
                this.onError(this.props.attr, I18n$F.t('ra_Instance %s is not alive', this.props.oContext.instance.toString()));
            }
        }
    }
    componentWillUnmount() {
        if (this.props.oContext.registerOnForceUpdate) {
            this.props.oContext.registerOnForceUpdate(this.props.attr);
        }
        if (this.sendToTimeout) {
            clearTimeout(this.sendToTimeout);
            this.sendToTimeout = null;
        }
    }
    onUpdate = (data) => {
        const value = ConfigGeneric.getValue(data || this.props.data, this.props.attr) || '';
        if (this.state.value !== value) {
            this.setState({ value });
        }
        else {
            this.forceUpdate();
        }
    };
    /**
     * Extract attribute out of data
     */
    static getValue(data, attr) {
        if (typeof attr === 'string') {
            return ConfigGeneric.getValue(data, attr.split('.'));
        }
        if (attr.length === 1) {
            return data[attr[0]];
        }
        const part = attr.shift();
        if (typeof part === 'string' && typeof data[part] === 'object') {
            return ConfigGeneric.getValue(data[part], attr);
        }
        return undefined;
    }
    static setValue(data, attr, value) {
        if (typeof attr === 'string') {
            ConfigGeneric.setValue(data, attr.split('.'), value);
            return;
        }
        if (attr.length === 1) {
            if (value === null) {
                delete data[attr[0]];
            }
            else {
                data[attr[0]] = value;
            }
        }
        else {
            const part = attr.shift();
            if (typeof part !== 'string') {
                return;
            }
            if (!data[part] || typeof data[part] === 'object') {
                data[part] = data[part] || {};
            }
            ConfigGeneric.setValue(data[part], attr, value);
        }
    }
    getText(text, noTranslation) {
        if (!text) {
            return '';
        }
        if (typeof text === 'string') {
            const strText = noTranslation ? text : I18n$F.t(text);
            if (strText.includes('${')) {
                return this.getPattern(strText, null, noTranslation);
            }
            return strText;
        }
        if (isObject$2(text)) {
            // todo
            if (text.func) {
                // calculate pattern
                if (typeof text.func === 'object') {
                    return this.getPattern(text.func[this.lang] || text.func.en || '', null, true);
                }
                return this.getPattern(text.func, null, noTranslation);
            }
            return text[this.lang] || text.en || '';
        }
        return text.toString();
    }
    renderDialogConfirm() {
        if (!this.state.confirmDialog) {
            return null;
        }
        const confirm = this.state.confirmData || this.props.schema.confirm;
        let icon = null;
        if (confirm.type === 'warning') {
            icon = React$24.createElement(IconWarning$2, null);
        }
        else if (confirm.type === 'error') {
            icon = React$24.createElement(IconError$2, null);
        }
        else if (confirm.type === 'info') {
            icon = React$24.createElement(IconInfo$2, null);
        }
        return (React$24.createElement(DialogConfirm$5, { title: this.getText(confirm.title) || I18n$F.t('ra_Please confirm'), text: this.getText(confirm.text), ok: this.getText(confirm.ok) || I18n$F.t('ra_Ok'), cancel: this.getText(confirm.cancel) || I18n$F.t('ra_Cancel'), icon: icon || undefined, onClose: isOk => this.setState({ confirmDialog: false }, () => {
                if (isOk) {
                    if (this.state.confirmCallback) {
                        const callback = this.state.confirmCallback;
                        this.setState({ confirmCallback: null }, () => callback(true));
                        return;
                    }
                    const data = JSON.parse(JSON.stringify(this.props.data));
                    if (this.state.confirmDepAttr) {
                        ConfigGeneric.setValue(data, this.state.confirmDepAttr, this.state.confirmDepNewValue);
                    }
                    ConfigGeneric.setValue(data, this.state.confirmAttr, this.state.confirmNewValue);
                    this.setState({
                        confirmDialog: false,
                        confirmDepAttr: null,
                        confirmDepNewValue: null,
                        confirmNewValue: null,
                        confirmAttr: null,
                        confirmData: null,
                    }, () => this.props.onChange(data));
                }
                else {
                    const callback = this.state.confirmCallback;
                    this.setState({
                        confirmDialog: false,
                        confirmDepAttr: null,
                        confirmDepNewValue: null,
                        confirmNewValue: null,
                        confirmAttr: null,
                        confirmData: null,
                        confirmCallback: null,
                    }, () => {
                        if (callback) {
                            callback(false);
                        }
                    });
                }
            }) }));
    }
    // eslint-disable-next-line react/no-unused-class-component-methods
    getIcon(iconSettings) {
        iconSettings = iconSettings || this.props.schema.icon;
        let icon = null;
        if (iconSettings === 'auth') {
            icon = React$24.createElement(IconAuth, null);
        }
        else if (iconSettings === 'send') {
            icon = React$24.createElement(IconSend$1, null);
        }
        else if (iconSettings === 'web') {
            icon = React$24.createElement(IconWeb, null);
        }
        else if (iconSettings === 'warning') {
            icon = React$24.createElement(IconWarning$2, null);
        }
        else if (iconSettings === 'error') {
            icon = React$24.createElement(IconError$2, null);
        }
        else if (iconSettings === 'info') {
            icon = React$24.createElement(IconInfo$2, null);
        }
        else if (iconSettings === 'search') {
            icon = React$24.createElement(IconSearch, null);
        }
        else if (iconSettings === 'book') {
            icon = React$24.createElement(IconMenuBook, null);
        }
        else if (iconSettings === 'help') {
            icon = React$24.createElement(IconHelp, null);
        }
        else if (iconSettings === 'upload') {
            icon = React$24.createElement(IconUploadFile, null);
        }
        else if (iconSettings === 'edit') {
            icon = React$24.createElement(IconEdit, null);
        }
        else if (iconSettings === 'user') {
            icon = React$24.createElement(IconPerson, null);
        }
        else if (iconSettings === 'group') {
            icon = React$24.createElement(IconGroup, null);
        }
        else if (iconSettings === 'delete') {
            icon = React$24.createElement(IconDelete$1, null);
        }
        else if (iconSettings === 'refresh') {
            icon = React$24.createElement(IconRefresh$1, null);
        }
        else if (iconSettings === 'add') {
            icon = React$24.createElement(IconAdd, null);
        }
        else if (iconSettings === 'unpair') {
            icon = React$24.createElement(IconLinkOff, null);
        }
        else if (iconSettings === 'pair') {
            icon = React$24.createElement(LinkIcon$1, null);
        }
        else if (iconSettings === 'save') {
            icon = React$24.createElement(Save, null);
        }
        else if (iconSettings === 'open') {
            icon = React$24.createElement(OpenInNew, null);
        }
        else if (iconSettings) {
            if (iconSettings.endsWith('.png') || iconSettings.endsWith('.svg') || iconSettings.endsWith('.jpg')) {
                // this path is relative to ./adapter/NAME
                if (!iconSettings.startsWith('http://') && !iconSettings.startsWith('https://')) {
                    iconSettings = `./adapter/${this.props.oContext.adapterName}/${iconSettings}`;
                }
            }
            icon = (React$24.createElement(Icon$4, { src: iconSettings, style: { width: 22, height: 22 } }));
        }
        return icon;
    }
    /**
     * Trigger onChange, to activate save button on change
     *
     * @param attr the changed attribute
     * @param newValue new value of the attribute
     */
    // eslint-disable-next-line react/no-unused-class-component-methods
    onChangeAsync(attr, newValue) {
        return new Promise(resolve => {
            const mayBePromise = this.onChange(attr, newValue, resolve);
            if (mayBePromise instanceof Promise) {
                mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
            }
        });
    }
    /**
     * Trigger onChange, to activate save button on change
     *
     * @param attr the changed attribute
     * @param newValue new value of the attribute
     * @param cb optional callback function, else returns a Promise
     */
    onChange(attr, newValue, cb) {
        // Do not use here deep copy, as it is not JsonConfig
        const data = JSON.parse(JSON.stringify(this.props.data));
        ConfigGeneric.setValue(data, attr, newValue);
        if (this.props.schema.confirm &&
            this.execute(this.props.schema.confirm.condition, false, data, this.props.arrayIndex, this.props.globalData)) {
            return new Promise(resolve => {
                this.setState({
                    confirmDialog: true,
                    confirmNewValue: newValue,
                    confirmAttr: attr,
                    confirmData: null,
                }, () => {
                    if (typeof cb === 'function') {
                        cb();
                    }
                    else {
                        resolve();
                    }
                });
            });
        }
        // find any inputs with confirmation
        if (this.props.schema.confirmDependsOn) {
            for (let z = 0; z < this.props.schema.confirmDependsOn.length; z++) {
                const dep = this.props.schema.confirmDependsOn[z];
                if (dep.confirm) {
                    const val = ConfigGeneric.getValue(data, dep.attr);
                    if (this.execute(dep.confirm.condition, false, data, this.props.arrayIndex, this.props.globalData)) {
                        return new Promise(resolve => {
                            this.setState({
                                confirmDialog: true,
                                confirmNewValue: newValue,
                                confirmAttr: attr,
                                confirmDepNewValue: val,
                                confirmDepAttr: dep.attr,
                                confirmData: dep.confirm,
                            }, () => {
                                if (typeof cb === 'function') {
                                    cb();
                                }
                                else {
                                    resolve();
                                }
                            });
                        });
                    }
                }
            }
        }
        const changed = [];
        if (this.props.schema.onChangeDependsOn) {
            for (let z = 0; z < this.props.schema.onChangeDependsOn.length; z++) {
                const dep = this.props.schema.onChangeDependsOn[z];
                if (dep.onChange) {
                    const val = ConfigGeneric.getValue(data, dep.attr);
                    let _newValue;
                    if (this.props.custom) {
                        _newValue = this.executeCustom(dep.onChange.calculateFunc, data, this.props.customObj, this.props.oContext.instanceObj, this.props.arrayIndex, this.props.globalData);
                    }
                    else {
                        _newValue = this.execute(dep.onChange.calculateFunc, val, data, this.props.arrayIndex, this.props.globalData);
                    }
                    if (_newValue !== val) {
                        ConfigGeneric.setValue(data, dep.attr, _newValue);
                        changed.push(dep.attr);
                    }
                }
            }
        }
        if (this.props.schema.hiddenDependsOn) {
            for (let z = 0; z < this.props.schema.hiddenDependsOn.length; z++) {
                const dep = this.props.schema.hiddenDependsOn[z];
                if (dep.hidden) {
                    changed.push(dep.attr);
                }
            }
        }
        if (this.props.schema.labelDependsOn) {
            for (let z = 0; z < this.props.schema.labelDependsOn.length; z++) {
                const dep = this.props.schema.labelDependsOn[z];
                if (dep.hidden) {
                    changed.push(dep.attr);
                }
            }
        }
        if (this.props.schema.helpDependsOn) {
            for (let z = 0; z < this.props.schema.helpDependsOn.length; z++) {
                const dep = this.props.schema.helpDependsOn[z];
                if (dep.hidden) {
                    changed.push(dep.attr);
                }
            }
        }
        if (this.props.schema.onChange && !this.props.schema.onChange.ignoreOwnChanges) {
            const val = ConfigGeneric.getValue(data, this.props.attr);
            const newValue_ = this.props.custom
                ? this.executeCustom(this.props.schema.onChange.calculateFunc, data, this.props.customObj, this.props.oContext.instanceObj, this.props.arrayIndex, this.props.globalData)
                : this.execute(this.props.schema.onChange.calculateFunc, val, data, this.props.arrayIndex, this.props.globalData);
            if (newValue_ !== val) {
                ConfigGeneric.setValue(data, this.props.attr, newValue_);
            }
        }
        if (this.props.custom) {
            this.props.onChange(attr, newValue, () => cb && cb());
            if (changed?.length) {
                changed.forEach((_attr, i) => setTimeout(() => this.props.onChange(_attr, ConfigGeneric.getValue(data, _attr)), i * 50));
            }
        }
        else {
            this.props.onChange(data, undefined, () => {
                if (changed.length) {
                    this.props.oContext.forceUpdate(changed, data);
                }
                if (cb) {
                    cb();
                }
            });
        }
        return Promise.resolve();
    }
    execute(func, defaultValue, data, arrayIndex, globalData) {
        let fun;
        if (isObject$2(func)) {
            fun = func.func;
        }
        else if (typeof func === 'string') {
            fun = func;
        }
        else {
            return func;
        }
        if (!fun) {
            return defaultValue;
        }
        try {
            const f = new Function('data', 'originalData', '_system', '_alive', '_common', '_socket', '_instance', 'arrayIndex', 'globalData', '_changed', fun.includes('return') ? fun : `return ${fun}`);
            return f(data || this.props.data, this.props.originalData, this.props.oContext.systemConfig, this.props.alive, this.props.common, this.props.oContext.socket, this.props.oContext.instance, arrayIndex, globalData, this.props.changed);
        }
        catch (e) {
            console.error(`Cannot execute ${JSON.stringify(func)}: ${e}`);
            return defaultValue;
        }
    }
    executeCustom(func, data, customObj, instanceObj, arrayIndex, globalData) {
        let fun;
        if (isObject$2(func)) {
            fun = func.func;
        }
        else if (typeof func === 'string') {
            fun = func;
        }
        else {
            return func;
        }
        if (!fun) {
            return null;
        }
        try {
            const f = new Function('data', 'originalData', '_system', 'instanceObj', 'customObj', '_socket', 'arrayIndex', 'globalData', '_changed', fun.includes('return') ? fun : `return ${fun}`);
            return f(data || this.props.data, this.props.originalData, this.props.oContext.systemConfig, instanceObj, customObj, this.props.oContext.socket, arrayIndex, globalData, this.props.changed);
        }
        catch (e) {
            console.error(`Cannot execute ${fun}: ${e}`);
            return null;
        }
    }
    calculate(schema) {
        let error;
        let disabled;
        let hidden;
        let defaultValue;
        if (this.props.custom) {
            error = schema.validator
                ? !this.executeCustom(schema.validator, this.props.data, this.props.customObj, this.props.oContext.instanceObj, this.props.arrayIndex, this.props.globalData)
                : false;
            if (schema.disabled === true) {
                disabled = true;
            }
            else {
                disabled = schema.disabled
                    ? this.executeCustom(schema.disabled, this.props.data, this.props.customObj, this.props.oContext.instanceObj, this.props.arrayIndex, this.props.globalData)
                    : false;
            }
            if (schema.hidden === true) {
                hidden = true;
            }
            else {
                hidden = schema.hidden
                    ? this.executeCustom(schema.hidden, this.props.data, this.props.customObj, this.props.oContext.instanceObj, this.props.arrayIndex, this.props.globalData)
                    : false;
            }
            defaultValue = schema.defaultFunc
                ? this.executeCustom(schema.defaultFunc, this.props.data, this.props.customObj, this.props.oContext.instanceObj, this.props.arrayIndex, this.props.globalData)
                : schema.default;
        }
        else {
            error = schema.validator
                ? !this.execute(schema.validator, false, this.props.data, this.props.arrayIndex, this.props.globalData)
                : false;
            if (schema.disabled === true) {
                disabled = true;
            }
            else {
                disabled = schema.disabled
                    ? this.execute(schema.disabled, false, this.props.data, this.props.arrayIndex, this.props.globalData)
                    : false;
            }
            if (schema.hidden === true) {
                hidden = true;
            }
            else {
                hidden = schema.hidden
                    ? this.execute(schema.hidden, false, this.props.data, this.props.arrayIndex, this.props.globalData)
                    : false;
            }
            defaultValue = schema.defaultFunc
                ? this.execute(schema.defaultFunc, schema.default, this.props.data, this.props.arrayIndex, this.props.globalData)
                : schema.default;
        }
        return {
            error,
            disabled,
            hidden,
            defaultValue,
        };
    }
    onError(attr, error) {
        if (!error) {
            delete this.isError[attr];
        }
        else {
            this.isError[attr] = error;
        }
        if (this.props.onError) {
            this.props.onError(attr, error);
        }
    }
    renderItem(_error, _disabled, _defaultValue) {
        return this.getText(this.props.schema.label) || this.getText(this.props.schema.text);
    }
    // eslint-disable-next-line react/no-unused-class-component-methods
    renderHelp(text, link, noTranslation) {
        if (!link) {
            text = this.getText(text, noTranslation) || '';
            if (text &&
                (text.includes('<a ') || text.includes('<br') || text.includes('<b>') || text.includes('<i>'))) {
                return Utils$e.renderTextWithA(text);
            }
            return text;
        }
        return (React$24.createElement("a", { href: link, target: "_blank", rel: "noreferrer", style: {
                color: this.props.oContext.themeType === 'dark' ? '#a147ff' : '#5b238f',
                textDecoration: 'underline',
            } }, this.getText(text, noTranslation)));
    }
    // we have a problem that a string '{"password": "${password}"}' cannot contain a double quota inside the string
    // escape it with \"
    static escapeString(str, data) {
        if (typeof str !== 'string') {
            return '';
        }
        str = str.replace(/`/g, '\\`');
        // extract all tokes with ${data.token}
        str = str.replace(/\${([^}]+)}/g, (_match, p1) => {
            if (p1 && typeof p1 === 'string' && p1.startsWith('data.')) {
                const value = ConfigGeneric.getValue(data, p1.replace(/^data\./, ''));
                if (typeof value === 'string') {
                    // Handle both backslashes and quotes to ensure valid JSON
                    if (value.includes('\\') || value.includes('"')) {
                        return `\${${p1}.replace(/\\\\/g, '\\\\\\\\').replace(/"/g, '\\\\"')}`;
                    }
                }
            }
            return _match;
        });
        return str;
    }
    getPattern(pattern, data, noTranslation) {
        data = data || this.props.data;
        if (!pattern) {
            return '';
        }
        let patternStr;
        if (typeof pattern === 'object') {
            if (pattern.func) {
                patternStr = pattern.func;
            }
            else {
                console.log(`Object must be stringified: ${JSON.stringify(pattern)}`);
                patternStr = JSON.stringify(pattern);
            }
        }
        else {
            patternStr = pattern;
        }
        try {
            if (this.props.custom) {
                const f = new Function('data', 'originalData', 'arrayIndex', 'globalData', '_system', 'instanceObj', 'customObj', '_socket', '_changed', `return \`${ConfigGeneric.escapeString(patternStr, data)}\``);
                return f(data, this.props.originalData, this.props.arrayIndex, this.props.globalData, this.props.oContext.systemConfig, this.props.oContext.instanceObj, this.props.customObj, this.props.oContext.socket, this.props.changed);
            }
            const f = new Function('data', 'originalData', 'arrayIndex', 'globalData', '_system', '_alive', '_common', '_socket', '_changed', `return \`${ConfigGeneric.escapeString(patternStr, data)}\``);
            const text = f(data, this.props.originalData, this.props.arrayIndex, this.props.globalData, this.props.oContext.systemConfig, this.props.alive, this.props.common, this.props.oContext.socket, this.props.changed);
            if (noTranslation) {
                return text;
            }
            return I18n$F.t(text);
        }
        catch (e) {
            console.error(`Cannot execute ${patternStr}: ${e}`);
            return patternStr;
        }
    }
    render() {
        const schema = this.props.schema;
        if (!schema) {
            return null;
        }
        // Do not show this component if expert mode is false
        if (this.props.expertMode === false && schema.expertMode) {
            return null;
        }
        if (this.props.alive && this.defaultSendToDone === false) {
            this.sendToTimeout = setTimeout(() => {
                this.sendToTimeout = null;
                this.sendTo();
            }, 200);
        }
        const { error, disabled, hidden, defaultValue } = this.calculate(schema);
        if (hidden) {
            // Remove all errors if an element is hidden
            if (Object.keys(this.isError).length) {
                setTimeout(isError => Object.keys(isError).forEach(attr => this.props.onError(attr)), 100, JSON.parse(JSON.stringify(this.isError)));
                this.isError = {};
            }
            if (schema.hideOnlyControl) {
                const item = (React$24.createElement(Grid2$2, { size: {
                        xs: schema.xs || DEFAULT_SM_SIZE, // if xs is not defined, take the full width
                        sm: schema.sm || undefined,
                        md: schema.md || undefined,
                        lg: schema.lg || undefined,
                        xl: schema.xl || undefined,
                    }, style: {
                        marginBottom: 0 /* marginRight: 8, */,
                        textAlign: 'left',
                        ...schema.style,
                        ...(this.props.oContext.themeType === 'dark' ? schema.darkStyle : {}),
                    } }));
                if (schema.newLine) {
                    return (React$24.createElement(React$24.Fragment, null,
                        React$24.createElement("div", { style: { flexBasis: '100%', height: 0 } }),
                        item));
                }
                return item;
            }
            return null;
        }
        // Add error
        if (schema.validatorNoSaveOnError) {
            if (error && !Object.keys(this.isError).length) {
                this.isError = {
                    [this.props.attr]: schema.validatorErrorText ? I18n$F.t(schema.validatorErrorText) : true,
                };
                setTimeout(isError => Object.keys(isError).forEach(attr => this.props.onError(attr, isError[attr])), 100, JSON.parse(JSON.stringify(this.isError)));
            }
            else if (!error && Object.keys(this.isError).length) {
                setTimeout(isError => Object.keys(isError).forEach(attr => this.props.onError(attr)), 100, JSON.parse(JSON.stringify(this.isError)));
                this.isError = {};
            }
        }
        const renderedItem = this.renderItem(error, disabled || this.props.commandRunning || this.props.disabled, defaultValue);
        if (this.noPlaceRequired) {
            return renderedItem;
        }
        const item = (React$24.createElement(Grid2$2, { title: this.getText(schema.tooltip), size: {
                xs: schema.xs || 12, // if xs is not defined, take the full width
                sm: schema.sm || undefined,
                md: schema.md || undefined,
                lg: schema.lg || undefined,
                xl: schema.xl || undefined,
            }, style: {
                marginBottom: 0,
                textAlign: 'left',
                width: schema.type === 'divider' || schema.type === 'header' ? schema.width || '100%' : undefined,
                ...schema.style,
                ...(this.props.oContext.themeType === 'dark' ? schema.darkStyle : {}),
            } }, this.props.schema.defaultSendTo && this.props.schema.button ? (React$24.createElement(Grid2$2, { container: true, style: { width: '100%' } },
            React$24.createElement(Grid2$2, { flex: 1 }, renderedItem),
            React$24.createElement(Grid2$2, null,
                React$24.createElement(Button$d, { disabled: disabled, variant: "outlined", onClick: () => this.sendTo(), title: this.props.schema.buttonTooltip
                        ? this.getText(this.props.schema.buttonTooltip, this.props.schema.buttonTooltipNoTranslation)
                        : I18n$F.t('ra_Request data by instance') }, this.getText(this.props.schema.button))))) : (renderedItem)));
        if (schema.newLine) {
            return (React$24.createElement(React$24.Fragment, null,
                React$24.createElement("div", { style: { flexBasis: '100%', height: 0 } }),
                this.renderDialogConfirm(),
                item));
        }
        if (this.state.confirmDialog) {
            return (React$24.createElement(React$24.Fragment, null,
                this.renderDialogConfirm(),
                item));
        }
        return item;
    }
}

const React$23 = await importShared('react');

const {FormHelperText: FormHelperText$j,Accordion: Accordion$2,AccordionSummary: AccordionSummary$2,AccordionDetails: AccordionDetails$2,IconButton: IconButton$d,Paper: Paper$1,Toolbar: Toolbar$2,Tooltip: Tooltip$2,Typography: Typography$3,Box: Box$c} = await importShared('@mui/material');

const {Add:AddIcon$1,Delete:DeleteIcon$1,ArrowUpward:UpIcon$1,ArrowDownward:DownIcon$1,ContentCopy:CopyContentIcon$1,ExpandMore:ExpandMoreIcon$2,Error:ErrorIcon$2,FileDownload:FileDownloadIcon,FileUpload:FileUploadIcon,AddCircle:AddCircleIcon} = await importShared('@mui/icons-material');

const {I18n: I18n$E,Utils: Utils$d} = await importShared('@iobroker/adapter-react-v5');
const styles$y = {
    fullWidth: {
        width: '100%',
    },
    accordionSummary: (theme) => ({
        backgroundColor: theme.palette.mode === 'dark' ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.08)',
    }),
    accordionTitle: {
    // fontWeight: 'bold',
    },
    toolbar: (theme) => ({
        backgroundColor: theme.palette.mode === 'dark' ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.08)',
        borderRadius: '3px',
    }),
    tooltip: {
        pointerEvents: 'none',
    },
};
class ConfigAccordion extends ConfigGeneric {
    typingTimer = null;
    constructor(props) {
        super(props);
        this.props.schema.items = this.props.schema.items || [];
    }
    componentDidMount() {
        super.componentDidMount();
        let value = ConfigGeneric.getValue(this.props.data, this.props.attr) || [];
        if (!Array.isArray(value)) {
            value = [];
        }
        this.setState({
            value,
            activeIndex: -1,
            iteration: 0,
            accordionErrors: {},
        });
    }
    componentWillUnmount() {
        if (this.typingTimer) {
            clearTimeout(this.typingTimer);
            this.typingTimer = null;
        }
        super.componentWillUnmount();
    }
    onAccordionError = (accordionIndex) => (attr, error) => {
        const newAccordionErrors = { ...this.state.accordionErrors };
        if (!newAccordionErrors[accordionIndex]) {
            newAccordionErrors[accordionIndex] = {};
        }
        if (!error) {
            delete newAccordionErrors[accordionIndex][attr];
            // Clean up empty accordion error objects
            if (Object.keys(newAccordionErrors[accordionIndex]).length === 0) {
                delete newAccordionErrors[accordionIndex];
            }
        }
        else {
            newAccordionErrors[accordionIndex][attr] = error;
        }
        this.setState({ accordionErrors: newAccordionErrors });
        // Also forward to parent
        this.props.onError(attr, error);
    };
    hasAccordionErrors = (accordionIndex) => {
        return !!(this.state.accordionErrors[accordionIndex] &&
            Object.keys(this.state.accordionErrors[accordionIndex]).length > 0);
    };
    itemAccordion(data, idx) {
        const { value } = this.state;
        const { schema } = this.props;
        const schemaItem = {
            type: 'panel',
            items: schema.items.reduce((accumulator, currentValue) => {
                accumulator[currentValue.attr] = currentValue;
                return accumulator;
            }, {}),
            style: { marginLeft: '-8px', marginTop: '10px', marginBottom: '10px' },
        };
        return (React$23.createElement(ConfigPanel, { oContext: this.props.oContext, index: idx + this.state.iteration, arrayIndex: idx, changed: this.props.changed, expertMode: this.props.expertMode, globalData: this.props.data, common: this.props.common, alive: this.props.alive, themeName: this.props.themeName, data: data, custom: true, schema: schemaItem, originalData: this.props.originalData, onChange: (attr, valueChange) => {
                const newObj = JSON.parse(JSON.stringify(value));
                newObj[idx][attr] = valueChange;
                this.setState({ value: newObj }, () => this.onChangeWrapper(newObj));
            }, onError: this.onAccordionError(idx), table: this.props.table }));
    }
    onDelete = (index) => () => {
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        newValue.splice(index, 1);
        this.setState({ value: newValue, iteration: this.state.iteration + 10000 }, () => this.onChangeWrapper(newValue));
    };
    onClone = (index) => () => {
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        const cloned = JSON.parse(JSON.stringify(newValue[index]));
        if (typeof this.props.schema.clone === 'string' && typeof cloned[this.props.schema.clone] === 'string') {
            let i = 1;
            let text = cloned[this.props.schema.clone];
            const pattern = text.match(/(\d+)$/);
            if (pattern) {
                text = text.replace(pattern[0], '');
                i = parseInt(pattern[0], 10) + 1;
            }
            else {
                text += '_';
            }
            while (newValue.find(it => it[this.props.schema.clone] === text + i.toString())) {
                i++;
            }
            cloned[this.props.schema.clone] = `${cloned[this.props.schema.clone]}_${i}`;
        }
        newValue.splice(index, 0, cloned);
        this.setState({
            value: newValue,
            activeIndex: -1,
            iteration: this.state.iteration + 10000,
        }, () => this.onChangeWrapper(newValue));
    };
    onChangeWrapper = (newValue) => {
        if (this.typingTimer) {
            clearTimeout(this.typingTimer);
        }
        this.typingTimer = setTimeout(value => {
            this.typingTimer = null;
            const mayByPromise = this.onChange(this.props.attr, value);
            if (mayByPromise instanceof Promise) {
                void mayByPromise.catch(e => this.onError(e));
            }
        }, 300, newValue);
    };
    onAdd = () => {
        const { schema } = this.props;
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        const newItem = schema.items &&
            schema.items.reduce((accumulator, currentValue) => {
                let defaultValue;
                if (currentValue.defaultFunc) {
                    if (this.props.custom) {
                        defaultValue = currentValue.defaultFunc
                            ? this.executeCustom(currentValue.defaultFunc, this.props.data, this.props.customObj, this.props.oContext.instanceObj, newValue.length, this.props.data)
                            : this.props.schema.default;
                    }
                    else {
                        defaultValue = currentValue.defaultFunc
                            ? this.execute(currentValue.defaultFunc, this.props.schema.default, this.props.data, newValue.length, this.props.data)
                            : this.props.schema.default;
                    }
                }
                else {
                    defaultValue = currentValue.default === undefined ? null : currentValue.default;
                }
                accumulator[currentValue.attr] = defaultValue;
                return accumulator;
            }, {});
        newValue.push(newItem);
        this.setState({ value: newValue, activeIndex: newValue.length - 1 }, () => this.onChangeWrapper(newValue));
    };
    onMoveUp(idx) {
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        const item = newValue[idx];
        newValue.splice(idx, 1);
        newValue.splice(idx - 1, 0, item);
        const newIndex = this.state.activeIndex - 1;
        this.setState({ value: newValue, activeIndex: newIndex, iteration: this.state.iteration + 10000 }, () => this.onChangeWrapper(newValue));
    }
    onMoveDown(idx) {
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        const item = newValue[idx];
        newValue.splice(idx, 1);
        newValue.splice(idx + 1, 0, item);
        const newIndex = this.state.activeIndex + 1;
        this.setState({ value: newValue, activeIndex: newIndex, iteration: this.state.iteration + 10000 }, () => this.onChangeWrapper(newValue));
    }
    onExport = () => {
        const { value } = this.state;
        const dataStr = JSON.stringify(value, null, 2);
        const dataUri = `data:application/json;charset=utf-8,${encodeURIComponent(dataStr)}`;
        const exportFileDefaultName = `config_section_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
    };
    onImport = (replace) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (event) => {
            const file = event.target.files?.[0];
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const jsonData = JSON.parse(e.target?.result);
                    if (!Array.isArray(jsonData)) {
                        alert(I18n$E.t('ra_Invalid JSON format. Expected an array.'));
                        return;
                    }
                    let newValue;
                    if (replace) {
                        newValue = jsonData;
                    }
                    else {
                        newValue = [...this.state.value, ...jsonData];
                    }
                    this.setState({ value: newValue, activeIndex: -1 }, () => this.onChangeWrapper(newValue));
                }
                catch {
                    alert(I18n$E.t('ra_Invalid JSON file.'));
                }
            };
            reader.readAsText(file);
        };
        input.click();
    };
    renderItem( /* error, disabled, defaultValue */) {
        const { schema } = this.props;
        const { value } = this.state;
        if (!value) {
            return null;
        }
        return (React$23.createElement(Paper$1, null,
            schema.label || !schema.noDelete ? (React$23.createElement(Toolbar$2, { variant: "dense" },
                schema.label ? (React$23.createElement(Typography$3, { variant: "h6", id: "tableTitle", component: "div" }, this.getText(schema.label))) : null,
                !schema.noDelete ? (React$23.createElement(React$23.Fragment, null,
                    React$23.createElement(Tooltip$2, { title: I18n$E.t('ra_Export configuration section') },
                        React$23.createElement(IconButton$d, { size: "small", color: "primary", onClick: this.onExport },
                            React$23.createElement(FileDownloadIcon, null))),
                    React$23.createElement(Tooltip$2, { title: I18n$E.t('ra_Import and replace configuration section') },
                        React$23.createElement(IconButton$d, { size: "small", color: "primary", onClick: () => this.onImport(true) },
                            React$23.createElement(FileUploadIcon, null))),
                    React$23.createElement(Tooltip$2, { title: I18n$E.t('ra_Import and add configuration section') },
                        React$23.createElement(IconButton$d, { size: "small", color: "primary", onClick: () => this.onImport(false) },
                            React$23.createElement(AddCircleIcon, null))),
                    React$23.createElement(IconButton$d, { size: "small", color: "primary", onClick: this.onAdd },
                        React$23.createElement(AddIcon$1, null)))) : null)) : null,
            value.map((idx, i) => (React$23.createElement(Accordion$2, { key: `${idx}_${i}`, expanded: this.state.activeIndex === i, onChange: (_e, expanded) => this.setState({ activeIndex: expanded ? i : -1 }) },
                React$23.createElement(AccordionSummary$2, { expandIcon: React$23.createElement(ExpandMoreIcon$2, null), sx: Utils$d.getStyle(this.props.oContext.theme, styles$y.fullWidth, styles$y.accordionSummary) },
                    React$23.createElement(Box$c, { sx: { display: 'flex', alignItems: 'center', gap: 1, width: '100%' } },
                        React$23.createElement(Typography$3, { style: styles$y.accordionTitle }, idx[schema.titleAttr]),
                        this.hasAccordionErrors(i) && React$23.createElement(ErrorIcon$2, { sx: { fontSize: 20, color: 'error.main' } }))),
                React$23.createElement(AccordionDetails$2, { style: {
                        ...schema.style,
                        ...(this.props.oContext.themeType ? schema.darkStyle : undefined),
                    } },
                    this.itemAccordion(value[i], i),
                    React$23.createElement(Toolbar$2, { sx: styles$y.toolbar },
                        i ? (React$23.createElement(Tooltip$2, { title: I18n$E.t('ra_Move up'), slotProps: { popper: { sx: styles$y.tooltip } } },
                            React$23.createElement(IconButton$d, { size: "small", onClick: () => this.onMoveUp(i) },
                                React$23.createElement(UpIcon$1, null)))) : (React$23.createElement("div", { style: styles$y.buttonEmpty })),
                        i < value.length - 1 ? (React$23.createElement(Tooltip$2, { title: I18n$E.t('ra_Move down'), slotProps: { popper: { sx: styles$y.tooltip } } },
                            React$23.createElement(IconButton$d, { size: "small", onClick: () => this.onMoveDown(i) },
                                React$23.createElement(DownIcon$1, null)))) : (React$23.createElement("div", { style: styles$y.buttonEmpty })),
                        !schema.noDelete ? (React$23.createElement(Tooltip$2, { title: I18n$E.t('ra_Delete current row'), slotProps: { popper: { sx: styles$y.tooltip } } },
                            React$23.createElement(IconButton$d, { size: "small", onClick: this.onDelete(i) },
                                React$23.createElement(DeleteIcon$1, null)))) : null,
                        schema.clone ? (React$23.createElement(Tooltip$2, { title: I18n$E.t('ra_Clone current row'), slotProps: { popper: { sx: styles$y.tooltip } } },
                            React$23.createElement(IconButton$d, { size: "small", onClick: this.onClone(i) },
                                React$23.createElement(CopyContentIcon$1, null)))) : null))))),
            !schema.noDelete && value.length > 0 ? (React$23.createElement(Toolbar$2, { variant: "dense", sx: styles$y.rootTool },
                React$23.createElement(IconButton$d, { size: "small", color: "primary", onClick: this.onAdd },
                    React$23.createElement(AddIcon$1, null)))) : null,
            schema.help ? (React$23.createElement(FormHelperText$j, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$22 = await importShared('react');

const {I18n: I18n$D} = await importShared('@iobroker/adapter-react-v5');
const styles$x = {
    root: {
        width: '100%',
    },
    notAlive: {
        color: '#a30000',
    },
};
class ConfigAlive extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const instance = this.getInstance();
        void this.props.oContext.socket
            .getState(`${instance}.alive`)
            .then(state => this.setState({ alive: !!(state && state.val), instance }));
    }
    getInstance() {
        let instance = this.props.schema.instance || `${this.props.oContext.adapterName}.${this.props.oContext.instance}`;
        if (instance.includes('${')) {
            instance = this.getPattern(instance, null, true);
        }
        if (instance && !instance.startsWith('system.adapter.')) {
            instance = `system.adapter.${instance}`;
        }
        return instance;
    }
    renderItem() {
        if (this.getInstance() !== this.state.instance) {
            setTimeout(() => {
                const instance = this.getInstance();
                if (instance) {
                    void this.props.oContext.socket
                        .getState(`${instance}.alive`)
                        .then(state => this.setState({ alive: !!(state && state.val), instance }));
                }
                else {
                    this.setState({ alive: null, instance });
                }
            }, 200);
        }
        if (this.state.alive !== false && this.state.alive !== true) {
            return null;
        }
        const instance = this.state.instance.replace(/^system.adapter./, '');
        return (React$22.createElement("div", { style: { ...styles$x.root, ...(!this.state.alive ? styles$x.notAlive : undefined) } }, this.state.alive
            ? this.props.schema.textAlive !== undefined
                ? this.props.schema.textAlive
                    ? I18n$D.t(this.props.schema.textAlive, instance)
                    : ''
                : I18n$D.t('ra_Instance %s is alive', instance)
            : this.props.schema.textNotAlive !== undefined
                ? this.props.schema.textNotAlive
                    ? I18n$D.t(this.props.schema.textNotAlive, instance)
                    : ''
                : I18n$D.t('ra_Instance %s is not alive', instance)));
    }
}

const React$21 = await importShared('react');

const {Autocomplete: Autocomplete$3,TextField: TextField$m} = await importShared('@mui/material');

const {I18n: I18n$C} = await importShared('@iobroker/adapter-react-v5');
class ConfigAutocomplete extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        const selectOptions = this.props.schema.options.map((item) => typeof item === 'string' ? { label: item, value: item } : JSON.parse(JSON.stringify(item)));
        // if __different
        if (Array.isArray(value)) {
            selectOptions.unshift({
                label: I18n$C.t(ConfigGeneric.DIFFERENT_LABEL),
                value: ConfigGeneric.DIFFERENT_VALUE,
            });
            this.setState({ value: ConfigGeneric.DIFFERENT_VALUE, selectOptions });
        }
        else {
            this.setState({ value, selectOptions });
        }
    }
    renderItem(error, disabled) {
        if (!this.state.selectOptions) {
            return null;
        }
        let item;
        const options = JSON.parse(JSON.stringify(this.state.selectOptions));
        const isIndeterminate = Array.isArray(this.state.value) || this.state.value === ConfigGeneric.DIFFERENT_VALUE;
        if (isIndeterminate) {
            [...this.state.value]
                .filter(val => !options.find(it => (typeof it === 'object' ? it.value === val : it === val)))
                .forEach(it => options.push({ label: it.toString(), value: it }));
            item = { label: I18n$C.t(ConfigGeneric.DIFFERENT_LABEL), value: ConfigGeneric.DIFFERENT_VALUE };
            options.unshift(item);
        }
        else {
            item =
                this.state.value !== null &&
                    this.state.value !== undefined &&
                    options.find(_item => typeof _item === 'object' ? _item.value == this.state.value : _item == this.state.value); // let "==" be and not ===
            if (this.state.value !== null && this.state.value !== undefined && !item && this.props.schema.freeSolo) {
                item = { value: this.state.value, label: this.state.value };
                options.push(item);
            }
        }
        return (React$21.createElement(Autocomplete$3, { fullWidth: true, freeSolo: !!this.props.schema.freeSolo, value: item, options: options, isOptionEqualToValue: (option, value) => option.value === value.value, filterOptions: (options, params) => {
                const filtered = options.filter(option => {
                    if (params.inputValue === '') {
                        return true;
                    }
                    return (option.label.toLowerCase().includes(params.inputValue.toLowerCase()) ||
                        option.value.toLowerCase().includes(params.inputValue.toLowerCase()));
                });
                if (this.props.schema.freeSolo && params.inputValue !== '') {
                    filtered.push({
                        label: params.inputValue,
                        value: params.inputValue,
                    });
                }
                return filtered;
            }, 
            // autoComplete
            onInputChange: e => {
                if (!e || !this.props.schema.freeSolo) {
                    return;
                }
                const val = e.target.value;
                if (val !== this.state.value) {
                    this.setState({ value: val }, () => this.onChange(this.props.attr, val));
                }
            }, onChange: (_, value) => {
                const val = typeof value === 'object' ? (value ? value.value : '') : value;
                if (val !== this.state.value) {
                    this.setState({ value: val }, () => this.onChange(this.props.attr, val));
                }
            }, getOptionLabel: option => (typeof option === 'object' ? (option?.label ?? '') : ''), renderInput: params => (React$21.createElement(TextField$m, { variant: "standard", ...params, error: !!error, 
                // inputProps are important and will be given in params
                // inputProps={{maxLength: this.props.schema.maxLength || this.props.schema.max || undefined}}
                placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation), disabled: disabled })) }));
    }
}

const React$20 = await importShared('react');

const {Autocomplete: Autocomplete$2,TextField: TextField$l,CircularProgress: CircularProgress$4,InputAdornment: InputAdornment$4} = await importShared('@mui/material');

const {I18n: I18n$B} = await importShared('@iobroker/adapter-react-v5');
class ConfigAutocompleteSendTo extends ConfigGeneric {
    initialized = false;
    localContext;
    askInstance() {
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        const selectOptions = this.props.schema.options
            ? this.props.schema.options.map((item) => typeof item === 'string' ? { label: item, value: item } : JSON.parse(JSON.stringify(item)))
            : [];
        if (this.props.alive) {
            let data = this.props.schema.data;
            if (data === undefined && this.props.schema.jsonData) {
                const dataStr = this.getPattern(this.props.schema.jsonData, null, true);
                try {
                    if (typeof dataStr === 'string') {
                        data = JSON.parse(dataStr);
                    }
                }
                catch {
                    console.error(`Cannot parse json data: ${JSON.stringify(data)}`);
                }
            }
            if (data === undefined) {
                data = null;
            }
            // Set loading state during sendTo request
            this.setState({ loading: true });
            void this.props.oContext.socket
                .sendTo(`${this.props.oContext.adapterName}.${this.props.oContext.instance}`, this.props.schema.command || 'send', data)
                .then((list) => {
                if (list && Array.isArray(list)) {
                    list.forEach(item => selectOptions.push(typeof item === 'string'
                        ? { label: item, value: item }
                        : JSON.parse(JSON.stringify(item))));
                }
                // if __different
                if (Array.isArray(value)) {
                    selectOptions.unshift({
                        label: I18n$B.t(ConfigGeneric.DIFFERENT_LABEL),
                        value: ConfigGeneric.DIFFERENT_VALUE,
                    });
                    this.setState({ value: ConfigGeneric.DIFFERENT_VALUE, selectOptions, loading: false });
                }
                else {
                    this.setState({ value, selectOptions, loading: false });
                }
            })
                .catch(error => {
                console.error('Error in autocompleteSendTo:', error);
                // Clear loading state on error
                this.setState({ loading: false });
            });
        }
        else if (Array.isArray(value)) {
            // if __different
            selectOptions.unshift({
                label: I18n$B.t(ConfigGeneric.DIFFERENT_LABEL),
                value: ConfigGeneric.DIFFERENT_VALUE,
            });
            this.setState({ value: ConfigGeneric.DIFFERENT_VALUE, selectOptions });
        }
        else {
            this.setState({ value, selectOptions });
        }
    }
    getContext() {
        const localContext = {};
        if (Array.isArray(this.props.schema.alsoDependsOn)) {
            this.props.schema.alsoDependsOn.forEach(attr => (localContext[attr] = ConfigGeneric.getValue(this.props.data, attr)));
        }
        return JSON.stringify(localContext);
    }
    renderItem(error, disabled) {
        if (this.props.alive) {
            const localContext = this.getContext();
            if (localContext !== this.localContext || !this.initialized) {
                this.localContext = localContext;
                setTimeout(() => this.askInstance(), this.initialized ? 300 : 50);
                this.initialized = true;
            }
        }
        let item;
        const options = this.state.selectOptions
            ? JSON.parse(JSON.stringify(this.state.selectOptions))
            : [];
        const isIndeterminate = Array.isArray(this.state.value) || this.state.value === ConfigGeneric.DIFFERENT_LABEL;
        if (isIndeterminate) {
            [...this.state.value]
                .filter(val => !options.find((it) => it.value === val))
                .forEach(it => options.push({ label: it.toString(), value: it }));
            item = { label: I18n$B.t(ConfigGeneric.DIFFERENT_LABEL), value: ConfigGeneric.DIFFERENT_VALUE };
            options.unshift(item);
        }
        else {
            item =
                this.state.value !== null &&
                    this.state.value !== undefined &&
                    options.find((item) => item.value == this.state.value); // let "==" be and not ===
            if (this.state.value !== null && this.state.value !== undefined && !item && this.props.schema.freeSolo) {
                item = { value: this.state.value, label: this.state.value };
                options.push(item);
            }
            item = item || null;
        }
        if (!options.length) {
            return (React$20.createElement(TextField$l, { variant: "standard", fullWidth: true, value: this.state.value === null || this.state.value === undefined ? '' : this.state.value, error: !!error, disabled: disabled, inputProps: {
                    maxLength: this.props.schema.maxLength || this.props.schema.max || undefined,
                }, InputProps: this.state.loading
                    ? {
                        endAdornment: (React$20.createElement(InputAdornment$4, { position: "end" },
                            React$20.createElement(CircularProgress$4, { size: 20 }))),
                    }
                    : undefined, onChange: e => {
                    const value = e.target.value;
                    this.setState({ value }, () => this.onChange(this.props.attr, (value || '').trim()));
                }, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }));
        }
        return (React$20.createElement(Autocomplete$2, { value: item, fullWidth: true, freeSolo: !!this.props.schema.freeSolo, options: options, isOptionEqualToValue: (option, value) => option.value === value.value, filterOptions: (options, params) => {
                const filtered = options.filter(option => {
                    if (params.inputValue === '') {
                        return true;
                    }
                    return (option.label.toLowerCase().includes(params.inputValue.toLowerCase()) ||
                        option.value.toLowerCase().includes(params.inputValue.toLowerCase()));
                });
                if (this.props.schema.freeSolo && params.inputValue !== '') {
                    filtered.push({
                        label: params.inputValue,
                        value: params.inputValue,
                    });
                }
                return filtered;
            }, getOptionLabel: (option) => option?.label ?? '', onInputChange: e => {
                if (!e || !this.props.schema.freeSolo) {
                    return;
                }
                const val = e.target.value;
                if (val !== this.state.value) {
                    this.setState({ value: val }, () => this.onChange(this.props.attr, val));
                }
            }, onChange: (_, value) => {
                const val = typeof value === 'object' ? (value ? value.value : '') : value;
                if (val !== this.state.value) {
                    this.setState({ value: val }, () => this.onChange(this.props.attr, val));
                }
            }, renderInput: params => (React$20.createElement(TextField$l, { variant: "standard", ...params, 
                // inputProps are important and will be given in params
                // inputProps={{maxLength: this.props.schema.maxLength || this.props.schema.max || undefined}}
                error: !!error, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation), disabled: disabled, InputProps: {
                    ...params.InputProps,
                    endAdornment: (React$20.createElement(React$20.Fragment, null,
                        this.state.loading ? (React$20.createElement(InputAdornment$4, { position: "end" },
                            React$20.createElement(CircularProgress$4, { size: 20 }))) : null,
                        params.InputProps.endAdornment)),
                } })) }));
    }
}

const React$1$ = await importShared('react');

const {InputLabel: InputLabel$h,FormControl: FormControl$m,Button: Button$c,TextField: TextField$k} = await importShared('@mui/material');

const {DialogCron,I18n: I18n$A} = await importShared('@iobroker/adapter-react-v5');
const styles$w = {
    fullWidth: {
        width: '100%',
    },
    flex: {
        display: 'flex',
    },
    button: {
        height: 48,
        marginLeft: 4,
        minWidth: 48,
    },
};
class ConfigCRON extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const { data, attr } = this.props;
        const value = ConfigGeneric.getValue(data, attr) || '';
        this.setState({ value, showDialog: false });
    }
    renderItem(error, disabled /* , defaultValue */) {
        const { schema, attr } = this.props;
        const { value, showDialog } = this.state;
        return (React$1$.createElement(FormControl$m, { style: styles$w.fullWidth, variant: "standard" },
            schema.label ? React$1$.createElement(InputLabel$h, { shrink: true }, this.getText(schema.label)) : null,
            React$1$.createElement("div", { style: styles$w.flex },
                React$1$.createElement(TextField$k, { variant: "standard", fullWidth: true, value: value ?? '', error: !!error, disabled: disabled, placeholder: this.getText(schema.placeholder), label: this.getText(schema.label), helperText: this.renderHelp(schema.help, schema.helpLink, schema.noTranslation), onChange: e => {
                        const value_ = e.target.value;
                        this.setState({ value: value_ }, () => this.onChange(attr, value_));
                    } }),
                React$1$.createElement(Button$c, { color: "grey", disabled: disabled, style: styles$w.button, size: "small", variant: "outlined", onClick: () => this.setState({ showDialog: true }) }, "...")),
            showDialog ? (React$1$.createElement(DialogCron, { title: I18n$A.t('ra_Define schedule'), simple: schema.simple, complex: schema.complex, cron: value, onClose: () => this.setState({ showDialog: false }), cancel: I18n$A.t('ra_Cancel'), ok: I18n$A.t('ra_Ok'), theme: this.props.oContext.theme, onOk: value_ => this.setState({ showDialog: false, value: value_ }, () => this.onChange(attr, value_)) })) : null));
    }
}

const React$1_ = await importShared('react');

const {InputLabel: InputLabel$g,MenuItem: MenuItem$e,FormControl: FormControl$l,Select: Select$d,FormHelperText: FormHelperText$i} = await importShared('@mui/material');

const {I18n: I18n$z} = await importShared('@iobroker/adapter-react-v5');
class ConfigCertificateSelect extends ConfigGeneric {
    async componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        // Important: getCertificates is only available in AdminConnection
        const certificates = await this.props.oContext.socket.getCertificates();
        const selectOptions = certificates
            .filter(el => {
            const name = this.props.attr.toLowerCase();
            if (name.includes(el.type)) {
                return true;
            }
            if (el.type === 'public' && name.includes('cert')) {
                return true;
            }
            if (el.type === 'private' && (name.includes('priv') || name.includes('key'))) {
                return true;
            }
            return !!(el.type === 'chained' && (name.includes('chain') || name.includes('ca')));
        })
            .map(el => ({ label: el.name, value: el.name }));
        selectOptions.unshift({ label: I18n$z.t(ConfigGeneric.NONE_LABEL), value: ConfigGeneric.NONE_VALUE });
        this.setState({ value, selectOptions });
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (!this.state.selectOptions) {
            return null;
        }
        const item = this.state.selectOptions?.find(_item => _item.value === this.state.value);
        return (React$1_.createElement(FormControl$l, { style: { width: '100%' }, variant: "standard" },
            this.props.schema.label ? (React$1_.createElement(InputLabel$g, { shrink: true }, this.getText(this.props.schema.label))) : null,
            React$1_.createElement(Select$d, { variant: "standard", error: !!error, displayEmpty: true, disabled: !!disabled, value: this.state.value, renderValue: () => this.getText(item?.label, this.props.schema.noTranslation !== false), onChange: e => this.setState({ value: e.target.value }, () => this.onChange(this.props.attr, this.state.value)) }, this.state.selectOptions?.map(item_ => (React$1_.createElement(MenuItem$e, { key: item_.value, value: item_.value, style: item_.value === ConfigGeneric.NONE_VALUE ? { opacity: 0.5 } : {} }, this.getText(item_.label, this.props.schema.noTranslation !== false))))),
            this.props.schema.help ? (React$1_.createElement(FormHelperText$i, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$1Z = await importShared('react');

const {InputLabel: InputLabel$f,MenuItem: MenuItem$d,FormControl: FormControl$k,Select: Select$c} = await importShared('@mui/material');

const {I18n: I18n$y} = await importShared('@iobroker/adapter-react-v5');
const styles$v = {
    fullWidth: {
        width: '100%',
    },
    leWidth: {
        width: 620,
        marginBottom: 10,
    },
    certWidth: {
        width: 200,
        marginRight: 10,
    },
};
class ConfigCertificates extends ConfigGeneric {
    async componentDidMount() {
        super.componentDidMount();
        // Important: getCertificates is only available in AdminConnection
        const certificates = await this.props.oContext.socket.getCertificates();
        const certsPublicOptions = [];
        const certsPrivateOptions = [];
        const certsChainOptions = [];
        let collectionsOptions = [];
        const collectionsOptionsObj = await this.props.oContext.socket.getObject('system.certificates');
        if (collectionsOptionsObj?.native?.collections) {
            collectionsOptions = Object.keys(collectionsOptionsObj.native.collections);
        }
        else {
            collectionsOptions = null;
        }
        certificates.forEach(el => {
            if (el.type === 'public') {
                certsPublicOptions.push({ label: el.name, value: el.name });
            }
            else if (el.type === 'private') {
                certsPrivateOptions.push({ label: el.name, value: el.name });
            }
            else if (el.type === 'chained') {
                certsChainOptions.push({ label: el.name, value: el.name });
            }
            else {
                certsPublicOptions.push({ label: el.name, value: el.name });
                certsPrivateOptions.push({ label: el.name, value: el.name });
                certsChainOptions.push({ label: el.name, value: el.name });
            }
        });
        certsPublicOptions.unshift({ label: I18n$y.t(ConfigGeneric.NONE_LABEL), value: ConfigGeneric.NONE_VALUE });
        certsPrivateOptions.unshift({ label: I18n$y.t(ConfigGeneric.NONE_LABEL), value: ConfigGeneric.NONE_VALUE });
        certsChainOptions.unshift({ label: I18n$y.t(ConfigGeneric.NONE_LABEL), value: ConfigGeneric.NONE_VALUE });
        this.setState({
            certsPublicOptions,
            certsChainOptions,
            certsPrivateOptions,
            collectionsOptions,
        });
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (!this.state.certsPublicOptions || !this.state.certsPrivateOptions || !this.state.certsChainOptions) {
            return null;
        }
        const leCollection = (ConfigGeneric.getValue(this.props.data, this.props.schema.leCollectionName || 'leCollection') || 'false').toString();
        const certPublic = ConfigGeneric.getValue(this.props.data, this.props.schema.certPublicName || 'certPublic');
        const certPrivate = ConfigGeneric.getValue(this.props.data, this.props.schema.certPrivateName || 'certPrivate');
        const certChained = ConfigGeneric.getValue(this.props.data, this.props.schema.certChainedName || 'certChained');
        const itemCertPublic = this.state.certsPublicOptions?.find(item => item.value === certPublic);
        const itemCertPrivate = this.state.certsPrivateOptions?.find(item => item.value === certPrivate);
        const itemCertChained = this.state.certsChainOptions?.find(item => item.value === certChained);
        return (React$1Z.createElement("div", { style: styles$v.fullWidth },
            this.state.collectionsOptions ? (React$1Z.createElement(FormControl$k, { style: styles$v.leWidth, variant: "standard" },
                React$1Z.createElement(InputLabel$f, { shrink: true }, "Let's encrypt"),
                React$1Z.createElement(Select$c, { variant: "standard", error: !!error, displayEmpty: true, disabled: !!disabled, value: leCollection, onChange: e => this.onChange(this.props.schema.leCollectionName || 'leCollection', e.target.value === 'false'
                        ? false
                        : e.target.value === 'true'
                            ? true
                            : e.target.value) },
                    React$1Z.createElement(MenuItem$d, { key: "_false", value: "false", style: { fontWeight: 'bold' } }, I18n$y.t("ra_Do not use let's encrypt")),
                    React$1Z.createElement(MenuItem$d, { key: "_true", value: "true", style: { fontWeight: 'bold' } }, I18n$y.t("ra_Use all available let's encrypt certificates")),
                    this.state.collectionsOptions?.map(item => (React$1Z.createElement(MenuItem$d, { key: item, value: item }, item)))))) : null,
            this.state.collectionsOptions ? React$1Z.createElement("br", null) : null,
            this.state.collectionsOptions && leCollection !== 'false' ? (React$1Z.createElement("div", null, I18n$y.t('ra_Fallback custom certificates'))) : null,
            React$1Z.createElement(FormControl$k, { style: styles$v.certWidth, variant: "standard" },
                React$1Z.createElement(InputLabel$f, { shrink: true }, I18n$y.t('ra_Public certificate')),
                React$1Z.createElement(Select$c, { variant: "standard", error: !!error, displayEmpty: true, disabled: !!disabled, value: certPublic || '', renderValue: () => this.getText(itemCertPublic?.label), onChange: e => this.onChange(this.props.schema.certPublicName || 'certPublic', e.target.value) }, this.state.certsPublicOptions?.map((item, i) => (React$1Z.createElement(MenuItem$d, { key: `${item.value}_${i}`, value: item.value, style: item.value === ConfigGeneric.NONE_VALUE ? { opacity: 0.5 } : {} }, this.getText(item.label)))))),
            React$1Z.createElement(FormControl$k, { style: styles$v.certWidth, variant: "standard" },
                React$1Z.createElement(InputLabel$f, { shrink: true }, I18n$y.t('ra_Private certificate')),
                React$1Z.createElement(Select$c, { variant: "standard", error: !!error, displayEmpty: true, disabled: !!disabled, value: certPrivate || '', renderValue: () => this.getText(itemCertPrivate?.label), onChange: e => this.onChange(this.props.schema.certPrivateName || 'certPrivate', e.target.value) }, this.state.certsPrivateOptions?.map((item, i) => (React$1Z.createElement(MenuItem$d, { key: `${item.value}_${i}`, value: item.value, style: item.value === ConfigGeneric.NONE_VALUE ? { opacity: 0.5 } : {} }, this.getText(item.label)))))),
            React$1Z.createElement(FormControl$k, { style: styles$v.certWidth, variant: "standard" },
                React$1Z.createElement(InputLabel$f, { shrink: true }, I18n$y.t('ra_Chained certificate')),
                React$1Z.createElement(Select$c, { variant: "standard", error: !!error, displayEmpty: true, disabled: !!disabled, value: certChained || '', renderValue: () => this.getText(itemCertChained?.label), onChange: e => this.onChange(this.props.schema.certChainedName || 'certChained', e.target.value) }, this.state.certsChainOptions?.map((item, i) => (React$1Z.createElement(MenuItem$d, { key: `${item.value}_${i}`, value: item.value, style: item.value === ConfigGeneric.NONE_VALUE ? { opacity: 0.5 } : {} }, this.getText(item.label))))))));
    }
}

const React$1Y = await importShared('react');

const {InputLabel: InputLabel$e,MenuItem: MenuItem$c,FormControl: FormControl$j,Select: Select$b,FormHelperText: FormHelperText$h} = await importShared('@mui/material');

const {I18n: I18n$x} = await importShared('@iobroker/adapter-react-v5');
class ConfigCertCollection extends ConfigGeneric {
    async componentDidMount() {
        super.componentDidMount();
        let collectionsOptions;
        const collectionsOptionsObj = await this.props.oContext.socket.getObject('system.certificates');
        if (collectionsOptionsObj?.native?.collections) {
            collectionsOptions = Object.keys(collectionsOptionsObj.native.collections);
        }
        else {
            collectionsOptions = [];
        }
        this.setState({ collectionsOptions });
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (!this.state.collectionsOptions) {
            return null;
        }
        const leCollection = (ConfigGeneric.getValue(this.props.data, this.props.schema.leCollectionName || 'leCollection') || 'false').toString();
        return (React$1Y.createElement(FormControl$j, { style: { width: '100%' }, variant: "standard" },
            this.props.schema.label ? (React$1Y.createElement(InputLabel$e, { shrink: true }, this.getText(this.props.schema.label))) : null,
            React$1Y.createElement(Select$b, { variant: "standard", error: !!error, displayEmpty: true, disabled: !!disabled, value: leCollection, onChange: e => this.onChange(this.props.schema.leCollectionName || 'leCollection', e.target.value === 'false' ? false : e.target.value === 'true' ? true : e.target.value) },
                React$1Y.createElement(MenuItem$c, { key: "_false", value: "false", style: { fontWeight: 'bold' } }, I18n$x.t("ra_Do not use let's encrypt")),
                React$1Y.createElement(MenuItem$c, { key: "_true", value: "true", style: { fontWeight: 'bold' } }, I18n$x.t("ra_Use all available let's encrypt certificates")),
                this.state.collectionsOptions?.map(item => (React$1Y.createElement(MenuItem$c, { key: item, value: item }, item)))),
            this.props.schema.help ? (React$1Y.createElement(FormHelperText$h, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$1X = await importShared('react');

const {FormControlLabel: FormControlLabel$3,Checkbox: Checkbox$6,FormHelperText: FormHelperText$g,FormControl: FormControl$i,CircularProgress: CircularProgress$3} = await importShared('@mui/material');

const {I18n: I18n$w} = await importShared('@iobroker/adapter-react-v5');
// Send to admin message to check if the docker available and if available, show checkbox, else show warning if specified in the schema
class ConfigCheckDocker extends ConfigGeneric {
    async componentDidMount() {
        super.componentDidMount();
        const id = await this.props.oContext.socket.getCurrentInstance();
        this.setState({ requesting: true }, async () => {
            const result = await this.props.oContext.socket.sendTo(id, 'checkDocker', null);
            this.setState({
                requesting: false,
                version: result?.version || '',
                errorDocker: result
                    ? !result.daemonRunning
                        ? I18n$w.t('ra_Docker is not installed or not running')
                        : ''
                    : I18n$w.t('ra_No response from admin'),
            });
        });
    }
    renderItem(error, disabled) {
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        if (this.state.requesting) {
            return React$1X.createElement(CircularProgress$3, null);
        }
        if (this.state.errorDocker && !value) {
            return (React$1X.createElement(FormHelperText$g, { style: { color: 'orange' } },
                I18n$w.t('ra_Docker is not available'),
                ":\u00A0",
                I18n$w.t(`ra_${this.state.errorDocker}`).replace(/^ra_/, '')));
        }
        return (React$1X.createElement(FormControl$i, { style: { width: '100%' }, variant: "standard" },
            React$1X.createElement(FormControlLabel$3, { onClick: e => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!disabled) {
                        const mayByPromise = this.onChange(this.props.attr, !value);
                        if (mayByPromise instanceof Promise) {
                            void mayByPromise.catch(e => console.error(`Cannot set value: ${e}`));
                        }
                    }
                }, control: React$1X.createElement(Checkbox$6, { checked: !!value, onChange: e => {
                        void this.onChange(this.props.attr, e.target.checked);
                    }, disabled: disabled || (!!this.state.errorDocker && !value) }), label: this.getText(this.props.schema.label) }),
            !this.props.schema.hideVersion ? (React$1X.createElement(FormHelperText$g, null, this.state.errorDocker ? this.state.errorDocker : this.state.version)) : null,
            this.props.schema.help ? (React$1X.createElement(FormHelperText$g, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$1W = await importShared('react');

const {Button: Button$b,CircularProgress: CircularProgress$2,Dialog: Dialog$4,DialogContent: DialogContent$3,DialogActions: DialogActions$3,DialogTitle: DialogTitle$3,Table: Table$1,TableHead: TableHead$1,TableCell: TableCell$1,TableRow: TableRow$1,TableBody: TableBody$1,DialogContentText,TableContainer: TableContainer$1,Box: Box$b} = await importShared('@mui/material');

const {Check:IconCheck,Send:IconSend} = await importShared('@mui/icons-material');

const {DialogConfirm: DialogConfirm$4,I18n: I18n$v} = await importShared('@iobroker/adapter-react-v5');
const styles$u = {
    fullWidth: {
        width: '100%',
    },
    licLabel: {
        fontWeight: 'bold',
        minWidth: 100,
        marginRight: 10,
        textTransform: 'capitalize',
        display: 'inline-block',
    },
    errorTitle: (theme) => ({
        color: theme.palette.mode === 'dark' ? '#e39191' : '#b62020',
    }),
    okTitle: (theme) => ({
        color: theme.palette.mode === 'dark' ? '#6fd56f' : '#007c00',
    }),
    errorText: (theme) => ({
        color: theme.palette.mode === 'dark' ? '#e39191' : '#b62020',
        mb: '30px',
    }),
};
class ConfigCheckLicense extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        this.setState({
            _error: '',
            running: false,
            showLicenseData: null,
            foundSuitableLicense: false,
            licenseOfflineCheck: false,
            result: null,
            allLicenses: null,
            askForUpdate: false,
            showLinkToProfile: false,
        });
    }
    renderErrorDialog() {
        if (this.state._error && !this.state.showLicenseData) {
            let content = this.state._error;
            if (this.state.allLicenses) {
                content = [React$1W.createElement("div", { key: "error" }, content)];
                content.push(React$1W.createElement(Button$b, { key: "button", variant: "contained", onClick: () => window.open('https://iobroker.net/www/account/licenses', '_blank') }, I18n$v.t('iobroker.net')));
                if (!this.state.allLicenses.length) {
                    content.push(React$1W.createElement("div", { key: "text1" }, I18n$v.t('ra_No one license found in license manager')));
                    content.push(React$1W.createElement("div", { key: "text2" }, I18n$v.t('ra_Please create license')));
                }
                else {
                    // license.id,
                    // validName,
                    // validUuid,
                    // validTill,
                    // validVersion,
                    // license,
                    content.push(React$1W.createElement(TableContainer$1, { key: "table" },
                        React$1W.createElement(Table$1, { size: "small" },
                            React$1W.createElement(TableHead$1, null,
                                React$1W.createElement(TableRow$1, null,
                                    React$1W.createElement(TableCell$1, null, I18n$v.t('ra_Product')),
                                    React$1W.createElement(TableCell$1, null, I18n$v.t('ra_Version')),
                                    React$1W.createElement(TableCell$1, null, "UUID"),
                                    React$1W.createElement(TableCell$1, null, I18n$v.t('ra_ValidTill')),
                                    React$1W.createElement(TableCell$1, null, I18n$v.t('ra_Commercial')),
                                    React$1W.createElement(TableCell$1, null, "ID"))),
                            React$1W.createElement(TableBody$1, null, this.state.allLicenses.map(license => (React$1W.createElement(TableRow$1, { key: license.id },
                                React$1W.createElement(TableCell$1, { sx: license.validName ? null : styles$u.errorText }, license.license.product),
                                React$1W.createElement(TableCell$1, { sx: license.validVersion ? null : styles$u.errorText }, license.license.version),
                                React$1W.createElement(TableCell$1, { sx: license.validUuid ? null : styles$u.errorText }, license.license.uuid || '--'),
                                React$1W.createElement(TableCell$1, { sx: license.validTill ? null : styles$u.errorText }, license.license.validTill &&
                                    license.license.validTill !== '0000-00-00 00:00:00'
                                    ? new Date(license.license.validTill).toLocaleDateString()
                                    : '--'),
                                React$1W.createElement(TableCell$1, null, license.license.invoice !== 'free'
                                    ? license.license.invoice === 'MANUALLY_CREATED'
                                        ? '✓'
                                        : license.license.invoice
                                    : '-'),
                                React$1W.createElement(TableCell$1, null, license.id))))))));
                }
            }
            return (React$1W.createElement(Dialog$4, { open: true, maxWidth: "xl", fullWidth: this.props.fullWidth !== undefined ? this.props.fullWidth : true, onClick: () => this.setState({ _error: '', allLicenses: null }) },
                React$1W.createElement(DialogTitle$3, null, I18n$v.t('ra_Error')),
                React$1W.createElement(DialogContent$3, null,
                    React$1W.createElement(DialogContentText, null, content)),
                React$1W.createElement(DialogActions$3, null,
                    React$1W.createElement(Button$b, { variant: "contained", onClick: () => this.setState({ _error: '', allLicenses: null }), color: "primary", autoFocus: true, startIcon: React$1W.createElement(IconCheck, null) }, I18n$v.t('ra_Ok')))));
        }
        return null;
    }
    renderMessageDialog() {
        if (this.state.showLicenseData) {
            const pre = [];
            const data = this.state.showLicenseData;
            Object.keys(data).forEach(key => {
                if (data[key] === null || data[key] === undefined) {
                    return;
                }
                if (typeof data[key] === 'object') {
                    const obj = data[key];
                    Object.keys(obj).forEach(key1 => {
                        if (obj[key1] !== null && obj[key1] !== undefined) {
                            if (typeof obj[key1] === 'object') {
                                pre.push(React$1W.createElement("div", { key: key1 },
                                    React$1W.createElement("div", { style: styles$u.licLabel },
                                        key1,
                                        ":"),
                                    JSON.stringify(obj[key1], null, 2)));
                            }
                            else {
                                pre.push(React$1W.createElement("div", { key: key1 },
                                    React$1W.createElement("div", { style: styles$u.licLabel },
                                        key,
                                        " -",
                                        key1,
                                        ":"),
                                    obj[key1].toString()));
                            }
                        }
                    });
                }
                else {
                    pre.push(React$1W.createElement("div", { key: key },
                        React$1W.createElement("div", { style: styles$u.licLabel },
                            key.replace(/_/g, ' '),
                            ":"),
                        data[key].toString()));
                }
            });
            pre.push(React$1W.createElement("div", { key: "checked" },
                React$1W.createElement("div", { style: styles$u.licLabel },
                    I18n$v.t('ra_Checked'),
                    ":"),
                this.state.licenseOfflineCheck ? I18n$v.t('ra_locally') : I18n$v.t('ra_via internet')));
            return (React$1W.createElement(Dialog$4, { open: true, onClose: () => this.setState({ showLicenseData: null }) },
                React$1W.createElement(DialogTitle$3, null,
                    React$1W.createElement(Box$b, { component: "span", sx: this.state.result ? styles$u.okTitle : styles$u.errorTitle }, I18n$v.t('ra_License %s', this.state.result ? 'OK' : 'INVALID'))),
                React$1W.createElement(DialogContent$3, null,
                    this.state.showLinkToProfile ? (React$1W.createElement(Button$b, { variant: "contained", onClick: () => window.open('https://iobroker.net/www/account/licenses', '_blank') }, "https://iobroker.net")) : null,
                    this.state._error ? (React$1W.createElement(Box$b, { component: "div", sx: styles$u.errorText }, this.state._error)) : null,
                    pre),
                React$1W.createElement(DialogActions$3, null,
                    React$1W.createElement(Button$b, { onClick: () => this.setState({ showLicenseData: null, _error: '' }), color: "primary", variant: "contained" }, I18n$v.t('ra_Close')))));
        }
        return null;
    }
    static parseJwt(token) {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const jsonPayload = decodeURIComponent(atob(base64)
            .split('')
            .map(c => `%${`00${c.charCodeAt(0).toString(16)}`.slice(-2)}`)
            .join(''));
        try {
            return JSON.parse(jsonPayload);
        }
        catch {
            return null;
        }
    }
    static isVersionValid(version, rule, invoice, adapterName) {
        if (!rule || !version) {
            return true;
        }
        let result = true;
        const [major] = version.split('.');
        if (rule.startsWith('>=')) {
            result = parseInt(major, 10) >= parseInt(rule.substring(2, 10));
        }
        else if (rule.startsWith('<=')) {
            result = parseInt(major, 10) <= parseInt(rule.substring(2, 10));
        }
        else if (rule.startsWith('>')) {
            result = parseInt(major, 10) > parseInt(rule.substring(1, 10));
        }
        else if (rule.startsWith('<')) {
            result = parseInt(major, 10) < parseInt(rule.substring(1, 10));
        }
        else if (rule.startsWith('=')) {
            result = parseInt(major, 10) === parseInt(rule.substring(1, 10));
        }
        else if (rule.startsWith('==')) {
            result = parseInt(major, 10) === parseInt(rule.substring(2, 10));
        }
        else if (rule.startsWith('===')) {
            result = parseInt(major, 10) === parseInt(rule.substring(3, 10));
        }
        if (!result && invoice && adapterName) {
            // all commercial licenses are valid for all versions
            if (invoice !== 'free') {
                return true;
            }
        }
        return true;
    }
    async findInLicenseManager(adapterName) {
        // read if the license manager is supported
        const licenses = await this.props.oContext.socket.getObject('system.licenses');
        const errors = [];
        if (licenses?.native?.licenses?.length) {
            // enable license manager
            let useLicense = null;
            const now = Date.now();
            let uuid;
            if (this.props.schema.uuid) {
                const uuidObj = await this.props.oContext.socket.getObject('system.meta.uuid');
                uuid = uuidObj?.native?.uuid;
            }
            let version;
            if (this.props.schema.version) {
                const aObj = await this.props.oContext.socket.getObject(`system.adapter.${adapterName}`);
                version = aObj?.common?.version;
            }
            // find license for vis
            licenses.native.licenses.forEach((license) => {
                const validTill = !license.validTill ||
                    license.validTill === '0000-00-00 00:00:00' ||
                    new Date(license.validTill).getTime() > now;
                const parts = (license.product || '').split('.');
                const validName = parts[1] === adapterName || (adapterName === 'vis-2' && parts[1] === 'vis');
                const validUuid = !uuid || !license.uuid || license.uuid === uuid;
                const validVersion = ConfigCheckLicense.isVersionValid(version, license.version, license.invoice, adapterName);
                // commercial license has priority over free license
                if ((!useLicense || license.invoice !== 'free') &&
                    validTill &&
                    validName &&
                    validUuid &&
                    validVersion) {
                    useLicense = license;
                }
                errors.push({
                    id: license.id,
                    validName,
                    validUuid,
                    validVersion,
                    validTill,
                    license,
                });
            });
            if (useLicense) {
                errors.find(e => e.id === useLicense.id).used = true;
            }
        }
        return errors;
    }
    async checkLicense(license, adapterName) {
        let uuid;
        if (this.props.schema.uuid) {
            const uuidObj = await this.props.oContext.socket.getObject('system.meta.uuid');
            uuid = uuidObj?.native?.uuid;
        }
        let version;
        if (this.props.schema.version) {
            const aObj = await this.props.oContext.socket.getObject(`system.adapter.${adapterName}`);
            version = aObj?.common?.version;
        }
        const controller = new AbortController();
        let timeout = setTimeout(() => {
            timeout = null;
            controller.abort();
        }, 5000);
        try {
            const response = await window.fetch('https://iobroker.net/api/v1/public/cert/', {
                method: 'POST',
                body: JSON.stringify({ json: license, uuid }),
                headers: {
                    'Content-Type': 'text/plain',
                },
                signal: controller.signal,
            });
            if (timeout) {
                clearTimeout(timeout);
            }
            const dataStr = await response.text();
            let data;
            try {
                data = JSON.parse(dataStr);
            }
            catch {
                // ignore
            }
            if (data?.error) {
                try {
                    const data_ = ConfigCheckLicense.parseJwt(license);
                    const _error = I18n$v.t(`ra_${data_.error || data.error || 'Unknown error'}`).replace(/^ra_/, '');
                    return this.setState({
                        _error,
                        licenseOfflineCheck: false,
                        showLicenseData: data_,
                        result: false,
                        running: false,
                    });
                }
                catch {
                    console.log('Cannot parse license');
                    return this.setState({ _error: data.error, result: false, running: false });
                }
            }
            else {
                let showLicenseData = null;
                try {
                    showLicenseData = ConfigCheckLicense.parseJwt(license);
                }
                catch {
                    // ignore
                }
                if (data) {
                    const validTill = data.validTill || data.valid_till;
                    if (validTill &&
                        validTill !== '0000-00-00 00:00:00' &&
                        new Date(validTill).getTime() < Date.now()) {
                        return this.setState({
                            _error: I18n$v.t('ra_License expired on %s', new Date(validTill).toLocaleString()),
                            licenseOfflineCheck: false,
                            showLicenseData,
                            result: false,
                            running: false,
                        });
                    }
                    const parts = (data.name || '').split('.');
                    if (parts[1] === adapterName || (parts[1] === 'vis' && adapterName === 'vis-2')) {
                        // check UUID
                        if (uuid && !data.uuid && adapterName === 'vis-2') {
                            return this.setState({
                                _error: I18n$v.t('ra_License must be converted', data.uuid),
                                showLinkToProfile: true,
                                licenseOfflineCheck: false,
                                showLicenseData,
                                result: false,
                                running: false,
                            });
                        }
                        if (uuid && data.uuid && data.uuid !== uuid) {
                            return this.setState({
                                _error: I18n$v.t('ra_Serial number (UUID) "%s" in license is for other device.', data.uuid),
                                licenseOfflineCheck: false,
                                showLicenseData,
                                result: false,
                                running: false,
                            });
                        }
                        if (!ConfigCheckLicense.isVersionValid(version, data.version, data.invoice, adapterName)) {
                            return this.setState({
                                _error: I18n$v.t('ra_License is for version %s, but required version is %s', data.version, this.props.schema.version),
                                licenseOfflineCheck: false,
                                showLicenseData,
                                result: false,
                                running: false,
                            });
                        }
                        return this.setState({
                            licenseOfflineCheck: false,
                            showLicenseData,
                            result: true,
                            running: false,
                        });
                    }
                    return this.setState({
                        _error: I18n$v.t('ra_License for other product "%s"', data.name),
                        licenseOfflineCheck: false,
                        showLicenseData,
                        result: false,
                        running: false,
                    });
                }
                throw new Error('ra_Invalid answer from server');
            }
        }
        catch (error) {
            if (error?.response?.status === 404) {
                return this.setState({ _error: I18n$v.t('ra_License does not exist'), result: false, running: false });
            }
            // check offline
            try {
                const data = ConfigCheckLicense.parseJwt(license);
                const parts = (data.name || '').split('.');
                if (data.valid_till &&
                    data.valid_till !== '0000-00-00 00:00:00' &&
                    new Date(data.valid_till).getTime() < Date.now()) {
                    return this.setState({
                        _error: I18n$v.t('ra_License expired on %s', new Date(data.valid_till).toLocaleString()),
                        showLicenseData: data,
                        licenseOfflineCheck: true,
                        running: false,
                        result: false,
                    });
                }
                if (parts[1] === adapterName) {
                    // check UUID
                    if (uuid && data.uuid && data.uuid !== uuid) {
                        return this.setState({
                            _error: I18n$v.t('ra_Serial number (UUID) "%s" in license is for other device.', data.uuid),
                            showLicenseData: data,
                            licenseOfflineCheck: true,
                            result: false,
                            running: false,
                        });
                    }
                    if (!ConfigCheckLicense.isVersionValid(version, data.version, data.invoice, adapterName)) {
                        return this.setState({
                            _error: I18n$v.t('ra_License is for version %s, but required version is %s', data.version, this.props.schema.version),
                            licenseOfflineCheck: true,
                            showLicenseData: data,
                            result: false,
                            running: false,
                        });
                    }
                    return this.setState({
                        running: false,
                        result: true,
                        licenseOfflineCheck: true,
                        showLicenseData: data,
                    });
                }
                return this.setState({
                    _error: I18n$v.t('ra_License for other product "%s"', data.name),
                    licenseOfflineCheck: true,
                    showLicenseData: data,
                    result: false,
                    running: false,
                });
            }
            catch {
                return this.setState({
                    _error: I18n$v.t('ra_Cannot decode license'),
                    result: false,
                    licenseOfflineCheck: true,
                    running: false,
                });
            }
        }
    }
    renderAskForUpdate() {
        if (!this.state.askForUpdate) {
            return null;
        }
        return (React$1W.createElement(DialogConfirm$4, { text: I18n$v.t('ra_License not found in license manager. Do you want to read licenses from iobroker.net?'), ok: I18n$v.t('ra_Yes'), onClose: async (isYes) => {
                if (isYes) {
                    this.setState({ askForUpdate: false });
                    try {
                        // updateLicense is available only in AdminConnection
                        await this.props.oContext.socket.updateLicenses(null, null);
                    }
                    catch (e) {
                        window.alert(I18n$v.t('ra_Cannot read licenses: %s', e));
                        return;
                    }
                    await this._onClick(true);
                }
                else {
                    this.setState({ askForUpdate: false, running: false });
                }
            } }));
    }
    async _onClick(secondRun) {
        const adapterName = this.props.oContext.adapterName === 'vis-2' ? 'vis' : this.props.oContext.adapterName;
        this.setState({ running: true });
        let license;
        let licenses;
        if (this.props.data.useLicenseManager) {
            licenses = await this.findInLicenseManager(adapterName);
            license = licenses.find(li => li.used);
            if (license) {
                license = license.license.json;
            }
            if (!license && !secondRun) {
                // no suitable license found in the license manager
                // should we read all licenses again?
                this.setState({ askForUpdate: true });
                return;
            }
        }
        else {
            license = this.props.data.license;
        }
        if (license) {
            await this.checkLicense(license, adapterName);
        }
        else if (this.props.data.useLicenseManager) {
            this.setState({
                _error: I18n$v.t('ra_Suitable license not found in license manager'),
                result: false,
                running: false,
                allLicenses: licenses,
            });
        }
        else {
            // this case could not happen
            this.setState({
                _error: I18n$v.t('ra_Please enter the license'),
                result: false,
                running: false,
            });
        }
    }
    renderItem( /* error, disabled, defaultValue */) {
        return (React$1W.createElement("div", { style: styles$u.fullWidth },
            React$1W.createElement(Button$b, { variant: this.props.schema.variant || 'outlined', color: this.props.schema.color || 'primary', style: styles$u.fullWidth, disabled: (!this.props.data.license && !this.props.data.useLicenseManager) || this.state.running, startIcon: React$1W.createElement(IconSend, null), onClick: () => this._onClick() },
                this.state.running ? (React$1W.createElement(CircularProgress$2, { size: 20, style: { marginRight: 8 } })) : null,
                this.getText(this.props.schema.label || 'ra_Check license', this.props.schema.noTranslation)),
            this.renderMessageDialog(),
            this.renderErrorDialog(),
            this.renderAskForUpdate()));
    }
}

const React$1V = await importShared('react');

const {FormControlLabel: FormControlLabel$2,Checkbox: Checkbox$5,FormHelperText: FormHelperText$f,FormControl: FormControl$h} = await importShared('@mui/material');

const {I18n: I18n$u} = await importShared('@iobroker/adapter-react-v5');
class ConfigCheckbox extends ConfigGeneric {
    renderItem(error, disabled) {
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        const isIndeterminate = Array.isArray(value);
        return (React$1V.createElement(FormControl$h, { style: { width: '100%' }, variant: "standard" },
            React$1V.createElement(FormControlLabel$2, { onClick: e => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!disabled) {
                        const mayByPromise = this.onChange(this.props.attr, !value);
                        if (mayByPromise instanceof Promise) {
                            void mayByPromise.catch(e => console.error(`Cannot set value: ${e}`));
                        }
                    }
                }, control: React$1V.createElement(Checkbox$5, { indeterminate: isIndeterminate, checked: !!value, onChange: e => {
                        let mayBePromise;
                        if (isIndeterminate) {
                            mayBePromise = this.onChange(this.props.attr, true);
                        }
                        else {
                            mayBePromise = this.onChange(this.props.attr, e.target.checked);
                        }
                        if (mayBePromise instanceof Promise) {
                            void mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
                        }
                    }, disabled: disabled || this.props.schema.readOnly }), label: this.getText(this.props.schema.label) }),
            React$1V.createElement(FormHelperText$f, { style: { color: 'red' } }, error
                ? this.props.schema.validatorErrorText
                    ? I18n$u.t(this.props.schema.validatorErrorText)
                    : I18n$u.t('ra_Error')
                : null),
            this.props.schema.help ? (React$1V.createElement(FormHelperText$f, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

/**
 * Notice: Some code was adapted from Material-UI's text field.
 *         Copyright (c) 2014 Call-Em-All (https://github.com/callemall/material-ui)
 */
const React$1U = await importShared('react');

const ReactDOM = await importShared('react-dom');

const {Input,OutlinedInput,InputLabel: InputLabel$d,Chip: Chip$2,FormControl: FormControl$g,FormHelperText: FormHelperText$e,Box: Box$a} = await importShared('@mui/material');
const {Utils: Utils$c} = await importShared('@iobroker/adapter-react-v5');

const variantComponent = {
    standard: Input,
    filled: FilledInput,
    outlined: OutlinedInput,
};
const styles$t = (theme) => {
    const light = theme.palette.mode === 'light';
    const bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
    return {
        root: {},
        inputRoot: {
            display: 'inline-flex',
            flexWrap: 'wrap',
            flex: 1,
            marginTop: 0,
            minWidth: 70,
            '&.mui-variant-outlined,&.mui-variant-filled': {
                boxSizing: 'border-box',
            },
            '&.mui-variant-outlined': {
                paddingTop: '14px',
            },
            '&.mui-variant-filled': {
                paddingTop: '28px',
            },
        },
        input: {
            display: 'inline-block',
            textOverflow: 'ellipsis',
            overflow: 'hidden',
            whiteSpace: 'nowrap',
            appearance: 'none', // Remove border in Safari, doesn't seem to break anything in other browsers
            WebkitTapHighlightColor: 'rgba(0,0,0,0)', // Remove mobile color flashing (deprecated style).
            float: 'left',
            flex: 1,
        },
        chipContainer: {
            display: 'flex',
            flexFlow: 'row wrap',
            alignItems: 'center',
            cursor: 'text',
            marginBottom: '-2px',
            minHeight: 40,
        },
        outlined: {
            '& input': {
                height: 16,
                paddingTop: '4px',
                paddingBottom: '12px',
                marginTop: '4px',
                marginBottom: '4px',
            },
        },
        standard: {
            marginTop: '18px',
        },
        filled: {
            '& input': {
                height: 22,
                marginBottom: '4px',
                marginTop: '4px',
                paddingTop: 0,
            },
            '$marginDense & input': {
                height: 26,
            },
        },
        labeled: {},
        label: {
            top: 4,
            '&$outlined&:not($labelShrink)': {
                top: 2,
                '$marginDense &': {
                    top: 5,
                },
            },
            '&$filled&:not($labelShrink)': {
                top: 15,
                '$marginDense &': {
                    top: 20,
                },
            },
        },
        labelShrink: {
            top: 0,
        },
        helperText: {
            marginBottom: -20,
        },
        focused: {},
        disabled: {},
        underline: {
            '&:after': {
                borderBottom: `2px solid ${theme.palette.primary[light ? 'dark' : 'light']}`,
                left: 0,
                bottom: 0,
                // Doing the other way around a crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
                content: '""',
                position: 'absolute',
                right: 0,
                transform: 'scaleX(0)',
                transition: theme.transitions.create('transform', {
                    duration: theme.transitions.duration.shorter,
                    easing: theme.transitions.easing.easeOut,
                }),
                pointerEvents: 'none', // Transparent to the hover style.
            },
            '&$focused:after': {
                transform: 'scaleX(1)',
            },
            '&$error:after': {
                borderBottomColor: theme.palette.error.main,
                transform: 'scaleX(1)', // error is always underlined in red
            },
            '&:before': {
                borderBottom: `1px solid ${bottomLineColor}`,
                left: 0,
                bottom: 0,
                // Doing the other way around a crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
                content: '"\\00a0"',
                position: 'absolute',
                right: 0,
                transition: theme.transitions.create('border-bottom-color', {
                    duration: theme.transitions.duration.shorter,
                }),
                pointerEvents: 'none', // Transparent to the hover style.
            },
            '&:hover:not($disabled):not($focused):not($error):before': {
                borderBottom: `2px solid ${theme.palette.text.primary}`,
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    borderBottom: `1px solid ${bottomLineColor}`,
                },
            },
            '&$disabled:before': {
                borderBottomStyle: 'dotted',
            },
        },
        error: {
            '&:after': {
                backgroundColor: theme.palette.error.main,
                transform: 'scaleX(1)', // error is always underlined in red
            },
        },
        chip: {
            margin: '0 8px 8px 0',
            float: 'left',
        },
        marginDense: {},
    };
};
const keyCodes = {
    BACKSPACE: 8,
    DELETE: 46,
    LEFT_ARROW: 37,
    RIGHT_ARROW: 39,
};
const defaultChipRenderer = ({ value, isFocused, isDisabled, isReadOnly, handleClick, handleDelete, style }, key) => (React$1U.createElement(Chip$2, { key: key, style: {
        ...style,
        pointerEvents: isDisabled || isReadOnly ? 'none' : undefined,
        backgroundColor: isFocused ? blue[300] : undefined,
    }, onClick: handleClick, onDelete: handleDelete, label: value }));
class ChipInput extends React$1U.Component {
    labelRef;
    labelNode = null;
    input;
    newChipKeyCodes;
    newChipKeys;
    actualInput = null;
    inputBlurTimeout = null;
    _keyPressed;
    _preventChipCreation;
    styles = {};
    styleTheme = null;
    constructor(props) {
        super(props);
        this.state = {
            chips: props.defaultValue || [],
            focusedChip: null,
            inputValue: '',
            isFocused: false,
            chipsUpdated: false,
            prevPropsValue: [],
            variant: this.props.variant || 'standard',
        };
        this.newChipKeyCodes = props.newChipKeyCodes || [13];
        this.newChipKeys = props.newChipKeys || ['Enter'];
        this.labelRef = React$1U.createRef();
        this.input = React$1U.createRef();
    }
    componentDidMount() {
        if (this.state.variant === 'outlined') {
            // eslint-disable-next-line react/no-find-dom-node
            this.labelNode = ReactDOM.findDOMNode(this.labelRef.current);
            this.forceUpdate();
        }
    }
    componentWillUnmount() {
        if (this.inputBlurTimeout) {
            clearTimeout(this.inputBlurTimeout);
        }
    }
    static getDerivedStateFromProps(props, state) {
        let newState = null;
        if (props.value && props.value.length !== state.prevPropsValue.length) {
            newState = { prevPropsValue: props.value };
            if (props.clearInputValueOnChange) {
                newState.inputValue = '';
            }
        }
        // if change detection is only necessary for clearInputValueOnChange
        if (props.clearInputValueOnChange && props.value && props.value.length !== state.prevPropsValue.length) {
            newState = { prevPropsValue: props.value, inputValue: '' };
        }
        if (props.disabled) {
            newState = { ...newState, focusedChip: null };
        }
        if (!state.chipsUpdated && props.defaultValue) {
            newState = { ...newState, chips: props.defaultValue };
        }
        return newState;
    }
    /**
     * Blurs this component.
     */
    // blur() {
    //     if (this.input) {
    //         this.actualInput.blur();
    //     }
    // }
    /**
     * Focuses this component.
     */
    focus = () => {
        this.actualInput?.focus();
        if (this.state.focusedChip) {
            this.setState({ focusedChip: null });
        }
    };
    handleInputBlur = (event) => {
        if (this.props.onBlur) {
            this.props.onBlur(event);
        }
        this.setState({ isFocused: false });
        if (this.state.focusedChip) {
            this.setState({ focusedChip: null });
        }
        const value = event.target.value;
        let addChipOptions;
        switch (this.props.blurBehavior || 'clear') {
            case 'add-or-clear':
                addChipOptions = { clearInputOnFail: true };
            // falls through
            case 'add':
                if (this.props.delayBeforeAdd) {
                    // Let's assume that we only want to add the existing content as chip, when
                    // another event has not added a chip within 200ms.
                    // e.g., onSelection Callback in Autocomplete case
                    const numChipsBefore = (this.props.value || this.state.chips).length;
                    this.inputBlurTimeout = setTimeout(() => {
                        const numChipsAfter = (this.props.value || this.state.chips).length;
                        if (numChipsBefore === numChipsAfter) {
                            this.handleAddChip(value, addChipOptions);
                        }
                        else {
                            this.clearInput();
                        }
                    }, 150);
                }
                else {
                    this.handleAddChip(value, addChipOptions);
                }
                break;
            case 'clear':
                this.clearInput();
                break;
        }
    };
    handleInputFocus = (event) => {
        this.setState({ isFocused: true });
        this.props.onFocus?.(event);
    };
    handleKeyDown = (event) => {
        const { focusedChip } = this.state;
        this._keyPressed = false;
        this._preventChipCreation = false;
        if (this.props.onKeyDown) {
            // Needed for arrow controls on a menu in autocomplete scenario
            this.props.onKeyDown(event);
            // Check if the callback marked the event as isDefaultPrevented() and skip further actions
            // enter key, for example, should not always add the current value of the inputField
            if (event.isDefaultPrevented()) {
                return;
            }
        }
        const chips = this.props.value || this.state.chips;
        if (this.newChipKeyCodes.includes(event.keyCode) || this.newChipKeys.includes(event.key)) {
            const result = this.handleAddChip(event.target.value);
            if (result !== false) {
                event.preventDefault();
            }
            return;
        }
        switch (event.keyCode) {
            case keyCodes.BACKSPACE:
                if (event.target.value === '') {
                    if (focusedChip) {
                        this.handleDeleteChip(chips[focusedChip], focusedChip);
                        if (focusedChip) {
                            this.setState({ focusedChip: focusedChip - 1 });
                        }
                    }
                    else {
                        this.setState({ focusedChip: chips.length - 1 });
                    }
                }
                break;
            case keyCodes.DELETE:
                if (event.target.value === '' && focusedChip) {
                    this.handleDeleteChip(chips[focusedChip], focusedChip);
                    if (focusedChip <= chips.length - 1) {
                        this.setState({ focusedChip });
                    }
                }
                break;
            case keyCodes.LEFT_ARROW:
                if (focusedChip === null && event.target.value === '' && chips.length) {
                    this.setState({ focusedChip: chips.length - 1 });
                }
                else if (focusedChip !== null && focusedChip > 0) {
                    this.setState({ focusedChip: focusedChip - 1 });
                }
                break;
            case keyCodes.RIGHT_ARROW:
                if (focusedChip !== null && focusedChip < chips.length - 1) {
                    this.setState({ focusedChip: focusedChip + 1 });
                }
                else {
                    this.setState({ focusedChip: null });
                }
                break;
            default:
                this.setState({ focusedChip: null });
                break;
        }
    };
    handleKeyUp = (event) => {
        if (!this._preventChipCreation &&
            (this.newChipKeyCodes.includes(event.keyCode) || this.newChipKeys.includes(event.key)) &&
            this._keyPressed) {
            this.clearInput();
        }
        else {
            this.updateInput(event.target.value);
        }
        if (this.props.onKeyUp) {
            this.props.onKeyUp(event);
        }
    };
    // handleKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {
    //     this._keyPressed = true;
    //     if (this.props.onKeyPress) {
    //         this.props.onKeyPress(event);
    //     }
    // };
    handleUpdateInput = (e) => {
        if (this.props.inputValue === null || this.props.inputValue === undefined) {
            this.updateInput(e.target.value);
        }
        if (this.props.onUpdateInput) {
            this.props.onUpdateInput(e);
        }
    };
    /**
     * Handles adding a chip.
     *
     * @param chip Value of the chip, either a string or an object (if dataSourceConfig is set)
     * @param options Additional options
     * @param options.clearInputOnFail If `true`, and `onBeforeAdd` returns `false`, clear the input
     * @returns True if the chip was added (or at least `onAdd` was called), false if adding the chip was prevented
     */
    handleAddChip(chip, options) {
        if (this.props.onBeforeAdd && !this.props.onBeforeAdd(chip)) {
            this._preventChipCreation = true;
            if (options && options.clearInputOnFail) {
                this.clearInput();
            }
            return false;
        }
        this.clearInput();
        const chips = this.props.value || this.state.chips;
        if (chip.trim().length) {
            if (this.props.allowDuplicates || !chips.includes(chip)) {
                if (this.props.value && this.props.onAdd) {
                    this.props.onAdd(chip);
                }
                else {
                    this.updateChips([...this.state.chips, chip]);
                }
            }
            return true;
        }
        return false;
    }
    handleDeleteChip(chip, i) {
        if (!this.props.value) {
            const chips = this.state.chips.slice();
            const changed = chips.splice(i, 1); // remove the chip at index i
            if (changed) {
                let focusedChip = this.state.focusedChip;
                if (this.state.focusedChip === i) {
                    focusedChip = null;
                }
                else if (this.state.focusedChip !== null && this.state.focusedChip > i) {
                    focusedChip = this.state.focusedChip - 1;
                }
                this.updateChips(chips, { focusedChip });
            }
        }
        else if (this.props.onDelete) {
            this.props.onDelete(chip, i);
        }
    }
    updateChips(chips, additionalUpdates = {}) {
        this.setState({ chips, chipsUpdated: true, ...additionalUpdates });
        if (this.props.onChange) {
            this.props.onChange(chips);
        }
    }
    /**
     * Clears the text field for adding new chips.
     * This only works in uncontrolled input mode, i.e., if the inputValue prop is not used.
     */
    clearInput() {
        this.updateInput('');
    }
    updateInput(value) {
        this.setState({ inputValue: value });
    }
    /**
     * Set the reference to the actual input, that is the input of the Input.
     *
     * @param ref - The reference
     */
    setActualInputRef = (ref) => {
        this.actualInput = ref;
        if (this.props.inputRef) {
            this.props.inputRef(ref);
        }
    };
    render() {
        const { alwaysShowPlaceholder, chipRenderer = defaultChipRenderer, className, disabled, disableUnderline, error, FormHelperTextProps, fullWidth, fullWidthInput, helperText, id, InputProps = {}, InputLabelProps = {}, inputValue, label, placeholder, readOnly, required, rootRef, value, margin, } = this.props;
        const variant = this.state.variant;
        if (this.styleTheme !== this.props.theme.palette.mode) {
            this.styleTheme = this.props.theme.palette.mode;
            this.styles = Utils$c.getStyle(this.props.theme, styles$t);
        }
        let chips = value || this.state.chips || [];
        if (!Array.isArray(chips)) {
            chips = (chips || '')
                .toString()
                .split(/[,\s]+/)
                .map((c) => c.trim());
        }
        const actualInputValue = inputValue ?? this.state.inputValue;
        const hasInput = (this.props.value || actualInputValue).length || actualInputValue.length;
        const shrinkFloatingLabel = typeof InputLabelProps.shrink === 'boolean'
            ? InputLabelProps.shrink
            : label !== null && (hasInput || this.state.isFocused || chips.length);
        const chipComponents = chips.map((chip, i) => chipRenderer({
            value: chip,
            isDisabled: !!disabled,
            isReadOnly: !!readOnly,
            isFocused: this.state.focusedChip === i,
            handleClick: () => this.setState({ focusedChip: i }),
            handleDelete: () => this.handleDeleteChip(chip, i),
            style: this.styles.chip,
        }, i.toString()));
        const InputMore = {};
        if (variant === 'outlined') {
            InputMore.notched = !!shrinkFloatingLabel;
            InputMore.labelWidth = (shrinkFloatingLabel && this.labelNode && this.labelNode.offsetWidth) || 0;
        }
        if (variant !== 'standard') {
            InputMore.startAdornment = chipComponents;
        }
        else {
            InputProps.disableUnderline = true;
        }
        const InputComponent = variantComponent[variant];
        return (React$1U.createElement(FormControl$g, { ref: rootRef, fullWidth: fullWidth, className: className, sx: { ...this.styles.root, ...(margin === 'dense' ? this.styles.marginDense : {}) }, error: error, required: chips.length > 0 ? undefined : required, onClick: this.focus, disabled: disabled, variant: variant, component: "div", margin: margin },
            label && (React$1U.createElement(InputLabel$d, { htmlFor: id, sx: {
                    '&.MuiInputLabel-root': this.styles.label,
                    '&.MuiInputLabel-shrink': this.styles.labelShrink,
                }, shrink: !!shrinkFloatingLabel, focused: this.state.isFocused, variant: variant, ref: this.labelRef, required: required, component: "label", ...InputLabelProps }, label)),
            React$1U.createElement(Box$a, { component: "div", id: "input-chip-container", sx: {
                    ...this.styles[variant],
                    ...this.styles.chipContainer,
                    ...(this.state.isFocused ? this.styles.focused : undefined),
                    ...(!disableUnderline && variant === 'standard' ? this.styles.underline : undefined),
                    ...(disabled ? this.styles.disabled : undefined),
                    ...(label ? this.styles.labeled : undefined),
                    ...(error ? this.styles.error : undefined),
                } },
                variant === 'standard' && chipComponents,
                React$1U.createElement(InputComponent, { ref: this.input, className: `mui-variant-${this.styles[variant]} ${label ? 'mui-chip-with-label' : 'mui-chip-no-label'}`, sx: {
                        '&.MuiInputBase-input': { ...this.styles.input, ...this.styles[variant] },
                        '&.MuiInputBase-root': { ...this.styles.inputRoot },
                    }, id: id, value: actualInputValue, onChange: this.handleUpdateInput, onKeyDown: this.handleKeyDown, 
                    // onKeyPress={this.handleKeyPress}
                    onKeyUp: this.handleKeyUp, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur, inputRef: this.setActualInputRef, disabled: disabled, fullWidth: fullWidthInput, placeholder: (!hasInput && (shrinkFloatingLabel || label === null || label === undefined)) ||
                        alwaysShowPlaceholder
                        ? placeholder
                        : undefined, readOnly: readOnly, ...InputProps, ...InputMore })),
            helperText && (React$1U.createElement(FormHelperText$e, { ...FormHelperTextProps, className: FormHelperTextProps?.className, style: this.styles.helperText }, helperText))));
    }
}

const React$1T = await importShared('react');

const {FormHelperText: FormHelperText$d,FormControl: FormControl$f} = await importShared('@mui/material');
const {I18n: I18n$t} = await importShared('@iobroker/adapter-react-v5');

class ConfigChip extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const { data, attr } = this.props;
        const value = ConfigGeneric.getValue(data, attr);
        if (this.props.schema.delimiter && typeof value === 'string') {
            const parts = value
                .split(this.props.schema.delimiter)
                .map(a => a.trim())
                .filter(a => a);
            this.setState({ value: parts });
        }
        else {
            this.setState({ value: value || [] });
        }
    }
    renderItem(error, disabled) {
        const { attr, schema } = this.props;
        const { value } = this.state;
        return (React$1T.createElement(FormControl$f, { fullWidth: true, variant: "standard" },
            React$1T.createElement(ChipInput, { value: value, disabled: !!disabled, label: this.getText(schema.label), error: !!error, onAdd: chip => {
                    const newValue = JSON.parse(JSON.stringify(value));
                    newValue.push(chip);
                    this.setState({ value: newValue }, () => {
                        let mayBePromise;
                        if (this.props.schema.delimiter) {
                            mayBePromise = this.onChange(attr, newValue.join(`${this.props.schema.delimiter} `));
                        }
                        else {
                            mayBePromise = this.onChange(attr, newValue);
                        }
                        if (mayBePromise instanceof Promise) {
                            mayBePromise.catch(e => console.error(e));
                        }
                    });
                }, theme: this.props.oContext.theme, onDelete: (_chip, index) => {
                    const newValue = JSON.parse(JSON.stringify(value));
                    newValue.splice(index, 1);
                    this.setState({ value: newValue }, () => {
                        let mayBePromise;
                        if (this.props.schema.delimiter) {
                            mayBePromise = this.onChange(attr, newValue.join(`${this.props.schema.delimiter} `));
                        }
                        else {
                            mayBePromise = this.onChange(attr, newValue);
                        }
                        if (mayBePromise instanceof Promise) {
                            mayBePromise.catch(e => console.error(e));
                        }
                    });
                } }),
            React$1T.createElement(FormHelperText$d, null, I18n$t.t('ra_Press ENTER Key to add new item')),
            this.props.schema.help ? (React$1T.createElement(FormHelperText$d, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$1S = await importShared('react');
const {IconButton: IconButton$c,TextField: TextField$j,Dialog: Dialog$3} = await importShared('@mui/material');

const {Close:ClearIcon$1} = await importShared('@mui/icons-material');

const {Utils: Utils$b} = await importShared('@iobroker/adapter-react-v5');
class ConfigColor extends ConfigGeneric {
    renderColorDialog() {
        return (!!this.state.showColorDialog && (React$1S.createElement(Dialog$3, { onClose: () => this.setState({ showColorDialog: false }), open: this.state.showColorDialog },
            React$1S.createElement(ChromePicker, { color: this.state.colorDialogValue, onChange: (color) => this.setState({ colorDialogValue: color.hex }, () => this.onChange(this.props.attr, this.state.colorDialogValue)) }))));
    }
    renderItem(_error, disabled /* , defaultValue */) {
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        let textColor = Utils$b.isUseBright(value, null);
        if (textColor === null) {
            textColor = undefined;
        }
        return (React$1S.createElement(React$1S.Fragment, null,
            this.renderColorDialog(),
            React$1S.createElement(TextField$j, { variant: "standard", disabled: !!disabled, style: { minWidth: 100, width: 'calc(100% - 8px)' }, label: this.getText(this.props.schema.label), value: value || '', onClick: () => !this.props.schema.readOnly &&
                    this.setState({ showColorDialog: true, colorDialogValue: value || '' }), onChange: e => {
                    const color = e.target.value;
                    const mayBePromise = this.onChange(this.props.attr, color);
                    if (mayBePromise instanceof Promise) {
                        void mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
                    }
                }, slotProps: {
                    htmlInput: {
                        style: {
                            // paddingLeft: noPadding ? 0 : 8,
                            backgroundColor: value,
                            color: textColor ? '#FFF' : '#000',
                        },
                        readOnly: this.props.schema.readOnly || false,
                    },
                    input: {
                        endAdornment: !this.props.schema.readOnly && value && !this.props.schema.noClearButton ? (React$1S.createElement(IconButton$c, { tabIndex: -1, size: "small", onClick: e => {
                                e.stopPropagation();
                                const mayBePromise = this.onChange(this.props.attr, '');
                                if (mayBePromise instanceof Promise) {
                                    void mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
                                }
                            } },
                            React$1S.createElement(ClearIcon$1, null))) : undefined,
                    },
                    inputLabel: {
                        shrink: true,
                    },
                } })));
    }
}

const React$1R = await importShared('react');

const {TextField: TextField$i,Fab: Fab$1,FormControlLabel: FormControlLabel$1,Checkbox: Checkbox$4} = await importShared('@mui/material');

const {GpsFixed:IconGpsFixed,LocationOn:IconLocationOn} = await importShared('@mui/icons-material');

const {I18n: I18n$s} = await importShared('@iobroker/adapter-react-v5');
const styles$s = {
    width: {
        width: 'calc(100% - 85px)',
    },
    width50: {
        width: 120,
        marginRight: 5,
    },
};
class ConfigCoordinates extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        this.setState({ value });
        const newState = {};
        if (this.props.schema.useSystemName) {
            newState.useSystem = !!ConfigGeneric.getValue(this.props.data, this.props.schema.useSystemName);
        }
        if (this.props.schema.longitudeName && this.props.schema.latitudeName) {
            newState.longitude = ConfigGeneric.getValue(this.props.data, this.props.schema.longitudeName);
            newState.latitude = ConfigGeneric.getValue(this.props.data, this.props.schema.latitudeName);
            if (!newState.longitude && !newState.latitude && this.props.schema.autoInit) {
                setTimeout(() => this.getCoordinates(), 300);
            }
        }
        else {
            const value_ = ConfigGeneric.getValue(this.props.data, this.props.attr);
            if (!value_ && this.props.schema.autoInit) {
                setTimeout(() => this.getCoordinates(), 300);
            }
        }
        if (Object.keys(newState).length) {
            setTimeout(() => this.setState(newState), 50);
        }
    }
    async getSystemCoordinates() {
        const obj = await this.props.oContext.socket.getCompactSystemConfig();
        if (obj?.common && (obj.common.longitude || obj.common.latitude)) {
            window.alert(I18n$s.t('ra_Used system settings'));
            if (this.props.schema.longitudeName && this.props.schema.latitudeName) {
                this.setState({
                    longitude: obj.common.longitude,
                    latitude: obj.common.latitude,
                }, async () => {
                    await this.onChange(this.props.schema.longitudeName, obj.common.longitude);
                    await this.onChange(this.props.schema.latitudeName, obj.common.latitude);
                });
            }
            else {
                const value = obj.common.latitude + (this.props.schema.divider || ',') + obj.common.longitude;
                this.setState({
                    value,
                }, () => {
                    const mayByPromise = this.onChange(this.props.attr, value);
                    if (mayByPromise instanceof Promise) {
                        mayByPromise.catch(e => console.error(`Cannot set value: ${e}`));
                    }
                });
            }
        }
        else {
            window.alert(I18n$s.t('ra_Cannot determine position: System settings are empty and GPS detection is disabled in browser'));
        }
    }
    getCoordinates() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(async (position) => {
                if (position?.coords) {
                    if (this.props.schema.longitudeName && this.props.schema.latitudeName) {
                        this.setState({
                            longitude: position.coords.longitude,
                            latitude: position.coords.latitude,
                        }, async () => {
                            await this.onChange(this.props.schema.longitudeName, position.coords.longitude || '');
                            await this.onChange(this.props.schema.latitudeName, position.coords.latitude || '');
                        });
                    }
                    else {
                        const value = position.coords.latitude +
                            (this.props.schema.divider || ',') +
                            position.coords.longitude;
                        this.setState({ value }, () => {
                            const mayByPromise = this.onChange(this.props.attr, value);
                            if (mayByPromise instanceof Promise) {
                                mayByPromise.catch(e => console.error(`Cannot set value: ${e}`));
                            }
                        });
                    }
                }
                else {
                    await this.getSystemCoordinates();
                }
            }, async (error) => {
                console.error(`Cannot determine coordinates from browser: ${error.message}`);
                await this.getSystemCoordinates();
            });
        }
        else {
            void this.getSystemCoordinates().catch(e => {
                console.error(`Cannot determine coordinates: ${e}`);
            });
        }
    }
    renderItem(error, disabled /* , defaultValue */) {
        return (React$1R.createElement(React$1R.Fragment, null,
            this.props.schema.useSystemName ? (React$1R.createElement(FormControlLabel$1, { control: React$1R.createElement(Checkbox$4, { checked: !!this.state.useSystem, onChange: e => {
                        const useSystem = e.target.checked;
                        if (useSystem) {
                            void this.getSystemCoordinates().catch(e => console.error(`Cannot determine coordinates: ${e}`));
                        }
                        this.setState({ useSystem }, () => this.onChange(this.props.schema.useSystemName, useSystem));
                    } }), label: I18n$s.t('ra_Use system settings for position') })) : null,
            this.props.schema.longitudeName && this.props.schema.latitudeName ? (React$1R.createElement(TextField$i, { variant: "standard", style: styles$s.width50, value: this.state.longitude ?? '', error: !!error, disabled: this.state.useSystem || !!disabled, onChange: e => {
                    const longitude = e.target.value;
                    this.setState({ longitude }, () => {
                        const mayBePromise = this.onChange(this.props.schema.longitudeName, (longitude || '').trim());
                        if (mayBePromise instanceof Promise) {
                            mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
                        }
                    });
                }, label: I18n$s.t('ra_Longitude') })) : null,
            this.props.schema.longitudeName && this.props.schema.latitudeName ? (React$1R.createElement(TextField$i, { variant: "standard", style: styles$s.width50, value: this.state.latitude ?? '', error: !!error, disabled: this.state.useSystem || !!disabled, onChange: e => {
                    const latitude = e.target.value;
                    this.setState({ latitude }, () => this.onChange(this.props.schema.latitudeName, (latitude || '').trim()));
                }, label: I18n$s.t('ra_Latitude') })) : null,
            !this.props.schema.longitudeName || !this.props.schema.latitudeName ? (React$1R.createElement(TextField$i, { variant: "standard", style: styles$s.width, value: this.state.value === null || this.state.value === undefined ? '' : this.state.value, error: !!error, disabled: !!disabled, slotProps: {
                    htmlInput: {
                        maxLength: this.props.schema.maxLength || this.props.schema.max || undefined,
                        readOnly: this.state.useSystem,
                    },
                }, onChange: e => {
                    const value = e.target.value;
                    this.setState({ value }, () => this.onChange(this.props.attr, (value || '').trim()));
                }, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) })) : null,
            !this.state.useSystem ? (React$1R.createElement(Fab$1, { size: "small", onClick: () => this.getCoordinates(), title: I18n$s.t('ra_Take browser position'), style: { marginRight: 4 } },
                React$1R.createElement(IconLocationOn, null))) : null,
            !this.state.useSystem ? (React$1R.createElement(Fab$1, { size: "small", onClick: () => this.getSystemCoordinates(), title: I18n$s.t('ra_Take position from system settings') },
                React$1R.createElement(IconGpsFixed, null))) : null));
    }
}

function _extends$2() {
    _extends$2 = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends$2.apply(this, arguments);
}

function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}

function _extends$1() {
    _extends$1 = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends$1.apply(this, arguments);
}

var define_process_env_default = {};
const MANIFEST_EXT = ".json";
const BROWSER_LOG_KEY = "FEDERATION_DEBUG";
const SEPARATOR = ":";
function isBrowserEnv() {
  return typeof window !== "undefined" && typeof window.document !== "undefined";
}
function isReactNativeEnv() {
  var _navigator;
  return typeof navigator !== "undefined" && ((_navigator = navigator) == null ? void 0 : _navigator.product) === "ReactNative";
}
function isBrowserDebug() {
  try {
    if (isBrowserEnv() && window.localStorage) {
      return Boolean(localStorage.getItem(BROWSER_LOG_KEY));
    }
  } catch (error2) {
    return false;
  }
  return false;
}
function isDebugMode() {
  if (typeof process !== "undefined" && define_process_env_default && define_process_env_default["FEDERATION_DEBUG"]) {
    return Boolean(define_process_env_default["FEDERATION_DEBUG"]);
  }
  if (typeof FEDERATION_DEBUG !== "undefined" && Boolean(FEDERATION_DEBUG)) {
    return true;
  }
  return isBrowserDebug();
}
const LOG_CATEGORY$1 = "[ Federation Runtime ]";
const composeKeyWithSeparator = function(...args) {
  if (!args.length) {
    return "";
  }
  return args.reduce((sum, cur) => {
    if (!cur) {
      return sum;
    }
    if (!sum) {
      return cur;
    }
    return `${sum}${SEPARATOR}${cur}`;
  }, "");
};
const getResourceUrl = (module, sourceUrl) => {
  if ("getPublicPath" in module) {
    let publicPath;
    if (!module.getPublicPath.startsWith("function")) {
      publicPath = new Function(module.getPublicPath)();
    } else {
      publicPath = new Function("return " + module.getPublicPath)()();
    }
    return `${publicPath}${sourceUrl}`;
  } else if ("publicPath" in module) {
    if (!isBrowserEnv() && !isReactNativeEnv() && "ssrPublicPath" in module) {
      return `${module.ssrPublicPath}${sourceUrl}`;
    }
    return `${module.publicPath}${sourceUrl}`;
  } else {
    console.warn("Cannot get resource URL. If in debug mode, please ignore.", module, sourceUrl);
    return "";
  }
};
const warn$1 = (msg) => {
  console.warn(`${LOG_CATEGORY$1}: ${msg}`);
};
function safeToString(info) {
  try {
    return JSON.stringify(info, null, 2);
  } catch (e) {
    return "";
  }
}
const simpleJoinRemoteEntry = (rPath, rName) => {
  if (!rPath) {
    return rName;
  }
  const transformPath = (str) => {
    if (str === ".") {
      return "";
    }
    if (str.startsWith("./")) {
      return str.replace("./", "");
    }
    if (str.startsWith("/")) {
      const strWithoutSlash = str.slice(1);
      if (strWithoutSlash.endsWith("/")) {
        return strWithoutSlash.slice(0, -1);
      }
      return strWithoutSlash;
    }
    return str;
  };
  const transformedPath = transformPath(rPath);
  if (!transformedPath) {
    return rName;
  }
  if (transformedPath.endsWith("/")) {
    return `${transformedPath}${rName}`;
  }
  return `${transformedPath}/${rName}`;
};
function inferAutoPublicPath(url2) {
  return url2.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
}
function generateSnapshotFromManifest(manifest, options = {}) {
  var _manifest_metaData, _manifest_metaData1;
  const { remotes = {}, overrides = {}, version } = options;
  let remoteSnapshot;
  const getPublicPath = () => {
    if ("publicPath" in manifest.metaData) {
      if (manifest.metaData.publicPath === "auto" && version) {
        return inferAutoPublicPath(version);
      }
      return manifest.metaData.publicPath;
    } else {
      return manifest.metaData.getPublicPath;
    }
  };
  const overridesKeys = Object.keys(overrides);
  let remotesInfo = {};
  if (!Object.keys(remotes).length) {
    var _manifest_remotes;
    remotesInfo = ((_manifest_remotes = manifest.remotes) == null ? void 0 : _manifest_remotes.reduce((res2, next) => {
      let matchedVersion;
      const name = next.federationContainerName;
      if (overridesKeys.includes(name)) {
        matchedVersion = overrides[name];
      } else {
        if ("version" in next) {
          matchedVersion = next.version;
        } else {
          matchedVersion = next.entry;
        }
      }
      res2[name] = {
        matchedVersion
      };
      return res2;
    }, {})) || {};
  }
  Object.keys(remotes).forEach((key) => remotesInfo[key] = {
    // overrides will override dependencies
    matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]
  });
  const { remoteEntry: { path: remoteEntryPath, name: remoteEntryName, type: remoteEntryType }, types: remoteTypes, buildInfo: { buildVersion }, globalName, ssrRemoteEntry } = manifest.metaData;
  const { exposes } = manifest;
  let basicRemoteSnapshot = {
    version: version ? version : "",
    buildVersion,
    globalName,
    remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),
    remoteEntryType,
    remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),
    remoteTypesZip: remoteTypes.zip || "",
    remoteTypesAPI: remoteTypes.api || "",
    remotesInfo,
    shared: manifest == null ? void 0 : manifest.shared.map((item) => ({
      assets: item.assets,
      sharedName: item.name,
      version: item.version
    })),
    modules: exposes == null ? void 0 : exposes.map((expose) => ({
      moduleName: expose.name,
      modulePath: expose.path,
      assets: expose.assets
    }))
  };
  if ((_manifest_metaData = manifest.metaData) == null ? void 0 : _manifest_metaData.prefetchInterface) {
    const prefetchInterface = manifest.metaData.prefetchInterface;
    basicRemoteSnapshot = _extends$1({}, basicRemoteSnapshot, {
      prefetchInterface
    });
  }
  if ((_manifest_metaData1 = manifest.metaData) == null ? void 0 : _manifest_metaData1.prefetchEntry) {
    const { path: path2, name, type } = manifest.metaData.prefetchEntry;
    basicRemoteSnapshot = _extends$1({}, basicRemoteSnapshot, {
      prefetchEntry: simpleJoinRemoteEntry(path2, name),
      prefetchEntryType: type
    });
  }
  if ("publicPath" in manifest.metaData) {
    remoteSnapshot = _extends$1({}, basicRemoteSnapshot, {
      publicPath: getPublicPath(),
      ssrPublicPath: manifest.metaData.ssrPublicPath
    });
  } else {
    remoteSnapshot = _extends$1({}, basicRemoteSnapshot, {
      getPublicPath: getPublicPath()
    });
  }
  if (ssrRemoteEntry) {
    const fullSSRRemoteEntry = simpleJoinRemoteEntry(ssrRemoteEntry.path, ssrRemoteEntry.name);
    remoteSnapshot.ssrRemoteEntry = fullSSRRemoteEntry;
    remoteSnapshot.ssrRemoteEntryType = ssrRemoteEntry.type || "commonjs-module";
  }
  return remoteSnapshot;
}
function isManifestProvider(moduleInfo) {
  if ("remoteEntry" in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {
    return true;
  } else {
    return false;
  }
}
let Logger = class Logger2 {
  setPrefix(prefix) {
    this.prefix = prefix;
  }
  log(...args) {
    console.log(this.prefix, ...args);
  }
  warn(...args) {
    console.log(this.prefix, ...args);
  }
  error(...args) {
    console.log(this.prefix, ...args);
  }
  success(...args) {
    console.log(this.prefix, ...args);
  }
  info(...args) {
    console.log(this.prefix, ...args);
  }
  ready(...args) {
    console.log(this.prefix, ...args);
  }
  debug(...args) {
    if (isDebugMode()) {
      console.log(this.prefix, ...args);
    }
  }
  constructor(prefix) {
    this.prefix = prefix;
  }
};
function createLogger(prefix) {
  return new Logger(prefix);
}
async function safeWrapper(callback, disableWarn) {
  try {
    const res2 = await callback();
    return res2;
  } catch (e) {
    warn$1(e);
    return;
  }
}
function isStaticResourcesEqual(url1, url2) {
  const REG_EXP = /^(https?:)?\/\//i;
  const relativeUrl1 = url1.replace(REG_EXP, "").replace(/\/$/, "");
  const relativeUrl2 = url2.replace(REG_EXP, "").replace(/\/$/, "");
  return relativeUrl1 === relativeUrl2;
}
function createScript(info) {
  let script2 = null;
  let needAttach = true;
  let timeout = 2e4;
  let timeoutId;
  const scripts = document.getElementsByTagName("script");
  for (let i = 0; i < scripts.length; i++) {
    const s = scripts[i];
    const scriptSrc = s.getAttribute("src");
    if (scriptSrc && isStaticResourcesEqual(scriptSrc, info.url)) {
      script2 = s;
      needAttach = false;
      break;
    }
  }
  if (!script2) {
    const attrs2 = info.attrs;
    script2 = document.createElement("script");
    script2.type = (attrs2 == null ? void 0 : attrs2["type"]) === "module" ? "module" : "text/javascript";
    let createScriptRes = void 0;
    if (info.createScriptHook) {
      createScriptRes = info.createScriptHook(info.url, info.attrs);
      if (createScriptRes instanceof HTMLScriptElement) {
        script2 = createScriptRes;
      } else if (typeof createScriptRes === "object") {
        if ("script" in createScriptRes && createScriptRes.script) {
          script2 = createScriptRes.script;
        }
        if ("timeout" in createScriptRes && createScriptRes.timeout) {
          timeout = createScriptRes.timeout;
        }
      }
    }
    if (!script2.src) {
      script2.src = info.url;
    }
    if (attrs2 && !createScriptRes) {
      Object.keys(attrs2).forEach((name) => {
        if (script2) {
          if (name === "async" || name === "defer") {
            script2[name] = attrs2[name];
          } else if (!script2.getAttribute(name)) {
            script2.setAttribute(name, attrs2[name]);
          }
        }
      });
    }
  }
  const onScriptComplete = async (prev, event) => {
    clearTimeout(timeoutId);
    const onScriptCompleteCallback = () => {
      if ((event == null ? void 0 : event.type) === "error") {
        (info == null ? void 0 : info.onErrorCallback) && (info == null ? void 0 : info.onErrorCallback(event));
      } else {
        (info == null ? void 0 : info.cb) && (info == null ? void 0 : info.cb());
      }
    };
    if (script2) {
      script2.onerror = null;
      script2.onload = null;
      safeWrapper(() => {
        const { needDeleteScript = true } = info;
        if (needDeleteScript) {
          (script2 == null ? void 0 : script2.parentNode) && script2.parentNode.removeChild(script2);
        }
      });
      if (prev && typeof prev === "function") {
        const result = prev(event);
        if (result instanceof Promise) {
          const res2 = await result;
          onScriptCompleteCallback();
          return res2;
        }
        onScriptCompleteCallback();
        return result;
      }
    }
    onScriptCompleteCallback();
  };
  script2.onerror = onScriptComplete.bind(null, script2.onerror);
  script2.onload = onScriptComplete.bind(null, script2.onload);
  timeoutId = setTimeout(() => {
    onScriptComplete(null, new Error(`Remote script "${info.url}" time-outed.`));
  }, timeout);
  return {
    script: script2,
    needAttach
  };
}
function createLink(info) {
  let link = null;
  let needAttach = true;
  const links = document.getElementsByTagName("link");
  for (let i = 0; i < links.length; i++) {
    const l = links[i];
    const linkHref = l.getAttribute("href");
    const linkRel = l.getAttribute("rel");
    if (linkHref && isStaticResourcesEqual(linkHref, info.url) && linkRel === info.attrs["rel"]) {
      link = l;
      needAttach = false;
      break;
    }
  }
  if (!link) {
    link = document.createElement("link");
    link.setAttribute("href", info.url);
    let createLinkRes = void 0;
    const attrs2 = info.attrs;
    if (info.createLinkHook) {
      createLinkRes = info.createLinkHook(info.url, attrs2);
      if (createLinkRes instanceof HTMLLinkElement) {
        link = createLinkRes;
      }
    }
    if (attrs2 && !createLinkRes) {
      Object.keys(attrs2).forEach((name) => {
        if (link && !link.getAttribute(name)) {
          link.setAttribute(name, attrs2[name]);
        }
      });
    }
  }
  const onLinkComplete = (prev, event) => {
    const onLinkCompleteCallback = () => {
      if ((event == null ? void 0 : event.type) === "error") {
        (info == null ? void 0 : info.onErrorCallback) && (info == null ? void 0 : info.onErrorCallback(event));
      } else {
        (info == null ? void 0 : info.cb) && (info == null ? void 0 : info.cb());
      }
    };
    if (link) {
      link.onerror = null;
      link.onload = null;
      safeWrapper(() => {
        const { needDeleteLink = true } = info;
        if (needDeleteLink) {
          (link == null ? void 0 : link.parentNode) && link.parentNode.removeChild(link);
        }
      });
      if (prev) {
        const res2 = prev(event);
        onLinkCompleteCallback();
        return res2;
      }
    }
    onLinkCompleteCallback();
  };
  link.onerror = onLinkComplete.bind(null, link.onerror);
  link.onload = onLinkComplete.bind(null, link.onload);
  return {
    link,
    needAttach
  };
}
function loadScript$1(url2, info) {
  const { attrs: attrs2 = {}, createScriptHook } = info;
  return new Promise((resolve, reject) => {
    const { script: script2, needAttach } = createScript({
      url: url2,
      cb: resolve,
      onErrorCallback: reject,
      attrs: _extends$1({
        fetchpriority: "high"
      }, attrs2),
      createScriptHook,
      needDeleteScript: true
    });
    needAttach && document.head.appendChild(script2);
  });
}
function importNodeModule(name) {
  if (!name) {
    throw new Error("import specifier is required");
  }
  const importModule = new Function("name", `return import(name)`);
  return importModule(name).then((res2) => res2).catch((error2) => {
    console.error(`Error importing module ${name}:`, error2);
    throw error2;
  });
}
const loadNodeFetch = async () => {
  const fetchModule = await importNodeModule("node-fetch");
  return fetchModule.default || fetchModule;
};
const lazyLoaderHookFetch = async (input, init, loaderHook2) => {
  const hook = (url2, init2) => {
    return loaderHook2.lifecycle.fetch.emit(url2, init2);
  };
  const res2 = await hook(input, init || {});
  if (!res2 || !(res2 instanceof Response)) {
    const fetchFunction = typeof fetch === "undefined" ? await loadNodeFetch() : fetch;
    return fetchFunction(input, init || {});
  }
  return res2;
};
const createScriptNode = typeof ENV_TARGET === "undefined" || ENV_TARGET !== "web" ? (url, cb, attrs, loaderHook) => {
  if (loaderHook == null ? void 0 : loaderHook.createScriptHook) {
    const hookResult = loaderHook.createScriptHook(url);
    if (hookResult && typeof hookResult === "object" && "url" in hookResult) {
      url = hookResult.url;
    }
  }
  let urlObj;
  try {
    urlObj = new URL(url);
  } catch (e) {
    console.error("Error constructing URL:", e);
    cb(new Error(`Invalid URL: ${e}`));
    return;
  }
  const getFetch = async () => {
    if (loaderHook == null ? void 0 : loaderHook.fetch) {
      return (input, init) => lazyLoaderHookFetch(input, init, loaderHook);
    }
    return typeof fetch === "undefined" ? loadNodeFetch() : fetch;
  };
  const handleScriptFetch = async (f, urlObj) => {
    try {
      var _vm_constants;
      const res = await f(urlObj.href);
      const data = await res.text();
      const [path, vm] = await Promise.all([
        importNodeModule("path"),
        importNodeModule("vm")
      ]);
      const scriptContext = {
        exports: {},
        module: {
          exports: {}
        }
      };
      const urlDirname = urlObj.pathname.split("/").slice(0, -1).join("/");
      const filename = path.basename(urlObj.pathname);
      var _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER;
      const script = new vm.Script(`(function(exports, module, require, __dirname, __filename) {${data}
})`, {
        filename,
        importModuleDynamically: (_vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER = (_vm_constants = vm.constants) == null ? void 0 : _vm_constants.USE_MAIN_CONTEXT_DEFAULT_LOADER) != null ? _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER : importNodeModule
      });
      script.runInThisContext()(scriptContext.exports, scriptContext.module, eval("require"), urlDirname, filename);
      const exportedInterface = scriptContext.module.exports || scriptContext.exports;
      if (attrs && exportedInterface && attrs["globalName"]) {
        const container = exportedInterface[attrs["globalName"]] || exportedInterface;
        cb(void 0, container);
        return;
      }
      cb(void 0, exportedInterface);
    } catch (e) {
      cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));
    }
  };
  getFetch().then(async (f2) => {
    if ((attrs == null ? void 0 : attrs["type"]) === "esm" || (attrs == null ? void 0 : attrs["type"]) === "module") {
      return loadModule(urlObj.href, {
        fetch: f2,
        vm: await importNodeModule("vm")
      }).then(async (module) => {
        await module.evaluate();
        cb(void 0, module.namespace);
      }).catch((e) => {
        cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));
      });
    }
    handleScriptFetch(f2, urlObj);
  }).catch((err) => {
    cb(err);
  });
} : (url2, cb2, attrs2, loaderHook2) => {
  cb2(new Error("createScriptNode is disabled in non-Node.js environment"));
};
const loadScriptNode = typeof ENV_TARGET === "undefined" || ENV_TARGET !== "web" ? (url2, info) => {
  return new Promise((resolve, reject) => {
    createScriptNode(url2, (error2, scriptContext2) => {
      if (error2) {
        reject(error2);
      } else {
        var _info_attrs, _info_attrs1;
        const remoteEntryKey = (info == null ? void 0 : (_info_attrs = info.attrs) == null ? void 0 : _info_attrs["globalName"]) || `__FEDERATION_${info == null ? void 0 : (_info_attrs1 = info.attrs) == null ? void 0 : _info_attrs1["name"]}:custom__`;
        const entryExports = globalThis[remoteEntryKey] = scriptContext2;
        resolve(entryExports);
      }
    }, info.attrs, info.loaderHook);
  });
} : (url2, info) => {
  throw new Error("loadScriptNode is disabled in non-Node.js environment");
};
async function loadModule(url2, options) {
  const { fetch: fetch1, vm: vm2 } = options;
  const response = await fetch1(url2);
  const code = await response.text();
  const module = new vm2.SourceTextModule(code, {
    // @ts-ignore
    importModuleDynamically: async (specifier, script2) => {
      const resolvedUrl = new URL(specifier, url2).href;
      return loadModule(resolvedUrl, options);
    }
  });
  await module.link(async (specifier) => {
    const resolvedUrl = new URL(specifier, url2).href;
    const module2 = await loadModule(resolvedUrl, options);
    return module2;
  });
  return module;
}

const RUNTIME_001 = 'RUNTIME-001';
const RUNTIME_002 = 'RUNTIME-002';
const RUNTIME_003 = 'RUNTIME-003';
const RUNTIME_004 = 'RUNTIME-004';
const RUNTIME_005 = 'RUNTIME-005';
const RUNTIME_006 = 'RUNTIME-006';
const RUNTIME_007 = 'RUNTIME-007';
const RUNTIME_008 = 'RUNTIME-008';
const TYPE_001 = 'TYPE-001';
const BUILD_001 = 'BUILD-001';

const getDocsUrl = (errorCode)=>{
    const type = errorCode.split('-')[0].toLowerCase();
    return `View the docs to see how to solve: https://module-federation.io/guide/troubleshooting/${type}/${errorCode}`;
};
const getShortErrorMsg = (errorCode, errorDescMap, args, originalErrorMsg)=>{
    const msg = [
        `${[
            errorDescMap[errorCode]
        ]} #${errorCode}`
    ];
    args && msg.push(`args: ${JSON.stringify(args)}`);
    msg.push(getDocsUrl(errorCode));
    originalErrorMsg && msg.push(`Original Error Message:\n ${originalErrorMsg}`);
    return msg.join('\n');
};

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

const runtimeDescMap = {
    [RUNTIME_001]: 'Failed to get remoteEntry exports.',
    [RUNTIME_002]: 'The remote entry interface does not contain "init"',
    [RUNTIME_003]: 'Failed to get manifest.',
    [RUNTIME_004]: 'Failed to locate remote.',
    [RUNTIME_005]: 'Invalid loadShareSync function call from bundler runtime',
    [RUNTIME_006]: 'Invalid loadShareSync function call from runtime',
    [RUNTIME_007]: 'Failed to get remote snapshot.',
    [RUNTIME_008]: 'Failed to load script resources.'
};
const typeDescMap = {
    [TYPE_001]: 'Failed to generate type declaration. Execute the below cmd to reproduce and fix the error.'
};
const buildDescMap = {
    [BUILD_001]: 'Failed to find expose module.'
};
_extends({}, runtimeDescMap, typeDescMap, buildDescMap);

const LOG_CATEGORY = '[ Federation Runtime ]';
// FIXME: pre-bundle ?
const logger = createLogger(LOG_CATEGORY);
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function assert(condition, msg) {
    if (!condition) {
        error(msg);
    }
}
function error(msg) {
    if (msg instanceof Error) {
        msg.message = `${LOG_CATEGORY}: ${msg.message}`;
        throw msg;
    }
    throw new Error(`${LOG_CATEGORY}: ${msg}`);
}
function warn(msg) {
    if (msg instanceof Error) {
        msg.message = `${LOG_CATEGORY}: ${msg.message}`;
        logger.warn(msg);
    } else {
        logger.warn(msg);
    }
}

function addUniqueItem(arr, item) {
    if (arr.findIndex((name)=>name === item) === -1) {
        arr.push(item);
    }
    return arr;
}
function getFMId(remoteInfo) {
    if ('version' in remoteInfo && remoteInfo.version) {
        return `${remoteInfo.name}:${remoteInfo.version}`;
    } else if ('entry' in remoteInfo && remoteInfo.entry) {
        return `${remoteInfo.name}:${remoteInfo.entry}`;
    } else {
        return `${remoteInfo.name}`;
    }
}
function isRemoteInfoWithEntry(remote) {
    return typeof remote.entry !== 'undefined';
}
function isPureRemoteEntry(remote) {
    return !remote.entry.includes('.json');
}
function isObject$1(val) {
    return val && typeof val === 'object';
}
const objectToString$1 = Object.prototype.toString;
// eslint-disable-next-line @typescript-eslint/ban-types
function isPlainObject$1(val) {
    return objectToString$1.call(val) === '[object Object]';
}
function arrayOptions(options) {
    return Array.isArray(options) ? options : [
        options
    ];
}
function getRemoteEntryInfoFromSnapshot(snapshot) {
    const defaultRemoteEntryInfo = {
        url: '',
        type: 'global',
        globalName: ''
    };
    if (isBrowserEnv() || isReactNativeEnv()) {
        return 'remoteEntry' in snapshot ? {
            url: snapshot.remoteEntry,
            type: snapshot.remoteEntryType,
            globalName: snapshot.globalName
        } : defaultRemoteEntryInfo;
    }
    if ('ssrRemoteEntry' in snapshot) {
        return {
            url: snapshot.ssrRemoteEntry || defaultRemoteEntryInfo.url,
            type: snapshot.ssrRemoteEntryType || defaultRemoteEntryInfo.type,
            globalName: snapshot.globalName
        };
    }
    return defaultRemoteEntryInfo;
}
const processModuleAlias = (name, subPath)=>{
    // @host/ ./button -> @host/button
    let moduleName;
    if (name.endsWith('/')) {
        moduleName = name.slice(0, -1);
    } else {
        moduleName = name;
    }
    if (subPath.startsWith('.')) {
        subPath = subPath.slice(1);
    }
    moduleName = moduleName + subPath;
    return moduleName;
};

const CurrentGlobal = typeof globalThis === 'object' ? globalThis : window;
const nativeGlobal = (()=>{
    try {
        // get real window (incase of sandbox)
        return document.defaultView;
    } catch (e) {
        // node env
        return CurrentGlobal;
    }
})();
const Global = nativeGlobal;
function definePropertyGlobalVal(target, key, val) {
    Object.defineProperty(target, key, {
        value: val,
        configurable: false,
        writable: true
    });
}
function includeOwnProperty(target, key) {
    return Object.hasOwnProperty.call(target, key);
}
// This section is to prevent encapsulation by certain microfrontend frameworks. Due to reuse policies, sandbox escapes.
// The sandbox in the microfrontend does not replicate the value of 'configurable'.
// If there is no loading content on the global object, this section defines the loading object.
if (!includeOwnProperty(CurrentGlobal, '__GLOBAL_LOADING_REMOTE_ENTRY__')) {
    definePropertyGlobalVal(CurrentGlobal, '__GLOBAL_LOADING_REMOTE_ENTRY__', {});
}
const globalLoading = CurrentGlobal.__GLOBAL_LOADING_REMOTE_ENTRY__;
function setGlobalDefaultVal(target) {
    var _target___FEDERATION__, _target___FEDERATION__1, _target___FEDERATION__2, _target___FEDERATION__3, _target___FEDERATION__4, _target___FEDERATION__5;
    if (includeOwnProperty(target, '__VMOK__') && !includeOwnProperty(target, '__FEDERATION__')) {
        definePropertyGlobalVal(target, '__FEDERATION__', target.__VMOK__);
    }
    if (!includeOwnProperty(target, '__FEDERATION__')) {
        definePropertyGlobalVal(target, '__FEDERATION__', {
            __GLOBAL_PLUGIN__: [],
            __INSTANCES__: [],
            moduleInfo: {},
            __SHARE__: {},
            __MANIFEST_LOADING__: {},
            __PRELOADED_MAP__: new Map()
        });
        definePropertyGlobalVal(target, '__VMOK__', target.__FEDERATION__);
    }
    var ___GLOBAL_PLUGIN__;
    (___GLOBAL_PLUGIN__ = (_target___FEDERATION__ = target.__FEDERATION__).__GLOBAL_PLUGIN__) != null ? ___GLOBAL_PLUGIN__ : _target___FEDERATION__.__GLOBAL_PLUGIN__ = [];
    var ___INSTANCES__;
    (___INSTANCES__ = (_target___FEDERATION__1 = target.__FEDERATION__).__INSTANCES__) != null ? ___INSTANCES__ : _target___FEDERATION__1.__INSTANCES__ = [];
    var _moduleInfo;
    (_moduleInfo = (_target___FEDERATION__2 = target.__FEDERATION__).moduleInfo) != null ? _moduleInfo : _target___FEDERATION__2.moduleInfo = {};
    var ___SHARE__;
    (___SHARE__ = (_target___FEDERATION__3 = target.__FEDERATION__).__SHARE__) != null ? ___SHARE__ : _target___FEDERATION__3.__SHARE__ = {};
    var ___MANIFEST_LOADING__;
    (___MANIFEST_LOADING__ = (_target___FEDERATION__4 = target.__FEDERATION__).__MANIFEST_LOADING__) != null ? ___MANIFEST_LOADING__ : _target___FEDERATION__4.__MANIFEST_LOADING__ = {};
    var ___PRELOADED_MAP__;
    (___PRELOADED_MAP__ = (_target___FEDERATION__5 = target.__FEDERATION__).__PRELOADED_MAP__) != null ? ___PRELOADED_MAP__ : _target___FEDERATION__5.__PRELOADED_MAP__ = new Map();
}
setGlobalDefaultVal(CurrentGlobal);
setGlobalDefaultVal(nativeGlobal);
function setGlobalFederationInstance(FederationInstance) {
    CurrentGlobal.__FEDERATION__.__INSTANCES__.push(FederationInstance);
}
function getGlobalFederationConstructor() {
    return CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR__;
}
function setGlobalFederationConstructor(FederationConstructor, isDebug = isDebugMode()) {
    if (isDebug) {
        CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = FederationConstructor;
        CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = "0.15.0";
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
function getInfoWithoutType(target, key) {
    if (typeof key === 'string') {
        const keyRes = target[key];
        if (keyRes) {
            return {
                value: target[key],
                key: key
            };
        } else {
            const targetKeys = Object.keys(target);
            for (const targetKey of targetKeys){
                const [targetTypeOrName, _] = targetKey.split(':');
                const nKey = `${targetTypeOrName}:${key}`;
                const typeWithKeyRes = target[nKey];
                if (typeWithKeyRes) {
                    return {
                        value: typeWithKeyRes,
                        key: nKey
                    };
                }
            }
            return {
                value: undefined,
                key: key
            };
        }
    } else {
        throw new Error('key must be string');
    }
}
const getGlobalSnapshot = ()=>nativeGlobal.__FEDERATION__.moduleInfo;
const getTargetSnapshotInfoByModuleInfo = (moduleInfo, snapshot)=>{
    // Check if the remote is included in the hostSnapshot
    const moduleKey = getFMId(moduleInfo);
    const getModuleInfo = getInfoWithoutType(snapshot, moduleKey).value;
    // The remoteSnapshot might not include a version
    if (getModuleInfo && !getModuleInfo.version && 'version' in moduleInfo && moduleInfo['version']) {
        getModuleInfo.version = moduleInfo['version'];
    }
    if (getModuleInfo) {
        return getModuleInfo;
    }
    // If the remote is not included in the hostSnapshot, deploy a micro app snapshot
    if ('version' in moduleInfo && moduleInfo['version']) {
        const { version } = moduleInfo, resModuleInfo = _object_without_properties_loose(moduleInfo, [
            "version"
        ]);
        const moduleKeyWithoutVersion = getFMId(resModuleInfo);
        const getModuleInfoWithoutVersion = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, moduleKeyWithoutVersion).value;
        if ((getModuleInfoWithoutVersion == null ? void 0 : getModuleInfoWithoutVersion.version) === version) {
            return getModuleInfoWithoutVersion;
        }
    }
    return;
};
const getGlobalSnapshotInfoByModuleInfo = (moduleInfo)=>getTargetSnapshotInfoByModuleInfo(moduleInfo, nativeGlobal.__FEDERATION__.moduleInfo);
const setGlobalSnapshotInfoByModuleInfo = (remoteInfo, moduleDetailInfo)=>{
    const moduleKey = getFMId(remoteInfo);
    nativeGlobal.__FEDERATION__.moduleInfo[moduleKey] = moduleDetailInfo;
    return nativeGlobal.__FEDERATION__.moduleInfo;
};
const addGlobalSnapshot = (moduleInfos)=>{
    nativeGlobal.__FEDERATION__.moduleInfo = _extends$2({}, nativeGlobal.__FEDERATION__.moduleInfo, moduleInfos);
    return ()=>{
        const keys = Object.keys(moduleInfos);
        for (const key of keys){
            delete nativeGlobal.__FEDERATION__.moduleInfo[key];
        }
    };
};
const getRemoteEntryExports = (name, globalName)=>{
    const remoteEntryKey = globalName || `__FEDERATION_${name}:custom__`;
    const entryExports = CurrentGlobal[remoteEntryKey];
    return {
        remoteEntryKey,
        entryExports
    };
};
const getGlobalHostPlugins = ()=>nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;
const getPreloaded = (id)=>CurrentGlobal.__FEDERATION__.__PRELOADED_MAP__.get(id);
const setPreloaded = (id)=>CurrentGlobal.__FEDERATION__.__PRELOADED_MAP__.set(id, true);

const DEFAULT_SCOPE = 'default';
const DEFAULT_REMOTE_TYPE = 'global';

// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// those constants are based on https://www.rubydoc.info/gems/semantic_range/3.0.0/SemanticRange#BUILDIDENTIFIER-constant
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
const buildIdentifier = '[0-9A-Za-z-]+';
const build = `(?:\\+(${buildIdentifier}(?:\\.${buildIdentifier})*))`;
const numericIdentifier = '0|[1-9]\\d*';
const numericIdentifierLoose = '[0-9]+';
const nonNumericIdentifier = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
const preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`;
const preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\.${preReleaseIdentifierLoose})*))`;
const preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`;
const preRelease = `(?:-(${preReleaseIdentifier}(?:\\.${preReleaseIdentifier})*))`;
const xRangeIdentifier = `${numericIdentifier}|x|X|\\*`;
const xRangePlain = `[v=\\s]*(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`;
const hyphenRange = `^\\s*(${xRangePlain})\\s+-\\s+(${xRangePlain})\\s*$`;
const mainVersionLoose = `(${numericIdentifierLoose})\\.(${numericIdentifierLoose})\\.(${numericIdentifierLoose})`;
const loosePlain = `[v=\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`;
const gtlt = '((?:<|>)?=?)';
const comparatorTrim = `(\\s*)${gtlt}\\s*(${loosePlain}|${xRangePlain})`;
const loneTilde = '(?:~>?)';
const tildeTrim = `(\\s*)${loneTilde}\\s+`;
const loneCaret = '(?:\\^)';
const caretTrim = `(\\s*)${loneCaret}\\s+`;
const star = '(<|>)?=?\\s*\\*';
const caret = `^${loneCaret}${xRangePlain}$`;
const mainVersion = `(${numericIdentifier})\\.(${numericIdentifier})\\.(${numericIdentifier})`;
const fullPlain = `v?${mainVersion}${preRelease}?${build}?`;
const tilde = `^${loneTilde}${xRangePlain}$`;
const xRange = `^${gtlt}\\s*${xRangePlain}$`;
const comparator = `^${gtlt}\\s*(${fullPlain})$|^$`;
// copy from semver package
const gte0 = '^\\s*>=\\s*0.0.0\\s*$';

// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function parseRegex(source) {
    return new RegExp(source);
}
function isXVersion(version) {
    return !version || version.toLowerCase() === 'x' || version === '*';
}
function pipe(...fns) {
    return (x)=>fns.reduce((v, f)=>f(v), x);
}
function extractComparator(comparatorString) {
    return comparatorString.match(parseRegex(comparator));
}
function combineVersion(major, minor, patch, preRelease) {
    const mainVersion = `${major}.${minor}.${patch}`;
    if (preRelease) {
        return `${mainVersion}-${preRelease}`;
    }
    return mainVersion;
}

// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function parseHyphen(range) {
    return range.replace(parseRegex(hyphenRange), (_range, from, fromMajor, fromMinor, fromPatch, _fromPreRelease, _fromBuild, to, toMajor, toMinor, toPatch, toPreRelease)=>{
        if (isXVersion(fromMajor)) {
            from = '';
        } else if (isXVersion(fromMinor)) {
            from = `>=${fromMajor}.0.0`;
        } else if (isXVersion(fromPatch)) {
            from = `>=${fromMajor}.${fromMinor}.0`;
        } else {
            from = `>=${from}`;
        }
        if (isXVersion(toMajor)) {
            to = '';
        } else if (isXVersion(toMinor)) {
            to = `<${Number(toMajor) + 1}.0.0-0`;
        } else if (isXVersion(toPatch)) {
            to = `<${toMajor}.${Number(toMinor) + 1}.0-0`;
        } else if (toPreRelease) {
            to = `<=${toMajor}.${toMinor}.${toPatch}-${toPreRelease}`;
        } else {
            to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
    });
}
function parseComparatorTrim(range) {
    return range.replace(parseRegex(comparatorTrim), '$1$2$3');
}
function parseTildeTrim(range) {
    return range.replace(parseRegex(tildeTrim), '$1~');
}
function parseCaretTrim(range) {
    return range.replace(parseRegex(caretTrim), '$1^');
}
function parseCarets(range) {
    return range.trim().split(/\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(caret), (_, major, minor, patch, preRelease)=>{
            if (isXVersion(major)) {
                return '';
            } else if (isXVersion(minor)) {
                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;
            } else if (isXVersion(patch)) {
                if (major === '0') {
                    return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;
                } else {
                    return `>=${major}.${minor}.0 <${Number(major) + 1}.0.0-0`;
                }
            } else if (preRelease) {
                if (major === '0') {
                    if (minor === '0') {
                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${minor}.${Number(patch) + 1}-0`;
                    } else {
                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;
                    }
                } else {
                    return `>=${major}.${minor}.${patch}-${preRelease} <${Number(major) + 1}.0.0-0`;
                }
            } else {
                if (major === '0') {
                    if (minor === '0') {
                        return `>=${major}.${minor}.${patch} <${major}.${minor}.${Number(patch) + 1}-0`;
                    } else {
                        return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;
                    }
                }
                return `>=${major}.${minor}.${patch} <${Number(major) + 1}.0.0-0`;
            }
        })).join(' ');
}
function parseTildes(range) {
    return range.trim().split(/\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(tilde), (_, major, minor, patch, preRelease)=>{
            if (isXVersion(major)) {
                return '';
            } else if (isXVersion(minor)) {
                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;
            } else if (isXVersion(patch)) {
                return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;
            } else if (preRelease) {
                return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;
            }
            return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;
        })).join(' ');
}
function parseXRanges(range) {
    return range.split(/\s+/).map((rangeVersion)=>rangeVersion.trim().replace(parseRegex(xRange), (ret, gtlt, major, minor, patch, preRelease)=>{
            const isXMajor = isXVersion(major);
            const isXMinor = isXMajor || isXVersion(minor);
            const isXPatch = isXMinor || isXVersion(patch);
            if (gtlt === '=' && isXPatch) {
                gtlt = '';
            }
            preRelease = '';
            if (isXMajor) {
                if (gtlt === '>' || gtlt === '<') {
                    // nothing is allowed
                    return '<0.0.0-0';
                } else {
                    // nothing is forbidden
                    return '*';
                }
            } else if (gtlt && isXPatch) {
                // replace X with 0
                if (isXMinor) {
                    minor = 0;
                }
                patch = 0;
                if (gtlt === '>') {
                    // >1 => >=2.0.0
                    // >1.2 => >=1.3.0
                    gtlt = '>=';
                    if (isXMinor) {
                        major = Number(major) + 1;
                        minor = 0;
                        patch = 0;
                    } else {
                        minor = Number(minor) + 1;
                        patch = 0;
                    }
                } else if (gtlt === '<=') {
                    // <=0.7.x is actually <0.8.0, since any 0.7.x should pass
                    // Similarly, <=7.x is actually <8.0.0, etc.
                    gtlt = '<';
                    if (isXMinor) {
                        major = Number(major) + 1;
                    } else {
                        minor = Number(minor) + 1;
                    }
                }
                if (gtlt === '<') {
                    preRelease = '-0';
                }
                return `${gtlt + major}.${minor}.${patch}${preRelease}`;
            } else if (isXMinor) {
                return `>=${major}.0.0${preRelease} <${Number(major) + 1}.0.0-0`;
            } else if (isXPatch) {
                return `>=${major}.${minor}.0${preRelease} <${major}.${Number(minor) + 1}.0-0`;
            }
            return ret;
        })).join(' ');
}
function parseStar(range) {
    return range.trim().replace(parseRegex(star), '');
}
function parseGTE0(comparatorString) {
    return comparatorString.trim().replace(parseRegex(gte0), '');
}

// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function compareAtom(rangeAtom, versionAtom) {
    rangeAtom = Number(rangeAtom) || rangeAtom;
    versionAtom = Number(versionAtom) || versionAtom;
    if (rangeAtom > versionAtom) {
        return 1;
    }
    if (rangeAtom === versionAtom) {
        return 0;
    }
    return -1;
}
function comparePreRelease(rangeAtom, versionAtom) {
    const { preRelease: rangePreRelease } = rangeAtom;
    const { preRelease: versionPreRelease } = versionAtom;
    if (rangePreRelease === undefined && Boolean(versionPreRelease)) {
        return 1;
    }
    if (Boolean(rangePreRelease) && versionPreRelease === undefined) {
        return -1;
    }
    if (rangePreRelease === undefined && versionPreRelease === undefined) {
        return 0;
    }
    for(let i = 0, n = rangePreRelease.length; i <= n; i++){
        const rangeElement = rangePreRelease[i];
        const versionElement = versionPreRelease[i];
        if (rangeElement === versionElement) {
            continue;
        }
        if (rangeElement === undefined && versionElement === undefined) {
            return 0;
        }
        if (!rangeElement) {
            return 1;
        }
        if (!versionElement) {
            return -1;
        }
        return compareAtom(rangeElement, versionElement);
    }
    return 0;
}
function compareVersion(rangeAtom, versionAtom) {
    return compareAtom(rangeAtom.major, versionAtom.major) || compareAtom(rangeAtom.minor, versionAtom.minor) || compareAtom(rangeAtom.patch, versionAtom.patch) || comparePreRelease(rangeAtom, versionAtom);
}
function eq$1(rangeAtom, versionAtom) {
    return rangeAtom.version === versionAtom.version;
}
function compare(rangeAtom, versionAtom) {
    switch(rangeAtom.operator){
        case '':
        case '=':
            return eq$1(rangeAtom, versionAtom);
        case '>':
            return compareVersion(rangeAtom, versionAtom) < 0;
        case '>=':
            return eq$1(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) < 0;
        case '<':
            return compareVersion(rangeAtom, versionAtom) > 0;
        case '<=':
            return eq$1(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) > 0;
        case undefined:
            {
                // mean * or x -> all versions
                return true;
            }
        default:
            return false;
    }
}

// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function parseComparatorString(range) {
    return pipe(// handle caret
    // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
    // ^1.2.3 --> >=1.2.3 <2.0.0-0
    // ^1.2.0 --> >=1.2.0 <2.0.0-0
    parseCarets, // handle tilde
    // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
    parseTildes, parseXRanges, parseStar)(range);
}
function parseRange(range) {
    return pipe(// handle hyphenRange
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    parseHyphen, // handle trim comparator
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    parseComparatorTrim, // handle trim tilde
    // `~ 1.2.3` => `~1.2.3`
    parseTildeTrim, // handle trim caret
    // `^ 1.2.3` => `^1.2.3`
    parseCaretTrim)(range.trim()).split(/\s+/).join(' ');
}
function satisfy(version, range) {
    if (!version) {
        return false;
    }
    // Extract version details once
    const extractedVersion = extractComparator(version);
    if (!extractedVersion) {
        // If the version string is invalid, it can't satisfy any range
        return false;
    }
    const [, versionOperator, , versionMajor, versionMinor, versionPatch, versionPreRelease] = extractedVersion;
    const versionAtom = {
        operator: versionOperator,
        version: combineVersion(versionMajor, versionMinor, versionPatch, versionPreRelease),
        major: versionMajor,
        minor: versionMinor,
        patch: versionPatch,
        preRelease: versionPreRelease == null ? void 0 : versionPreRelease.split('.')
    };
    // Split the range by || to handle OR conditions
    const orRanges = range.split('||');
    for (const orRange of orRanges){
        const trimmedOrRange = orRange.trim();
        if (!trimmedOrRange) {
            // An empty range string signifies wildcard *, satisfy any valid version
            // (We already checked if the version itself is valid)
            return true;
        }
        // Handle simple wildcards explicitly before complex parsing
        if (trimmedOrRange === '*' || trimmedOrRange === 'x') {
            return true;
        }
        try {
            // Apply existing parsing logic to the current OR sub-range
            const parsedSubRange = parseRange(trimmedOrRange); // Handles hyphens, trims etc.
            // Check if the result of initial parsing is empty, which can happen
            // for some wildcard cases handled by parseRange/parseComparatorString.
            // E.g. `parseStar` used in `parseComparatorString` returns ''.
            if (!parsedSubRange.trim()) {
                // If parsing results in empty string, treat as wildcard match
                return true;
            }
            const parsedComparatorString = parsedSubRange.split(' ').map((rangeVersion)=>parseComparatorString(rangeVersion)) // Expands ^, ~
            .join(' ');
            // Check again if the comparator string became empty after specific parsing like ^ or ~
            if (!parsedComparatorString.trim()) {
                return true;
            }
            // Split the sub-range by space for implicit AND conditions
            const comparators = parsedComparatorString.split(/\s+/).map((comparator)=>parseGTE0(comparator))// Filter out empty strings that might result from multiple spaces
            .filter(Boolean);
            // If a sub-range becomes empty after parsing (e.g., invalid characters),
            // it cannot be satisfied. This check might be redundant now but kept for safety.
            if (comparators.length === 0) {
                continue;
            }
            let subRangeSatisfied = true;
            for (const comparator of comparators){
                const extractedComparator = extractComparator(comparator);
                // If any part of the AND sub-range is invalid, the sub-range is not satisfied
                if (!extractedComparator) {
                    subRangeSatisfied = false;
                    break;
                }
                const [, rangeOperator, , rangeMajor, rangeMinor, rangePatch, rangePreRelease] = extractedComparator;
                const rangeAtom = {
                    operator: rangeOperator,
                    version: combineVersion(rangeMajor, rangeMinor, rangePatch, rangePreRelease),
                    major: rangeMajor,
                    minor: rangeMinor,
                    patch: rangePatch,
                    preRelease: rangePreRelease == null ? void 0 : rangePreRelease.split('.')
                };
                // Check if the version satisfies this specific comparator in the AND chain
                if (!compare(rangeAtom, versionAtom)) {
                    subRangeSatisfied = false; // This part of the AND condition failed
                    break; // No need to check further comparators in this sub-range
                }
            }
            // If all AND conditions within this OR sub-range were met, the overall range is satisfied
            if (subRangeSatisfied) {
                return true;
            }
        } catch (e) {
            // Log error and treat this sub-range as unsatisfied
            console.error(`[semver] Error processing range part "${trimmedOrRange}":`, e);
            continue;
        }
    }
    // If none of the OR sub-ranges were satisfied
    return false;
}

function formatShare(shareArgs, from, name, shareStrategy) {
    let get;
    if ('get' in shareArgs) {
        // eslint-disable-next-line prefer-destructuring
        get = shareArgs.get;
    } else if ('lib' in shareArgs) {
        get = ()=>Promise.resolve(shareArgs.lib);
    } else {
        get = ()=>Promise.resolve(()=>{
                throw new Error(`Can not get shared '${name}'!`);
            });
    }
    var _shareArgs_version, _shareArgs_scope, _shareArgs_strategy;
    return _extends$2({
        deps: [],
        useIn: [],
        from,
        loading: null
    }, shareArgs, {
        shareConfig: _extends$2({
            requiredVersion: `^${shareArgs.version}`,
            singleton: false,
            eager: false,
            strictVersion: false
        }, shareArgs.shareConfig),
        get,
        loaded: (shareArgs == null ? void 0 : shareArgs.loaded) || 'lib' in shareArgs ? true : undefined,
        version: (_shareArgs_version = shareArgs.version) != null ? _shareArgs_version : '0',
        scope: Array.isArray(shareArgs.scope) ? shareArgs.scope : [
            (_shareArgs_scope = shareArgs.scope) != null ? _shareArgs_scope : 'default'
        ],
        strategy: ((_shareArgs_strategy = shareArgs.strategy) != null ? _shareArgs_strategy : shareStrategy) || 'version-first'
    });
}
function formatShareConfigs(globalOptions, userOptions) {
    const shareArgs = userOptions.shared || {};
    const from = userOptions.name;
    const shareInfos = Object.keys(shareArgs).reduce((res, pkgName)=>{
        const arrayShareArgs = arrayOptions(shareArgs[pkgName]);
        res[pkgName] = res[pkgName] || [];
        arrayShareArgs.forEach((shareConfig)=>{
            res[pkgName].push(formatShare(shareConfig, from, pkgName, userOptions.shareStrategy));
        });
        return res;
    }, {});
    const shared = _extends$2({}, globalOptions.shared);
    Object.keys(shareInfos).forEach((shareKey)=>{
        if (!shared[shareKey]) {
            shared[shareKey] = shareInfos[shareKey];
        } else {
            shareInfos[shareKey].forEach((newUserSharedOptions)=>{
                const isSameVersion = shared[shareKey].find((sharedVal)=>sharedVal.version === newUserSharedOptions.version);
                if (!isSameVersion) {
                    shared[shareKey].push(newUserSharedOptions);
                }
            });
        }
    });
    return {
        shared,
        shareInfos
    };
}
function versionLt(a, b) {
    const transformInvalidVersion = (version)=>{
        const isNumberVersion = !Number.isNaN(Number(version));
        if (isNumberVersion) {
            const splitArr = version.split('.');
            let validVersion = version;
            for(let i = 0; i < 3 - splitArr.length; i++){
                validVersion += '.0';
            }
            return validVersion;
        }
        return version;
    };
    if (satisfy(transformInvalidVersion(a), `<=${transformInvalidVersion(b)}`)) {
        return true;
    } else {
        return false;
    }
}
const findVersion = (shareVersionMap, cb)=>{
    const callback = cb || function(prev, cur) {
        return versionLt(prev, cur);
    };
    return Object.keys(shareVersionMap).reduce((prev, cur)=>{
        if (!prev) {
            return cur;
        }
        if (callback(prev, cur)) {
            return cur;
        }
        // default version is '0' https://github.com/webpack/webpack/blob/main/lib/sharing/ProvideSharedModule.js#L136
        if (prev === '0') {
            return cur;
        }
        return prev;
    }, 0);
};
const isLoaded = (shared)=>{
    return Boolean(shared.loaded) || typeof shared.lib === 'function';
};
const isLoading = (shared)=>{
    return Boolean(shared.loading);
};
function findSingletonVersionOrderByVersion(shareScopeMap, scope, pkgName) {
    const versions = shareScopeMap[scope][pkgName];
    const callback = function(prev, cur) {
        return !isLoaded(versions[prev]) && versionLt(prev, cur);
    };
    return findVersion(shareScopeMap[scope][pkgName], callback);
}
function findSingletonVersionOrderByLoaded(shareScopeMap, scope, pkgName) {
    const versions = shareScopeMap[scope][pkgName];
    const callback = function(prev, cur) {
        const isLoadingOrLoaded = (shared)=>{
            return isLoaded(shared) || isLoading(shared);
        };
        if (isLoadingOrLoaded(versions[cur])) {
            if (isLoadingOrLoaded(versions[prev])) {
                return Boolean(versionLt(prev, cur));
            } else {
                return true;
            }
        }
        if (isLoadingOrLoaded(versions[prev])) {
            return false;
        }
        return versionLt(prev, cur);
    };
    return findVersion(shareScopeMap[scope][pkgName], callback);
}
function getFindShareFunction(strategy) {
    if (strategy === 'loaded-first') {
        return findSingletonVersionOrderByLoaded;
    }
    return findSingletonVersionOrderByVersion;
}
function getRegisteredShare(localShareScopeMap, pkgName, shareInfo, resolveShare) {
    if (!localShareScopeMap) {
        return;
    }
    const { shareConfig, scope = DEFAULT_SCOPE, strategy } = shareInfo;
    const scopes = Array.isArray(scope) ? scope : [
        scope
    ];
    for (const sc of scopes){
        if (shareConfig && localShareScopeMap[sc] && localShareScopeMap[sc][pkgName]) {
            const { requiredVersion } = shareConfig;
            const findShareFunction = getFindShareFunction(strategy);
            const maxOrSingletonVersion = findShareFunction(localShareScopeMap, sc, pkgName);
            //@ts-ignore
            const defaultResolver = ()=>{
                if (shareConfig.singleton) {
                    if (typeof requiredVersion === 'string' && !satisfy(maxOrSingletonVersion, requiredVersion)) {
                        const msg = `Version ${maxOrSingletonVersion} from ${maxOrSingletonVersion && localShareScopeMap[sc][pkgName][maxOrSingletonVersion].from} of shared singleton module ${pkgName} does not satisfy the requirement of ${shareInfo.from} which needs ${requiredVersion})`;
                        if (shareConfig.strictVersion) {
                            error(msg);
                        } else {
                            warn(msg);
                        }
                    }
                    return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                } else {
                    if (requiredVersion === false || requiredVersion === '*') {
                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                    }
                    if (satisfy(maxOrSingletonVersion, requiredVersion)) {
                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                    }
                    for (const [versionKey, versionValue] of Object.entries(localShareScopeMap[sc][pkgName])){
                        if (satisfy(versionKey, requiredVersion)) {
                            return versionValue;
                        }
                    }
                }
            };
            const params = {
                shareScopeMap: localShareScopeMap,
                scope: sc,
                pkgName,
                version: maxOrSingletonVersion,
                GlobalFederation: Global.__FEDERATION__,
                resolver: defaultResolver
            };
            const resolveShared = resolveShare.emit(params) || params;
            return resolveShared.resolver();
        }
    }
}
function getGlobalShareScope() {
    return Global.__FEDERATION__.__SHARE__;
}
function getTargetSharedOptions(options) {
    const { pkgName, extraOptions, shareInfos } = options;
    const defaultResolver = (sharedOptions)=>{
        if (!sharedOptions) {
            return undefined;
        }
        const shareVersionMap = {};
        sharedOptions.forEach((shared)=>{
            shareVersionMap[shared.version] = shared;
        });
        const callback = function(prev, cur) {
            return !isLoaded(shareVersionMap[prev]) && versionLt(prev, cur);
        };
        const maxVersion = findVersion(shareVersionMap, callback);
        return shareVersionMap[maxVersion];
    };
    var _extraOptions_resolver;
    const resolver = (_extraOptions_resolver = extraOptions == null ? void 0 : extraOptions.resolver) != null ? _extraOptions_resolver : defaultResolver;
    return Object.assign({}, resolver(shareInfos[pkgName]), extraOptions == null ? void 0 : extraOptions.customShareInfo);
}

function getBuilderId$1() {
    //@ts-ignore
    return typeof FEDERATION_BUILD_IDENTIFIER !== 'undefined' ? FEDERATION_BUILD_IDENTIFIER : '';
}

// Function to match a remote with its name and expose
// id: pkgName(@federation/app1) + expose(button) = @federation/app1/button
// id: alias(app1) + expose(button) = app1/button
// id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort
function matchRemoteWithNameAndExpose(remotes, id) {
    for (const remote of remotes){
        // match pkgName
        const isNameMatched = id.startsWith(remote.name);
        let expose = id.replace(remote.name, '');
        if (isNameMatched) {
            if (expose.startsWith('/')) {
                const pkgNameOrAlias = remote.name;
                expose = `.${expose}`;
                return {
                    pkgNameOrAlias,
                    expose,
                    remote
                };
            } else if (expose === '') {
                return {
                    pkgNameOrAlias: remote.name,
                    expose: '.',
                    remote
                };
            }
        }
        // match alias
        const isAliasMatched = remote.alias && id.startsWith(remote.alias);
        let exposeWithAlias = remote.alias && id.replace(remote.alias, '');
        if (remote.alias && isAliasMatched) {
            if (exposeWithAlias && exposeWithAlias.startsWith('/')) {
                const pkgNameOrAlias = remote.alias;
                exposeWithAlias = `.${exposeWithAlias}`;
                return {
                    pkgNameOrAlias,
                    expose: exposeWithAlias,
                    remote
                };
            } else if (exposeWithAlias === '') {
                return {
                    pkgNameOrAlias: remote.alias,
                    expose: '.',
                    remote
                };
            }
        }
    }
    return;
}
// Function to match a remote with its name or alias
function matchRemote(remotes, nameOrAlias) {
    for (const remote of remotes){
        const isNameMatched = nameOrAlias === remote.name;
        if (isNameMatched) {
            return remote;
        }
        const isAliasMatched = remote.alias && nameOrAlias === remote.alias;
        if (isAliasMatched) {
            return remote;
        }
    }
    return;
}

function registerPlugins(plugins, hookInstances) {
    const globalPlugins = getGlobalHostPlugins();
    // Incorporate global plugins
    if (globalPlugins.length > 0) {
        globalPlugins.forEach((plugin)=>{
            if (plugins == null ? void 0 : plugins.find((item)=>item.name !== plugin.name)) {
                plugins.push(plugin);
            }
        });
    }
    if (plugins && plugins.length > 0) {
        plugins.forEach((plugin)=>{
            hookInstances.forEach((hookInstance)=>{
                hookInstance.applyPlugin(plugin);
            });
        });
    }
    return plugins;
}

const importCallback = '.then(callbacks[0]).catch(callbacks[1])';
async function loadEsmEntry({ entry, remoteEntryExports }) {
    return new Promise((resolve, reject)=>{
        try {
            if (!remoteEntryExports) {
                if (typeof FEDERATION_ALLOW_NEW_FUNCTION !== 'undefined') {
                    new Function('callbacks', `import("${entry}")${importCallback}`)([
                        resolve,
                        reject
                    ]);
                } else {
                    import(/* webpackIgnore: true */ /* @vite-ignore */ entry).then(resolve).catch(reject);
                }
            } else {
                resolve(remoteEntryExports);
            }
        } catch (e) {
            reject(e);
        }
    });
}
async function loadSystemJsEntry({ entry, remoteEntryExports }) {
    return new Promise((resolve, reject)=>{
        try {
            if (!remoteEntryExports) {
                //@ts-ignore
                if (typeof __system_context__ === 'undefined') {
                    //@ts-ignore
                    System.import(entry).then(resolve).catch(reject);
                } else {
                    new Function('callbacks', `System.import("${entry}")${importCallback}`)([
                        resolve,
                        reject
                    ]);
                }
            } else {
                resolve(remoteEntryExports);
            }
        } catch (e) {
            reject(e);
        }
    });
}
function handleRemoteEntryLoaded(name, globalName, entry) {
    const { remoteEntryKey, entryExports } = getRemoteEntryExports(name, globalName);
    assert(entryExports, getShortErrorMsg(RUNTIME_001, runtimeDescMap, {
        remoteName: name,
        remoteEntryUrl: entry,
        remoteEntryKey
    }));
    return entryExports;
}
async function loadEntryScript({ name, globalName, entry, loaderHook }) {
    const { entryExports: remoteEntryExports } = getRemoteEntryExports(name, globalName);
    if (remoteEntryExports) {
        return remoteEntryExports;
    }
    return loadScript$1(entry, {
        attrs: {},
        createScriptHook: (url, attrs)=>{
            const res = loaderHook.lifecycle.createScript.emit({
                url,
                attrs
            });
            if (!res) return;
            if (res instanceof HTMLScriptElement) {
                return res;
            }
            if ('script' in res || 'timeout' in res) {
                return res;
            }
            return;
        }
    }).then(()=>{
        return handleRemoteEntryLoaded(name, globalName, entry);
    }).catch((e)=>{
        assert(undefined, getShortErrorMsg(RUNTIME_008, runtimeDescMap, {
            remoteName: name,
            resourceUrl: entry
        }));
        throw e;
    });
}
async function loadEntryDom({ remoteInfo, remoteEntryExports, loaderHook }) {
    const { entry, entryGlobalName: globalName, name, type } = remoteInfo;
    switch(type){
        case 'esm':
        case 'module':
            return loadEsmEntry({
                entry,
                remoteEntryExports
            });
        case 'system':
            return loadSystemJsEntry({
                entry,
                remoteEntryExports
            });
        default:
            return loadEntryScript({
                entry,
                globalName,
                name,
                loaderHook
            });
    }
}
async function loadEntryNode({ remoteInfo, loaderHook }) {
    const { entry, entryGlobalName: globalName, name, type } = remoteInfo;
    const { entryExports: remoteEntryExports } = getRemoteEntryExports(name, globalName);
    if (remoteEntryExports) {
        return remoteEntryExports;
    }
    return loadScriptNode(entry, {
        attrs: {
            name,
            globalName,
            type
        },
        loaderHook: {
            createScriptHook: (url, attrs = {})=>{
                const res = loaderHook.lifecycle.createScript.emit({
                    url,
                    attrs
                });
                if (!res) return;
                if ('url' in res) {
                    return res;
                }
                return;
            }
        }
    }).then(()=>{
        return handleRemoteEntryLoaded(name, globalName, entry);
    }).catch((e)=>{
        throw e;
    });
}
function getRemoteEntryUniqueKey(remoteInfo) {
    const { entry, name } = remoteInfo;
    return composeKeyWithSeparator(name, entry);
}
async function getRemoteEntry({ origin, remoteEntryExports, remoteInfo }) {
    const uniqueKey = getRemoteEntryUniqueKey(remoteInfo);
    if (remoteEntryExports) {
        return remoteEntryExports;
    }
    if (!globalLoading[uniqueKey]) {
        const loadEntryHook = origin.remoteHandler.hooks.lifecycle.loadEntry;
        const loaderHook = origin.loaderHook;
        globalLoading[uniqueKey] = loadEntryHook.emit({
            loaderHook,
            remoteInfo,
            remoteEntryExports
        }).then((res)=>{
            if (res) {
                return res;
            }
            // Use ENV_TARGET if defined, otherwise fallback to isBrowserEnv, must keep this
            const isWebEnvironment = typeof ENV_TARGET !== 'undefined' ? ENV_TARGET === 'web' : isBrowserEnv();
            return isWebEnvironment ? loadEntryDom({
                remoteInfo,
                remoteEntryExports,
                loaderHook
            }) : loadEntryNode({
                remoteInfo,
                loaderHook
            });
        });
    }
    return globalLoading[uniqueKey];
}
function getRemoteInfo(remote) {
    return _extends$2({}, remote, {
        entry: 'entry' in remote ? remote.entry : '',
        type: remote.type || DEFAULT_REMOTE_TYPE,
        entryGlobalName: remote.entryGlobalName || remote.name,
        shareScope: remote.shareScope || DEFAULT_SCOPE
    });
}

let Module = class Module {
    async getEntry() {
        if (this.remoteEntryExports) {
            return this.remoteEntryExports;
        }
        let remoteEntryExports;
        try {
            remoteEntryExports = await getRemoteEntry({
                origin: this.host,
                remoteInfo: this.remoteInfo,
                remoteEntryExports: this.remoteEntryExports
            });
        } catch (err) {
            const uniqueKey = getRemoteEntryUniqueKey(this.remoteInfo);
            remoteEntryExports = await this.host.loaderHook.lifecycle.loadEntryError.emit({
                getRemoteEntry,
                origin: this.host,
                remoteInfo: this.remoteInfo,
                remoteEntryExports: this.remoteEntryExports,
                globalLoading,
                uniqueKey
            });
        }
        assert(remoteEntryExports, `remoteEntryExports is undefined \n ${safeToString(this.remoteInfo)}`);
        this.remoteEntryExports = remoteEntryExports;
        return this.remoteEntryExports;
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    async get(id, expose, options, remoteSnapshot) {
        const { loadFactory = true } = options || {
            loadFactory: true
        };
        // Get remoteEntry.js
        const remoteEntryExports = await this.getEntry();
        if (!this.inited) {
            const localShareScopeMap = this.host.shareScopeMap;
            const shareScopeKeys = Array.isArray(this.remoteInfo.shareScope) ? this.remoteInfo.shareScope : [
                this.remoteInfo.shareScope
            ];
            if (!shareScopeKeys.length) {
                shareScopeKeys.push('default');
            }
            shareScopeKeys.forEach((shareScopeKey)=>{
                if (!localShareScopeMap[shareScopeKey]) {
                    localShareScopeMap[shareScopeKey] = {};
                }
            });
            // TODO: compate legacy init params, should use shareScopeMap if exist
            const shareScope = localShareScopeMap[shareScopeKeys[0]];
            const initScope = [];
            const remoteEntryInitOptions = {
                version: this.remoteInfo.version || '',
                shareScopeKeys: Array.isArray(this.remoteInfo.shareScope) ? shareScopeKeys : this.remoteInfo.shareScope || 'default'
            };
            // Help to find host instance
            Object.defineProperty(remoteEntryInitOptions, 'shareScopeMap', {
                value: localShareScopeMap,
                // remoteEntryInitOptions will be traversed and assigned during container init, ,so this attribute is not allowed to be traversed
                enumerable: false
            });
            const initContainerOptions = await this.host.hooks.lifecycle.beforeInitContainer.emit({
                shareScope,
                // @ts-ignore shareScopeMap will be set by Object.defineProperty
                remoteEntryInitOptions,
                initScope,
                remoteInfo: this.remoteInfo,
                origin: this.host
            });
            if (typeof (remoteEntryExports == null ? void 0 : remoteEntryExports.init) === 'undefined') {
                error(getShortErrorMsg(RUNTIME_002, runtimeDescMap, {
                    hostName: this.host.name,
                    remoteName: this.remoteInfo.name,
                    remoteEntryUrl: this.remoteInfo.entry,
                    remoteEntryKey: this.remoteInfo.entryGlobalName
                }));
            }
            await remoteEntryExports.init(initContainerOptions.shareScope, initContainerOptions.initScope, initContainerOptions.remoteEntryInitOptions);
            await this.host.hooks.lifecycle.initContainer.emit(_extends$2({}, initContainerOptions, {
                id,
                remoteSnapshot,
                remoteEntryExports
            }));
        }
        this.lib = remoteEntryExports;
        this.inited = true;
        let moduleFactory;
        moduleFactory = await this.host.loaderHook.lifecycle.getModuleFactory.emit({
            remoteEntryExports,
            expose,
            moduleInfo: this.remoteInfo
        });
        // get exposeGetter
        if (!moduleFactory) {
            moduleFactory = await remoteEntryExports.get(expose);
        }
        assert(moduleFactory, `${getFMId(this.remoteInfo)} remote don't export ${expose}.`);
        // keep symbol for module name always one format
        const symbolName = processModuleAlias(this.remoteInfo.name, expose);
        const wrapModuleFactory = this.wraperFactory(moduleFactory, symbolName);
        if (!loadFactory) {
            return wrapModuleFactory;
        }
        const exposeContent = await wrapModuleFactory();
        return exposeContent;
    }
    wraperFactory(moduleFactory, id) {
        function defineModuleId(res, id) {
            if (res && typeof res === 'object' && Object.isExtensible(res) && !Object.getOwnPropertyDescriptor(res, Symbol.for('mf_module_id'))) {
                Object.defineProperty(res, Symbol.for('mf_module_id'), {
                    value: id,
                    enumerable: false
                });
            }
        }
        if (moduleFactory instanceof Promise) {
            return async ()=>{
                const res = await moduleFactory();
                // This parameter is used for bridge debugging
                defineModuleId(res, id);
                return res;
            };
        } else {
            return ()=>{
                const res = moduleFactory();
                // This parameter is used for bridge debugging
                defineModuleId(res, id);
                return res;
            };
        }
    }
    constructor({ remoteInfo, host }){
        this.inited = false;
        this.lib = undefined;
        this.remoteInfo = remoteInfo;
        this.host = host;
    }
};

class SyncHook {
    on(fn) {
        if (typeof fn === 'function') {
            this.listeners.add(fn);
        }
    }
    once(fn) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.on(function wrapper(...args) {
            self.remove(wrapper);
            // eslint-disable-next-line prefer-spread
            return fn.apply(null, args);
        });
    }
    emit(...data) {
        let result;
        if (this.listeners.size > 0) {
            // eslint-disable-next-line prefer-spread
            this.listeners.forEach((fn)=>{
                result = fn(...data);
            });
        }
        return result;
    }
    remove(fn) {
        this.listeners.delete(fn);
    }
    removeAll() {
        this.listeners.clear();
    }
    constructor(type){
        this.type = '';
        this.listeners = new Set();
        if (type) {
            this.type = type;
        }
    }
}

class AsyncHook extends SyncHook {
    emit(...data) {
        let result;
        const ls = Array.from(this.listeners);
        if (ls.length > 0) {
            let i = 0;
            const call = (prev)=>{
                if (prev === false) {
                    return false; // Abort process
                } else if (i < ls.length) {
                    return Promise.resolve(ls[i++].apply(null, data)).then(call);
                } else {
                    return prev;
                }
            };
            result = call();
        }
        return Promise.resolve(result);
    }
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function checkReturnData(originalData, returnedData) {
    if (!isObject$1(returnedData)) {
        return false;
    }
    if (originalData !== returnedData) {
        // eslint-disable-next-line no-restricted-syntax
        for(const key in originalData){
            if (!(key in returnedData)) {
                return false;
            }
        }
    }
    return true;
}
class SyncWaterfallHook extends SyncHook {
    emit(data) {
        if (!isObject$1(data)) {
            error(`The data for the "${this.type}" hook should be an object.`);
        }
        for (const fn of this.listeners){
            try {
                const tempData = fn(data);
                if (checkReturnData(data, tempData)) {
                    data = tempData;
                } else {
                    this.onerror(`A plugin returned an unacceptable value for the "${this.type}" type.`);
                    break;
                }
            } catch (e) {
                warn(e);
                this.onerror(e);
            }
        }
        return data;
    }
    constructor(type){
        super(), this.onerror = error;
        this.type = type;
    }
}

class AsyncWaterfallHook extends SyncHook {
    emit(data) {
        if (!isObject$1(data)) {
            error(`The response data for the "${this.type}" hook must be an object.`);
        }
        const ls = Array.from(this.listeners);
        if (ls.length > 0) {
            let i = 0;
            const processError = (e)=>{
                warn(e);
                this.onerror(e);
                return data;
            };
            const call = (prevData)=>{
                if (checkReturnData(data, prevData)) {
                    data = prevData;
                    if (i < ls.length) {
                        try {
                            return Promise.resolve(ls[i++](data)).then(call, processError);
                        } catch (e) {
                            return processError(e);
                        }
                    }
                } else {
                    this.onerror(`A plugin returned an incorrect value for the "${this.type}" type.`);
                }
                return data;
            };
            return Promise.resolve(call(data));
        }
        return Promise.resolve(data);
    }
    constructor(type){
        super(), this.onerror = error;
        this.type = type;
    }
}

class PluginSystem {
    applyPlugin(plugin) {
        assert(isPlainObject$1(plugin), 'Plugin configuration is invalid.');
        // The plugin's name is mandatory and must be unique
        const pluginName = plugin.name;
        assert(pluginName, 'A name must be provided by the plugin.');
        if (!this.registerPlugins[pluginName]) {
            this.registerPlugins[pluginName] = plugin;
            Object.keys(this.lifecycle).forEach((key)=>{
                const pluginLife = plugin[key];
                if (pluginLife) {
                    this.lifecycle[key].on(pluginLife);
                }
            });
        }
    }
    removePlugin(pluginName) {
        assert(pluginName, 'A name is required.');
        const plugin = this.registerPlugins[pluginName];
        assert(plugin, `The plugin "${pluginName}" is not registered.`);
        Object.keys(plugin).forEach((key)=>{
            if (key !== 'name') {
                this.lifecycle[key].remove(plugin[key]);
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow
    inherit({ lifecycle, registerPlugins }) {
        Object.keys(lifecycle).forEach((hookName)=>{
            assert(!this.lifecycle[hookName], `The hook "${hookName}" has a conflict and cannot be inherited.`);
            this.lifecycle[hookName] = lifecycle[hookName];
        });
        Object.keys(registerPlugins).forEach((pluginName)=>{
            assert(!this.registerPlugins[pluginName], `The plugin "${pluginName}" has a conflict and cannot be inherited.`);
            this.applyPlugin(registerPlugins[pluginName]);
        });
    }
    constructor(lifecycle){
        this.registerPlugins = {};
        this.lifecycle = lifecycle;
        this.lifecycleKeys = Object.keys(lifecycle);
    }
}

function defaultPreloadArgs(preloadConfig) {
    return _extends$2({
        resourceCategory: 'sync',
        share: true,
        depsRemote: true,
        prefetchInterface: false
    }, preloadConfig);
}
function formatPreloadArgs(remotes, preloadArgs) {
    return preloadArgs.map((args)=>{
        const remoteInfo = matchRemote(remotes, args.nameOrAlias);
        assert(remoteInfo, `Unable to preload ${args.nameOrAlias} as it is not included in ${!remoteInfo && safeToString({
            remoteInfo,
            remotes
        })}`);
        return {
            remote: remoteInfo,
            preloadConfig: defaultPreloadArgs(args)
        };
    });
}
function normalizePreloadExposes(exposes) {
    if (!exposes) {
        return [];
    }
    return exposes.map((expose)=>{
        if (expose === '.') {
            return expose;
        }
        if (expose.startsWith('./')) {
            return expose.replace('./', '');
        }
        return expose;
    });
}
function preloadAssets(remoteInfo, host, assets, // It is used to distinguish preload from load remote parallel loading
useLinkPreload = true) {
    const { cssAssets, jsAssetsWithoutEntry, entryAssets } = assets;
    if (host.options.inBrowser) {
        entryAssets.forEach((asset)=>{
            const { moduleInfo } = asset;
            const module = host.moduleCache.get(remoteInfo.name);
            if (module) {
                getRemoteEntry({
                    origin: host,
                    remoteInfo: moduleInfo,
                    remoteEntryExports: module.remoteEntryExports
                });
            } else {
                getRemoteEntry({
                    origin: host,
                    remoteInfo: moduleInfo,
                    remoteEntryExports: undefined
                });
            }
        });
        if (useLinkPreload) {
            const defaultAttrs = {
                rel: 'preload',
                as: 'style'
            };
            cssAssets.forEach((cssUrl)=>{
                const { link: cssEl, needAttach } = createLink({
                    url: cssUrl,
                    cb: ()=>{
                    // noop
                    },
                    attrs: defaultAttrs,
                    createLinkHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createLink.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    }
                });
                needAttach && document.head.appendChild(cssEl);
            });
        } else {
            const defaultAttrs = {
                rel: 'stylesheet',
                type: 'text/css'
            };
            cssAssets.forEach((cssUrl)=>{
                const { link: cssEl, needAttach } = createLink({
                    url: cssUrl,
                    cb: ()=>{
                    // noop
                    },
                    attrs: defaultAttrs,
                    createLinkHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createLink.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    },
                    needDeleteLink: false
                });
                needAttach && document.head.appendChild(cssEl);
            });
        }
        if (useLinkPreload) {
            const defaultAttrs = {
                rel: 'preload',
                as: 'script'
            };
            jsAssetsWithoutEntry.forEach((jsUrl)=>{
                const { link: linkEl, needAttach } = createLink({
                    url: jsUrl,
                    cb: ()=>{
                    // noop
                    },
                    attrs: defaultAttrs,
                    createLinkHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createLink.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    }
                });
                needAttach && document.head.appendChild(linkEl);
            });
        } else {
            const defaultAttrs = {
                fetchpriority: 'high',
                type: (remoteInfo == null ? void 0 : remoteInfo.type) === 'module' ? 'module' : 'text/javascript'
            };
            jsAssetsWithoutEntry.forEach((jsUrl)=>{
                const { script: scriptEl, needAttach } = createScript({
                    url: jsUrl,
                    cb: ()=>{
                    // noop
                    },
                    attrs: defaultAttrs,
                    createScriptHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createScript.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLScriptElement) {
                            return res;
                        }
                        return;
                    },
                    needDeleteScript: true
                });
                needAttach && document.head.appendChild(scriptEl);
            });
        }
    }
}

function assignRemoteInfo(remoteInfo, remoteSnapshot) {
    const remoteEntryInfo = getRemoteEntryInfoFromSnapshot(remoteSnapshot);
    if (!remoteEntryInfo.url) {
        error(`The attribute remoteEntry of ${remoteInfo.name} must not be undefined.`);
    }
    let entryUrl = getResourceUrl(remoteSnapshot, remoteEntryInfo.url);
    if (!isBrowserEnv() && !entryUrl.startsWith('http')) {
        entryUrl = `https:${entryUrl}`;
    }
    remoteInfo.type = remoteEntryInfo.type;
    remoteInfo.entryGlobalName = remoteEntryInfo.globalName;
    remoteInfo.entry = entryUrl;
    remoteInfo.version = remoteSnapshot.version;
    remoteInfo.buildVersion = remoteSnapshot.buildVersion;
}
function snapshotPlugin() {
    return {
        name: 'snapshot-plugin',
        async afterResolve (args) {
            const { remote, pkgNameOrAlias, expose, origin, remoteInfo, id } = args;
            if (!isRemoteInfoWithEntry(remote) || !isPureRemoteEntry(remote)) {
                const { remoteSnapshot, globalSnapshot } = await origin.snapshotHandler.loadRemoteSnapshotInfo({
                    moduleInfo: remote,
                    id
                });
                assignRemoteInfo(remoteInfo, remoteSnapshot);
                // preloading assets
                const preloadOptions = {
                    remote,
                    preloadConfig: {
                        nameOrAlias: pkgNameOrAlias,
                        exposes: [
                            expose
                        ],
                        resourceCategory: 'sync',
                        share: false,
                        depsRemote: false
                    }
                };
                const assets = await origin.remoteHandler.hooks.lifecycle.generatePreloadAssets.emit({
                    origin,
                    preloadOptions,
                    remoteInfo,
                    remote,
                    remoteSnapshot,
                    globalSnapshot
                });
                if (assets) {
                    preloadAssets(remoteInfo, origin, assets, false);
                }
                return _extends$2({}, args, {
                    remoteSnapshot
                });
            }
            return args;
        }
    };
}

// name
// name:version
function splitId(id) {
    const splitInfo = id.split(':');
    if (splitInfo.length === 1) {
        return {
            name: splitInfo[0],
            version: undefined
        };
    } else if (splitInfo.length === 2) {
        return {
            name: splitInfo[0],
            version: splitInfo[1]
        };
    } else {
        return {
            name: splitInfo[1],
            version: splitInfo[2]
        };
    }
}
// Traverse all nodes in moduleInfo and traverse the entire snapshot
function traverseModuleInfo(globalSnapshot, remoteInfo, traverse, isRoot, memo = {}, remoteSnapshot) {
    const id = getFMId(remoteInfo);
    const { value: snapshotValue } = getInfoWithoutType(globalSnapshot, id);
    const effectiveRemoteSnapshot = remoteSnapshot || snapshotValue;
    if (effectiveRemoteSnapshot && !isManifestProvider(effectiveRemoteSnapshot)) {
        traverse(effectiveRemoteSnapshot, remoteInfo, isRoot);
        if (effectiveRemoteSnapshot.remotesInfo) {
            const remoteKeys = Object.keys(effectiveRemoteSnapshot.remotesInfo);
            for (const key of remoteKeys){
                if (memo[key]) {
                    continue;
                }
                memo[key] = true;
                const subRemoteInfo = splitId(key);
                const remoteValue = effectiveRemoteSnapshot.remotesInfo[key];
                traverseModuleInfo(globalSnapshot, {
                    name: subRemoteInfo.name,
                    version: remoteValue.matchedVersion
                }, traverse, false, memo, undefined);
            }
        }
    }
}
const isExisted = (type, url)=>{
    return document.querySelector(`${type}[${type === 'link' ? 'href' : 'src'}="${url}"]`);
};
// eslint-disable-next-line max-lines-per-function
function generatePreloadAssets(origin, preloadOptions, remote, globalSnapshot, remoteSnapshot) {
    const cssAssets = [];
    const jsAssets = [];
    const entryAssets = [];
    const loadedSharedJsAssets = new Set();
    const loadedSharedCssAssets = new Set();
    const { options } = origin;
    const { preloadConfig: rootPreloadConfig } = preloadOptions;
    const { depsRemote } = rootPreloadConfig;
    const memo = {};
    traverseModuleInfo(globalSnapshot, remote, (moduleInfoSnapshot, remoteInfo, isRoot)=>{
        let preloadConfig;
        if (isRoot) {
            preloadConfig = rootPreloadConfig;
        } else {
            if (Array.isArray(depsRemote)) {
                // eslint-disable-next-line array-callback-return
                const findPreloadConfig = depsRemote.find((remoteConfig)=>{
                    if (remoteConfig.nameOrAlias === remoteInfo.name || remoteConfig.nameOrAlias === remoteInfo.alias) {
                        return true;
                    }
                    return false;
                });
                if (!findPreloadConfig) {
                    return;
                }
                preloadConfig = defaultPreloadArgs(findPreloadConfig);
            } else if (depsRemote === true) {
                preloadConfig = rootPreloadConfig;
            } else {
                return;
            }
        }
        const remoteEntryUrl = getResourceUrl(moduleInfoSnapshot, getRemoteEntryInfoFromSnapshot(moduleInfoSnapshot).url);
        if (remoteEntryUrl) {
            entryAssets.push({
                name: remoteInfo.name,
                moduleInfo: {
                    name: remoteInfo.name,
                    entry: remoteEntryUrl,
                    type: 'remoteEntryType' in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntryType : 'global',
                    entryGlobalName: 'globalName' in moduleInfoSnapshot ? moduleInfoSnapshot.globalName : remoteInfo.name,
                    shareScope: '',
                    version: 'version' in moduleInfoSnapshot ? moduleInfoSnapshot.version : undefined
                },
                url: remoteEntryUrl
            });
        }
        let moduleAssetsInfo = 'modules' in moduleInfoSnapshot ? moduleInfoSnapshot.modules : [];
        const normalizedPreloadExposes = normalizePreloadExposes(preloadConfig.exposes);
        if (normalizedPreloadExposes.length && 'modules' in moduleInfoSnapshot) {
            var _moduleInfoSnapshot_modules;
            moduleAssetsInfo = moduleInfoSnapshot == null ? void 0 : (_moduleInfoSnapshot_modules = moduleInfoSnapshot.modules) == null ? void 0 : _moduleInfoSnapshot_modules.reduce((assets, moduleAssetInfo)=>{
                if ((normalizedPreloadExposes == null ? void 0 : normalizedPreloadExposes.indexOf(moduleAssetInfo.moduleName)) !== -1) {
                    assets.push(moduleAssetInfo);
                }
                return assets;
            }, []);
        }
        function handleAssets(assets) {
            const assetsRes = assets.map((asset)=>getResourceUrl(moduleInfoSnapshot, asset));
            if (preloadConfig.filter) {
                return assetsRes.filter(preloadConfig.filter);
            }
            return assetsRes;
        }
        if (moduleAssetsInfo) {
            const assetsLength = moduleAssetsInfo.length;
            for(let index = 0; index < assetsLength; index++){
                const assetsInfo = moduleAssetsInfo[index];
                const exposeFullPath = `${remoteInfo.name}/${assetsInfo.moduleName}`;
                origin.remoteHandler.hooks.lifecycle.handlePreloadModule.emit({
                    id: assetsInfo.moduleName === '.' ? remoteInfo.name : exposeFullPath,
                    name: remoteInfo.name,
                    remoteSnapshot: moduleInfoSnapshot,
                    preloadConfig,
                    remote: remoteInfo,
                    origin
                });
                const preloaded = getPreloaded(exposeFullPath);
                if (preloaded) {
                    continue;
                }
                if (preloadConfig.resourceCategory === 'all') {
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.async));
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.async));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));
                // eslint-disable-next-line no-constant-condition
                } else if (preloadConfig.resourceCategory = 'sync') {
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));
                }
                setPreloaded(exposeFullPath);
            }
        }
    }, true, memo, remoteSnapshot);
    if (remoteSnapshot.shared) {
        const collectSharedAssets = (shareInfo, snapshotShared)=>{
            const registeredShared = getRegisteredShare(origin.shareScopeMap, snapshotShared.sharedName, shareInfo, origin.sharedHandler.hooks.lifecycle.resolveShare);
            // If the global share does not exist, or the lib function does not exist, it means that the shared has not been loaded yet and can be preloaded.
            if (registeredShared && typeof registeredShared.lib === 'function') {
                snapshotShared.assets.js.sync.forEach((asset)=>{
                    loadedSharedJsAssets.add(asset);
                });
                snapshotShared.assets.css.sync.forEach((asset)=>{
                    loadedSharedCssAssets.add(asset);
                });
            }
        };
        remoteSnapshot.shared.forEach((shared)=>{
            var _options_shared;
            const shareInfos = (_options_shared = options.shared) == null ? void 0 : _options_shared[shared.sharedName];
            if (!shareInfos) {
                return;
            }
            // if no version, preload all shared
            const sharedOptions = shared.version ? shareInfos.find((s)=>s.version === shared.version) : shareInfos;
            if (!sharedOptions) {
                return;
            }
            const arrayShareInfo = arrayOptions(sharedOptions);
            arrayShareInfo.forEach((s)=>{
                collectSharedAssets(s, shared);
            });
        });
    }
    const needPreloadJsAssets = jsAssets.filter((asset)=>!loadedSharedJsAssets.has(asset) && !isExisted('script', asset));
    const needPreloadCssAssets = cssAssets.filter((asset)=>!loadedSharedCssAssets.has(asset) && !isExisted('link', asset));
    return {
        cssAssets: needPreloadCssAssets,
        jsAssetsWithoutEntry: needPreloadJsAssets,
        entryAssets: entryAssets.filter((entry)=>!isExisted('script', entry.url))
    };
}
const generatePreloadAssetsPlugin = function() {
    return {
        name: 'generate-preload-assets-plugin',
        async generatePreloadAssets (args) {
            const { origin, preloadOptions, remoteInfo, remote, globalSnapshot, remoteSnapshot } = args;
            if (!isBrowserEnv()) {
                return {
                    cssAssets: [],
                    jsAssetsWithoutEntry: [],
                    entryAssets: []
                };
            }
            if (isRemoteInfoWithEntry(remote) && isPureRemoteEntry(remote)) {
                return {
                    cssAssets: [],
                    jsAssetsWithoutEntry: [],
                    entryAssets: [
                        {
                            name: remote.name,
                            url: remote.entry,
                            moduleInfo: {
                                name: remoteInfo.name,
                                entry: remote.entry,
                                type: remoteInfo.type || 'global',
                                entryGlobalName: '',
                                shareScope: ''
                            }
                        }
                    ]
                };
            }
            assignRemoteInfo(remoteInfo, remoteSnapshot);
            const assets = generatePreloadAssets(origin, preloadOptions, remoteInfo, globalSnapshot, remoteSnapshot);
            return assets;
        }
    };
};

function getGlobalRemoteInfo(moduleInfo, origin) {
    const hostGlobalSnapshot = getGlobalSnapshotInfoByModuleInfo({
        name: origin.name,
        version: origin.options.version
    });
    // get remote detail info from global
    const globalRemoteInfo = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && getInfoWithoutType(hostGlobalSnapshot.remotesInfo, moduleInfo.name).value;
    if (globalRemoteInfo && globalRemoteInfo.matchedVersion) {
        return {
            hostGlobalSnapshot,
            globalSnapshot: getGlobalSnapshot(),
            remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
                name: moduleInfo.name,
                version: globalRemoteInfo.matchedVersion
            })
        };
    }
    return {
        hostGlobalSnapshot: undefined,
        globalSnapshot: getGlobalSnapshot(),
        remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
            name: moduleInfo.name,
            version: 'version' in moduleInfo ? moduleInfo.version : undefined
        })
    };
}
class SnapshotHandler {
    // eslint-disable-next-line max-lines-per-function
    async loadRemoteSnapshotInfo({ moduleInfo, id, expose }) {
        const { options } = this.HostInstance;
        await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({
            options,
            moduleInfo
        });
        let hostSnapshot = getGlobalSnapshotInfoByModuleInfo({
            name: this.HostInstance.options.name,
            version: this.HostInstance.options.version
        });
        if (!hostSnapshot) {
            hostSnapshot = {
                version: this.HostInstance.options.version || '',
                remoteEntry: '',
                remotesInfo: {}
            };
            addGlobalSnapshot({
                [this.HostInstance.options.name]: hostSnapshot
            });
        }
        // In dynamic loadRemote scenarios, incomplete remotesInfo delivery may occur. In such cases, the remotesInfo in the host needs to be completed in the snapshot at runtime.
        // This ensures the snapshot's integrity and helps the chrome plugin correctly identify all producer modules, ensuring that proxyable producer modules will not be missing.
        if (hostSnapshot && 'remotesInfo' in hostSnapshot && !getInfoWithoutType(hostSnapshot.remotesInfo, moduleInfo.name).value) {
            if ('version' in moduleInfo || 'entry' in moduleInfo) {
                hostSnapshot.remotesInfo = _extends$2({}, hostSnapshot == null ? void 0 : hostSnapshot.remotesInfo, {
                    [moduleInfo.name]: {
                        matchedVersion: 'version' in moduleInfo ? moduleInfo.version : moduleInfo.entry
                    }
                });
            }
        }
        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);
        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({
            options,
            moduleInfo,
            hostGlobalSnapshot,
            remoteSnapshot,
            globalSnapshot
        });
        let mSnapshot;
        let gSnapshot;
        // global snapshot includes manifest or module info includes manifest
        if (globalRemoteSnapshot) {
            if (isManifestProvider(globalRemoteSnapshot)) {
                const remoteEntry = isBrowserEnv() ? globalRemoteSnapshot.remoteEntry : globalRemoteSnapshot.ssrRemoteEntry || globalRemoteSnapshot.remoteEntry || '';
                const moduleSnapshot = await this.getManifestJson(remoteEntry, moduleInfo, {});
                // eslint-disable-next-line @typescript-eslint/no-shadow
                const globalSnapshotRes = setGlobalSnapshotInfoByModuleInfo(_extends$2({}, moduleInfo, {
                    // The global remote may be overridden
                    // Therefore, set the snapshot key to the global address of the actual request
                    entry: remoteEntry
                }), moduleSnapshot);
                mSnapshot = moduleSnapshot;
                gSnapshot = globalSnapshotRes;
            } else {
                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                    options: this.HostInstance.options,
                    moduleInfo,
                    remoteSnapshot: globalRemoteSnapshot,
                    from: 'global'
                });
                mSnapshot = remoteSnapshotRes;
                gSnapshot = globalSnapshotRes;
            }
        } else {
            if (isRemoteInfoWithEntry(moduleInfo)) {
                // get from manifest.json and merge remote info from remote server
                const moduleSnapshot = await this.getManifestJson(moduleInfo.entry, moduleInfo, {});
                // eslint-disable-next-line @typescript-eslint/no-shadow
                const globalSnapshotRes = setGlobalSnapshotInfoByModuleInfo(moduleInfo, moduleSnapshot);
                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                    options: this.HostInstance.options,
                    moduleInfo,
                    remoteSnapshot: moduleSnapshot,
                    from: 'global'
                });
                mSnapshot = remoteSnapshotRes;
                gSnapshot = globalSnapshotRes;
            } else {
                error(getShortErrorMsg(RUNTIME_007, runtimeDescMap, {
                    hostName: moduleInfo.name,
                    hostVersion: moduleInfo.version,
                    globalSnapshot: JSON.stringify(globalSnapshotRes)
                }));
            }
        }
        await this.hooks.lifecycle.afterLoadSnapshot.emit({
            id,
            host: this.HostInstance,
            options,
            moduleInfo,
            remoteSnapshot: mSnapshot
        });
        return {
            remoteSnapshot: mSnapshot,
            globalSnapshot: gSnapshot
        };
    }
    getGlobalRemoteInfo(moduleInfo) {
        return getGlobalRemoteInfo(moduleInfo, this.HostInstance);
    }
    async getManifestJson(manifestUrl, moduleInfo, extraOptions) {
        const getManifest = async ()=>{
            let manifestJson = this.manifestCache.get(manifestUrl);
            if (manifestJson) {
                return manifestJson;
            }
            try {
                let res = await this.loaderHook.lifecycle.fetch.emit(manifestUrl, {});
                if (!res || !(res instanceof Response)) {
                    res = await fetch(manifestUrl, {});
                }
                manifestJson = await res.json();
            } catch (err) {
                manifestJson = await this.HostInstance.remoteHandler.hooks.lifecycle.errorLoadRemote.emit({
                    id: manifestUrl,
                    error: err,
                    from: 'runtime',
                    lifecycle: 'afterResolve',
                    origin: this.HostInstance
                });
                if (!manifestJson) {
                    delete this.manifestLoading[manifestUrl];
                    error(getShortErrorMsg(RUNTIME_003, runtimeDescMap, {
                        manifestUrl,
                        moduleName: moduleInfo.name,
                        hostName: this.HostInstance.options.name
                    }, `${err}`));
                }
            }
            assert(manifestJson.metaData && manifestJson.exposes && manifestJson.shared, `${manifestUrl} is not a federation manifest`);
            this.manifestCache.set(manifestUrl, manifestJson);
            return manifestJson;
        };
        const asyncLoadProcess = async ()=>{
            const manifestJson = await getManifest();
            const remoteSnapshot = generateSnapshotFromManifest(manifestJson, {
                version: manifestUrl
            });
            const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                options: this.HostInstance.options,
                moduleInfo,
                manifestJson,
                remoteSnapshot,
                manifestUrl,
                from: 'manifest'
            });
            return remoteSnapshotRes;
        };
        if (!this.manifestLoading[manifestUrl]) {
            this.manifestLoading[manifestUrl] = asyncLoadProcess().then((res)=>res);
        }
        return this.manifestLoading[manifestUrl];
    }
    constructor(HostInstance){
        this.loadingHostSnapshot = null;
        this.manifestCache = new Map();
        this.hooks = new PluginSystem({
            beforeLoadRemoteSnapshot: new AsyncHook('beforeLoadRemoteSnapshot'),
            loadSnapshot: new AsyncWaterfallHook('loadGlobalSnapshot'),
            loadRemoteSnapshot: new AsyncWaterfallHook('loadRemoteSnapshot'),
            afterLoadSnapshot: new AsyncWaterfallHook('afterLoadSnapshot')
        });
        this.manifestLoading = Global.__FEDERATION__.__MANIFEST_LOADING__;
        this.HostInstance = HostInstance;
        this.loaderHook = HostInstance.loaderHook;
    }
}

class SharedHandler {
    // register shared in shareScopeMap
    registerShared(globalOptions, userOptions) {
        const { shareInfos, shared } = formatShareConfigs(globalOptions, userOptions);
        const sharedKeys = Object.keys(shareInfos);
        sharedKeys.forEach((sharedKey)=>{
            const sharedVals = shareInfos[sharedKey];
            sharedVals.forEach((sharedVal)=>{
                const registeredShared = getRegisteredShare(this.shareScopeMap, sharedKey, sharedVal, this.hooks.lifecycle.resolveShare);
                if (!registeredShared && sharedVal && sharedVal.lib) {
                    this.setShared({
                        pkgName: sharedKey,
                        lib: sharedVal.lib,
                        get: sharedVal.get,
                        loaded: true,
                        shared: sharedVal,
                        from: userOptions.name
                    });
                }
            });
        });
        return {
            shareInfos,
            shared
        };
    }
    async loadShare(pkgName, extraOptions) {
        const { host } = this;
        // This function performs the following steps:
        // 1. Checks if the currently loaded share already exists, if not, it throws an error
        // 2. Searches globally for a matching share, if found, it uses it directly
        // 3. If not found, it retrieves it from the current share and stores the obtained share globally.
        const shareInfo = getTargetSharedOptions({
            pkgName,
            extraOptions,
            shareInfos: host.options.shared
        });
        if (shareInfo == null ? void 0 : shareInfo.scope) {
            await Promise.all(shareInfo.scope.map(async (shareScope)=>{
                await Promise.all(this.initializeSharing(shareScope, {
                    strategy: shareInfo.strategy
                }));
                return;
            }));
        }
        const loadShareRes = await this.hooks.lifecycle.beforeLoadShare.emit({
            pkgName,
            shareInfo,
            shared: host.options.shared,
            origin: host
        });
        const { shareInfo: shareInfoRes } = loadShareRes;
        // Assert that shareInfoRes exists, if not, throw an error
        assert(shareInfoRes, `Cannot find ${pkgName} Share in the ${host.options.name}. Please ensure that the ${pkgName} Share parameters have been injected`);
        // Retrieve from cache
        const registeredShared = getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
        const addUseIn = (shared)=>{
            if (!shared.useIn) {
                shared.useIn = [];
            }
            addUniqueItem(shared.useIn, host.options.name);
        };
        if (registeredShared && registeredShared.lib) {
            addUseIn(registeredShared);
            return registeredShared.lib;
        } else if (registeredShared && registeredShared.loading && !registeredShared.loaded) {
            const factory = await registeredShared.loading;
            registeredShared.loaded = true;
            if (!registeredShared.lib) {
                registeredShared.lib = factory;
            }
            addUseIn(registeredShared);
            return factory;
        } else if (registeredShared) {
            const asyncLoadProcess = async ()=>{
                const factory = await registeredShared.get();
                shareInfoRes.lib = factory;
                shareInfoRes.loaded = true;
                addUseIn(shareInfoRes);
                const gShared = getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
                if (gShared) {
                    gShared.lib = factory;
                    gShared.loaded = true;
                }
                return factory;
            };
            const loading = asyncLoadProcess();
            this.setShared({
                pkgName,
                loaded: false,
                shared: registeredShared,
                from: host.options.name,
                lib: null,
                loading
            });
            return loading;
        } else {
            if (extraOptions == null ? void 0 : extraOptions.customShareInfo) {
                return false;
            }
            const asyncLoadProcess = async ()=>{
                const factory = await shareInfoRes.get();
                shareInfoRes.lib = factory;
                shareInfoRes.loaded = true;
                addUseIn(shareInfoRes);
                const gShared = getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
                if (gShared) {
                    gShared.lib = factory;
                    gShared.loaded = true;
                }
                return factory;
            };
            const loading = asyncLoadProcess();
            this.setShared({
                pkgName,
                loaded: false,
                shared: shareInfoRes,
                from: host.options.name,
                lib: null,
                loading
            });
            return loading;
        }
    }
    /**
   * This function initializes the sharing sequence (executed only once per share scope).
   * It accepts one argument, the name of the share scope.
   * If the share scope does not exist, it creates one.
   */ // eslint-disable-next-line @typescript-eslint/member-ordering
    initializeSharing(shareScopeName = DEFAULT_SCOPE, extraOptions) {
        const { host } = this;
        const from = extraOptions == null ? void 0 : extraOptions.from;
        const strategy = extraOptions == null ? void 0 : extraOptions.strategy;
        let initScope = extraOptions == null ? void 0 : extraOptions.initScope;
        const promises = [];
        if (from !== 'build') {
            const { initTokens } = this;
            if (!initScope) initScope = [];
            let initToken = initTokens[shareScopeName];
            if (!initToken) initToken = initTokens[shareScopeName] = {
                from: this.host.name
            };
            if (initScope.indexOf(initToken) >= 0) return promises;
            initScope.push(initToken);
        }
        const shareScope = this.shareScopeMap;
        const hostName = host.options.name;
        // Creates a new share scope if necessary
        if (!shareScope[shareScopeName]) {
            shareScope[shareScopeName] = {};
        }
        // Executes all initialization snippets from all accessible modules
        const scope = shareScope[shareScopeName];
        const register = (name, shared)=>{
            var _activeVersion_shareConfig;
            const { version, eager } = shared;
            scope[name] = scope[name] || {};
            const versions = scope[name];
            const activeVersion = versions[version];
            const activeVersionEager = Boolean(activeVersion && (activeVersion.eager || ((_activeVersion_shareConfig = activeVersion.shareConfig) == null ? void 0 : _activeVersion_shareConfig.eager)));
            if (!activeVersion || activeVersion.strategy !== 'loaded-first' && !activeVersion.loaded && (Boolean(!eager) !== !activeVersionEager ? eager : hostName > activeVersion.from)) {
                versions[version] = shared;
            }
        };
        const initFn = (mod)=>mod && mod.init && mod.init(shareScope[shareScopeName], initScope);
        const initRemoteModule = async (key)=>{
            const { module } = await host.remoteHandler.getRemoteModuleAndOptions({
                id: key
            });
            if (module.getEntry) {
                let remoteEntryExports;
                try {
                    remoteEntryExports = await module.getEntry();
                } catch (error) {
                    remoteEntryExports = await host.remoteHandler.hooks.lifecycle.errorLoadRemote.emit({
                        id: key,
                        error,
                        from: 'runtime',
                        lifecycle: 'beforeLoadShare',
                        origin: host
                    });
                }
                if (!module.inited) {
                    await initFn(remoteEntryExports);
                    module.inited = true;
                }
            }
        };
        Object.keys(host.options.shared).forEach((shareName)=>{
            const sharedArr = host.options.shared[shareName];
            sharedArr.forEach((shared)=>{
                if (shared.scope.includes(shareScopeName)) {
                    register(shareName, shared);
                }
            });
        });
        // TODO: strategy==='version-first' need to be removed in the future
        if (host.options.shareStrategy === 'version-first' || strategy === 'version-first') {
            host.options.remotes.forEach((remote)=>{
                if (remote.shareScope === shareScopeName) {
                    promises.push(initRemoteModule(remote.name));
                }
            });
        }
        return promises;
    }
    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
    // 1. If the loaded shared already exists globally, then it will be reused
    // 2. If lib exists in local shared, it will be used directly
    // 3. If the local get returns something other than Promise, then it will be used directly
    loadShareSync(pkgName, extraOptions) {
        const { host } = this;
        const shareInfo = getTargetSharedOptions({
            pkgName,
            extraOptions,
            shareInfos: host.options.shared
        });
        if (shareInfo == null ? void 0 : shareInfo.scope) {
            shareInfo.scope.forEach((shareScope)=>{
                this.initializeSharing(shareScope, {
                    strategy: shareInfo.strategy
                });
            });
        }
        const registeredShared = getRegisteredShare(this.shareScopeMap, pkgName, shareInfo, this.hooks.lifecycle.resolveShare);
        const addUseIn = (shared)=>{
            if (!shared.useIn) {
                shared.useIn = [];
            }
            addUniqueItem(shared.useIn, host.options.name);
        };
        if (registeredShared) {
            if (typeof registeredShared.lib === 'function') {
                addUseIn(registeredShared);
                if (!registeredShared.loaded) {
                    registeredShared.loaded = true;
                    if (registeredShared.from === host.options.name) {
                        shareInfo.loaded = true;
                    }
                }
                return registeredShared.lib;
            }
            if (typeof registeredShared.get === 'function') {
                const module = registeredShared.get();
                if (!(module instanceof Promise)) {
                    addUseIn(registeredShared);
                    this.setShared({
                        pkgName,
                        loaded: true,
                        from: host.options.name,
                        lib: module,
                        shared: registeredShared
                    });
                    return module;
                }
            }
        }
        if (shareInfo.lib) {
            if (!shareInfo.loaded) {
                shareInfo.loaded = true;
            }
            return shareInfo.lib;
        }
        if (shareInfo.get) {
            const module = shareInfo.get();
            if (module instanceof Promise) {
                const errorCode = (extraOptions == null ? void 0 : extraOptions.from) === 'build' ? RUNTIME_005 : RUNTIME_006;
                throw new Error(getShortErrorMsg(errorCode, runtimeDescMap, {
                    hostName: host.options.name,
                    sharedPkgName: pkgName
                }));
            }
            shareInfo.lib = module;
            this.setShared({
                pkgName,
                loaded: true,
                from: host.options.name,
                lib: shareInfo.lib,
                shared: shareInfo
            });
            return shareInfo.lib;
        }
        throw new Error(getShortErrorMsg(RUNTIME_006, runtimeDescMap, {
            hostName: host.options.name,
            sharedPkgName: pkgName
        }));
    }
    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {
        const { host } = this;
        this.shareScopeMap[scopeName] = shareScope;
        this.hooks.lifecycle.initContainerShareScopeMap.emit({
            shareScope,
            options: host.options,
            origin: host,
            scopeName,
            hostShareScopeMap: extraOptions.hostShareScopeMap
        });
    }
    setShared({ pkgName, shared, from, lib, loading, loaded, get }) {
        const { version, scope = 'default' } = shared, shareInfo = _object_without_properties_loose(shared, [
            "version",
            "scope"
        ]);
        const scopes = Array.isArray(scope) ? scope : [
            scope
        ];
        scopes.forEach((sc)=>{
            if (!this.shareScopeMap[sc]) {
                this.shareScopeMap[sc] = {};
            }
            if (!this.shareScopeMap[sc][pkgName]) {
                this.shareScopeMap[sc][pkgName] = {};
            }
            if (!this.shareScopeMap[sc][pkgName][version]) {
                this.shareScopeMap[sc][pkgName][version] = _extends$2({
                    version,
                    scope: [
                        'default'
                    ]
                }, shareInfo, {
                    lib,
                    loaded,
                    loading
                });
                if (get) {
                    this.shareScopeMap[sc][pkgName][version].get = get;
                }
                return;
            }
            const registeredShared = this.shareScopeMap[sc][pkgName][version];
            if (loading && !registeredShared.loading) {
                registeredShared.loading = loading;
            }
        });
    }
    _setGlobalShareScopeMap(hostOptions) {
        const globalShareScopeMap = getGlobalShareScope();
        const identifier = hostOptions.id || hostOptions.name;
        if (identifier && !globalShareScopeMap[identifier]) {
            globalShareScopeMap[identifier] = this.shareScopeMap;
        }
    }
    constructor(host){
        this.hooks = new PluginSystem({
            afterResolve: new AsyncWaterfallHook('afterResolve'),
            beforeLoadShare: new AsyncWaterfallHook('beforeLoadShare'),
            // not used yet
            loadShare: new AsyncHook(),
            resolveShare: new SyncWaterfallHook('resolveShare'),
            // maybe will change, temporarily for internal use only
            initContainerShareScopeMap: new SyncWaterfallHook('initContainerShareScopeMap')
        });
        this.host = host;
        this.shareScopeMap = {};
        this.initTokens = {};
        this._setGlobalShareScopeMap(host.options);
    }
}

class RemoteHandler {
    formatAndRegisterRemote(globalOptions, userOptions) {
        const userRemotes = userOptions.remotes || [];
        return userRemotes.reduce((res, remote)=>{
            this.registerRemote(remote, res, {
                force: false
            });
            return res;
        }, globalOptions.remotes);
    }
    setIdToRemoteMap(id, remoteMatchInfo) {
        const { remote, expose } = remoteMatchInfo;
        const { name, alias } = remote;
        this.idToRemoteMap[id] = {
            name: remote.name,
            expose
        };
        if (alias && id.startsWith(name)) {
            const idWithAlias = id.replace(name, alias);
            this.idToRemoteMap[idWithAlias] = {
                name: remote.name,
                expose
            };
            return;
        }
        if (alias && id.startsWith(alias)) {
            const idWithName = id.replace(alias, name);
            this.idToRemoteMap[idWithName] = {
                name: remote.name,
                expose
            };
        }
    }
    // eslint-disable-next-line max-lines-per-function
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async loadRemote(id, options) {
        const { host } = this;
        try {
            const { loadFactory = true } = options || {
                loadFactory: true
            };
            // 1. Validate the parameters of the retrieved module. There are two module request methods: pkgName + expose and alias + expose.
            // 2. Request the snapshot information of the current host and globally store the obtained snapshot information. The retrieved module information is partially offline and partially online. The online module information will retrieve the modules used online.
            // 3. Retrieve the detailed information of the current module from global (remoteEntry address, expose resource address)
            // 4. After retrieving remoteEntry, call the init of the module, and then retrieve the exported content of the module through get
            // id: pkgName(@federation/app1) + expose(button) = @federation/app1/button
            // id: alias(app1) + expose(button) = app1/button
            // id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort
            const { module, moduleOptions, remoteMatchInfo } = await this.getRemoteModuleAndOptions({
                id
            });
            const { pkgNameOrAlias, remote, expose, id: idRes, remoteSnapshot } = remoteMatchInfo;
            const moduleOrFactory = await module.get(idRes, expose, options, remoteSnapshot);
            const moduleWrapper = await this.hooks.lifecycle.onLoad.emit({
                id: idRes,
                pkgNameOrAlias,
                expose,
                exposeModule: loadFactory ? moduleOrFactory : undefined,
                exposeModuleFactory: loadFactory ? undefined : moduleOrFactory,
                remote,
                options: moduleOptions,
                moduleInstance: module,
                origin: host
            });
            this.setIdToRemoteMap(id, remoteMatchInfo);
            if (typeof moduleWrapper === 'function') {
                return moduleWrapper;
            }
            return moduleOrFactory;
        } catch (error) {
            const { from = 'runtime' } = options || {
                from: 'runtime'
            };
            const failOver = await this.hooks.lifecycle.errorLoadRemote.emit({
                id,
                error,
                from,
                lifecycle: 'onLoad',
                origin: host
            });
            if (!failOver) {
                throw error;
            }
            return failOver;
        }
    }
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async preloadRemote(preloadOptions) {
        const { host } = this;
        await this.hooks.lifecycle.beforePreloadRemote.emit({
            preloadOps: preloadOptions,
            options: host.options,
            origin: host
        });
        const preloadOps = formatPreloadArgs(host.options.remotes, preloadOptions);
        await Promise.all(preloadOps.map(async (ops)=>{
            const { remote } = ops;
            const remoteInfo = getRemoteInfo(remote);
            const { globalSnapshot, remoteSnapshot } = await host.snapshotHandler.loadRemoteSnapshotInfo({
                moduleInfo: remote
            });
            const assets = await this.hooks.lifecycle.generatePreloadAssets.emit({
                origin: host,
                preloadOptions: ops,
                remote,
                remoteInfo,
                globalSnapshot,
                remoteSnapshot
            });
            if (!assets) {
                return;
            }
            preloadAssets(remoteInfo, host, assets);
        }));
    }
    registerRemotes(remotes, options) {
        const { host } = this;
        remotes.forEach((remote)=>{
            this.registerRemote(remote, host.options.remotes, {
                force: options == null ? void 0 : options.force
            });
        });
    }
    async getRemoteModuleAndOptions(options) {
        const { host } = this;
        const { id } = options;
        let loadRemoteArgs;
        try {
            loadRemoteArgs = await this.hooks.lifecycle.beforeRequest.emit({
                id,
                options: host.options,
                origin: host
            });
        } catch (error) {
            loadRemoteArgs = await this.hooks.lifecycle.errorLoadRemote.emit({
                id,
                options: host.options,
                origin: host,
                from: 'runtime',
                error,
                lifecycle: 'beforeRequest'
            });
            if (!loadRemoteArgs) {
                throw error;
            }
        }
        const { id: idRes } = loadRemoteArgs;
        const remoteSplitInfo = matchRemoteWithNameAndExpose(host.options.remotes, idRes);
        assert(remoteSplitInfo, getShortErrorMsg(RUNTIME_004, runtimeDescMap, {
            hostName: host.options.name,
            requestId: idRes
        }));
        const { remote: rawRemote } = remoteSplitInfo;
        const remoteInfo = getRemoteInfo(rawRemote);
        const matchInfo = await host.sharedHandler.hooks.lifecycle.afterResolve.emit(_extends$2({
            id: idRes
        }, remoteSplitInfo, {
            options: host.options,
            origin: host,
            remoteInfo
        }));
        const { remote, expose } = matchInfo;
        assert(remote && expose, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${idRes}.`);
        let module = host.moduleCache.get(remote.name);
        const moduleOptions = {
            host: host,
            remoteInfo
        };
        if (!module) {
            module = new Module(moduleOptions);
            host.moduleCache.set(remote.name, module);
        }
        return {
            module,
            moduleOptions,
            remoteMatchInfo: matchInfo
        };
    }
    registerRemote(remote, targetRemotes, options) {
        const { host } = this;
        const normalizeRemote = ()=>{
            if (remote.alias) {
                // Validate if alias equals the prefix of remote.name and remote.alias, if so, throw an error
                // As multi-level path references cannot guarantee unique names, alias being a prefix of remote.name is not supported
                const findEqual = targetRemotes.find((item)=>{
                    var _item_alias;
                    return remote.alias && (item.name.startsWith(remote.alias) || ((_item_alias = item.alias) == null ? void 0 : _item_alias.startsWith(remote.alias)));
                });
                assert(!findEqual, `The alias ${remote.alias} of remote ${remote.name} is not allowed to be the prefix of ${findEqual && findEqual.name} name or alias`);
            }
            // Set the remote entry to a complete path
            if ('entry' in remote) {
                if (isBrowserEnv() && !remote.entry.startsWith('http')) {
                    remote.entry = new URL(remote.entry, window.location.origin).href;
                }
            }
            if (!remote.shareScope) {
                remote.shareScope = DEFAULT_SCOPE;
            }
            if (!remote.type) {
                remote.type = DEFAULT_REMOTE_TYPE;
            }
        };
        this.hooks.lifecycle.beforeRegisterRemote.emit({
            remote,
            origin: host
        });
        const registeredRemote = targetRemotes.find((item)=>item.name === remote.name);
        if (!registeredRemote) {
            normalizeRemote();
            targetRemotes.push(remote);
            this.hooks.lifecycle.registerRemote.emit({
                remote,
                origin: host
            });
        } else {
            const messages = [
                `The remote "${remote.name}" is already registered.`,
                'Please note that overriding it may cause unexpected errors.'
            ];
            if (options == null ? void 0 : options.force) {
                // remove registered remote
                this.removeRemote(registeredRemote);
                normalizeRemote();
                targetRemotes.push(remote);
                this.hooks.lifecycle.registerRemote.emit({
                    remote,
                    origin: host
                });
                warn$1(messages.join(' '));
            }
        }
    }
    removeRemote(remote) {
        try {
            const { host } = this;
            const { name } = remote;
            const remoteIndex = host.options.remotes.findIndex((item)=>item.name === name);
            if (remoteIndex !== -1) {
                host.options.remotes.splice(remoteIndex, 1);
            }
            const loadedModule = host.moduleCache.get(remote.name);
            if (loadedModule) {
                const remoteInfo = loadedModule.remoteInfo;
                const key = remoteInfo.entryGlobalName;
                if (CurrentGlobal[key]) {
                    var _Object_getOwnPropertyDescriptor;
                    if ((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(CurrentGlobal, key)) == null ? void 0 : _Object_getOwnPropertyDescriptor.configurable) {
                        delete CurrentGlobal[key];
                    } else {
                        // @ts-ignore
                        CurrentGlobal[key] = undefined;
                    }
                }
                const remoteEntryUniqueKey = getRemoteEntryUniqueKey(loadedModule.remoteInfo);
                if (globalLoading[remoteEntryUniqueKey]) {
                    delete globalLoading[remoteEntryUniqueKey];
                }
                host.snapshotHandler.manifestCache.delete(remoteInfo.entry);
                // delete unloaded shared and instance
                let remoteInsId = remoteInfo.buildVersion ? composeKeyWithSeparator(remoteInfo.name, remoteInfo.buildVersion) : remoteInfo.name;
                const remoteInsIndex = CurrentGlobal.__FEDERATION__.__INSTANCES__.findIndex((ins)=>{
                    if (remoteInfo.buildVersion) {
                        return ins.options.id === remoteInsId;
                    } else {
                        return ins.name === remoteInsId;
                    }
                });
                if (remoteInsIndex !== -1) {
                    const remoteIns = CurrentGlobal.__FEDERATION__.__INSTANCES__[remoteInsIndex];
                    remoteInsId = remoteIns.options.id || remoteInsId;
                    const globalShareScopeMap = getGlobalShareScope();
                    let isAllSharedNotUsed = true;
                    const needDeleteKeys = [];
                    Object.keys(globalShareScopeMap).forEach((instId)=>{
                        const shareScopeMap = globalShareScopeMap[instId];
                        shareScopeMap && Object.keys(shareScopeMap).forEach((shareScope)=>{
                            const shareScopeVal = shareScopeMap[shareScope];
                            shareScopeVal && Object.keys(shareScopeVal).forEach((shareName)=>{
                                const sharedPkgs = shareScopeVal[shareName];
                                sharedPkgs && Object.keys(sharedPkgs).forEach((shareVersion)=>{
                                    const shared = sharedPkgs[shareVersion];
                                    if (shared && typeof shared === 'object' && shared.from === remoteInfo.name) {
                                        if (shared.loaded || shared.loading) {
                                            shared.useIn = shared.useIn.filter((usedHostName)=>usedHostName !== remoteInfo.name);
                                            if (shared.useIn.length) {
                                                isAllSharedNotUsed = false;
                                            } else {
                                                needDeleteKeys.push([
                                                    instId,
                                                    shareScope,
                                                    shareName,
                                                    shareVersion
                                                ]);
                                            }
                                        } else {
                                            needDeleteKeys.push([
                                                instId,
                                                shareScope,
                                                shareName,
                                                shareVersion
                                            ]);
                                        }
                                    }
                                });
                            });
                        });
                    });
                    if (isAllSharedNotUsed) {
                        remoteIns.shareScopeMap = {};
                        delete globalShareScopeMap[remoteInsId];
                    }
                    needDeleteKeys.forEach(([insId, shareScope, shareName, shareVersion])=>{
                        var _globalShareScopeMap_insId_shareScope_shareName, _globalShareScopeMap_insId_shareScope, _globalShareScopeMap_insId;
                        (_globalShareScopeMap_insId = globalShareScopeMap[insId]) == null ? true : (_globalShareScopeMap_insId_shareScope = _globalShareScopeMap_insId[shareScope]) == null ? true : (_globalShareScopeMap_insId_shareScope_shareName = _globalShareScopeMap_insId_shareScope[shareName]) == null ? true : delete _globalShareScopeMap_insId_shareScope_shareName[shareVersion];
                    });
                    CurrentGlobal.__FEDERATION__.__INSTANCES__.splice(remoteInsIndex, 1);
                }
                const { hostGlobalSnapshot } = getGlobalRemoteInfo(remote, host);
                if (hostGlobalSnapshot) {
                    const remoteKey = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && getInfoWithoutType(hostGlobalSnapshot.remotesInfo, remote.name).key;
                    if (remoteKey) {
                        delete hostGlobalSnapshot.remotesInfo[remoteKey];
                        if (//eslint-disable-next-line no-extra-boolean-cast
                        Boolean(Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey])) {
                            delete Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey];
                        }
                    }
                }
                host.moduleCache.delete(remote.name);
            }
        } catch (err) {
            logger.log('removeRemote fail: ', err);
        }
    }
    constructor(host){
        this.hooks = new PluginSystem({
            beforeRegisterRemote: new SyncWaterfallHook('beforeRegisterRemote'),
            registerRemote: new SyncWaterfallHook('registerRemote'),
            beforeRequest: new AsyncWaterfallHook('beforeRequest'),
            onLoad: new AsyncHook('onLoad'),
            handlePreloadModule: new SyncHook('handlePreloadModule'),
            errorLoadRemote: new AsyncHook('errorLoadRemote'),
            beforePreloadRemote: new AsyncHook('beforePreloadRemote'),
            generatePreloadAssets: new AsyncHook('generatePreloadAssets'),
            // not used yet
            afterPreloadRemote: new AsyncHook(),
            loadEntry: new AsyncHook()
        });
        this.host = host;
        this.idToRemoteMap = {};
    }
}

const USE_SNAPSHOT = typeof FEDERATION_OPTIMIZE_NO_SNAPSHOT_PLUGIN === 'boolean' ? !FEDERATION_OPTIMIZE_NO_SNAPSHOT_PLUGIN : true; // Default to true (use snapshot) when not explicitly defined
class FederationHost {
    initOptions(userOptions) {
        this.registerPlugins(userOptions.plugins);
        const options = this.formatOptions(this.options, userOptions);
        this.options = options;
        return options;
    }
    async loadShare(pkgName, extraOptions) {
        return this.sharedHandler.loadShare(pkgName, extraOptions);
    }
    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
    // 1. If the loaded shared already exists globally, then it will be reused
    // 2. If lib exists in local shared, it will be used directly
    // 3. If the local get returns something other than Promise, then it will be used directly
    loadShareSync(pkgName, extraOptions) {
        return this.sharedHandler.loadShareSync(pkgName, extraOptions);
    }
    initializeSharing(shareScopeName = DEFAULT_SCOPE, extraOptions) {
        return this.sharedHandler.initializeSharing(shareScopeName, extraOptions);
    }
    initRawContainer(name, url, container) {
        const remoteInfo = getRemoteInfo({
            name,
            entry: url
        });
        const module = new Module({
            host: this,
            remoteInfo
        });
        module.remoteEntryExports = container;
        this.moduleCache.set(name, module);
        return module;
    }
    // eslint-disable-next-line max-lines-per-function
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async loadRemote(id, options) {
        return this.remoteHandler.loadRemote(id, options);
    }
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async preloadRemote(preloadOptions) {
        return this.remoteHandler.preloadRemote(preloadOptions);
    }
    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {
        this.sharedHandler.initShareScopeMap(scopeName, shareScope, extraOptions);
    }
    formatOptions(globalOptions, userOptions) {
        const { shared } = formatShareConfigs(globalOptions, userOptions);
        const { userOptions: userOptionsRes, options: globalOptionsRes } = this.hooks.lifecycle.beforeInit.emit({
            origin: this,
            userOptions,
            options: globalOptions,
            shareInfo: shared
        });
        const remotes = this.remoteHandler.formatAndRegisterRemote(globalOptionsRes, userOptionsRes);
        const { shared: handledShared } = this.sharedHandler.registerShared(globalOptionsRes, userOptionsRes);
        const plugins = [
            ...globalOptionsRes.plugins
        ];
        if (userOptionsRes.plugins) {
            userOptionsRes.plugins.forEach((plugin)=>{
                if (!plugins.includes(plugin)) {
                    plugins.push(plugin);
                }
            });
        }
        const optionsRes = _extends$2({}, globalOptions, userOptions, {
            plugins,
            remotes,
            shared: handledShared
        });
        this.hooks.lifecycle.init.emit({
            origin: this,
            options: optionsRes
        });
        return optionsRes;
    }
    registerPlugins(plugins) {
        const pluginRes = registerPlugins(plugins, [
            this.hooks,
            this.remoteHandler.hooks,
            this.sharedHandler.hooks,
            this.snapshotHandler.hooks,
            this.loaderHook,
            this.bridgeHook
        ]);
        // Merge plugin
        this.options.plugins = this.options.plugins.reduce((res, plugin)=>{
            if (!plugin) return res;
            if (res && !res.find((item)=>item.name === plugin.name)) {
                res.push(plugin);
            }
            return res;
        }, pluginRes || []);
    }
    registerRemotes(remotes, options) {
        return this.remoteHandler.registerRemotes(remotes, options);
    }
    constructor(userOptions){
        this.hooks = new PluginSystem({
            beforeInit: new SyncWaterfallHook('beforeInit'),
            init: new SyncHook(),
            // maybe will change, temporarily for internal use only
            beforeInitContainer: new AsyncWaterfallHook('beforeInitContainer'),
            // maybe will change, temporarily for internal use only
            initContainer: new AsyncWaterfallHook('initContainer')
        });
        this.version = "0.15.0";
        this.moduleCache = new Map();
        this.loaderHook = new PluginSystem({
            // FIXME: may not be suitable , not open to the public yet
            getModuleInfo: new SyncHook(),
            createScript: new SyncHook(),
            createLink: new SyncHook(),
            fetch: new AsyncHook(),
            loadEntryError: new AsyncHook(),
            getModuleFactory: new AsyncHook()
        });
        this.bridgeHook = new PluginSystem({
            beforeBridgeRender: new SyncHook(),
            afterBridgeRender: new SyncHook(),
            beforeBridgeDestroy: new SyncHook(),
            afterBridgeDestroy: new SyncHook()
        });
        const plugins = USE_SNAPSHOT ? [
            snapshotPlugin(),
            generatePreloadAssetsPlugin()
        ] : [];
        // TODO: Validate the details of the options
        // Initialize options with default values
        const defaultOptions = {
            id: getBuilderId$1(),
            name: userOptions.name,
            plugins,
            remotes: [],
            shared: {},
            inBrowser: isBrowserEnv()
        };
        this.name = userOptions.name;
        this.options = defaultOptions;
        this.snapshotHandler = new SnapshotHandler(this);
        this.sharedHandler = new SharedHandler(this);
        this.remoteHandler = new RemoteHandler(this);
        this.shareScopeMap = this.sharedHandler.shareScopeMap;
        this.registerPlugins([
            ...defaultOptions.plugins,
            ...userOptions.plugins || []
        ]);
        this.options = this.formatOptions(defaultOptions, userOptions);
    }
}

// injected by bundler, so it can not use runtime-core stuff
function getBuilderId() {
    //@ts-ignore
    return typeof FEDERATION_BUILD_IDENTIFIER !== 'undefined' ? FEDERATION_BUILD_IDENTIFIER : '';
}
function getGlobalFederationInstance(name, version) {
    const buildId = getBuilderId();
    return CurrentGlobal.__FEDERATION__.__INSTANCES__.find((GMInstance)=>{
        if (buildId && GMInstance.options.id === getBuilderId()) {
            return true;
        }
        if (GMInstance.options.name === name && !GMInstance.options.version && !version) {
            return true;
        }
        if (GMInstance.options.name === name && version && GMInstance.options.version === version) {
            return true;
        }
        return false;
    });
}

let FederationInstance = null;
function init(options) {
    // Retrieve the same instance with the same name
    const instance = getGlobalFederationInstance(options.name, options.version);
    if (!instance) {
        // Retrieve debug constructor
        const FederationConstructor = getGlobalFederationConstructor() || FederationHost;
        FederationInstance = new FederationConstructor(options);
        setGlobalFederationInstance(FederationInstance);
        return FederationInstance;
    } else {
        // Merge options
        instance.initOptions(options);
        if (!FederationInstance) {
            FederationInstance = instance;
        }
        return instance;
    }
}
function loadRemote(...args) {
    assert(FederationInstance, 'Please call init first');
    const loadRemote1 = FederationInstance.loadRemote;
    // eslint-disable-next-line prefer-spread
    return loadRemote1.apply(FederationInstance, args);
}
function registerRemotes(...args) {
    assert(FederationInstance, 'Please call init first');
    // eslint-disable-next-line prefer-spread
    return FederationInstance.registerRemotes.apply(FederationInstance, args);
}
// Inject for debug
setGlobalFederationConstructor(FederationHost);

const React$1Q = await importShared('react');

const {LinearProgress: LinearProgress$3} = await importShared('@mui/material');
const IconsMaterial = await importShared('@mui/icons-material');

const AdapterReact = await importShared('@iobroker/adapter-react-v5');

const {I18n: I18n$r} = await importShared('@iobroker/adapter-react-v5');
init({
    name: 'iobroker_admin',
    shared: {
        '@iobroker/adapter-react-v5': {
            lib: () => AdapterReact,
            version: '*',
        },
        '@mui/icons-material': {
            lib: () => IconsMaterial,
            version: '*',
        },
        '@iobroker/json-config': {
            lib: () => JsonConfig,
            version: '*',
        },
    },
    remotes: [],
});
class ConfigCustom extends ConfigGeneric {
    static runningLoads = {};
    constructor(props) {
        super(props);
        // schema.url - location of Widget
        // schema.name - Component name
        // schema.i18n - i18n
        Object.assign(this.state, {
            Component: null,
            error: '',
        });
    }
    // load component dynamically
    async componentDidMount() {
        if (!this.props.schema.url) {
            console.error('URL is empty. Cannot load custom component!');
            this.setState({ error: 'URL is empty. Cannot load custom component!' });
            return;
        }
        let url;
        if (this.props.schema.url.startsWith('http:') || this.props.schema.url.startsWith('https:')) {
            url = this.props.schema.url;
        }
        else if (this.props.schema.url.startsWith('./')) {
            url = `${window.location.protocol}//${window.location.host}${this.props.schema.url.replace(/^\./, '')}`;
        }
        else {
            url = `${window.location.protocol}//${window.location.host}/adapter/${this.props.oContext.adapterName}/${this.props.schema.url}`;
        }
        const [uniqueName, fileToLoad, ...componentNameParts] = this.props.schema.name.split('/');
        const componentName = componentNameParts.join('/');
        if (!url) {
            console.error('Cannot find URL for custom component! Please define "url" as "custom/customComponents.js" in the schema');
            return;
        }
        if (!uniqueName || !fileToLoad || !componentName) {
            console.error('Invalid format of "name"! Please define "name" as "ConfigCustomBackItUpSet/Components/AdapterExist" in the schema');
            return;
        }
        let setPromise = ConfigCustom.runningLoads[`${url}!${fileToLoad}`];
        if (!(setPromise instanceof Promise)) {
            let i18nPromise;
            if (this.props.schema.i18n === true) {
                // load i18n from files
                const pos = url.lastIndexOf('/');
                let i18nURL;
                if (pos !== -1) {
                    i18nURL = url.substring(0, pos);
                }
                else {
                    i18nURL = url;
                }
                const lang = I18n$r.getLanguage();
                const file = `${i18nURL}/i18n/${lang}.json`;
                i18nPromise = fetch(file)
                    .then(data => data.json())
                    .then(json => I18n$r.extendTranslations(json, lang))
                    .catch(error => {
                    if (lang !== 'en') {
                        // try to load English
                        fetch(`${i18nURL}/i18n/en.json`)
                            .then(data => data.json())
                            .then(json => I18n$r.extendTranslations(json, lang))
                            .catch(err => console.log(`Cannot load i18n "${file}": ${err}`));
                        return;
                    }
                    console.log(`Cannot load i18n "${file}": ${error}`);
                });
            }
            else if (this.props.schema.i18n && typeof this.props.schema.i18n === 'object') {
                try {
                    I18n$r.extendTranslations(this.props.schema.i18n);
                }
                catch (error) {
                    console.error(`Cannot import i18n: ${error}`);
                }
            }
            try {
                console.log(url, uniqueName, fileToLoad, componentName);
                registerRemotes([
                    {
                        name: uniqueName,
                        entry: url,
                        type: this.props.schema.bundlerType || undefined,
                    },
                ]);
                setPromise = loadRemote(`${uniqueName}/${fileToLoad}`);
                if (i18nPromise instanceof Promise) {
                    setPromise = Promise.all([setPromise, i18nPromise]).then(result => result[0]);
                }
                // remember promise
                ConfigCustom.runningLoads[`${url}!${fileToLoad}`] = setPromise;
            }
            catch (error) {
                console.error(error);
                this.setState({ error: `Cannot import from ${this.props.schema.url}: ${error}` });
            }
        }
        try {
            const component = (await setPromise).default;
            if (!component?.[componentName]) {
                const keys = Object.keys(component || {});
                console.error('URL is empty. Cannot load custom component!');
                this.setState({
                    error: `Component ${this.props.schema.name} not found in ${this.props.schema.url}. Found: ${keys.join(', ')}`,
                });
            }
            else {
                this.setState({ Component: component[componentName] });
            }
        }
        catch (error) {
            console.error(error);
            this.setState({ error: `Cannot import from ${this.props.schema.url}: ${error}` });
        }
    }
    render() {
        const CustomComponent = this.state.Component;
        const schema = this.props.schema || {};
        const item = CustomComponent ? (React$1Q.createElement(CustomComponent, { ...this.props, 
            // @ts-expect-error BF (2024-12-18) Remove after the 7.4 will be mainstream. All following lines
            socket: this.props.oContext.socket, theme: this.props.oContext.theme, themeType: this.props.oContext.themeType, instance: this.props.oContext.instance, adapterName: this.props.oContext.adapterName, systemConfig: this.props.oContext.systemConfig, forceUpdate: this.props.oContext.forceUpdate })) : this.state.error ? (React$1Q.createElement("div", null, this.state.error)) : (React$1Q.createElement(LinearProgress$3, null));
        if (schema.newLine) {
            return (React$1Q.createElement(React$1Q.Fragment, null,
                React$1Q.createElement("div", { style: { flexBasis: '100%', height: 0 } }),
                item));
        }
        return item;
    }
}

const _excluded$F = ["localeText"];
const React$1P = await importShared('react');

await importShared('prop-types');
const MuiPickersAdapterContext = /* @__PURE__ */ React$1P.createContext(null);
const LocalizationProvider = function LocalizationProvider2(inProps) {
  const {
    localeText: inLocaleText
  } = inProps, otherInProps = _objectWithoutPropertiesLoose(inProps, _excluded$F);
  const {
    utils: parentUtils,
    localeText: parentLocaleText
  } = React$1P.useContext(MuiPickersAdapterContext) ?? {
    utils: void 0,
    localeText: void 0
  };
  const props = useThemeProps({
    // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
    // We will then merge this theme value with our value manually
    props: otherInProps,
    name: "MuiLocalizationProvider"
  });
  const {
    children,
    dateAdapter: DateAdapter,
    dateFormats,
    dateLibInstance,
    adapterLocale,
    localeText: themeLocaleText
  } = props;
  const localeText = React$1P.useMemo(() => _extends$3({}, themeLocaleText, parentLocaleText, inLocaleText), [themeLocaleText, parentLocaleText, inLocaleText]);
  const utils = React$1P.useMemo(() => {
    if (!DateAdapter) {
      if (parentUtils) {
        return parentUtils;
      }
      return null;
    }
    const adapter = new DateAdapter({
      locale: adapterLocale,
      formats: dateFormats,
      instance: dateLibInstance
    });
    if (!adapter.isMUIAdapter) {
      throw new Error(["MUI X: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
    }
    return adapter;
  }, [DateAdapter, adapterLocale, dateFormats, dateLibInstance, parentUtils]);
  const defaultDates = React$1P.useMemo(() => {
    if (!utils) {
      return null;
    }
    return {
      minDate: utils.date("1900-01-01T00:00:00.000"),
      maxDate: utils.date("2099-12-31T00:00:00.000")
    };
  }, [utils]);
  const contextValue = React$1P.useMemo(() => {
    return {
      utils,
      defaultDates,
      localeText
    };
  }, [defaultDates, utils, localeText]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MuiPickersAdapterContext.Provider, {
    value: contextValue,
    children
  });
};

const getPickersLocalization = pickersTranslations => {
  return {
    components: {
      MuiLocalizationProvider: {
        defaultProps: {
          localeText: _extends$3({}, pickersTranslations)
        }
      }
    }
  };
};
const buildGetOpenDialogAriaText = params => {
  const {
    utils,
    formatKey,
    contextTranslation,
    propsTranslation
  } = params;
  return value => {
    const formattedValue = value !== null && utils.isValid(value) ? utils.format(value, formatKey) : null;
    const translation = propsTranslation ?? contextTranslation;
    return translation(value, utils, formattedValue);
  };
};

// This object is not Partial<PickersLocaleText> because it is the default values

const enUSPickers = {
  // Calendar navigation
  previousMonth: 'Previous month',
  nextMonth: 'Next month',
  // View navigation
  openPreviousView: 'Open previous view',
  openNextView: 'Open next view',
  calendarViewSwitchingButtonAriaLabel: view => view === 'year' ? 'year view is open, switch to calendar view' : 'calendar view is open, switch to year view',
  // DateRange labels
  start: 'Start',
  end: 'End',
  startDate: 'Start date',
  startTime: 'Start time',
  endDate: 'End date',
  endTime: 'End time',
  // Action bar
  cancelButtonLabel: 'Cancel',
  clearButtonLabel: 'Clear',
  okButtonLabel: 'OK',
  todayButtonLabel: 'Today',
  // Toolbar titles
  datePickerToolbarTitle: 'Select date',
  dateTimePickerToolbarTitle: 'Select date & time',
  timePickerToolbarTitle: 'Select time',
  dateRangePickerToolbarTitle: 'Select date range',
  // Clock labels
  clockLabelText: (view, time, utils, formattedTime) => `Select ${view}. ${!formattedTime && (time === null || !utils.isValid(time)) ? 'No time selected' : `Selected time is ${formattedTime ?? utils.format(time, 'fullTime')}`}`,
  hoursClockNumberText: hours => `${hours} hours`,
  minutesClockNumberText: minutes => `${minutes} minutes`,
  secondsClockNumberText: seconds => `${seconds} seconds`,
  // Digital clock labels
  selectViewText: view => `Select ${view}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: 'Week number',
  calendarWeekNumberHeaderText: '#',
  calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
  calendarWeekNumberText: weekNumber => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils, formattedDate) => formattedDate || value !== null && utils.isValid(value) ? `Choose date, selected date is ${formattedDate ?? utils.format(value, 'fullDate')}` : 'Choose date',
  openTimePickerDialogue: (value, utils, formattedTime) => formattedTime || value !== null && utils.isValid(value) ? `Choose time, selected time is ${formattedTime ?? utils.format(value, 'fullTime')}` : 'Choose time',
  fieldClearLabel: 'Clear',
  // Table labels
  timeTableLabel: 'pick time',
  dateTableLabel: 'pick date',
  // Field section placeholders
  fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
  fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
  fieldDayPlaceholder: () => 'DD',
  fieldWeekDayPlaceholder: params => params.contentType === 'letter' ? 'EEEE' : 'EE',
  fieldHoursPlaceholder: () => 'hh',
  fieldMinutesPlaceholder: () => 'mm',
  fieldSecondsPlaceholder: () => 'ss',
  fieldMeridiemPlaceholder: () => 'aa',
  // View names
  year: 'Year',
  month: 'Month',
  day: 'Day',
  weekDay: 'Week day',
  hours: 'Hours',
  minutes: 'Minutes',
  seconds: 'Seconds',
  meridiem: 'Meridiem',
  // Common
  empty: 'Empty'
};
const DEFAULT_LOCALE = enUSPickers;
getPickersLocalization(enUSPickers);

const React$1O = await importShared('react');
const useLocalizationContext = () => {
  const localization = React$1O.useContext(MuiPickersAdapterContext);
  if (localization === null) {
    throw new Error(['MUI X: Can not find the date and time pickers localization context.', 'It looks like you forgot to wrap your component in LocalizationProvider.', 'This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package'].join('\n'));
  }
  if (localization.utils === null) {
    throw new Error(['MUI X: Can not find the date and time pickers adapter from its localization context.', 'It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider.'].join('\n'));
  }
  const localeText = React$1O.useMemo(() => _extends$3({}, DEFAULT_LOCALE, localization.localeText), [localization.localeText]);
  return React$1O.useMemo(() => _extends$3({}, localization, {
    localeText
  }), [localization, localeText]);
};
const useUtils = () => useLocalizationContext().utils;
const useDefaultDates = () => useLocalizationContext().defaultDates;
const useNow = timezone => {
  const utils = useUtils();
  const now = React$1O.useRef(undefined);
  if (now.current === undefined) {
    now.current = utils.date(undefined, timezone);
  }
  return now.current;
};

const usePickersTranslations = () => useLocalizationContext().localeText;

const React$1N = await importShared('react');

await importShared('prop-types');
const RtlContext = /* @__PURE__ */ React$1N.createContext();
const useRtl = () => {
  const value = React$1N.useContext(RtlContext);
  return value ?? false;
};

/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}

function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}

await importShared('prop-types');
const React$1M = await importShared('react');
var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return addClass(node, c);
  });
};
var removeClass = function removeClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return removeClass$1(node, c);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node) forceReflow(node);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props; _this$props.classNames; var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return /* @__PURE__ */ React$1M.createElement(Transition, _extends$3({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React$1M.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};

const React$1L = await importShared('react');
const ArrowDropDownIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), 'ArrowDropDown');

/**
 * @ignore - internal component.
 */
const ArrowLeftIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
}), 'ArrowLeft');

/**
 * @ignore - internal component.
 */
const ArrowRightIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), 'ArrowRight');

/**
 * @ignore - internal component.
 */
const CalendarIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
  d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
}), 'Calendar');

/**
 * @ignore - internal component.
 */
const ClockIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsxs(React$1L.Fragment, {
  children: [/*#__PURE__*/jsxRuntimeExports.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /*#__PURE__*/jsxRuntimeExports.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), 'Clock');

/**
 * @ignore - internal component.
 */
createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
  d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
}), 'DateRange');

/**
 * @ignore - internal component.
 */
createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsxs(React$1L.Fragment, {
  children: [/*#__PURE__*/jsxRuntimeExports.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /*#__PURE__*/jsxRuntimeExports.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), 'Time');

/**
 * @ignore - internal component.
 */
const ClearIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), 'Clear');

function getPickersArrowSwitcherUtilityClass(slot) {
  return generateUtilityClass('MuiPickersArrowSwitcher', slot);
}
generateUtilityClasses('MuiPickersArrowSwitcher', ['root', 'spacer', 'button', 'previousIconButton', 'nextIconButton', 'leftArrowIcon', 'rightArrowIcon']);

const _excluded$E = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel", "labelId"],
  _excluded2$6 = ["ownerState"],
  _excluded3$2 = ["ownerState"];
const React$1K = await importShared('react');
const PickersArrowSwitcherRoot = styled('div', {
  name: 'MuiPickersArrowSwitcher',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({
  display: 'flex'
});
const PickersArrowSwitcherSpacer = styled('div', {
  name: 'MuiPickersArrowSwitcher',
  slot: 'Spacer',
  overridesResolver: (props, styles) => styles.spacer
})(({
  theme
}) => ({
  width: theme.spacing(3)
}));
const PickersArrowSwitcherButton = styled(IconButton$e, {
  name: 'MuiPickersArrowSwitcher',
  slot: 'Button',
  overridesResolver: (props, styles) => styles.button
})({
  variants: [{
    props: {
      hidden: true
    },
    style: {
      visibility: 'hidden'
    }
  }]
});
const useUtilityClasses$v = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    spacer: ['spacer'],
    button: ['button'],
    previousIconButton: ['previousIconButton'],
    nextIconButton: ['nextIconButton'],
    leftArrowIcon: ['leftArrowIcon'],
    rightArrowIcon: ['rightArrowIcon']
  };
  return composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
};
const PickersArrowSwitcher = /*#__PURE__*/React$1K.forwardRef(function PickersArrowSwitcher(inProps, ref) {
  const isRtl = useRtl();
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPickersArrowSwitcher'
  });
  const {
      children,
      className,
      slots,
      slotProps,
      isNextDisabled,
      isNextHidden,
      onGoToNext,
      nextLabel,
      isPreviousDisabled,
      isPreviousHidden,
      onGoToPrevious,
      previousLabel,
      labelId
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$E);
  const ownerState = props;
  const classes = useUtilityClasses$v(ownerState);
  const nextProps = {
    isDisabled: isNextDisabled,
    isHidden: isNextHidden,
    goTo: onGoToNext,
    label: nextLabel
  };
  const previousProps = {
    isDisabled: isPreviousDisabled,
    isHidden: isPreviousHidden,
    goTo: onGoToPrevious,
    label: previousLabel
  };
  const PreviousIconButton = slots?.previousIconButton ?? PickersArrowSwitcherButton;
  const previousIconButtonProps = useSlotProps({
    elementType: PreviousIconButton,
    externalSlotProps: slotProps?.previousIconButton,
    additionalProps: {
      size: 'medium',
      title: previousProps.label,
      'aria-label': previousProps.label,
      disabled: previousProps.isDisabled,
      edge: 'end',
      onClick: previousProps.goTo
    },
    ownerState: _extends$3({}, ownerState, {
      hidden: previousProps.isHidden
    }),
    className: clsx(classes.button, classes.previousIconButton)
  });
  const NextIconButton = slots?.nextIconButton ?? PickersArrowSwitcherButton;
  const nextIconButtonProps = useSlotProps({
    elementType: NextIconButton,
    externalSlotProps: slotProps?.nextIconButton,
    additionalProps: {
      size: 'medium',
      title: nextProps.label,
      'aria-label': nextProps.label,
      disabled: nextProps.isDisabled,
      edge: 'start',
      onClick: nextProps.goTo
    },
    ownerState: _extends$3({}, ownerState, {
      hidden: nextProps.isHidden
    }),
    className: clsx(classes.button, classes.nextIconButton)
  });
  const LeftArrowIcon = slots?.leftArrowIcon ?? ArrowLeftIcon;
  // The spread is here to avoid this bug mui/material-ui#34056
  const _useSlotProps = useSlotProps({
      elementType: LeftArrowIcon,
      externalSlotProps: slotProps?.leftArrowIcon,
      additionalProps: {
        fontSize: 'inherit'
      },
      ownerState,
      className: classes.leftArrowIcon
    }),
    leftArrowIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$6);
  const RightArrowIcon = slots?.rightArrowIcon ?? ArrowRightIcon;
  // The spread is here to avoid this bug mui/material-ui#34056
  const _useSlotProps2 = useSlotProps({
      elementType: RightArrowIcon,
      externalSlotProps: slotProps?.rightArrowIcon,
      additionalProps: {
        fontSize: 'inherit'
      },
      ownerState,
      className: classes.rightArrowIcon
    }),
    rightArrowIconProps = _objectWithoutPropertiesLoose(_useSlotProps2, _excluded3$2);
  return /*#__PURE__*/jsxRuntimeExports.jsxs(PickersArrowSwitcherRoot, _extends$3({
    ref: ref,
    className: clsx(classes.root, className),
    ownerState: ownerState
  }, other, {
    children: [/*#__PURE__*/jsxRuntimeExports.jsx(PreviousIconButton, _extends$3({}, previousIconButtonProps, {
      children: isRtl ? /*#__PURE__*/jsxRuntimeExports.jsx(RightArrowIcon, _extends$3({}, rightArrowIconProps)) : /*#__PURE__*/jsxRuntimeExports.jsx(LeftArrowIcon, _extends$3({}, leftArrowIconProps))
    })), children ? /*#__PURE__*/jsxRuntimeExports.jsx(Typography$4, {
      variant: "subtitle1",
      component: "span",
      id: labelId,
      children: children
    }) : /*#__PURE__*/jsxRuntimeExports.jsx(PickersArrowSwitcherSpacer, {
      className: classes.spacer,
      ownerState: ownerState
    }), /*#__PURE__*/jsxRuntimeExports.jsx(NextIconButton, _extends$3({}, nextIconButtonProps, {
      children: isRtl ? /*#__PURE__*/jsxRuntimeExports.jsx(LeftArrowIcon, _extends$3({}, leftArrowIconProps)) : /*#__PURE__*/jsxRuntimeExports.jsx(RightArrowIcon, _extends$3({}, rightArrowIconProps))
    }))]
  }));
});

const areViewsEqual = (views, expectedViews) => {
  if (views.length !== expectedViews.length) {
    return false;
  }
  return expectedViews.every(expectedView => views.includes(expectedView));
};
const applyDefaultViewProps = ({
  openTo,
  defaultOpenTo,
  views,
  defaultViews
}) => {
  const viewsWithDefault = views ?? defaultViews;
  let openToWithDefault;
  if (openTo != null) {
    openToWithDefault = openTo;
  } else if (viewsWithDefault.includes(defaultOpenTo)) {
    openToWithDefault = defaultOpenTo;
  } else if (viewsWithDefault.length > 0) {
    openToWithDefault = viewsWithDefault[0];
  } else {
    throw new Error('MUI X: The `views` prop must contain at least one view.');
  }
  return {
    views: viewsWithDefault,
    openTo: openToWithDefault
  };
};

const timeViews = ['hours', 'minutes', 'seconds'];
const isTimeView = view => timeViews.includes(view);
const isInternalTimeView = view => timeViews.includes(view) || view === 'meridiem';
const getMeridiem = (date, utils) => {
  if (!date) {
    return null;
  }
  return utils.getHours(date) >= 12 ? 'pm' : 'am';
};
const convertValueToMeridiem = (value, meridiem, ampm) => {
  if (ampm) {
    const currentMeridiem = value >= 12 ? 'pm' : 'am';
    if (currentMeridiem !== meridiem) {
      return meridiem === 'am' ? value - 12 : value + 12;
    }
  }
  return value;
};
const convertToMeridiem = (time, meridiem, ampm, utils) => {
  const newHoursAmount = convertValueToMeridiem(utils.getHours(time), meridiem, ampm);
  return utils.setHours(time, newHoursAmount);
};
const getSecondsInDay = (date, utils) => {
  return utils.getHours(date) * 3600 + utils.getMinutes(date) * 60 + utils.getSeconds(date);
};
const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation, utils) => (dateLeft, dateRight) => {
  if (disableIgnoringDatePartForTimeValidation) {
    return utils.isAfter(dateLeft, dateRight);
  }
  return getSecondsInDay(dateLeft, utils) > getSecondsInDay(dateRight, utils);
};
const resolveTimeFormat = (utils, {
  format,
  views,
  ampm
}) => {
  if (format != null) {
    return format;
  }
  const formats = utils.formats;
  if (areViewsEqual(views, ['hours'])) {
    return ampm ? `${formats.hours12h} ${formats.meridiem}` : formats.hours24h;
  }
  if (areViewsEqual(views, ['minutes'])) {
    return formats.minutes;
  }
  if (areViewsEqual(views, ['seconds'])) {
    return formats.seconds;
  }
  if (areViewsEqual(views, ['minutes', 'seconds'])) {
    return `${formats.minutes}:${formats.seconds}`;
  }
  if (areViewsEqual(views, ['hours', 'minutes', 'seconds'])) {
    return ampm ? `${formats.hours12h}:${formats.minutes}:${formats.seconds} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}:${formats.seconds}`;
  }
  return ampm ? `${formats.hours12h}:${formats.minutes} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}`;
};

const React$1J = await importShared('react');
function useViews({
  onChange,
  onViewChange,
  openTo,
  view: inView,
  views,
  autoFocus,
  focusedView: inFocusedView,
  onFocusedViewChange
}) {
  const previousOpenTo = React$1J.useRef(openTo);
  const previousViews = React$1J.useRef(views);
  const defaultView = React$1J.useRef(views.includes(openTo) ? openTo : views[0]);
  const [view, setView] = useControlled({
    name: "useViews",
    state: "view",
    controlled: inView,
    default: defaultView.current
  });
  const defaultFocusedView = React$1J.useRef(autoFocus ? view : null);
  const [focusedView, setFocusedView] = useControlled({
    name: "useViews",
    state: "focusedView",
    controlled: inFocusedView,
    default: defaultFocusedView.current
  });
  React$1J.useEffect(() => {
    if (previousOpenTo.current && previousOpenTo.current !== openTo || previousViews.current && previousViews.current.some((previousView2) => !views.includes(previousView2))) {
      setView(views.includes(openTo) ? openTo : views[0]);
      previousViews.current = views;
      previousOpenTo.current = openTo;
    }
  }, [openTo, setView, view, views]);
  const viewIndex = views.indexOf(view);
  const previousView = views[viewIndex - 1] ?? null;
  const nextView = views[viewIndex + 1] ?? null;
  const handleFocusedViewChange = useEventCallback((viewToFocus, hasFocus) => {
    if (hasFocus) {
      setFocusedView(viewToFocus);
    } else {
      setFocusedView(
        (prevFocusedView) => viewToFocus === prevFocusedView ? null : prevFocusedView
        // If false the blur is due to view switching
      );
    }
    onFocusedViewChange?.(viewToFocus, hasFocus);
  });
  const handleChangeView = useEventCallback((newView) => {
    handleFocusedViewChange(newView, true);
    if (newView === view) {
      return;
    }
    setView(newView);
    if (onViewChange) {
      onViewChange(newView);
    }
  });
  const goToNextView = useEventCallback(() => {
    if (nextView) {
      handleChangeView(nextView);
    }
  });
  const setValueAndGoToNextView = useEventCallback((value, currentViewSelectionState, selectedView) => {
    const isSelectionFinishedOnCurrentView = currentViewSelectionState === "finish";
    const hasMoreViews = selectedView ? (
      // handles case like `DateTimePicker`, where a view might return a `finish` selection state
      // but when it's not the final view given all `views` -> overall selection state should be `partial`.
      views.indexOf(selectedView) < views.length - 1
    ) : Boolean(nextView);
    const globalSelectionState = isSelectionFinishedOnCurrentView && hasMoreViews ? "partial" : currentViewSelectionState;
    onChange(value, globalSelectionState, selectedView);
    if (selectedView && selectedView !== view) {
      const nextViewAfterSelected = views[views.indexOf(selectedView) + 1];
      if (nextViewAfterSelected) {
        handleChangeView(nextViewAfterSelected);
      }
    } else if (isSelectionFinishedOnCurrentView) {
      goToNextView();
    }
  });
  return {
    view,
    setView: handleChangeView,
    focusedView,
    setFocusedView: handleFocusedViewChange,
    nextView,
    previousView,
    // Always return up-to-date default view instead of the initial one (i.e. defaultView.current)
    defaultView: views.includes(openTo) ? openTo : views[0],
    goToNextView,
    setValueAndGoToNextView
  };
}

const React$1I = await importShared('react');
function useNextMonthDisabled(month, {
  disableFuture,
  maxDate,
  timezone
}) {
  const utils = useUtils();
  return React$1I.useMemo(() => {
    const now = utils.date(undefined, timezone);
    const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, maxDate) ? now : maxDate);
    return !utils.isAfter(lastEnabledMonth, month);
  }, [disableFuture, maxDate, month, utils, timezone]);
}
function usePreviousMonthDisabled(month, {
  disablePast,
  minDate,
  timezone
}) {
  const utils = useUtils();
  return React$1I.useMemo(() => {
    const now = utils.date(undefined, timezone);
    const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, minDate) ? now : minDate);
    return !utils.isBefore(firstEnabledMonth, month);
  }, [disablePast, minDate, month, utils, timezone]);
}
function useMeridiemMode(date, ampm, onChange, selectionState) {
  const utils = useUtils();
  const meridiemMode = getMeridiem(date, utils);
  const handleMeridiemChange = React$1I.useCallback(mode => {
    const timeWithMeridiem = date == null ? null : convertToMeridiem(date, mode, Boolean(ampm), utils);
    onChange(timeWithMeridiem, selectionState ?? 'partial');
  }, [ampm, date, onChange, selectionState, utils]);
  return {
    meridiemMode,
    handleMeridiemChange
  };
}

const DAY_SIZE = 36;
const DAY_MARGIN = 2;
const DIALOG_WIDTH = 320;
const MAX_CALENDAR_HEIGHT = 280;
const VIEW_HEIGHT = 336;
const DIGITAL_CLOCK_VIEW_HEIGHT = 232;
const MULTI_SECTION_CLOCK_SECTION_WIDTH = 48;

const PickerViewRoot = styled('div')({
  overflow: 'hidden',
  width: DIALOG_WIDTH,
  maxHeight: VIEW_HEIGHT,
  display: 'flex',
  flexDirection: 'column',
  margin: '0 auto'
});

function getTimeClockUtilityClass(slot) {
  return generateUtilityClass('MuiTimeClock', slot);
}
generateUtilityClasses('MuiTimeClock', ['root', 'arrowSwitcher']);

const CLOCK_WIDTH = 220;
const CLOCK_HOUR_WIDTH = 36;
const clockCenter = {
  x: CLOCK_WIDTH / 2,
  y: CLOCK_WIDTH / 2
};
const baseClockPoint = {
  x: clockCenter.x,
  y: 0
};
const cx = baseClockPoint.x - clockCenter.x;
const cy = baseClockPoint.y - clockCenter.y;
const rad2deg = rad => rad * (180 / Math.PI);
const getAngleValue = (step, offsetX, offsetY) => {
  const x = offsetX - clockCenter.x;
  const y = offsetY - clockCenter.y;
  const atan = Math.atan2(cx, cy) - Math.atan2(x, y);
  let deg = rad2deg(atan);
  deg = Math.round(deg / step) * step;
  deg %= 360;
  const value = Math.floor(deg / step) || 0;
  const delta = x ** 2 + y ** 2;
  const distance = Math.sqrt(delta);
  return {
    value,
    distance
  };
};
const getMinutes = (offsetX, offsetY, step = 1) => {
  const angleStep = step * 6;
  let {
    value
  } = getAngleValue(angleStep, offsetX, offsetY);
  value = value * step % 60;
  return value;
};
const getHours = (offsetX, offsetY, ampm) => {
  const {
    value,
    distance
  } = getAngleValue(30, offsetX, offsetY);
  let hour = value || 12;
  if (!ampm) {
    if (distance < CLOCK_WIDTH / 2 - CLOCK_HOUR_WIDTH) {
      hour += 12;
      hour %= 24;
    }
  } else {
    hour %= 12;
  }
  return hour;
};

function getClockPointerUtilityClass(slot) {
  return generateUtilityClass('MuiClockPointer', slot);
}
generateUtilityClasses('MuiClockPointer', ['root', 'thumb']);

const _excluded$D = ["className", "hasSelected", "isInner", "type", "viewValue"];
const React$1H = await importShared('react');
const useUtilityClasses$u = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    thumb: ['thumb']
  };
  return composeClasses(slots, getClockPointerUtilityClass, classes);
};
const ClockPointerRoot = styled('div', {
  name: 'MuiClockPointer',
  slot: 'Root',
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  width: 2,
  backgroundColor: (theme.vars || theme).palette.primary.main,
  position: 'absolute',
  left: 'calc(50% - 1px)',
  bottom: '50%',
  transformOrigin: 'center bottom 0px',
  variants: [{
    props: {
      shouldAnimate: true
    },
    style: {
      transition: theme.transitions.create(['transform', 'height'])
    }
  }]
}));
const ClockPointerThumb = styled('div', {
  name: 'MuiClockPointer',
  slot: 'Thumb',
  overridesResolver: (_, styles) => styles.thumb
})(({
  theme
}) => ({
  width: 4,
  height: 4,
  backgroundColor: (theme.vars || theme).palette.primary.contrastText,
  borderRadius: '50%',
  position: 'absolute',
  top: -21,
  left: `calc(50% - ${CLOCK_HOUR_WIDTH / 2}px)`,
  border: `${(CLOCK_HOUR_WIDTH - 4) / 2}px solid ${(theme.vars || theme).palette.primary.main}`,
  boxSizing: 'content-box',
  variants: [{
    props: {
      hasSelected: true
    },
    style: {
      backgroundColor: (theme.vars || theme).palette.primary.main
    }
  }]
}));

/**
 * @ignore - internal component.
 */
function ClockPointer(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiClockPointer'
  });
  const {
      className,
      isInner,
      type,
      viewValue
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$D);
  const previousType = React$1H.useRef(type);
  React$1H.useEffect(() => {
    previousType.current = type;
  }, [type]);
  const ownerState = _extends$3({}, props, {
    shouldAnimate: previousType.current !== type
  });
  const classes = useUtilityClasses$u(ownerState);
  const getAngleStyle = () => {
    const max = type === 'hours' ? 12 : 60;
    let angle = 360 / max * viewValue;
    if (type === 'hours' && viewValue > 12) {
      angle -= 360; // round up angle to max 360 degrees
    }
    return {
      height: Math.round((isInner ? 0.26 : 0.4) * CLOCK_WIDTH),
      transform: `rotateZ(${angle}deg)`
    };
  };
  return /*#__PURE__*/jsxRuntimeExports.jsx(ClockPointerRoot, _extends$3({
    style: getAngleStyle(),
    className: clsx(classes.root, className),
    ownerState: ownerState
  }, other, {
    children: /*#__PURE__*/jsxRuntimeExports.jsx(ClockPointerThumb, {
      ownerState: ownerState,
      className: classes.thumb
    })
  }));
}

function getClockUtilityClass(slot) {
  return generateUtilityClass('MuiClock', slot);
}
generateUtilityClasses('MuiClock', ['root', 'clock', 'wrapper', 'squareMask', 'pin', 'amButton', 'pmButton', 'meridiemText', 'selected']);

const mergeDateAndTime = (utils, dateParam, timeParam) => {
  let mergedDate = dateParam;
  mergedDate = utils.setHours(mergedDate, utils.getHours(timeParam));
  mergedDate = utils.setMinutes(mergedDate, utils.getMinutes(timeParam));
  mergedDate = utils.setSeconds(mergedDate, utils.getSeconds(timeParam));
  mergedDate = utils.setMilliseconds(mergedDate, utils.getMilliseconds(timeParam));
  return mergedDate;
};
const findClosestEnabledDate = ({
  date,
  disableFuture,
  disablePast,
  maxDate,
  minDate,
  isDateDisabled,
  utils,
  timezone
}) => {
  const today = mergeDateAndTime(utils, utils.date(undefined, timezone), date);
  if (disablePast && utils.isBefore(minDate, today)) {
    minDate = today;
  }
  if (disableFuture && utils.isAfter(maxDate, today)) {
    maxDate = today;
  }
  let forward = date;
  let backward = date;
  if (utils.isBefore(date, minDate)) {
    forward = minDate;
    backward = null;
  }
  if (utils.isAfter(date, maxDate)) {
    if (backward) {
      backward = maxDate;
    }
    forward = null;
  }
  while (forward || backward) {
    if (forward && utils.isAfter(forward, maxDate)) {
      forward = null;
    }
    if (backward && utils.isBefore(backward, minDate)) {
      backward = null;
    }
    if (forward) {
      if (!isDateDisabled(forward)) {
        return forward;
      }
      forward = utils.addDays(forward, 1);
    }
    if (backward) {
      if (!isDateDisabled(backward)) {
        return backward;
      }
      backward = utils.addDays(backward, -1);
    }
  }
  return null;
};
const replaceInvalidDateByNull = (utils, value) => value == null || !utils.isValid(value) ? null : value;
const applyDefaultDate = (utils, value, defaultValue) => {
  if (value == null || !utils.isValid(value)) {
    return defaultValue;
  }
  return value;
};
const areDatesEqual = (utils, a, b) => {
  if (!utils.isValid(a) && a != null && !utils.isValid(b) && b != null) {
    return true;
  }
  return utils.isEqual(a, b);
};
const getMonthsInYear = (utils, year) => {
  const firstMonth = utils.startOfYear(year);
  const months = [firstMonth];
  while (months.length < 12) {
    const prevMonth = months[months.length - 1];
    months.push(utils.addMonths(prevMonth, 1));
  }
  return months;
};
const getTodayDate = (utils, timezone, valueType) => valueType === 'date' ? utils.startOfDay(utils.date(undefined, timezone)) : utils.date(undefined, timezone);
const formatMeridiem = (utils, meridiem) => {
  const date = utils.setHours(utils.date(), meridiem === 'am' ? 2 : 14);
  return utils.format(date, 'meridiem');
};
const dateViews = ['year', 'month', 'day'];
const isDatePickerView = view => dateViews.includes(view);
const resolveDateFormat = (utils, {
  format,
  views
}, isInToolbar) => {
  if (format != null) {
    return format;
  }
  const formats = utils.formats;
  if (areViewsEqual(views, ['year'])) {
    return formats.year;
  }
  if (areViewsEqual(views, ['month'])) {
    return formats.month;
  }
  if (areViewsEqual(views, ['day'])) {
    return formats.dayOfMonth;
  }
  if (areViewsEqual(views, ['month', 'year'])) {
    return `${formats.month} ${formats.year}`;
  }
  if (areViewsEqual(views, ['day', 'month'])) {
    return `${formats.month} ${formats.dayOfMonth}`;
  }
  if (isInToolbar) {
    // Little localization hack (Google is doing the same for android native pickers):
    // For english localization it is convenient to include weekday into the date "Mon, Jun 1".
    // For other locales using strings like "June 1", without weekday.
    return /en/.test(utils.getCurrentLocaleCode()) ? formats.normalDateWithWeekday : formats.normalDate;
  }
  return formats.keyboardDate;
};
const getWeekdays = (utils, date) => {
  const start = utils.startOfWeek(date);
  return [0, 1, 2, 3, 4, 5, 6].map(diff => utils.addDays(start, diff));
};

const React$1G = await importShared('react');
const useUtilityClasses$t = ownerState => {
  const {
    classes,
    meridiemMode
  } = ownerState;
  const slots = {
    root: ['root'],
    clock: ['clock'],
    wrapper: ['wrapper'],
    squareMask: ['squareMask'],
    pin: ['pin'],
    amButton: ['amButton', meridiemMode === 'am' && 'selected'],
    pmButton: ['pmButton', meridiemMode === 'pm' && 'selected'],
    meridiemText: ['meridiemText']
  };
  return composeClasses(slots, getClockUtilityClass, classes);
};
const ClockRoot = styled('div', {
  name: 'MuiClock',
  slot: 'Root',
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  margin: theme.spacing(2)
}));
const ClockClock = styled('div', {
  name: 'MuiClock',
  slot: 'Clock',
  overridesResolver: (_, styles) => styles.clock
})({
  backgroundColor: 'rgba(0,0,0,.07)',
  borderRadius: '50%',
  height: 220,
  width: 220,
  flexShrink: 0,
  position: 'relative',
  pointerEvents: 'none'
});
const ClockWrapper = styled('div', {
  name: 'MuiClock',
  slot: 'Wrapper',
  overridesResolver: (_, styles) => styles.wrapper
})({
  '&:focus': {
    outline: 'none'
  }
});
const ClockSquareMask = styled('div', {
  name: 'MuiClock',
  slot: 'SquareMask',
  overridesResolver: (_, styles) => styles.squareMask
})({
  width: '100%',
  height: '100%',
  position: 'absolute',
  pointerEvents: 'auto',
  outline: 0,
  // Disable scroll capabilities.
  touchAction: 'none',
  userSelect: 'none',
  variants: [{
    props: {
      disabled: false
    },
    style: {
      '@media (pointer: fine)': {
        cursor: 'pointer',
        borderRadius: '50%'
      },
      '&:active': {
        cursor: 'move'
      }
    }
  }]
});
const ClockPin = styled('div', {
  name: 'MuiClock',
  slot: 'Pin',
  overridesResolver: (_, styles) => styles.pin
})(({
  theme
}) => ({
  width: 6,
  height: 6,
  borderRadius: '50%',
  backgroundColor: (theme.vars || theme).palette.primary.main,
  position: 'absolute',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)'
}));
const meridiemButtonCommonStyles = (theme, meridiemMode) => ({
  zIndex: 1,
  bottom: 8,
  paddingLeft: 4,
  paddingRight: 4,
  width: CLOCK_HOUR_WIDTH,
  variants: [{
    props: {
      meridiemMode
    },
    style: {
      backgroundColor: (theme.vars || theme).palette.primary.main,
      color: (theme.vars || theme).palette.primary.contrastText,
      '&:hover': {
        backgroundColor: (theme.vars || theme).palette.primary.light
      }
    }
  }]
});
const ClockAmButton = styled(IconButton$e, {
  name: 'MuiClock',
  slot: 'AmButton',
  overridesResolver: (_, styles) => styles.amButton
})(({
  theme
}) => _extends$3({}, meridiemButtonCommonStyles(theme, 'am'), {
  // keeping it here to make TS happy
  position: 'absolute',
  left: 8
}));
const ClockPmButton = styled(IconButton$e, {
  name: 'MuiClock',
  slot: 'PmButton',
  overridesResolver: (_, styles) => styles.pmButton
})(({
  theme
}) => _extends$3({}, meridiemButtonCommonStyles(theme, 'pm'), {
  // keeping it here to make TS happy
  position: 'absolute',
  right: 8
}));
const ClockMeridiemText = styled(Typography$4, {
  name: 'MuiClock',
  slot: 'meridiemText',
  overridesResolver: (_, styles) => styles.meridiemText
})({
  overflow: 'hidden',
  whiteSpace: 'nowrap',
  textOverflow: 'ellipsis'
});

/**
 * @ignore - internal component.
 */
function Clock(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiClock'
  });
  const {
    ampm,
    ampmInClock,
    autoFocus,
    children,
    value,
    handleMeridiemChange,
    isTimeDisabled,
    meridiemMode,
    minutesStep = 1,
    onChange,
    selectedId,
    type,
    viewValue,
    viewRange: [minViewValue, maxViewValue],
    disabled = false,
    readOnly,
    className
  } = props;
  const ownerState = props;
  const utils = useUtils();
  const translations = usePickersTranslations();
  const isMoving = React$1G.useRef(false);
  const classes = useUtilityClasses$t(ownerState);
  const isSelectedTimeDisabled = isTimeDisabled(viewValue, type);
  const isPointerInner = !ampm && type === 'hours' && (viewValue < 1 || viewValue > 12);
  const handleValueChange = (newValue, isFinish) => {
    if (disabled || readOnly) {
      return;
    }
    if (isTimeDisabled(newValue, type)) {
      return;
    }
    onChange(newValue, isFinish);
  };
  const setTime = (event, isFinish) => {
    let {
      offsetX,
      offsetY
    } = event;
    if (offsetX === undefined) {
      const rect = event.target.getBoundingClientRect();
      offsetX = event.changedTouches[0].clientX - rect.left;
      offsetY = event.changedTouches[0].clientY - rect.top;
    }
    const newSelectedValue = type === 'seconds' || type === 'minutes' ? getMinutes(offsetX, offsetY, minutesStep) : getHours(offsetX, offsetY, Boolean(ampm));
    handleValueChange(newSelectedValue, isFinish);
  };
  const handleTouchSelection = event => {
    isMoving.current = true;
    setTime(event, 'shallow');
  };
  const handleTouchEnd = event => {
    if (isMoving.current) {
      setTime(event, 'finish');
      isMoving.current = false;
    }
    event.preventDefault();
  };
  const handleMouseMove = event => {
    // event.buttons & PRIMARY_MOUSE_BUTTON
    if (event.buttons > 0) {
      setTime(event.nativeEvent, 'shallow');
    }
  };
  const handleMouseUp = event => {
    if (isMoving.current) {
      isMoving.current = false;
    }
    setTime(event.nativeEvent, 'finish');
  };
  const hasSelected = React$1G.useMemo(() => {
    if (type === 'hours') {
      return true;
    }
    return viewValue % 5 === 0;
  }, [type, viewValue]);
  const keyboardControlStep = type === 'minutes' ? minutesStep : 1;
  const listboxRef = React$1G.useRef(null);
  // Since this is rendered when a Popper is opened we can't use passive effects.
  // Focusing in passive effects in Popper causes scroll jump.
  useEnhancedEffect(() => {
    if (autoFocus) {
      // The ref not being resolved would be a bug in MUI.
      listboxRef.current.focus();
    }
  }, [autoFocus]);
  const clampValue = newValue => Math.max(minViewValue, Math.min(maxViewValue, newValue));
  const circleValue = newValue => (newValue + (maxViewValue + 1)) % (maxViewValue + 1);
  const handleKeyDown = event => {
    // TODO: Why this early exit?
    if (isMoving.current) {
      return;
    }
    switch (event.key) {
      case 'Home':
        // reset both hours and minutes
        handleValueChange(minViewValue, 'partial');
        event.preventDefault();
        break;
      case 'End':
        handleValueChange(maxViewValue, 'partial');
        event.preventDefault();
        break;
      case 'ArrowUp':
        handleValueChange(circleValue(viewValue + keyboardControlStep), 'partial');
        event.preventDefault();
        break;
      case 'ArrowDown':
        handleValueChange(circleValue(viewValue - keyboardControlStep), 'partial');
        event.preventDefault();
        break;
      case 'PageUp':
        handleValueChange(clampValue(viewValue + 5), 'partial');
        event.preventDefault();
        break;
      case 'PageDown':
        handleValueChange(clampValue(viewValue - 5), 'partial');
        event.preventDefault();
        break;
      case 'Enter':
      case ' ':
        handleValueChange(viewValue, 'finish');
        event.preventDefault();
        break;
      // do nothing
    }
  };
  return /*#__PURE__*/jsxRuntimeExports.jsxs(ClockRoot, {
    className: clsx(classes.root, className),
    children: [/*#__PURE__*/jsxRuntimeExports.jsxs(ClockClock, {
      className: classes.clock,
      children: [/*#__PURE__*/jsxRuntimeExports.jsx(ClockSquareMask, {
        onTouchMove: handleTouchSelection,
        onTouchStart: handleTouchSelection,
        onTouchEnd: handleTouchEnd,
        onMouseUp: handleMouseUp,
        onMouseMove: handleMouseMove,
        ownerState: {
          disabled
        },
        className: classes.squareMask
      }), !isSelectedTimeDisabled && /*#__PURE__*/jsxRuntimeExports.jsxs(React$1G.Fragment, {
        children: [/*#__PURE__*/jsxRuntimeExports.jsx(ClockPin, {
          className: classes.pin
        }), value != null && /*#__PURE__*/jsxRuntimeExports.jsx(ClockPointer, {
          type: type,
          viewValue: viewValue,
          isInner: isPointerInner,
          hasSelected: hasSelected
        })]
      }), /*#__PURE__*/jsxRuntimeExports.jsx(ClockWrapper, {
        "aria-activedescendant": selectedId,
        "aria-label": translations.clockLabelText(type, value, utils, value == null ? null : utils.format(value, 'fullTime')),
        ref: listboxRef,
        role: "listbox",
        onKeyDown: handleKeyDown,
        tabIndex: 0,
        className: classes.wrapper,
        children: children
      })]
    }), ampm && ampmInClock && /*#__PURE__*/jsxRuntimeExports.jsxs(React$1G.Fragment, {
      children: [/*#__PURE__*/jsxRuntimeExports.jsx(ClockAmButton, {
        onClick: readOnly ? undefined : () => handleMeridiemChange('am'),
        disabled: disabled || meridiemMode === null,
        ownerState: ownerState,
        className: classes.amButton,
        title: formatMeridiem(utils, 'am'),
        children: /*#__PURE__*/jsxRuntimeExports.jsx(ClockMeridiemText, {
          variant: "caption",
          className: classes.meridiemText,
          children: formatMeridiem(utils, 'am')
        })
      }), /*#__PURE__*/jsxRuntimeExports.jsx(ClockPmButton, {
        disabled: disabled || meridiemMode === null,
        onClick: readOnly ? undefined : () => handleMeridiemChange('pm'),
        ownerState: ownerState,
        className: classes.pmButton,
        title: formatMeridiem(utils, 'pm'),
        children: /*#__PURE__*/jsxRuntimeExports.jsx(ClockMeridiemText, {
          variant: "caption",
          className: classes.meridiemText,
          children: formatMeridiem(utils, 'pm')
        })
      })]
    })]
  });
}

function getClockNumberUtilityClass(slot) {
  return generateUtilityClass('MuiClockNumber', slot);
}
const clockNumberClasses = generateUtilityClasses('MuiClockNumber', ['root', 'selected', 'disabled']);

const _excluded$C = ["className", "disabled", "index", "inner", "label", "selected"];
await importShared('react');
const useUtilityClasses$s = ownerState => {
  const {
    classes,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ['root', selected && 'selected', disabled && 'disabled']
  };
  return composeClasses(slots, getClockNumberUtilityClass, classes);
};
const ClockNumberRoot = styled('span', {
  name: 'MuiClockNumber',
  slot: 'Root',
  overridesResolver: (_, styles) => [styles.root, {
    [`&.${clockNumberClasses.disabled}`]: styles.disabled
  }, {
    [`&.${clockNumberClasses.selected}`]: styles.selected
  }]
})(({
  theme
}) => ({
  height: CLOCK_HOUR_WIDTH,
  width: CLOCK_HOUR_WIDTH,
  position: 'absolute',
  left: `calc((100% - ${CLOCK_HOUR_WIDTH}px) / 2)`,
  display: 'inline-flex',
  justifyContent: 'center',
  alignItems: 'center',
  borderRadius: '50%',
  color: (theme.vars || theme).palette.text.primary,
  fontFamily: theme.typography.fontFamily,
  '&:focused': {
    backgroundColor: (theme.vars || theme).palette.background.paper
  },
  [`&.${clockNumberClasses.selected}`]: {
    color: (theme.vars || theme).palette.primary.contrastText
  },
  [`&.${clockNumberClasses.disabled}`]: {
    pointerEvents: 'none',
    color: (theme.vars || theme).palette.text.disabled
  },
  variants: [{
    props: {
      inner: true
    },
    style: _extends$3({}, theme.typography.body2, {
      color: (theme.vars || theme).palette.text.secondary
    })
  }]
}));

/**
 * @ignore - internal component.
 */
function ClockNumber(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiClockNumber'
  });
  const {
      className,
      disabled,
      index,
      inner,
      label,
      selected
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$C);
  const ownerState = props;
  const classes = useUtilityClasses$s(ownerState);
  const angle = index % 12 / 12 * Math.PI * 2 - Math.PI / 2;
  const length = (CLOCK_WIDTH - CLOCK_HOUR_WIDTH - 2) / 2 * (inner ? 0.65 : 1);
  const x = Math.round(Math.cos(angle) * length);
  const y = Math.round(Math.sin(angle) * length);
  return /*#__PURE__*/jsxRuntimeExports.jsx(ClockNumberRoot, _extends$3({
    className: clsx(classes.root, className),
    "aria-disabled": disabled ? true : undefined,
    "aria-selected": selected ? true : undefined,
    role: "option",
    style: {
      transform: `translate(${x}px, ${y + (CLOCK_WIDTH - CLOCK_HOUR_WIDTH) / 2}px`
    },
    ownerState: ownerState
  }, other, {
    children: label
  }));
}

await importShared('react');
/**
 * @ignore - internal component.
 */
const getHourNumbers = ({
  ampm,
  value,
  getClockNumberText,
  isDisabled,
  selectedId,
  utils
}) => {
  const currentHours = value ? utils.getHours(value) : null;
  const hourNumbers = [];
  const startHour = ampm ? 1 : 0;
  const endHour = ampm ? 12 : 23;
  const isSelected = hour => {
    if (currentHours === null) {
      return false;
    }
    if (ampm) {
      if (hour === 12) {
        return currentHours === 12 || currentHours === 0;
      }
      return currentHours === hour || currentHours - 12 === hour;
    }
    return currentHours === hour;
  };
  for (let hour = startHour; hour <= endHour; hour += 1) {
    let label = hour.toString();
    if (hour === 0) {
      label = '00';
    }
    const inner = !ampm && (hour === 0 || hour > 12);
    label = utils.formatNumber(label);
    const selected = isSelected(hour);
    hourNumbers.push(/*#__PURE__*/jsxRuntimeExports.jsx(ClockNumber, {
      id: selected ? selectedId : undefined,
      index: hour,
      inner: inner,
      selected: selected,
      disabled: isDisabled(hour),
      label: label,
      "aria-label": getClockNumberText(label)
    }, hour));
  }
  return hourNumbers;
};
const getMinutesNumbers = ({
  utils,
  value,
  isDisabled,
  getClockNumberText,
  selectedId
}) => {
  const f = utils.formatNumber;
  return [[5, f('05')], [10, f('10')], [15, f('15')], [20, f('20')], [25, f('25')], [30, f('30')], [35, f('35')], [40, f('40')], [45, f('45')], [50, f('50')], [55, f('55')], [0, f('00')]].map(([numberValue, label], index) => {
    const selected = numberValue === value;
    return /*#__PURE__*/jsxRuntimeExports.jsx(ClockNumber, {
      label: label,
      id: selected ? selectedId : undefined,
      index: index + 1,
      inner: false,
      disabled: isDisabled(numberValue),
      selected: selected,
      "aria-label": getClockNumberText(label)
    }, numberValue);
  });
};

const React$1F = await importShared('react');
/**
 * Hooks making sure that:
 * - The value returned by `onChange` always have the timezone of `props.value` or `props.defaultValue` if defined
 * - The value rendered is always the one from `props.timezone` if defined
 */
const useValueWithTimezone = ({
  timezone: timezoneProp,
  value: valueProp,
  defaultValue,
  referenceDate,
  onChange,
  valueManager
}) => {
  const utils = useUtils();
  const firstDefaultValue = React$1F.useRef(defaultValue);
  const inputValue = valueProp ?? firstDefaultValue.current ?? valueManager.emptyValue;
  const inputTimezone = React$1F.useMemo(() => valueManager.getTimezone(utils, inputValue), [utils, valueManager, inputValue]);
  const setInputTimezone = useEventCallback(newValue => {
    if (inputTimezone == null) {
      return newValue;
    }
    return valueManager.setTimezone(utils, inputTimezone, newValue);
  });
  let timezoneToRender;
  if (timezoneProp) {
    timezoneToRender = timezoneProp;
  } else if (inputTimezone) {
    timezoneToRender = inputTimezone;
  } else if (referenceDate) {
    timezoneToRender = utils.getTimezone(referenceDate);
  } else {
    timezoneToRender = 'default';
  }
  const valueWithTimezoneToRender = React$1F.useMemo(() => valueManager.setTimezone(utils, timezoneToRender, inputValue), [valueManager, utils, timezoneToRender, inputValue]);
  const handleValueChange = useEventCallback((newValue, ...otherParams) => {
    const newValueWithInputTimezone = setInputTimezone(newValue);
    onChange?.(newValueWithInputTimezone, ...otherParams);
  });
  return {
    value: valueWithTimezoneToRender,
    handleValueChange,
    timezone: timezoneToRender
  };
};

/**
 * Wrapper around `useControlled` and `useValueWithTimezone`
 */
const useControlledValueWithTimezone = ({
  name,
  timezone: timezoneProp,
  value: valueProp,
  defaultValue,
  referenceDate,
  onChange: onChangeProp,
  valueManager
}) => {
  const [valueWithInputTimezone, setValue] = useControlled({
    name,
    state: 'value',
    controlled: valueProp,
    default: defaultValue ?? valueManager.emptyValue
  });
  const onChange = useEventCallback((newValue, ...otherParams) => {
    setValue(newValue);
    onChangeProp?.(newValue, ...otherParams);
  });
  return useValueWithTimezone({
    timezone: timezoneProp,
    value: valueWithInputTimezone,
    defaultValue: undefined,
    referenceDate,
    onChange,
    valueManager
  });
};

const SECTION_TYPE_GRANULARITY = {
  year: 1,
  month: 2,
  day: 3,
  hours: 4,
  minutes: 5,
  seconds: 6,
  milliseconds: 7
};
const getSectionTypeGranularity = sections => Math.max(...sections.map(section => SECTION_TYPE_GRANULARITY[section.type] ?? 1));
const roundDate = (utils, granularity, date) => {
  if (granularity === SECTION_TYPE_GRANULARITY.year) {
    return utils.startOfYear(date);
  }
  if (granularity === SECTION_TYPE_GRANULARITY.month) {
    return utils.startOfMonth(date);
  }
  if (granularity === SECTION_TYPE_GRANULARITY.day) {
    return utils.startOfDay(date);
  }

  // We don't have startOfHour / startOfMinute / startOfSecond
  let roundedDate = date;
  if (granularity < SECTION_TYPE_GRANULARITY.minutes) {
    roundedDate = utils.setMinutes(roundedDate, 0);
  }
  if (granularity < SECTION_TYPE_GRANULARITY.seconds) {
    roundedDate = utils.setSeconds(roundedDate, 0);
  }
  if (granularity < SECTION_TYPE_GRANULARITY.milliseconds) {
    roundedDate = utils.setMilliseconds(roundedDate, 0);
  }
  return roundedDate;
};
const getDefaultReferenceDate = ({
  props,
  utils,
  granularity,
  timezone,
  getTodayDate: inGetTodayDate
}) => {
  let referenceDate = inGetTodayDate ? inGetTodayDate() : roundDate(utils, granularity, getTodayDate(utils, timezone));
  if (props.minDate != null && utils.isAfterDay(props.minDate, referenceDate)) {
    referenceDate = roundDate(utils, granularity, props.minDate);
  }
  if (props.maxDate != null && utils.isBeforeDay(props.maxDate, referenceDate)) {
    referenceDate = roundDate(utils, granularity, props.maxDate);
  }
  const isAfter = createIsAfterIgnoreDatePart(props.disableIgnoringDatePartForTimeValidation ?? false, utils);
  if (props.minTime != null && isAfter(props.minTime, referenceDate)) {
    referenceDate = roundDate(utils, granularity, props.disableIgnoringDatePartForTimeValidation ? props.minTime : mergeDateAndTime(utils, referenceDate, props.minTime));
  }
  if (props.maxTime != null && isAfter(referenceDate, props.maxTime)) {
    referenceDate = roundDate(utils, granularity, props.disableIgnoringDatePartForTimeValidation ? props.maxTime : mergeDateAndTime(utils, referenceDate, props.maxTime));
  }
  return referenceDate;
};

const getDateSectionConfigFromFormatToken = (utils, formatToken) => {
  const config = utils.formatTokenMap[formatToken];
  if (config == null) {
    throw new Error([`MUI X: The token "${formatToken}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));
  }
  if (typeof config === "string") {
    return {
      type: config,
      contentType: config === "meridiem" ? "letter" : "digit",
      maxLength: void 0
    };
  }
  return {
    type: config.sectionType,
    contentType: config.contentType,
    maxLength: config.maxLength
  };
};
const getDeltaFromKeyCode = (keyCode) => {
  switch (keyCode) {
    case "ArrowUp":
      return 1;
    case "ArrowDown":
      return -1;
    case "PageUp":
      return 5;
    case "PageDown":
      return -5;
    default:
      return 0;
  }
};
const getDaysInWeekStr = (utils, format) => {
  const elements = [];
  const now = utils.date(void 0, "default");
  const startDate = utils.startOfWeek(now);
  const endDate = utils.endOfWeek(now);
  let current = startDate;
  while (utils.isBefore(current, endDate)) {
    elements.push(current);
    current = utils.addDays(current, 1);
  }
  return elements.map((weekDay) => utils.formatByString(weekDay, format));
};
const getLetterEditingOptions = (utils, timezone, sectionType, format) => {
  switch (sectionType) {
    case "month": {
      return getMonthsInYear(utils, utils.date(void 0, timezone)).map((month) => utils.formatByString(month, format));
    }
    case "weekDay": {
      return getDaysInWeekStr(utils, format);
    }
    case "meridiem": {
      const now = utils.date(void 0, timezone);
      return [utils.startOfDay(now), utils.endOfDay(now)].map((date) => utils.formatByString(date, format));
    }
    default: {
      return [];
    }
  }
};
const FORMAT_SECONDS_NO_LEADING_ZEROS = "s";
const NON_LOCALIZED_DIGITS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
const getLocalizedDigits = (utils) => {
  const today = utils.date(void 0);
  const formattedZero = utils.formatByString(utils.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);
  if (formattedZero === "0") {
    return NON_LOCALIZED_DIGITS;
  }
  return Array.from({
    length: 10
  }).map((_, index) => utils.formatByString(utils.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));
};
const removeLocalizedDigits = (valueStr, localizedDigits) => {
  if (localizedDigits[0] === "0") {
    return valueStr;
  }
  const digits = [];
  let currentFormattedDigit = "";
  for (let i = 0; i < valueStr.length; i += 1) {
    currentFormattedDigit += valueStr[i];
    const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);
    if (matchingDigitIndex > -1) {
      digits.push(matchingDigitIndex.toString());
      currentFormattedDigit = "";
    }
  }
  return digits.join("");
};
const applyLocalizedDigits = (valueStr, localizedDigits) => {
  if (localizedDigits[0] === "0") {
    return valueStr;
  }
  return valueStr.split("").map((char) => localizedDigits[Number(char)]).join("");
};
const isStringNumber = (valueStr, localizedDigits) => {
  const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);
  return nonLocalizedValueStr !== " " && !Number.isNaN(Number(nonLocalizedValueStr));
};
const cleanLeadingZeros = (valueStr, size) => {
  let cleanValueStr = valueStr;
  cleanValueStr = Number(cleanValueStr).toString();
  while (cleanValueStr.length < size) {
    cleanValueStr = `0${cleanValueStr}`;
  }
  return cleanValueStr;
};
const cleanDigitSectionValue = (utils, value, sectionBoundaries, localizedDigits, section) => {
  if (section.type === "day" && section.contentType === "digit-with-letter") {
    const date = utils.setDate(sectionBoundaries.longestMonth, value);
    return utils.formatByString(date, section.format);
  }
  let valueStr = value.toString();
  if (section.hasLeadingZerosInInput) {
    valueStr = cleanLeadingZeros(valueStr, section.maxLength);
  }
  return applyLocalizedDigits(valueStr, localizedDigits);
};
const adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {
  const delta = getDeltaFromKeyCode(keyCode);
  const isStart = keyCode === "Home";
  const isEnd = keyCode === "End";
  const shouldSetAbsolute = section.value === "" || isStart || isEnd;
  const adjustDigitSection = () => {
    const sectionBoundaries = sectionsValueBoundaries[section.type]({
      currentDate: activeDate,
      format: section.format,
      contentType: section.contentType
    });
    const getCleanValue = (value) => cleanDigitSectionValue(utils, value, sectionBoundaries, localizedDigits, section);
    const step = section.type === "minutes" && stepsAttributes?.minutesStep ? stepsAttributes.minutesStep : 1;
    let newSectionValueNumber;
    if (shouldSetAbsolute) {
      if (section.type === "year" && !isEnd && !isStart) {
        return utils.formatByString(utils.date(void 0, timezone), section.format);
      }
      if (delta > 0 || isStart) {
        newSectionValueNumber = sectionBoundaries.minimum;
      } else {
        newSectionValueNumber = sectionBoundaries.maximum;
      }
    } else {
      const currentSectionValue = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10);
      newSectionValueNumber = currentSectionValue + delta * step;
    }
    if (newSectionValueNumber % step !== 0) {
      if (delta < 0 || isStart) {
        newSectionValueNumber += step - (step + newSectionValueNumber) % step;
      }
      if (delta > 0 || isEnd) {
        newSectionValueNumber -= newSectionValueNumber % step;
      }
    }
    if (newSectionValueNumber > sectionBoundaries.maximum) {
      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
    }
    if (newSectionValueNumber < sectionBoundaries.minimum) {
      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
    }
    return getCleanValue(newSectionValueNumber);
  };
  const adjustLetterSection = () => {
    const options = getLetterEditingOptions(utils, timezone, section.type, section.format);
    if (options.length === 0) {
      return section.value;
    }
    if (shouldSetAbsolute) {
      if (delta > 0 || isStart) {
        return options[0];
      }
      return options[options.length - 1];
    }
    const currentOptionIndex = options.indexOf(section.value);
    const newOptionIndex = (currentOptionIndex + delta) % options.length;
    const clampedIndex = (newOptionIndex + options.length) % options.length;
    return options[clampedIndex];
  };
  if (section.contentType === "digit" || section.contentType === "digit-with-letter") {
    return adjustDigitSection();
  }
  return adjustLetterSection();
};
const getSectionVisibleValue = (section, target, localizedDigits) => {
  let value = section.value || section.placeholder;
  const hasLeadingZeros = target === "non-input" ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;
  if (target === "non-input" && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {
    value = Number(removeLocalizedDigits(value, localizedDigits)).toString();
  }
  const shouldAddInvisibleSpace = ["input-rtl", "input-ltr"].includes(target) && section.contentType === "digit" && !hasLeadingZeros && value.length === 1;
  if (shouldAddInvisibleSpace) {
    value = `${value}‎`;
  }
  if (target === "input-rtl") {
    value = `⁨${value}⁩`;
  }
  return value;
};
const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {
  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);
};
const isFourDigitYearFormat = (utils, format) => utils.formatByString(utils.date(void 0, "system"), format).length === 4;
const doesSectionFormatHaveLeadingZeros = (utils, contentType, sectionType, format) => {
  if (contentType !== "digit") {
    return false;
  }
  const now = utils.date(void 0, "default");
  switch (sectionType) {
    case "year": {
      if (utils.lib === "dayjs" && format === "YY") {
        return true;
      }
      return utils.formatByString(utils.setYear(now, 1), format).startsWith("0");
    }
    case "month": {
      return utils.formatByString(utils.startOfYear(now), format).length > 1;
    }
    case "day": {
      return utils.formatByString(utils.startOfMonth(now), format).length > 1;
    }
    case "weekDay": {
      return utils.formatByString(utils.startOfWeek(now), format).length > 1;
    }
    case "hours": {
      return utils.formatByString(utils.setHours(now, 1), format).length > 1;
    }
    case "minutes": {
      return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;
    }
    case "seconds": {
      return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;
    }
    default: {
      throw new Error("Invalid section type");
    }
  }
};
const getDateFromDateSections = (utils, sections, localizedDigits) => {
  const shouldSkipWeekDays = sections.some((section) => section.type === "day");
  const sectionFormats = [];
  const sectionValues = [];
  for (let i = 0; i < sections.length; i += 1) {
    const section = sections[i];
    const shouldSkip = shouldSkipWeekDays && section.type === "weekDay";
    if (!shouldSkip) {
      sectionFormats.push(section.format);
      sectionValues.push(getSectionVisibleValue(section, "non-input", localizedDigits));
    }
  }
  const formatWithoutSeparator = sectionFormats.join(" ");
  const dateWithoutSeparatorStr = sectionValues.join(" ");
  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);
};
const createDateStrForV7HiddenInputFromSections = (sections) => sections.map((section) => {
  return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;
}).join("");
const createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {
  const formattedSections = sections.map((section) => {
    const dateValue = getSectionVisibleValue(section, isRtl ? "input-rtl" : "input-ltr", localizedDigits);
    return `${section.startSeparator}${dateValue}${section.endSeparator}`;
  });
  const dateStr = formattedSections.join("");
  if (!isRtl) {
    return dateStr;
  }
  return `⁦${dateStr}⁩`;
};
const getSectionsBoundaries = (utils, localizedDigits, timezone) => {
  const today = utils.date(void 0, timezone);
  const endOfYear = utils.endOfYear(today);
  const endOfDay = utils.endOfDay(today);
  const {
    maxDaysInMonth,
    longestMonth
  } = getMonthsInYear(utils, today).reduce((acc, month) => {
    const daysInMonth = utils.getDaysInMonth(month);
    if (daysInMonth > acc.maxDaysInMonth) {
      return {
        maxDaysInMonth: daysInMonth,
        longestMonth: month
      };
    }
    return acc;
  }, {
    maxDaysInMonth: 0,
    longestMonth: null
  });
  return {
    year: ({
      format
    }) => ({
      minimum: 0,
      maximum: isFourDigitYearFormat(utils, format) ? 9999 : 99
    }),
    month: () => ({
      minimum: 1,
      // Assumption: All years have the same amount of months
      maximum: utils.getMonth(endOfYear) + 1
    }),
    day: ({
      currentDate
    }) => ({
      minimum: 1,
      maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,
      longestMonth
    }),
    weekDay: ({
      format,
      contentType
    }) => {
      if (contentType === "digit") {
        const daysInWeek = getDaysInWeekStr(utils, format).map(Number);
        return {
          minimum: Math.min(...daysInWeek),
          maximum: Math.max(...daysInWeek)
        };
      }
      return {
        minimum: 1,
        maximum: 7
      };
    },
    hours: ({
      format
    }) => {
      const lastHourInDay = utils.getHours(endOfDay);
      const hasMeridiem = removeLocalizedDigits(utils.formatByString(utils.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();
      if (hasMeridiem) {
        return {
          minimum: 1,
          maximum: Number(removeLocalizedDigits(utils.formatByString(utils.startOfDay(today), format), localizedDigits))
        };
      }
      return {
        minimum: 0,
        maximum: lastHourInDay
      };
    },
    minutes: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of minutes
      maximum: utils.getMinutes(endOfDay)
    }),
    seconds: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of seconds
      maximum: utils.getSeconds(endOfDay)
    }),
    meridiem: () => ({
      minimum: 0,
      maximum: 1
    }),
    empty: () => ({
      minimum: 0,
      maximum: 0
    })
  };
};
const transferDateSectionValue = (utils, section, dateToTransferFrom, dateToTransferTo) => {
  switch (section.type) {
    case "year": {
      return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));
    }
    case "month": {
      return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));
    }
    case "weekDay": {
      const formattedDaysInWeek = getDaysInWeekStr(utils, section.format);
      const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);
      const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);
      const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);
      const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;
      return utils.addDays(dateToTransferFrom, diff);
    }
    case "day": {
      return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));
    }
    case "meridiem": {
      const isAM = utils.getHours(dateToTransferFrom) < 12;
      const mergedDateHours = utils.getHours(dateToTransferTo);
      if (isAM && mergedDateHours >= 12) {
        return utils.addHours(dateToTransferTo, -12);
      }
      if (!isAM && mergedDateHours < 12) {
        return utils.addHours(dateToTransferTo, 12);
      }
      return dateToTransferTo;
    }
    case "hours": {
      return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));
    }
    case "minutes": {
      return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));
    }
    case "seconds": {
      return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));
    }
    default: {
      return dateToTransferTo;
    }
  }
};
const reliableSectionModificationOrder = {
  year: 1,
  month: 2,
  day: 3,
  weekDay: 4,
  hours: 5,
  minutes: 6,
  seconds: 7,
  meridiem: 8,
  empty: 9
};
const mergeDateIntoReferenceDate = (utils, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => (
  // cloning sections before sort to avoid mutating it
  [...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {
    if (!shouldLimitToEditedSections || section.modified) {
      return transferDateSectionValue(utils, section, dateToTransferFrom, mergedDate);
    }
    return mergedDate;
  }, referenceDate)
);
const isAndroid = () => navigator.userAgent.toLowerCase().includes("android");
const getSectionOrder = (sections, shouldApplyRTL) => {
  const neighbors = {};
  if (!shouldApplyRTL) {
    sections.forEach((_, index) => {
      const leftIndex = index === 0 ? null : index - 1;
      const rightIndex = index === sections.length - 1 ? null : index + 1;
      neighbors[index] = {
        leftIndex,
        rightIndex
      };
    });
    return {
      neighbors,
      startIndex: 0,
      endIndex: sections.length - 1
    };
  }
  const rtl2ltr = {};
  const ltr2rtl = {};
  let groupedSectionsStart = 0;
  let groupedSectionsEnd = 0;
  let RTLIndex = sections.length - 1;
  while (RTLIndex >= 0) {
    groupedSectionsEnd = sections.findIndex(
      // eslint-disable-next-line @typescript-eslint/no-loop-func
      (section, index) => index >= groupedSectionsStart && section.endSeparator?.includes(" ") && // Special case where the spaces were not there in the initial input
      section.endSeparator !== " / "
    );
    if (groupedSectionsEnd === -1) {
      groupedSectionsEnd = sections.length - 1;
    }
    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {
      ltr2rtl[i] = RTLIndex;
      rtl2ltr[RTLIndex] = i;
      RTLIndex -= 1;
    }
    groupedSectionsStart = groupedSectionsEnd + 1;
  }
  sections.forEach((_, index) => {
    const rtlIndex = ltr2rtl[index];
    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];
    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];
    neighbors[index] = {
      leftIndex,
      rightIndex
    };
  });
  return {
    neighbors,
    startIndex: rtl2ltr[0],
    endIndex: rtl2ltr[sections.length - 1]
  };
};
const parseSelectedSections = (selectedSections, sections) => {
  if (selectedSections == null) {
    return null;
  }
  if (selectedSections === "all") {
    return "all";
  }
  if (typeof selectedSections === "string") {
    const index = sections.findIndex((section) => section.type === selectedSections);
    return index === -1 ? null : index;
  }
  return selectedSections;
};
const getSectionValueText = (section, utils) => {
  if (!section.value) {
    return void 0;
  }
  switch (section.type) {
    case "month": {
      if (section.contentType === "digit") {
        return utils.format(utils.setMonth(utils.date(), Number(section.value) - 1), "month");
      }
      const parsedDate = utils.parse(section.value, section.format);
      return parsedDate ? utils.format(parsedDate, "month") : void 0;
    }
    case "day":
      return section.contentType === "digit" ? utils.format(utils.setDate(utils.startOfYear(utils.date()), Number(section.value)), "dayOfMonthFull") : section.value;
    case "weekDay":
      return void 0;
    default:
      return void 0;
  }
};
const getSectionValueNow = (section, utils) => {
  if (!section.value) {
    return void 0;
  }
  switch (section.type) {
    case "weekDay": {
      if (section.contentType === "letter") {
        return void 0;
      }
      return Number(section.value);
    }
    case "meridiem": {
      const parsedDate = utils.parse(`01:00 ${section.value}`, `${utils.formats.hours12h}:${utils.formats.minutes} ${section.format}`);
      if (parsedDate) {
        return utils.getHours(parsedDate) >= 12 ? 1 : 0;
      }
      return void 0;
    }
    case "day":
      return section.contentType === "digit-with-letter" ? parseInt(section.value, 10) : Number(section.value);
    case "month": {
      if (section.contentType === "digit") {
        return Number(section.value);
      }
      const parsedDate = utils.parse(section.value, section.format);
      return parsedDate ? utils.getMonth(parsedDate) + 1 : void 0;
    }
    default:
      return section.contentType !== "letter" ? Number(section.value) : void 0;
  }
};

const _excluded$B = ["value", "referenceDate"];
const singleItemValueManager = {
  emptyValue: null,
  getTodayValue: getTodayDate,
  getInitialReferenceValue: _ref => {
    let {
        value,
        referenceDate
      } = _ref,
      params = _objectWithoutPropertiesLoose(_ref, _excluded$B);
    if (value != null && params.utils.isValid(value)) {
      return value;
    }
    if (referenceDate != null) {
      return referenceDate;
    }
    return getDefaultReferenceDate(params);
  },
  cleanValue: replaceInvalidDateByNull,
  areValuesEqual: areDatesEqual,
  isSameError: (a, b) => a === b,
  hasError: error => error != null,
  defaultErrorState: null,
  getTimezone: (utils, value) => value == null || !utils.isValid(value) ? null : utils.getTimezone(value),
  setTimezone: (utils, timezone, value) => value == null ? null : utils.setTimezone(value, timezone)
};
const singleItemFieldValueManager = {
  updateReferenceValue: (utils, value, prevReferenceValue) => value == null || !utils.isValid(value) ? prevReferenceValue : value,
  getSectionsFromValue: (utils, date, prevSections, getSectionsFromDate) => {
    const shouldReUsePrevDateSections = !utils.isValid(date) && !!prevSections;
    if (shouldReUsePrevDateSections) {
      return prevSections;
    }
    return getSectionsFromDate(date);
  },
  getV7HiddenInputValueFromSections: createDateStrForV7HiddenInputFromSections,
  getV6InputValueFromSections: createDateStrForV6InputFromSections,
  getActiveDateManager: (utils, state) => ({
    date: state.value,
    referenceDate: state.referenceValue,
    getSections: sections => sections,
    getNewValuesFromNewActiveDate: newActiveDate => ({
      value: newActiveDate,
      referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : newActiveDate
    })
  }),
  parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue)
};

const React$1E = await importShared('react');
const useClockReferenceDate = ({
  value,
  referenceDate: referenceDateProp,
  utils,
  props,
  timezone
}) => {
  const referenceDate = React$1E.useMemo(() => singleItemValueManager.getInitialReferenceValue({
    value,
    utils,
    props,
    referenceDate: referenceDateProp,
    granularity: SECTION_TYPE_GRANULARITY.day,
    timezone,
    getTodayDate: () => getTodayDate(utils, timezone, 'date')
  }),
  // We only want to compute the reference date on mount.
  [] // eslint-disable-line react-hooks/exhaustive-deps
  );
  return value ?? referenceDate;
};

const _excluded$A = ["ampm", "ampmInClock", "autoFocus", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableTime", "showViewSwitcher", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "timezone"];
const React$1D = await importShared('react');
await importShared('prop-types');
const useUtilityClasses$r = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    arrowSwitcher: ["arrowSwitcher"]
  };
  return composeClasses(slots, getTimeClockUtilityClass, classes);
};
const TimeClockRoot = styled(PickerViewRoot, {
  name: "MuiTimeClock",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  display: "flex",
  flexDirection: "column",
  position: "relative"
});
const TimeClockArrowSwitcher = styled(PickersArrowSwitcher, {
  name: "MuiTimeClock",
  slot: "ArrowSwitcher",
  overridesResolver: (props, styles) => styles.arrowSwitcher
})({
  position: "absolute",
  right: 12,
  top: 15
});
const TIME_CLOCK_DEFAULT_VIEWS = ["hours", "minutes"];
const TimeClock = /* @__PURE__ */ React$1D.forwardRef(function TimeClock2(inProps, ref) {
  const utils = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiTimeClock"
  });
  const {
    ampm = utils.is12HourCycleInCurrentLocale(),
    ampmInClock = false,
    autoFocus,
    slots,
    slotProps,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableIgnoringDatePartForTimeValidation = false,
    maxTime,
    minTime,
    disableFuture,
    disablePast,
    minutesStep = 1,
    shouldDisableTime,
    showViewSwitcher,
    onChange,
    view: inView,
    views = TIME_CLOCK_DEFAULT_VIEWS,
    openTo,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    className,
    disabled,
    readOnly,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$A);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "TimeClock",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    onChange,
    valueManager: singleItemValueManager
  });
  const valueOrReferenceDate = useClockReferenceDate({
    value,
    referenceDate: referenceDateProp,
    utils,
    props,
    timezone
  });
  const translations = usePickersTranslations();
  const now = useNow(timezone);
  const {
    view,
    setView,
    previousView,
    nextView,
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onViewChange,
    onChange: handleValueChange,
    focusedView,
    onFocusedViewChange
  });
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(valueOrReferenceDate, ampm, setValueAndGoToNextView);
  const isTimeDisabled = React$1D.useCallback((rawValue, viewType) => {
    const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils);
    const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
    const containsValidTime = ({
      start,
      end
    }) => {
      if (minTime && isAfter(minTime, end)) {
        return false;
      }
      if (maxTime && isAfter(start, maxTime)) {
        return false;
      }
      if (disableFuture && isAfter(start, now)) {
        return false;
      }
      if (disablePast && isAfter(now, shouldCheckPastEnd ? end : start)) {
        return false;
      }
      return true;
    };
    const isValidValue = (timeValue, step = 1) => {
      if (timeValue % step !== 0) {
        return false;
      }
      if (shouldDisableTime) {
        switch (viewType) {
          case "hours":
            return !shouldDisableTime(utils.setHours(valueOrReferenceDate, timeValue), "hours");
          case "minutes":
            return !shouldDisableTime(utils.setMinutes(valueOrReferenceDate, timeValue), "minutes");
          case "seconds":
            return !shouldDisableTime(utils.setSeconds(valueOrReferenceDate, timeValue), "seconds");
          default:
            return false;
        }
      }
      return true;
    };
    switch (viewType) {
      case "hours": {
        const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
        const dateWithNewHours = utils.setHours(valueOrReferenceDate, valueWithMeridiem);
        if (utils.getHours(dateWithNewHours) !== valueWithMeridiem) {
          return true;
        }
        const start = utils.setSeconds(utils.setMinutes(dateWithNewHours, 0), 0);
        const end = utils.setSeconds(utils.setMinutes(dateWithNewHours, 59), 59);
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(valueWithMeridiem);
      }
      case "minutes": {
        const dateWithNewMinutes = utils.setMinutes(valueOrReferenceDate, rawValue);
        const start = utils.setSeconds(dateWithNewMinutes, 0);
        const end = utils.setSeconds(dateWithNewMinutes, 59);
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(rawValue, minutesStep);
      }
      case "seconds": {
        const dateWithNewSeconds = utils.setSeconds(valueOrReferenceDate, rawValue);
        const start = dateWithNewSeconds;
        const end = dateWithNewSeconds;
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(rawValue);
      }
      default:
        throw new Error("not supported");
    }
  }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableTime, utils, disableFuture, disablePast, now, views]);
  const selectedId = useId();
  const viewProps = React$1D.useMemo(() => {
    switch (view) {
      case "hours": {
        const handleHoursChange = (hourValue, isFinish) => {
          const valueWithMeridiem = convertValueToMeridiem(hourValue, meridiemMode, ampm);
          setValueAndGoToNextView(utils.setHours(valueOrReferenceDate, valueWithMeridiem), isFinish, "hours");
        };
        const viewValue = utils.getHours(valueOrReferenceDate);
        let viewRange;
        if (ampm) {
          if (viewValue > 12) {
            viewRange = [12, 23];
          } else {
            viewRange = [0, 11];
          }
        } else {
          viewRange = [0, 23];
        }
        return {
          onChange: handleHoursChange,
          viewValue,
          children: getHourNumbers({
            value,
            utils,
            ampm,
            getClockNumberText: translations.hoursClockNumberText,
            isDisabled: (hourValue) => disabled || isTimeDisabled(hourValue, "hours"),
            selectedId
          }),
          viewRange
        };
      }
      case "minutes": {
        const minutesValue = utils.getMinutes(valueOrReferenceDate);
        const handleMinutesChange = (minuteValue, isFinish) => {
          setValueAndGoToNextView(utils.setMinutes(valueOrReferenceDate, minuteValue), isFinish, "minutes");
        };
        return {
          viewValue: minutesValue,
          onChange: handleMinutesChange,
          children: getMinutesNumbers({
            utils,
            value: minutesValue,
            getClockNumberText: translations.minutesClockNumberText,
            isDisabled: (minuteValue) => disabled || isTimeDisabled(minuteValue, "minutes"),
            selectedId
          }),
          viewRange: [0, 59]
        };
      }
      case "seconds": {
        const secondsValue = utils.getSeconds(valueOrReferenceDate);
        const handleSecondsChange = (secondValue, isFinish) => {
          setValueAndGoToNextView(utils.setSeconds(valueOrReferenceDate, secondValue), isFinish, "seconds");
        };
        return {
          viewValue: secondsValue,
          onChange: handleSecondsChange,
          children: getMinutesNumbers({
            utils,
            value: secondsValue,
            getClockNumberText: translations.secondsClockNumberText,
            isDisabled: (secondValue) => disabled || isTimeDisabled(secondValue, "seconds"),
            selectedId
          }),
          viewRange: [0, 59]
        };
      }
      default:
        throw new Error("You must provide the type for ClockView");
    }
  }, [view, utils, value, ampm, translations.hoursClockNumberText, translations.minutesClockNumberText, translations.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, isTimeDisabled, selectedId, disabled]);
  const ownerState = props;
  const classes = useUtilityClasses$r(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TimeClockRoot, _extends$3({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Clock, _extends$3({
      autoFocus: autoFocus ?? !!focusedView,
      ampmInClock: ampmInClock && views.includes("hours"),
      value,
      type: view,
      ampm,
      minutesStep,
      isTimeDisabled,
      meridiemMode,
      handleMeridiemChange,
      selectedId,
      disabled,
      readOnly
    }, viewProps)), showViewSwitcher && /* @__PURE__ */ jsxRuntimeExports.jsx(TimeClockArrowSwitcher, {
      className: classes.arrowSwitcher,
      slots,
      slotProps,
      onGoToPrevious: () => setView(previousView),
      isPreviousDisabled: !previousView,
      previousLabel: translations.openPreviousView,
      onGoToNext: () => setView(nextView),
      isNextDisabled: !nextView,
      nextLabel: translations.openNextView,
      ownerState
    })]
  }));
});

function getDigitalClockUtilityClass(slot) {
  return generateUtilityClass('MuiDigitalClock', slot);
}
generateUtilityClasses('MuiDigitalClock', ['root', 'list', 'item']);

/* Use it instead of .includes method for IE support */
function arrayIncludes(array, itemOrItems) {
  if (Array.isArray(itemOrItems)) {
    return itemOrItems.every(item => array.indexOf(item) !== -1);
  }
  return array.indexOf(itemOrItems) !== -1;
}
const onSpaceOrEnter = (innerFn, externalEvent) => event => {
  if (event.key === 'Enter' || event.key === ' ') {
    innerFn(event);

    // prevent any side effects
    event.preventDefault();
    event.stopPropagation();
  }
};

// https://www.abeautifulsite.net/posts/finding-the-active-element-in-a-shadow-root/
const getActiveElement = (root = document) => {
  const activeEl = root.activeElement;
  if (!activeEl) {
    return null;
  }
  if (activeEl.shadowRoot) {
    return getActiveElement(activeEl.shadowRoot);
  }
  return activeEl;
};

/**
 * Gets the index of the focused list item in a given ul list element.
 *
 * @param {HTMLUListElement} listElement - The list element to search within.
 * @returns {number} The index of the focused list item, or -1 if none is focused.
 */
const getFocusedListItemIndex = listElement => {
  const children = Array.from(listElement.children);
  return children.indexOf(getActiveElement(document));
};
const DEFAULT_DESKTOP_MODE_MEDIA_QUERY = '@media (pointer: fine)';

const _excluded$z = ["ampm", "timeStep", "autoFocus", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableTime", "onChange", "view", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "views", "skipDisabled", "timezone"];
const React$1C = await importShared('react');
await importShared('prop-types');
const useUtilityClasses$q = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    list: ["list"],
    item: ["item"]
  };
  return composeClasses(slots, getDigitalClockUtilityClass, classes);
};
const DigitalClockRoot = styled(PickerViewRoot, {
  name: "MuiDigitalClock",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  overflowY: "auto",
  width: "100%",
  "@media (prefers-reduced-motion: no-preference)": {
    scrollBehavior: "auto"
  },
  maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT,
  variants: [{
    props: {
      alreadyRendered: true
    },
    style: {
      "@media (prefers-reduced-motion: no-preference)": {
        scrollBehavior: "smooth"
      }
    }
  }]
});
const DigitalClockList = styled(MenuList, {
  name: "MuiDigitalClock",
  slot: "List",
  overridesResolver: (props, styles) => styles.list
})({
  padding: 0
});
const DigitalClockItem = styled(MenuItem$f, {
  name: "MuiDigitalClock",
  slot: "Item",
  overridesResolver: (props, styles) => styles.item
})(({
  theme
}) => ({
  padding: "8px 16px",
  margin: "2px 4px",
  "&:first-of-type": {
    marginTop: 4
  },
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
  },
  "&.Mui-selected": {
    backgroundColor: (theme.vars || theme).palette.primary.main,
    color: (theme.vars || theme).palette.primary.contrastText,
    "&:focus-visible, &:hover": {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  "&.Mui-focusVisible": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity)
  }
}));
const DigitalClock = /* @__PURE__ */ React$1C.forwardRef(function DigitalClock2(inProps, ref) {
  const utils = useUtils();
  const containerRef = React$1C.useRef(null);
  const handleRef = useForkRef(ref, containerRef);
  const listRef = React$1C.useRef(null);
  const props = useThemeProps({
    props: inProps,
    name: "MuiDigitalClock"
  });
  const {
    ampm = utils.is12HourCycleInCurrentLocale(),
    timeStep = 30,
    autoFocus,
    slots,
    slotProps,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableIgnoringDatePartForTimeValidation = false,
    maxTime,
    minTime,
    disableFuture,
    disablePast,
    minutesStep = 1,
    shouldDisableTime,
    onChange,
    view: inView,
    openTo,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    className,
    disabled,
    readOnly,
    views = ["hours"],
    skipDisabled = false,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$z);
  const {
    value,
    handleValueChange: handleRawValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "DigitalClock",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    onChange,
    valueManager: singleItemValueManager
  });
  const translations = usePickersTranslations();
  const now = useNow(timezone);
  const ownerState = React$1C.useMemo(() => _extends$3({}, props, {
    alreadyRendered: !!containerRef.current
  }), [props]);
  const classes = useUtilityClasses$q(ownerState);
  const ClockItem = slots?.digitalClockItem ?? DigitalClockItem;
  const clockItemProps = useSlotProps({
    elementType: ClockItem,
    externalSlotProps: slotProps?.digitalClockItem,
    ownerState: {},
    className: classes.item
  });
  const valueOrReferenceDate = useClockReferenceDate({
    value,
    referenceDate: referenceDateProp,
    utils,
    props,
    timezone
  });
  const handleValueChange = useEventCallback((newValue) => handleRawValueChange(newValue, "finish", "hours"));
  const {
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onViewChange,
    onChange: handleValueChange,
    focusedView,
    onFocusedViewChange
  });
  const handleItemSelect = useEventCallback((newValue) => {
    setValueAndGoToNextView(newValue, "finish");
  });
  React$1C.useEffect(() => {
    if (containerRef.current === null) {
      return;
    }
    const activeItem = containerRef.current.querySelector('[role="listbox"] [role="option"][tabindex="0"], [role="listbox"] [role="option"][aria-selected="true"]');
    if (!activeItem) {
      return;
    }
    const offsetTop = activeItem.offsetTop;
    if (autoFocus || !!focusedView) {
      activeItem.focus();
    }
    containerRef.current.scrollTop = offsetTop - 4;
  });
  const isTimeDisabled = React$1C.useCallback((valueToCheck) => {
    const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils);
    const containsValidTime = () => {
      if (minTime && isAfter(minTime, valueToCheck)) {
        return false;
      }
      if (maxTime && isAfter(valueToCheck, maxTime)) {
        return false;
      }
      if (disableFuture && isAfter(valueToCheck, now)) {
        return false;
      }
      if (disablePast && isAfter(now, valueToCheck)) {
        return false;
      }
      return true;
    };
    const isValidValue = () => {
      if (utils.getMinutes(valueToCheck) % minutesStep !== 0) {
        return false;
      }
      if (shouldDisableTime) {
        return !shouldDisableTime(valueToCheck, "hours");
      }
      return true;
    };
    return !containsValidTime() || !isValidValue();
  }, [disableIgnoringDatePartForTimeValidation, utils, minTime, maxTime, disableFuture, now, disablePast, minutesStep, shouldDisableTime]);
  const timeOptions = React$1C.useMemo(() => {
    const result = [];
    const startOfDay = utils.startOfDay(valueOrReferenceDate);
    let nextTimeStepOption = startOfDay;
    while (utils.isSameDay(valueOrReferenceDate, nextTimeStepOption)) {
      result.push(nextTimeStepOption);
      nextTimeStepOption = utils.addMinutes(nextTimeStepOption, timeStep);
    }
    return result;
  }, [valueOrReferenceDate, timeStep, utils]);
  const focusedOptionIndex = timeOptions.findIndex((option) => utils.isEqual(option, valueOrReferenceDate));
  const handleKeyDown = (event) => {
    switch (event.key) {
      case "PageUp": {
        const newIndex = getFocusedListItemIndex(listRef.current) - 5;
        const children = listRef.current.children;
        const newFocusedIndex = Math.max(0, newIndex);
        const childToFocus = children[newFocusedIndex];
        if (childToFocus) {
          childToFocus.focus();
        }
        event.preventDefault();
        break;
      }
      case "PageDown": {
        const newIndex = getFocusedListItemIndex(listRef.current) + 5;
        const children = listRef.current.children;
        const newFocusedIndex = Math.min(children.length - 1, newIndex);
        const childToFocus = children[newFocusedIndex];
        if (childToFocus) {
          childToFocus.focus();
        }
        event.preventDefault();
        break;
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockRoot, _extends$3({
    ref: handleRef,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockList, {
      ref: listRef,
      role: "listbox",
      "aria-label": translations.timePickerToolbarTitle,
      className: classes.list,
      onKeyDown: handleKeyDown,
      children: timeOptions.map((option, index) => {
        if (skipDisabled && isTimeDisabled(option)) {
          return null;
        }
        const isSelected = utils.isEqual(option, value);
        const formattedValue = utils.format(option, ampm ? "fullTime12h" : "fullTime24h");
        const tabIndex = focusedOptionIndex === index || focusedOptionIndex === -1 && index === 0 ? 0 : -1;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockItem, _extends$3({
          onClick: () => !readOnly && handleItemSelect(option),
          selected: isSelected,
          disabled: disabled || isTimeDisabled(option),
          disableRipple: readOnly,
          role: "option",
          "aria-disabled": readOnly,
          "aria-selected": isSelected,
          tabIndex
        }, clockItemProps, {
          children: formattedValue
        }), `${option.valueOf()}-${formattedValue}`);
      })
    })
  }));
});

function getMultiSectionDigitalClockUtilityClass(slot) {
  return generateUtilityClass('MuiMultiSectionDigitalClock', slot);
}
generateUtilityClasses('MuiMultiSectionDigitalClock', ['root']);

function getMultiSectionDigitalClockSectionUtilityClass(slot) {
  return generateUtilityClass('MuiMultiSectionDigitalClockSection', slot);
}
generateUtilityClasses('MuiMultiSectionDigitalClockSection', ['root', 'item']);

const _excluded$y = ["autoFocus", "onChange", "className", "disabled", "readOnly", "items", "active", "slots", "slotProps", "skipDisabled"];
const React$1B = await importShared('react');
const useUtilityClasses$p = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    item: ['item']
  };
  return composeClasses(slots, getMultiSectionDigitalClockSectionUtilityClass, classes);
};
const MultiSectionDigitalClockSectionRoot = styled(MenuList, {
  name: 'MuiMultiSectionDigitalClockSection',
  slot: 'Root',
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT,
  width: 56,
  padding: 0,
  overflow: 'hidden',
  '@media (prefers-reduced-motion: no-preference)': {
    scrollBehavior: 'auto'
  },
  '@media (pointer: fine)': {
    '&:hover': {
      overflowY: 'auto'
    }
  },
  '@media (pointer: none), (pointer: coarse)': {
    overflowY: 'auto'
  },
  '&:not(:first-of-type)': {
    borderLeft: `1px solid ${(theme.vars || theme).palette.divider}`
  },
  '&::after': {
    display: 'block',
    content: '""',
    // subtracting the height of one item, extra margin and borders to make sure the max height is correct
    height: 'calc(100% - 40px - 6px)'
  },
  variants: [{
    props: {
      alreadyRendered: true
    },
    style: {
      '@media (prefers-reduced-motion: no-preference)': {
        scrollBehavior: 'smooth'
      }
    }
  }]
}));
const MultiSectionDigitalClockSectionItem = styled(MenuItem$f, {
  name: 'MuiMultiSectionDigitalClockSection',
  slot: 'Item',
  overridesResolver: (_, styles) => styles.item
})(({
  theme
}) => ({
  padding: 8,
  margin: '2px 4px',
  width: MULTI_SECTION_CLOCK_SECTION_WIDTH,
  justifyContent: 'center',
  '&:first-of-type': {
    marginTop: 4
  },
  '&:hover': {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
  },
  '&.Mui-selected': {
    backgroundColor: (theme.vars || theme).palette.primary.main,
    color: (theme.vars || theme).palette.primary.contrastText,
    '&:focus-visible, &:hover': {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  '&.Mui-focusVisible': {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity)
  }
}));
/**
 * @ignore - internal component.
 */
const MultiSectionDigitalClockSection = /*#__PURE__*/React$1B.forwardRef(function MultiSectionDigitalClockSection(inProps, ref) {
  const containerRef = React$1B.useRef(null);
  const handleRef = useForkRef(ref, containerRef);
  const previousActive = React$1B.useRef(null);
  const props = useThemeProps({
    props: inProps,
    name: 'MuiMultiSectionDigitalClockSection'
  });
  const {
      autoFocus,
      onChange,
      className,
      disabled,
      readOnly,
      items,
      active,
      slots,
      slotProps,
      skipDisabled
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$y);
  const ownerState = React$1B.useMemo(() => _extends$3({}, props, {
    alreadyRendered: !!containerRef.current
  }), [props]);
  const classes = useUtilityClasses$p(ownerState);
  const DigitalClockSectionItem = slots?.digitalClockSectionItem ?? MultiSectionDigitalClockSectionItem;
  React$1B.useEffect(() => {
    if (containerRef.current === null) {
      return;
    }
    const activeItem = containerRef.current.querySelector('[role="option"][tabindex="0"], [role="option"][aria-selected="true"]');
    if (active && autoFocus && activeItem) {
      activeItem.focus();
    }
    if (!activeItem || previousActive.current === activeItem) {
      return;
    }
    previousActive.current = activeItem;
    const offsetTop = activeItem.offsetTop;

    // Subtracting the 4px of extra margin intended for the first visible section item
    containerRef.current.scrollTop = offsetTop - 4;
  });
  const focusedOptionIndex = items.findIndex(item => item.isFocused(item.value));
  const handleKeyDown = event => {
    switch (event.key) {
      case 'PageUp':
        {
          const newIndex = getFocusedListItemIndex(containerRef.current) - 5;
          const children = containerRef.current.children;
          const newFocusedIndex = Math.max(0, newIndex);
          const childToFocus = children[newFocusedIndex];
          if (childToFocus) {
            childToFocus.focus();
          }
          event.preventDefault();
          break;
        }
      case 'PageDown':
        {
          const newIndex = getFocusedListItemIndex(containerRef.current) + 5;
          const children = containerRef.current.children;
          const newFocusedIndex = Math.min(children.length - 1, newIndex);
          const childToFocus = children[newFocusedIndex];
          if (childToFocus) {
            childToFocus.focus();
          }
          event.preventDefault();
          break;
        }
    }
  };
  return /*#__PURE__*/jsxRuntimeExports.jsx(MultiSectionDigitalClockSectionRoot, _extends$3({
    ref: handleRef,
    className: clsx(classes.root, className),
    ownerState: ownerState,
    autoFocusItem: autoFocus && active,
    role: "listbox",
    onKeyDown: handleKeyDown
  }, other, {
    children: items.map((option, index) => {
      const isItemDisabled = option.isDisabled?.(option.value);
      const isDisabled = disabled || isItemDisabled;
      if (skipDisabled && isDisabled) {
        return null;
      }
      const isSelected = option.isSelected(option.value);
      const tabIndex = focusedOptionIndex === index || focusedOptionIndex === -1 && index === 0 ? 0 : -1;
      return /*#__PURE__*/jsxRuntimeExports.jsx(DigitalClockSectionItem, _extends$3({
        onClick: () => !readOnly && onChange(option.value),
        selected: isSelected,
        disabled: isDisabled,
        disableRipple: readOnly,
        role: "option"
        // aria-readonly is not supported here and does not have any effect
        ,
        "aria-disabled": readOnly || isDisabled || undefined,
        "aria-label": option.ariaLabel,
        "aria-selected": isSelected,
        tabIndex: tabIndex,
        className: classes.item
      }, slotProps?.digitalClockSectionItem, {
        children: option.label
      }), option.label);
    })
  }));
});

const getHourSectionOptions = ({
  now,
  value,
  utils,
  ampm,
  isDisabled,
  resolveAriaLabel,
  timeStep,
  valueOrReferenceDate
}) => {
  const currentHours = value ? utils.getHours(value) : null;
  const result = [];
  const isSelected = (hour, overriddenCurrentHours) => {
    const resolvedCurrentHours = overriddenCurrentHours ?? currentHours;
    if (resolvedCurrentHours === null) {
      return false;
    }
    if (ampm) {
      if (hour === 12) {
        return resolvedCurrentHours === 12 || resolvedCurrentHours === 0;
      }
      return resolvedCurrentHours === hour || resolvedCurrentHours - 12 === hour;
    }
    return resolvedCurrentHours === hour;
  };
  const isFocused = hour => {
    return isSelected(hour, utils.getHours(valueOrReferenceDate));
  };
  const endHour = ampm ? 11 : 23;
  for (let hour = 0; hour <= endHour; hour += timeStep) {
    let label = utils.format(utils.setHours(now, hour), ampm ? 'hours12h' : 'hours24h');
    const ariaLabel = resolveAriaLabel(parseInt(label, 10).toString());
    label = utils.formatNumber(label);
    result.push({
      value: hour,
      label,
      isSelected,
      isDisabled,
      isFocused,
      ariaLabel
    });
  }
  return result;
};
const getTimeSectionOptions = ({
  value,
  utils,
  isDisabled,
  timeStep,
  resolveLabel,
  resolveAriaLabel,
  hasValue = true
}) => {
  const isSelected = timeValue => {
    if (value === null) {
      return false;
    }
    return hasValue && value === timeValue;
  };
  const isFocused = timeValue => {
    return value === timeValue;
  };
  return [...Array.from({
    length: Math.ceil(60 / timeStep)
  }, (_, index) => {
    const timeValue = timeStep * index;
    return {
      value: timeValue,
      label: utils.formatNumber(resolveLabel(timeValue)),
      isDisabled,
      isSelected,
      isFocused,
      ariaLabel: resolveAriaLabel(timeValue.toString())
    };
  })];
};

const _excluded$x = ["ampm", "timeSteps", "autoFocus", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableTime", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "skipDisabled", "timezone"];
const React$1A = await importShared('react');
await importShared('prop-types');
const useUtilityClasses$o = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getMultiSectionDigitalClockUtilityClass, classes);
};
const MultiSectionDigitalClockRoot = styled(PickerViewRoot, {
  name: "MuiMultiSectionDigitalClock",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  display: "flex",
  flexDirection: "row",
  width: "100%",
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
}));
const MultiSectionDigitalClock = /* @__PURE__ */ React$1A.forwardRef(function MultiSectionDigitalClock2(inProps, ref) {
  const utils = useUtils();
  const isRtl = useRtl();
  const props = useThemeProps({
    props: inProps,
    name: "MuiMultiSectionDigitalClock"
  });
  const {
    ampm = utils.is12HourCycleInCurrentLocale(),
    timeSteps: inTimeSteps,
    autoFocus,
    slots,
    slotProps,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableIgnoringDatePartForTimeValidation = false,
    maxTime,
    minTime,
    disableFuture,
    disablePast,
    minutesStep = 1,
    shouldDisableTime,
    onChange,
    view: inView,
    views: inViews = ["hours", "minutes"],
    openTo,
    onViewChange,
    focusedView: inFocusedView,
    onFocusedViewChange,
    className,
    disabled,
    readOnly,
    skipDisabled = false,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$x);
  const {
    value,
    handleValueChange: handleRawValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "MultiSectionDigitalClock",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    onChange,
    valueManager: singleItemValueManager
  });
  const translations = usePickersTranslations();
  const now = useNow(timezone);
  const timeSteps = React$1A.useMemo(() => _extends$3({
    hours: 1,
    minutes: 5,
    seconds: 5
  }, inTimeSteps), [inTimeSteps]);
  const valueOrReferenceDate = useClockReferenceDate({
    value,
    referenceDate: referenceDateProp,
    utils,
    props,
    timezone
  });
  const handleValueChange = useEventCallback((newValue, selectionState, selectedView) => handleRawValueChange(newValue, selectionState, selectedView));
  const views = React$1A.useMemo(() => {
    if (!ampm || !inViews.includes("hours")) {
      return inViews;
    }
    return inViews.includes("meridiem") ? inViews : [...inViews, "meridiem"];
  }, [ampm, inViews]);
  const {
    view,
    setValueAndGoToNextView,
    focusedView
  } = useViews({
    view: inView,
    views,
    openTo,
    onViewChange,
    onChange: handleValueChange,
    focusedView: inFocusedView,
    onFocusedViewChange
  });
  const handleMeridiemValueChange = useEventCallback((newValue) => {
    setValueAndGoToNextView(newValue, "finish", "meridiem");
  });
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(valueOrReferenceDate, ampm, handleMeridiemValueChange, "finish");
  const isTimeDisabled = React$1A.useCallback((rawValue, viewType) => {
    const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils);
    const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
    const containsValidTime = ({
      start,
      end
    }) => {
      if (minTime && isAfter(minTime, end)) {
        return false;
      }
      if (maxTime && isAfter(start, maxTime)) {
        return false;
      }
      if (disableFuture && isAfter(start, now)) {
        return false;
      }
      if (disablePast && isAfter(now, shouldCheckPastEnd ? end : start)) {
        return false;
      }
      return true;
    };
    const isValidValue = (timeValue, step = 1) => {
      if (timeValue % step !== 0) {
        return false;
      }
      if (shouldDisableTime) {
        switch (viewType) {
          case "hours":
            return !shouldDisableTime(utils.setHours(valueOrReferenceDate, timeValue), "hours");
          case "minutes":
            return !shouldDisableTime(utils.setMinutes(valueOrReferenceDate, timeValue), "minutes");
          case "seconds":
            return !shouldDisableTime(utils.setSeconds(valueOrReferenceDate, timeValue), "seconds");
          default:
            return false;
        }
      }
      return true;
    };
    switch (viewType) {
      case "hours": {
        const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
        const dateWithNewHours = utils.setHours(valueOrReferenceDate, valueWithMeridiem);
        if (utils.getHours(dateWithNewHours) !== valueWithMeridiem) {
          return true;
        }
        const start = utils.setSeconds(utils.setMinutes(dateWithNewHours, 0), 0);
        const end = utils.setSeconds(utils.setMinutes(dateWithNewHours, 59), 59);
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(valueWithMeridiem);
      }
      case "minutes": {
        const dateWithNewMinutes = utils.setMinutes(valueOrReferenceDate, rawValue);
        const start = utils.setSeconds(dateWithNewMinutes, 0);
        const end = utils.setSeconds(dateWithNewMinutes, 59);
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(rawValue, minutesStep);
      }
      case "seconds": {
        const dateWithNewSeconds = utils.setSeconds(valueOrReferenceDate, rawValue);
        const start = dateWithNewSeconds;
        const end = dateWithNewSeconds;
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(rawValue);
      }
      default:
        throw new Error("not supported");
    }
  }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableTime, utils, disableFuture, disablePast, now, views]);
  const buildViewProps = React$1A.useCallback((viewToBuild) => {
    switch (viewToBuild) {
      case "hours": {
        return {
          onChange: (hours) => {
            const valueWithMeridiem = convertValueToMeridiem(hours, meridiemMode, ampm);
            setValueAndGoToNextView(utils.setHours(valueOrReferenceDate, valueWithMeridiem), "finish", "hours");
          },
          items: getHourSectionOptions({
            now,
            value,
            ampm,
            utils,
            isDisabled: (hours) => isTimeDisabled(hours, "hours"),
            timeStep: timeSteps.hours,
            resolveAriaLabel: translations.hoursClockNumberText,
            valueOrReferenceDate
          })
        };
      }
      case "minutes": {
        return {
          onChange: (minutes) => {
            setValueAndGoToNextView(utils.setMinutes(valueOrReferenceDate, minutes), "finish", "minutes");
          },
          items: getTimeSectionOptions({
            value: utils.getMinutes(valueOrReferenceDate),
            utils,
            isDisabled: (minutes) => isTimeDisabled(minutes, "minutes"),
            resolveLabel: (minutes) => utils.format(utils.setMinutes(now, minutes), "minutes"),
            timeStep: timeSteps.minutes,
            hasValue: !!value,
            resolveAriaLabel: translations.minutesClockNumberText
          })
        };
      }
      case "seconds": {
        return {
          onChange: (seconds) => {
            setValueAndGoToNextView(utils.setSeconds(valueOrReferenceDate, seconds), "finish", "seconds");
          },
          items: getTimeSectionOptions({
            value: utils.getSeconds(valueOrReferenceDate),
            utils,
            isDisabled: (seconds) => isTimeDisabled(seconds, "seconds"),
            resolveLabel: (seconds) => utils.format(utils.setSeconds(now, seconds), "seconds"),
            timeStep: timeSteps.seconds,
            hasValue: !!value,
            resolveAriaLabel: translations.secondsClockNumberText
          })
        };
      }
      case "meridiem": {
        const amLabel = formatMeridiem(utils, "am");
        const pmLabel = formatMeridiem(utils, "pm");
        return {
          onChange: handleMeridiemChange,
          items: [{
            value: "am",
            label: amLabel,
            isSelected: () => !!value && meridiemMode === "am",
            isFocused: () => !!valueOrReferenceDate && meridiemMode === "am",
            ariaLabel: amLabel
          }, {
            value: "pm",
            label: pmLabel,
            isSelected: () => !!value && meridiemMode === "pm",
            isFocused: () => !!valueOrReferenceDate && meridiemMode === "pm",
            ariaLabel: pmLabel
          }]
        };
      }
      default:
        throw new Error(`Unknown view: ${viewToBuild} found.`);
    }
  }, [now, value, ampm, utils, timeSteps.hours, timeSteps.minutes, timeSteps.seconds, translations.hoursClockNumberText, translations.minutesClockNumberText, translations.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, isTimeDisabled, handleMeridiemChange]);
  const viewsToRender = React$1A.useMemo(() => {
    if (!isRtl) {
      return views;
    }
    const digitViews = views.filter((v) => v !== "meridiem");
    digitViews.reverse();
    if (views.includes("meridiem")) {
      digitViews.push("meridiem");
    }
    return digitViews;
  }, [isRtl, views]);
  const viewTimeOptions = React$1A.useMemo(() => {
    return views.reduce((result, currentView) => {
      return _extends$3({}, result, {
        [currentView]: buildViewProps(currentView)
      });
    }, {});
  }, [views, buildViewProps]);
  const ownerState = props;
  const classes = useUtilityClasses$o(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockRoot, _extends$3({
    ref,
    className: clsx(classes.root, className),
    ownerState,
    role: "group"
  }, other, {
    children: viewsToRender.map((timeView) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockSection, {
      items: viewTimeOptions[timeView].items,
      onChange: viewTimeOptions[timeView].onChange,
      active: view === timeView,
      autoFocus: autoFocus || focusedView === timeView,
      disabled,
      readOnly,
      slots,
      slotProps,
      skipDisabled,
      "aria-label": translations.selectViewText(timeView)
    }, timeView))
  }));
});

function getPickersDayUtilityClass(slot) {
  return generateUtilityClass('MuiPickersDay', slot);
}
const pickersDayClasses = generateUtilityClasses('MuiPickersDay', ['root', 'dayWithMargin', 'dayOutsideMonth', 'hiddenDaySpacingFiller', 'today', 'selected', 'disabled']);

const _excluded$w = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "onMouseEnter", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today", "isFirstVisibleCell", "isLastVisibleCell"];
const React$1z = await importShared('react');

await importShared('prop-types');
const useUtilityClasses$n = (ownerState) => {
  const {
    selected,
    disableMargin,
    disableHighlightToday,
    today,
    disabled,
    outsideCurrentMonth,
    showDaysOutsideCurrentMonth,
    classes
  } = ownerState;
  const isHiddenDaySpacingFiller = outsideCurrentMonth && !showDaysOutsideCurrentMonth;
  const slots = {
    root: ["root", selected && !isHiddenDaySpacingFiller && "selected", disabled && "disabled", !disableMargin && "dayWithMargin", !disableHighlightToday && today && "today", outsideCurrentMonth && showDaysOutsideCurrentMonth && "dayOutsideMonth", isHiddenDaySpacingFiller && "hiddenDaySpacingFiller"],
    hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
  };
  return composeClasses(slots, getPickersDayUtilityClass, classes);
};
const styleArg = ({
  theme
}) => _extends$3({}, theme.typography.caption, {
  width: DAY_SIZE,
  height: DAY_SIZE,
  borderRadius: "50%",
  padding: 0,
  // explicitly setting to `transparent` to avoid potentially getting impacted by change from the overridden component
  backgroundColor: "transparent",
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.short
  }),
  color: (theme.vars || theme).palette.text.primary,
  "@media (pointer: fine)": {
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
    }
  },
  "&:focus": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity),
    [`&.${pickersDayClasses.selected}`]: {
      willChange: "background-color",
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  [`&.${pickersDayClasses.selected}`]: {
    color: (theme.vars || theme).palette.primary.contrastText,
    backgroundColor: (theme.vars || theme).palette.primary.main,
    fontWeight: theme.typography.fontWeightMedium,
    "&:hover": {
      willChange: "background-color",
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  [`&.${pickersDayClasses.disabled}:not(.${pickersDayClasses.selected})`]: {
    color: (theme.vars || theme).palette.text.disabled
  },
  [`&.${pickersDayClasses.disabled}&.${pickersDayClasses.selected}`]: {
    opacity: 0.6
  },
  variants: [{
    props: {
      disableMargin: false
    },
    style: {
      margin: `0 ${DAY_MARGIN}px`
    }
  }, {
    props: {
      outsideCurrentMonth: true,
      showDaysOutsideCurrentMonth: true
    },
    style: {
      color: (theme.vars || theme).palette.text.secondary
    }
  }, {
    props: {
      disableHighlightToday: false,
      today: true
    },
    style: {
      [`&:not(.${pickersDayClasses.selected})`]: {
        border: `1px solid ${(theme.vars || theme).palette.text.secondary}`
      }
    }
  }]
});
const overridesResolver = (props, styles) => {
  const {
    ownerState
  } = props;
  return [styles.root, !ownerState.disableMargin && styles.dayWithMargin, !ownerState.disableHighlightToday && ownerState.today && styles.today, !ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && styles.dayOutsideMonth, ownerState.outsideCurrentMonth && !ownerState.showDaysOutsideCurrentMonth && styles.hiddenDaySpacingFiller];
};
const PickersDayRoot = styled(ButtonBase, {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver
})(styleArg);
const PickersDayFiller = styled("div", {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver
})(({
  theme
}) => _extends$3({}, styleArg({
  theme
}), {
  // visibility: 'hidden' does not work here as it hides the element from screen readers as well
  opacity: 0,
  pointerEvents: "none"
}));
const noop = () => {
};
const PickersDayRaw = /* @__PURE__ */ React$1z.forwardRef(function PickersDay2(inProps, forwardedRef) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersDay"
  });
  const {
    autoFocus = false,
    className,
    day,
    disabled = false,
    disableHighlightToday = false,
    disableMargin = false,
    isAnimating,
    onClick,
    onDaySelect,
    onFocus = noop,
    onBlur = noop,
    onKeyDown = noop,
    onMouseDown = noop,
    onMouseEnter = noop,
    outsideCurrentMonth,
    selected = false,
    showDaysOutsideCurrentMonth = false,
    children,
    today: isToday = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$w);
  const ownerState = _extends$3({}, props, {
    autoFocus,
    disabled,
    disableHighlightToday,
    disableMargin,
    selected,
    showDaysOutsideCurrentMonth,
    today: isToday
  });
  const classes = useUtilityClasses$n(ownerState);
  const utils = useUtils();
  const ref = React$1z.useRef(null);
  const handleRef = useForkRef(ref, forwardedRef);
  useEnhancedEffect(() => {
    if (autoFocus && !disabled && !isAnimating && !outsideCurrentMonth) {
      ref.current.focus();
    }
  }, [autoFocus, disabled, isAnimating, outsideCurrentMonth]);
  const handleMouseDown = (event) => {
    onMouseDown(event);
    if (outsideCurrentMonth) {
      event.preventDefault();
    }
  };
  const handleClick = (event) => {
    if (!disabled) {
      onDaySelect(day);
    }
    if (outsideCurrentMonth) {
      event.currentTarget.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  if (outsideCurrentMonth && !showDaysOutsideCurrentMonth) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayFiller, {
      className: clsx(classes.root, classes.hiddenDaySpacingFiller, className),
      ownerState,
      role: other.role
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayRoot, _extends$3({
    className: clsx(classes.root, className),
    ref: handleRef,
    centerRipple: true,
    disabled,
    tabIndex: selected ? 0 : -1,
    onKeyDown: (event) => onKeyDown(event, day),
    onFocus: (event) => onFocus(event, day),
    onBlur: (event) => onBlur(event, day),
    onMouseEnter: (event) => onMouseEnter(event, day),
    onClick: handleClick,
    onMouseDown: handleMouseDown
  }, other, {
    ownerState,
    children: !children ? utils.format(day, "dayOfMonth") : children
  }));
});
const PickersDay = /* @__PURE__ */ React$1z.memo(PickersDayRaw);

const validateDate = ({
  props,
  value,
  timezone,
  adapter
}) => {
  if (value === null) {
    return null;
  }
  const {
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    disablePast,
    disableFuture
  } = props;
  const now = adapter.utils.date(undefined, timezone);
  const minDate = applyDefaultDate(adapter.utils, props.minDate, adapter.defaultDates.minDate);
  const maxDate = applyDefaultDate(adapter.utils, props.maxDate, adapter.defaultDates.maxDate);
  switch (true) {
    case !adapter.utils.isValid(value):
      return 'invalidDate';
    case Boolean(shouldDisableDate && shouldDisableDate(value)):
      return 'shouldDisableDate';
    case Boolean(shouldDisableMonth && shouldDisableMonth(value)):
      return 'shouldDisableMonth';
    case Boolean(shouldDisableYear && shouldDisableYear(value)):
      return 'shouldDisableYear';
    case Boolean(disableFuture && adapter.utils.isAfterDay(value, now)):
      return 'disableFuture';
    case Boolean(disablePast && adapter.utils.isBeforeDay(value, now)):
      return 'disablePast';
    case Boolean(minDate && adapter.utils.isBeforeDay(value, minDate)):
      return 'minDate';
    case Boolean(maxDate && adapter.utils.isAfterDay(value, maxDate)):
      return 'maxDate';
    default:
      return null;
  }
};
validateDate.valueManager = singleItemValueManager;

const validateTime = ({
  adapter,
  value,
  timezone,
  props
}) => {
  if (value === null) {
    return null;
  }
  const {
    minTime,
    maxTime,
    minutesStep,
    shouldDisableTime,
    disableIgnoringDatePartForTimeValidation = false,
    disablePast,
    disableFuture
  } = props;
  const now = adapter.utils.date(undefined, timezone);
  const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, adapter.utils);
  switch (true) {
    case !adapter.utils.isValid(value):
      return 'invalidDate';
    case Boolean(minTime && isAfter(minTime, value)):
      return 'minTime';
    case Boolean(maxTime && isAfter(value, maxTime)):
      return 'maxTime';
    case Boolean(disableFuture && adapter.utils.isAfter(value, now)):
      return 'disableFuture';
    case Boolean(disablePast && adapter.utils.isBefore(value, now)):
      return 'disablePast';
    case Boolean(shouldDisableTime && shouldDisableTime(value, 'hours')):
      return 'shouldDisableTime-hours';
    case Boolean(shouldDisableTime && shouldDisableTime(value, 'minutes')):
      return 'shouldDisableTime-minutes';
    case Boolean(shouldDisableTime && shouldDisableTime(value, 'seconds')):
      return 'shouldDisableTime-seconds';
    case Boolean(minutesStep && adapter.utils.getMinutes(value) % minutesStep !== 0):
      return 'minutesStep';
    default:
      return null;
  }
};
validateTime.valueManager = singleItemValueManager;

const DATE_VALIDATION_PROP_NAMES = ['disablePast', 'disableFuture', 'minDate', 'maxDate', 'shouldDisableDate', 'shouldDisableMonth', 'shouldDisableYear'];
const TIME_VALIDATION_PROP_NAMES = ['disablePast', 'disableFuture', 'minTime', 'maxTime', 'shouldDisableTime', 'minutesStep', 'ampm', 'disableIgnoringDatePartForTimeValidation'];
const DATE_TIME_VALIDATION_PROP_NAMES = ['minDateTime', 'maxDateTime'];
const VALIDATION_PROP_NAMES = [...DATE_VALIDATION_PROP_NAMES, ...TIME_VALIDATION_PROP_NAMES, ...DATE_TIME_VALIDATION_PROP_NAMES];
/**
 * Extract the validation props for the props received by a component.
 * Limit the risk of forgetting some of them and reduce the bundle size.
 */
const extractValidationProps = props => VALIDATION_PROP_NAMES.reduce((extractedProps, propName) => {
  if (props.hasOwnProperty(propName)) {
    extractedProps[propName] = props[propName];
  }
  return extractedProps;
}, {});

const React$1y = await importShared('react');
/**
 * Utility hook to check if a given value is valid based on the provided validation props.
 * @template TDate
 * @template TValue The value type. It will be either the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
 * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
 * @param {UseValidationOptions<TValue, TDate, TError, TValidationProps>} options The options to configure the hook.
 * @param {TValue} options.value The value to validate.
 * @param {PickersTimezone} options.timezone The timezone to use for the validation.
 * @param {Validator<TValue, TDate, TError, TValidationProps>} options.validator The validator function to use.
 * @param {TValidationProps} options.props The validation props, they differ depending on the component.
 * @param {(error: TError, value: TValue) => void} options.onError Callback fired when the error associated with the current value changes.
 */
function useValidation(options) {
  const {
    props,
    validator,
    value,
    timezone,
    onError
  } = options;
  const adapter = useLocalizationContext();
  const previousValidationErrorRef = React$1y.useRef(validator.valueManager.defaultErrorState);
  const validationError = validator({
    adapter,
    value,
    timezone,
    props
  });
  const hasValidationError = validator.valueManager.hasError(validationError);
  React$1y.useEffect(() => {
    if (onError && !validator.valueManager.isSameError(validationError, previousValidationErrorRef.current)) {
      onError(validationError, value);
    }
    previousValidationErrorRef.current = validationError;
  }, [validator, onError, validationError, value]);
  const getValidationErrorForNewValue = useEventCallback(newValue => {
    return validator({
      adapter,
      value: newValue,
      timezone,
      props
    });
  });
  return {
    validationError,
    hasValidationError,
    getValidationErrorForNewValue
  };
}

const expandFormat = ({
  utils,
  format
}) => {
  // Expand the provided format
  let formatExpansionOverflow = 10;
  let prevFormat = format;
  let nextFormat = utils.expandFormat(format);
  while (nextFormat !== prevFormat) {
    prevFormat = nextFormat;
    nextFormat = utils.expandFormat(prevFormat);
    formatExpansionOverflow -= 1;
    if (formatExpansionOverflow < 0) {
      throw new Error('MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.');
    }
  }
  return nextFormat;
};
const getEscapedPartsFromFormat = ({
  utils,
  expandedFormat
}) => {
  const escapedParts = [];
  const {
    start: startChar,
    end: endChar
  } = utils.escapedCharacters;
  const regExp = new RegExp(`(\\${startChar}[^\\${endChar}]*\\${endChar})+`, 'g');
  let match = null;
  // eslint-disable-next-line no-cond-assign
  while (match = regExp.exec(expandedFormat)) {
    escapedParts.push({
      start: match.index,
      end: regExp.lastIndex - 1
    });
  }
  return escapedParts;
};
const getSectionPlaceholder = (utils, localeText, sectionConfig, sectionFormat) => {
  switch (sectionConfig.type) {
    case 'year':
      {
        return localeText.fieldYearPlaceholder({
          digitAmount: utils.formatByString(utils.date(undefined, 'default'), sectionFormat).length,
          format: sectionFormat
        });
      }
    case 'month':
      {
        return localeText.fieldMonthPlaceholder({
          contentType: sectionConfig.contentType,
          format: sectionFormat
        });
      }
    case 'day':
      {
        return localeText.fieldDayPlaceholder({
          format: sectionFormat
        });
      }
    case 'weekDay':
      {
        return localeText.fieldWeekDayPlaceholder({
          contentType: sectionConfig.contentType,
          format: sectionFormat
        });
      }
    case 'hours':
      {
        return localeText.fieldHoursPlaceholder({
          format: sectionFormat
        });
      }
    case 'minutes':
      {
        return localeText.fieldMinutesPlaceholder({
          format: sectionFormat
        });
      }
    case 'seconds':
      {
        return localeText.fieldSecondsPlaceholder({
          format: sectionFormat
        });
      }
    case 'meridiem':
      {
        return localeText.fieldMeridiemPlaceholder({
          format: sectionFormat
        });
      }
    default:
      {
        return sectionFormat;
      }
  }
};
const createSection = ({
  utils,
  date,
  shouldRespectLeadingZeros,
  localeText,
  localizedDigits,
  now,
  token,
  startSeparator
}) => {
  if (token === '') {
    throw new Error('MUI X: Should not call `commitToken` with an empty token');
  }
  const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);
  const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, sectionConfig.contentType, sectionConfig.type, token);
  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';
  const isValidDate = date != null && utils.isValid(date);
  let sectionValue = isValidDate ? utils.formatByString(date, token) : '';
  let maxLength = null;
  if (hasLeadingZerosInInput) {
    if (hasLeadingZerosInFormat) {
      maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;
    } else {
      if (sectionConfig.maxLength == null) {
        throw new Error(`MUI X: The token ${token} should have a 'maxDigitNumber' property on it's adapter`);
      }
      maxLength = sectionConfig.maxLength;
      if (isValidDate) {
        sectionValue = applyLocalizedDigits(cleanLeadingZeros(removeLocalizedDigits(sectionValue, localizedDigits), maxLength), localizedDigits);
      }
    }
  }
  return _extends$3({}, sectionConfig, {
    format: token,
    maxLength,
    value: sectionValue,
    placeholder: getSectionPlaceholder(utils, localeText, sectionConfig, token),
    hasLeadingZerosInFormat,
    hasLeadingZerosInInput,
    startSeparator,
    endSeparator: '',
    modified: false
  });
};
const buildSections = params => {
  const {
    utils,
    expandedFormat,
    escapedParts
  } = params;
  const now = utils.date(undefined);
  const sections = [];
  let startSeparator = '';

  // This RegExp tests if the beginning of a string corresponds to a supported token
  const validTokens = Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length); // Sort to put longest word first

  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;
  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join('|')})*$`);
  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join('|')})`);
  const getEscapedPartOfCurrentChar = i => escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);
  let i = 0;
  while (i < expandedFormat.length) {
    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);
    const isEscapedChar = escapedPartOfCurrentChar != null;
    const firstWordInFormat = regExpFirstWordInFormat.exec(expandedFormat.slice(i))?.[1];

    // The first word in the format is only composed of tokens.
    // We extract those tokens to create a new sections.
    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {
      let word = firstWordInFormat;
      while (word.length > 0) {
        const firstWord = regExpFirstTokenInWord.exec(word)[1];
        word = word.slice(firstWord.length);
        sections.push(createSection(_extends$3({}, params, {
          now,
          token: firstWord,
          startSeparator
        })));
        startSeparator = '';
      }
      i += firstWordInFormat.length;
    }
    // The remaining format does not start with a token,
    // We take the first character and add it to the current section's end separator.
    else {
      const char = expandedFormat[i];

      // If we are on the opening or closing character of an escaped part of the format,
      // Then we ignore this character.
      const isEscapeBoundary = isEscapedChar && escapedPartOfCurrentChar?.start === i || escapedPartOfCurrentChar?.end === i;
      if (!isEscapeBoundary) {
        if (sections.length === 0) {
          startSeparator += char;
        } else {
          sections[sections.length - 1].endSeparator += char;
        }
      }
      i += 1;
    }
  }
  if (sections.length === 0 && startSeparator.length > 0) {
    sections.push({
      type: 'empty',
      contentType: 'letter',
      maxLength: null,
      format: '',
      value: '',
      placeholder: '',
      hasLeadingZerosInFormat: false,
      hasLeadingZerosInInput: false,
      startSeparator,
      endSeparator: '',
      modified: false
    });
  }
  return sections;
};
const postProcessSections = ({
  isRtl,
  formatDensity,
  sections
}) => {
  return sections.map(section => {
    const cleanSeparator = separator => {
      let cleanedSeparator = separator;
      if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {
        cleanedSeparator = `\u2069${cleanedSeparator}\u2066`;
      }
      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {
        cleanedSeparator = ` ${cleanedSeparator} `;
      }
      return cleanedSeparator;
    };
    section.startSeparator = cleanSeparator(section.startSeparator);
    section.endSeparator = cleanSeparator(section.endSeparator);
    return section;
  });
};
const buildSectionsFromFormat = params => {
  let expandedFormat = expandFormat(params);
  if (params.isRtl && params.enableAccessibleFieldDOMStructure) {
    expandedFormat = expandedFormat.split(' ').reverse().join(' ');
  }
  const escapedParts = getEscapedPartsFromFormat(_extends$3({}, params, {
    expandedFormat
  }));
  const sections = buildSections(_extends$3({}, params, {
    expandedFormat,
    escapedParts
  }));
  return postProcessSections(_extends$3({}, params, {
    sections
  }));
};

const React$1x = await importShared('react');
const useFieldState = params => {
  const utils = useUtils();
  const translations = usePickersTranslations();
  const adapter = useLocalizationContext();
  const isRtl = useRtl();
  const {
    valueManager,
    fieldValueManager,
    valueType,
    validator,
    internalProps,
    internalProps: {
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      onChange,
      format,
      formatDensity = 'dense',
      selectedSections: selectedSectionsProp,
      onSelectedSectionsChange,
      shouldRespectLeadingZeros = false,
      timezone: timezoneProp,
      enableAccessibleFieldDOMStructure = false
    }
  } = params;
  const {
    timezone,
    value: valueFromTheOutside,
    handleValueChange
  } = useValueWithTimezone({
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    onChange,
    valueManager
  });
  const localizedDigits = React$1x.useMemo(() => getLocalizedDigits(utils), [utils]);
  const sectionsValueBoundaries = React$1x.useMemo(() => getSectionsBoundaries(utils, localizedDigits, timezone), [utils, localizedDigits, timezone]);
  const getSectionsFromValue = React$1x.useCallback((value, fallbackSections = null) => fieldValueManager.getSectionsFromValue(utils, value, fallbackSections, date => buildSectionsFromFormat({
    utils,
    localeText: translations,
    localizedDigits,
    format,
    date,
    formatDensity,
    shouldRespectLeadingZeros,
    enableAccessibleFieldDOMStructure,
    isRtl
  })), [fieldValueManager, format, translations, localizedDigits, isRtl, shouldRespectLeadingZeros, utils, formatDensity, enableAccessibleFieldDOMStructure]);
  const [state, setState] = React$1x.useState(() => {
    const sections = getSectionsFromValue(valueFromTheOutside);
    const stateWithoutReferenceDate = {
      sections,
      value: valueFromTheOutside,
      referenceValue: valueManager.emptyValue,
      tempValueStrAndroid: null
    };
    const granularity = getSectionTypeGranularity(sections);
    const referenceValue = valueManager.getInitialReferenceValue({
      referenceDate: referenceDateProp,
      value: valueFromTheOutside,
      utils,
      props: internalProps,
      granularity,
      timezone
    });
    return _extends$3({}, stateWithoutReferenceDate, {
      referenceValue
    });
  });
  const [selectedSections, innerSetSelectedSections] = useControlled({
    controlled: selectedSectionsProp,
    default: null,
    name: 'useField',
    state: 'selectedSections'
  });
  const setSelectedSections = newSelectedSections => {
    innerSetSelectedSections(newSelectedSections);
    onSelectedSectionsChange?.(newSelectedSections);
  };
  const parsedSelectedSections = React$1x.useMemo(() => parseSelectedSections(selectedSections, state.sections), [selectedSections, state.sections]);
  const activeSectionIndex = parsedSelectedSections === 'all' ? 0 : parsedSelectedSections;
  const publishValue = ({
    value,
    referenceValue,
    sections
  }) => {
    setState(prevState => _extends$3({}, prevState, {
      sections,
      value,
      referenceValue,
      tempValueStrAndroid: null
    }));
    if (valueManager.areValuesEqual(utils, state.value, value)) {
      return;
    }
    const context = {
      validationError: validator({
        adapter,
        value,
        timezone,
        props: internalProps
      })
    };
    handleValueChange(value, context);
  };
  const setSectionValue = (sectionIndex, newSectionValue) => {
    const newSections = [...state.sections];
    newSections[sectionIndex] = _extends$3({}, newSections[sectionIndex], {
      value: newSectionValue,
      modified: true
    });
    return newSections;
  };
  const clearValue = () => {
    publishValue({
      value: valueManager.emptyValue,
      referenceValue: state.referenceValue,
      sections: getSectionsFromValue(valueManager.emptyValue)
    });
  };
  const clearActiveSection = () => {
    if (activeSectionIndex == null) {
      return;
    }
    const activeSection = state.sections[activeSectionIndex];
    const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);
    const nonEmptySectionCountBefore = activeDateManager.getSections(state.sections).filter(section => section.value !== '').length;
    const hasNoOtherNonEmptySections = nonEmptySectionCountBefore === (activeSection.value === '' ? 0 : 1);
    const newSections = setSectionValue(activeSectionIndex, '');
    const newActiveDate = hasNoOtherNonEmptySections ? null : utils.getInvalidDate();
    const newValues = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
    publishValue(_extends$3({}, newValues, {
      sections: newSections
    }));
  };
  const updateValueFromValueStr = valueStr => {
    const parseDateStr = (dateStr, referenceDate) => {
      const date = utils.parse(dateStr, format);
      if (date == null || !utils.isValid(date)) {
        return null;
      }
      const sections = buildSectionsFromFormat({
        utils,
        localeText: translations,
        localizedDigits,
        format,
        date,
        formatDensity,
        shouldRespectLeadingZeros,
        enableAccessibleFieldDOMStructure,
        isRtl
      });
      return mergeDateIntoReferenceDate(utils, date, sections, referenceDate, false);
    };
    const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);
    const newReferenceValue = fieldValueManager.updateReferenceValue(utils, newValue, state.referenceValue);
    publishValue({
      value: newValue,
      referenceValue: newReferenceValue,
      sections: getSectionsFromValue(newValue, state.sections)
    });
  };
  const updateSectionValue = ({
    activeSection,
    newSectionValue,
    shouldGoToNextSection
  }) => {
    /**
     * 1. Decide which section should be focused
     */
    if (shouldGoToNextSection && activeSectionIndex < state.sections.length - 1) {
      setSelectedSections(activeSectionIndex + 1);
    }

    /**
     * 2. Try to build a valid date from the new section value
     */
    const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);
    const newSections = setSectionValue(activeSectionIndex, newSectionValue);
    const newActiveDateSections = activeDateManager.getSections(newSections);
    const newActiveDate = getDateFromDateSections(utils, newActiveDateSections, localizedDigits);
    let values;
    let shouldPublish;

    /**
     * If the new date is valid,
     * Then we merge the value of the modified sections into the reference date.
     * This makes sure that we don't lose some information of the initial date (like the time on a date field).
     */
    if (newActiveDate != null && utils.isValid(newActiveDate)) {
      const mergedDate = mergeDateIntoReferenceDate(utils, newActiveDate, newActiveDateSections, activeDateManager.referenceDate, true);
      values = activeDateManager.getNewValuesFromNewActiveDate(mergedDate);
      shouldPublish = true;
    } else {
      values = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
      shouldPublish = (newActiveDate != null && !utils.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils.isValid(activeDateManager.date));
    }

    /**
     * Publish or update the internal state with the new value and sections.
     */
    if (shouldPublish) {
      return publishValue(_extends$3({}, values, {
        sections: newSections
      }));
    }
    return setState(prevState => _extends$3({}, prevState, values, {
      sections: newSections,
      tempValueStrAndroid: null
    }));
  };
  const setTempAndroidValueStr = tempValueStrAndroid => setState(prev => _extends$3({}, prev, {
    tempValueStrAndroid
  }));
  React$1x.useEffect(() => {
    const sections = getSectionsFromValue(state.value);
    setState(prevState => _extends$3({}, prevState, {
      sections
    }));
  }, [format, utils.locale, isRtl]); // eslint-disable-line react-hooks/exhaustive-deps

  React$1x.useEffect(() => {
    let shouldUpdate;
    if (!valueManager.areValuesEqual(utils, state.value, valueFromTheOutside)) {
      shouldUpdate = true;
    } else {
      shouldUpdate = valueManager.getTimezone(utils, state.value) !== valueManager.getTimezone(utils, valueFromTheOutside);
    }
    if (shouldUpdate) {
      setState(prevState => _extends$3({}, prevState, {
        value: valueFromTheOutside,
        referenceValue: fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, prevState.referenceValue),
        sections: getSectionsFromValue(valueFromTheOutside)
      }));
    }
  }, [valueFromTheOutside]); // eslint-disable-line react-hooks/exhaustive-deps

  return {
    state,
    activeSectionIndex,
    parsedSelectedSections,
    setSelectedSections,
    clearValue,
    clearActiveSection,
    updateSectionValue,
    updateValueFromValueStr,
    setTempAndroidValueStr,
    getSectionsFromValue,
    sectionsValueBoundaries,
    localizedDigits,
    timezone
  };
};

const React$1w = await importShared('react');

/**
 * The letter editing and the numeric editing each define a `CharacterEditingApplier`.
 * This function decides what the new section value should be and if the focus should switch to the next section.
 *
 * If it returns `null`, then the section value is not updated and the focus does not move.
 */

/**
 * Function called by `applyQuery` which decides:
 * - what is the new section value ?
 * - should the query used to get this value be stored for the next key press ?
 *
 * If it returns `{ sectionValue: string; shouldGoToNextSection: boolean }`,
 * Then we store the query and update the section with the new value.
 *
 * If it returns `{ saveQuery: true` },
 * Then we store the query and don't update the section.
 *
 * If it returns `{ saveQuery: false },
 * Then we do nothing.
 */

const QUERY_LIFE_DURATION_MS = 5000;
const isQueryResponseWithoutValue = response => response.saveQuery != null;

/**
 * Update the active section value when the user pressed a key that is not a navigation key (arrow key for example).
 * This hook has two main editing behaviors
 *
 * 1. The numeric editing when the user presses a digit
 * 2. The letter editing when the user presses another key
 */
const useFieldCharacterEditing = ({
  sections,
  updateSectionValue,
  sectionsValueBoundaries,
  localizedDigits,
  setTempAndroidValueStr,
  timezone
}) => {
  const utils = useUtils();
  const [query, setQuery] = React$1w.useState(null);
  const resetQuery = useEventCallback(() => setQuery(null));
  React$1w.useEffect(() => {
    if (query != null && sections[query.sectionIndex]?.type !== query.sectionType) {
      resetQuery();
    }
  }, [sections, query, resetQuery]);
  React$1w.useEffect(() => {
    if (query != null) {
      const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);
      return () => {
        clearTimeout(timeout);
      };
    }
    return () => {};
  }, [query, resetQuery]);
  const applyQuery = ({
    keyPressed,
    sectionIndex
  }, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {
    const cleanKeyPressed = keyPressed.toLowerCase();
    const activeSection = sections[sectionIndex];

    // The current query targets the section being editing
    // We can try to concatenate the value
    if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {
      const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;
      const queryResponse = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);
      if (!isQueryResponseWithoutValue(queryResponse)) {
        setQuery({
          sectionIndex,
          value: concatenatedQueryValue,
          sectionType: activeSection.type
        });
        return queryResponse;
      }
    }
    const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);
    if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {
      resetQuery();
      return null;
    }
    setQuery({
      sectionIndex,
      value: cleanKeyPressed,
      sectionType: activeSection.type
    });
    if (isQueryResponseWithoutValue(queryResponse)) {
      return null;
    }
    return queryResponse;
  };
  const applyLetterEditing = params => {
    const findMatchingOptions = (format, options, queryValue) => {
      const matchingValues = options.filter(option => option.toLowerCase().startsWith(queryValue));
      if (matchingValues.length === 0) {
        return {
          saveQuery: false
        };
      }
      return {
        sectionValue: matchingValues[0],
        shouldGoToNextSection: matchingValues.length === 1
      };
    };
    const testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, fallbackFormat, formatFallbackValue) => {
      const getOptions = format => getLetterEditingOptions(utils, timezone, activeSection.type, format);
      if (activeSection.contentType === 'letter') {
        return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);
      }

      // When editing a digit-format month / weekDay and the user presses a letter,
      // We can support the letter editing by using the letter-format month / weekDay and re-formatting the result.
      // We just have to make sure that the default month / weekDay format is a letter format,
      if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils, fallbackFormat).contentType === 'letter') {
        const fallbackOptions = getOptions(fallbackFormat);
        const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);
        if (isQueryResponseWithoutValue(response)) {
          return {
            saveQuery: false
          };
        }
        return _extends$3({}, response, {
          sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)
        });
      }
      return {
        saveQuery: false
      };
    };
    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
      switch (activeSection.type) {
        case 'month':
          {
            const formatFallbackValue = fallbackValue => changeSectionValueFormat(utils, fallbackValue, utils.formats.month, activeSection.format);
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.month, formatFallbackValue);
          }
        case 'weekDay':
          {
            const formatFallbackValue = (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString();
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.weekday, formatFallbackValue);
          }
        case 'meridiem':
          {
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);
          }
        default:
          {
            return {
              saveQuery: false
            };
          }
      }
    };
    return applyQuery(params, getFirstSectionValueMatchingWithQuery);
  };
  const applyNumericEditing = params => {
    const getNewSectionValue = (queryValue, section) => {
      const cleanQueryValue = removeLocalizedDigits(queryValue, localizedDigits);
      const queryValueNumber = Number(cleanQueryValue);
      const sectionBoundaries = sectionsValueBoundaries[section.type]({
        currentDate: null,
        format: section.format,
        contentType: section.contentType
      });
      if (queryValueNumber > sectionBoundaries.maximum) {
        return {
          saveQuery: false
        };
      }

      // If the user types `0` on a month section,
      // It is below the minimum, but we want to store the `0` in the query,
      // So that when he pressed `1`, it will store `01` and move to the next section.
      if (queryValueNumber < sectionBoundaries.minimum) {
        return {
          saveQuery: true
        };
      }
      const shouldGoToNextSection = queryValueNumber * 10 > sectionBoundaries.maximum || cleanQueryValue.length === sectionBoundaries.maximum.toString().length;
      const newSectionValue = cleanDigitSectionValue(utils, queryValueNumber, sectionBoundaries, localizedDigits, section);
      return {
        sectionValue: newSectionValue,
        shouldGoToNextSection
      };
    };
    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
      if (activeSection.contentType === 'digit' || activeSection.contentType === 'digit-with-letter') {
        return getNewSectionValue(queryValue, activeSection);
      }

      // When editing a letter-format month and the user presses a digit,
      // We can support the numeric editing by using the digit-format month and re-formatting the result.
      if (activeSection.type === 'month') {
        doesSectionFormatHaveLeadingZeros(utils, 'digit', 'month', 'MM');
        const response = getNewSectionValue(queryValue, {
          type: activeSection.type,
          format: 'MM',
          hasLeadingZerosInInput: true,
          contentType: 'digit',
          maxLength: 2
        });
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = changeSectionValueFormat(utils, response.sectionValue, 'MM', activeSection.format);
        return _extends$3({}, response, {
          sectionValue: formattedValue
        });
      }

      // When editing a letter-format weekDay and the user presses a digit,
      // We can support the numeric editing by returning the nth day in the week day array.
      if (activeSection.type === 'weekDay') {
        const response = getNewSectionValue(queryValue, activeSection);
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = getDaysInWeekStr(utils, activeSection.format)[Number(response.sectionValue) - 1];
        return _extends$3({}, response, {
          sectionValue: formattedValue
        });
      }
      return {
        saveQuery: false
      };
    };
    return applyQuery(params, getFirstSectionValueMatchingWithQuery, queryValue => isStringNumber(queryValue, localizedDigits));
  };
  const applyCharacterEditing = useEventCallback(params => {
    const activeSection = sections[params.sectionIndex];
    const isNumericEditing = isStringNumber(params.keyPressed, localizedDigits);
    const response = isNumericEditing ? applyNumericEditing(_extends$3({}, params, {
      keyPressed: applyLocalizedDigits(params.keyPressed, localizedDigits)
    })) : applyLetterEditing(params);
    if (response == null) {
      setTempAndroidValueStr(null);
      return;
    }
    updateSectionValue({
      activeSection,
      newSectionValue: response.sectionValue,
      shouldGoToNextSection: response.shouldGoToNextSection
    });
  });
  return {
    applyCharacterEditing,
    resetCharacterQuery: resetQuery
  };
};

const React$1v = await importShared('react');
const useFieldV7TextField = params => {
  const {
    internalProps: {
      disabled,
      readOnly = false
    },
    forwardedProps: {
      sectionListRef: inSectionListRef,
      onBlur,
      onClick,
      onFocus,
      onInput,
      onPaste,
      focused: focusedProp,
      autoFocus = false
    },
    fieldValueManager,
    applyCharacterEditing,
    resetCharacterQuery,
    setSelectedSections,
    parsedSelectedSections,
    state,
    clearActiveSection,
    clearValue,
    updateSectionValue,
    updateValueFromValueStr,
    sectionOrder,
    areAllSectionsEmpty,
    sectionsValueBoundaries
  } = params;
  const sectionListRef = React$1v.useRef(null);
  const handleSectionListRef = useForkRef(inSectionListRef, sectionListRef);
  const translations = usePickersTranslations();
  const utils = useUtils();
  const id = useId();
  const [focused, setFocused] = React$1v.useState(false);
  const interactions = React$1v.useMemo(() => ({
    syncSelectionToDOM: () => {
      if (!sectionListRef.current) {
        return;
      }
      const selection = document.getSelection();
      if (!selection) {
        return;
      }
      if (parsedSelectedSections == null) {
        // If the selection contains an element inside the field, we reset it.
        if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {
          selection.removeAllRanges();
        }
        if (focused) {
          sectionListRef.current.getRoot().blur();
        }
        return;
      }

      // On multi input range pickers we want to update selection range only for the active input
      if (!sectionListRef.current.getRoot().contains(getActiveElement(document))) {
        return;
      }
      const range = new window.Range();
      let target;
      if (parsedSelectedSections === 'all') {
        target = sectionListRef.current.getRoot();
      } else {
        const section = state.sections[parsedSelectedSections];
        if (section.type === 'empty') {
          target = sectionListRef.current.getSectionContainer(parsedSelectedSections);
        } else {
          target = sectionListRef.current.getSectionContent(parsedSelectedSections);
        }
      }
      range.selectNodeContents(target);
      target.focus();
      selection.removeAllRanges();
      selection.addRange(range);
    },
    getActiveSectionIndexFromDOM: () => {
      const activeElement = getActiveElement(document);
      if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {
        return null;
      }
      return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);
    },
    focusField: (newSelectedSections = 0) => {
      if (!sectionListRef.current ||
      // if the field is already focused, we don't need to focus it again
      interactions.getActiveSectionIndexFromDOM() != null) {
        return;
      }
      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);
      setFocused(true);
      sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();
    },
    setSelectedSections: newSelectedSections => {
      if (!sectionListRef.current) {
        return;
      }
      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);
      const newActiveSectionIndex = newParsedSelectedSections === 'all' ? 0 : newParsedSelectedSections;
      setFocused(newActiveSectionIndex !== null);
      setSelectedSections(newSelectedSections);
    },
    isFieldFocused: () => {
      const activeElement = getActiveElement(document);
      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);
    }
  }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);

  /**
   * If a section content has been updated with a value we don't want to keep,
   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).
   */
  const revertDOMSectionChange = useEventCallback(sectionIndex => {
    if (!sectionListRef.current) {
      return;
    }
    const section = state.sections[sectionIndex];
    sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;
    interactions.syncSelectionToDOM();
  });
  const handleContainerClick = useEventCallback((event, ...args) => {
    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.
    // We avoid this by checking if the call of `handleContainerClick` is actually intended, or a side effect.
    if (event.isDefaultPrevented() || !sectionListRef.current) {
      return;
    }
    setFocused(true);
    onClick?.(event, ...args);
    if (parsedSelectedSections === 'all') {
      setTimeout(() => {
        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;
        if (cursorPosition === 0) {
          setSelectedSections(sectionOrder.startIndex);
          return;
        }
        let sectionIndex = 0;
        let cursorOnStartOfSection = 0;
        while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {
          const section = state.sections[sectionIndex];
          sectionIndex += 1;
          cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;
        }
        setSelectedSections(sectionIndex - 1);
      });
    } else if (!focused) {
      setFocused(true);
      setSelectedSections(sectionOrder.startIndex);
    } else {
      const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);
      if (!hasClickedOnASection) {
        setSelectedSections(sectionOrder.startIndex);
      }
    }
  });
  const handleContainerInput = useEventCallback(event => {
    onInput?.(event);
    if (!sectionListRef.current || parsedSelectedSections !== 'all') {
      return;
    }
    const target = event.target;
    const keyPressed = target.textContent ?? '';
    sectionListRef.current.getRoot().innerHTML = state.sections.map(section => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join('');
    interactions.syncSelectionToDOM();
    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {
      resetCharacterQuery();
      clearValue();
      setSelectedSections('all');
    } else if (keyPressed.length > 1) {
      updateValueFromValueStr(keyPressed);
    } else {
      if (parsedSelectedSections === 'all') {
        setSelectedSections(0);
      }
      applyCharacterEditing({
        keyPressed,
        sectionIndex: 0
      });
    }
  });
  const handleContainerPaste = useEventCallback(event => {
    onPaste?.(event);
    if (readOnly || parsedSelectedSections !== 'all') {
      event.preventDefault();
      return;
    }
    const pastedValue = event.clipboardData.getData('text');
    event.preventDefault();
    resetCharacterQuery();
    updateValueFromValueStr(pastedValue);
  });
  const handleContainerFocus = useEventCallback((...args) => {
    onFocus?.(...args);
    if (focused || !sectionListRef.current) {
      return;
    }
    setFocused(true);
    const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement(getActiveElement(document)) != null;
    if (!isFocusInsideASection) {
      setSelectedSections(sectionOrder.startIndex);
    }
  });
  const handleContainerBlur = useEventCallback((...args) => {
    onBlur?.(...args);
    setTimeout(() => {
      if (!sectionListRef.current) {
        return;
      }
      const activeElement = getActiveElement(document);
      const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);
      if (shouldBlur) {
        setFocused(false);
        setSelectedSections(null);
      }
    });
  });
  const getInputContainerClickHandler = useEventCallback(sectionIndex => event => {
    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.
    // We avoid this by checking if the call to this function is actually intended, or a side effect.
    if (event.isDefaultPrevented()) {
      return;
    }
    setSelectedSections(sectionIndex);
  });
  const handleInputContentMouseUp = useEventCallback(event => {
    // Without this, the browser will remove the selected when clicking inside an already-selected section.
    event.preventDefault();
  });
  const getInputContentFocusHandler = useEventCallback(sectionIndex => () => {
    setSelectedSections(sectionIndex);
  });
  const handleInputContentPaste = useEventCallback(event => {
    // prevent default to avoid the input `onInput` handler being called
    event.preventDefault();
    if (readOnly || disabled || typeof parsedSelectedSections !== 'number') {
      return;
    }
    const activeSection = state.sections[parsedSelectedSections];
    const pastedValue = event.clipboardData.getData('text');
    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
    const digitsOnly = /^[0-9]+$/.test(pastedValue);
    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;
    if (isValidPastedValue) {
      resetCharacterQuery();
      updateSectionValue({
        activeSection,
        newSectionValue: pastedValue,
        shouldGoToNextSection: true
      });
    }
    // If the pasted value corresponds to a single section, but not the expected type, we skip the modification
    else if (!lettersOnly && !digitsOnly) {
      resetCharacterQuery();
      updateValueFromValueStr(pastedValue);
    }
  });
  const handleInputContentDragOver = useEventCallback(event => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'none';
  });
  const handleInputContentInput = useEventCallback(event => {
    if (!sectionListRef.current) {
      return;
    }
    const target = event.target;
    const keyPressed = target.textContent ?? '';
    const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);
    const section = state.sections[sectionIndex];
    if (readOnly || !sectionListRef.current) {
      revertDOMSectionChange(sectionIndex);
      return;
    }
    if (keyPressed.length === 0) {
      if (section.value === '') {
        revertDOMSectionChange(sectionIndex);
        return;
      }
      const inputType = event.nativeEvent.inputType;
      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {
        revertDOMSectionChange(sectionIndex);
        return;
      }
      resetCharacterQuery();
      clearActiveSection();
      return;
    }
    applyCharacterEditing({
      keyPressed,
      sectionIndex
    });

    // The DOM value needs to remain the one React is expecting.
    revertDOMSectionChange(sectionIndex);
  });
  useEnhancedEffect(() => {
    if (!focused || !sectionListRef.current) {
      return;
    }
    if (parsedSelectedSections === 'all') {
      sectionListRef.current.getRoot().focus();
    } else if (typeof parsedSelectedSections === 'number') {
      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);
      if (domElement) {
        domElement.focus();
      }
    }
  }, [parsedSelectedSections, focused]);
  const sectionBoundaries = React$1v.useMemo(() => {
    return state.sections.reduce((acc, next) => {
      acc[next.type] = sectionsValueBoundaries[next.type]({
        currentDate: null,
        contentType: next.contentType,
        format: next.format
      });
      return acc;
    }, {});
  }, [sectionsValueBoundaries, state.sections]);
  const isContainerEditable = parsedSelectedSections === 'all';
  const elements = React$1v.useMemo(() => {
    return state.sections.map((section, index) => {
      const isEditable = !isContainerEditable && !disabled && !readOnly;
      return {
        container: {
          'data-sectionindex': index,
          onClick: getInputContainerClickHandler(index)
        },
        content: {
          tabIndex: isContainerEditable || index > 0 ? -1 : 0,
          contentEditable: !isContainerEditable && !disabled && !readOnly,
          role: 'spinbutton',
          id: `${id}-${section.type}`,
          'aria-labelledby': `${id}-${section.type}`,
          'aria-readonly': readOnly,
          'aria-valuenow': getSectionValueNow(section, utils),
          'aria-valuemin': sectionBoundaries[section.type].minimum,
          'aria-valuemax': sectionBoundaries[section.type].maximum,
          'aria-valuetext': section.value ? getSectionValueText(section, utils) : translations.empty,
          'aria-label': translations[section.type],
          'aria-disabled': disabled,
          spellCheck: isEditable ? false : undefined,
          autoCapitalize: isEditable ? 'off' : undefined,
          autoCorrect: isEditable ? 'off' : undefined,
          [parseInt(React$1v.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,
          children: section.value || section.placeholder,
          onInput: handleInputContentInput,
          onPaste: handleInputContentPaste,
          onFocus: getInputContentFocusHandler(index),
          onDragOver: handleInputContentDragOver,
          onMouseUp: handleInputContentMouseUp,
          inputMode: section.contentType === 'letter' ? 'text' : 'numeric'
        },
        before: {
          children: section.startSeparator
        },
        after: {
          children: section.endSeparator
        }
      };
    });
  }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils, sectionBoundaries, id]);
  const handleValueStrChange = useEventCallback(event => {
    updateValueFromValueStr(event.target.value);
  });
  const valueStr = React$1v.useMemo(() => areAllSectionsEmpty ? '' : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);
  React$1v.useEffect(() => {
    if (sectionListRef.current == null) {
      throw new Error(['MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`', 'You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.', '', 'If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:', '', '<DatePicker slots={{ textField: MyCustomTextField }} />', '', 'Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element'].join('\n'));
    }
    if (autoFocus && sectionListRef.current) {
      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();
    }
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  return {
    interactions,
    returnedValue: {
      // Forwarded
      autoFocus,
      readOnly,
      focused: focusedProp ?? focused,
      sectionListRef: handleSectionListRef,
      onBlur: handleContainerBlur,
      onClick: handleContainerClick,
      onFocus: handleContainerFocus,
      onInput: handleContainerInput,
      onPaste: handleContainerPaste,
      // Additional
      enableAccessibleFieldDOMStructure: true,
      elements,
      // TODO v7: Try to set to undefined when there is a section selected.
      tabIndex: parsedSelectedSections === 0 ? -1 : 0,
      contentEditable: isContainerEditable,
      value: valueStr,
      onChange: handleValueStrChange,
      areAllSectionsEmpty
    }
  };
};

const React$1u = await importShared('react');
const cleanString = dirtyString => dirtyString.replace(/[\u2066\u2067\u2068\u2069]/g, '');
const addPositionPropertiesToSections = (sections, localizedDigits, isRtl) => {
  let position = 0;
  let positionInInput = isRtl ? 1 : 0;
  const newSections = [];
  for (let i = 0; i < sections.length; i += 1) {
    const section = sections[i];
    const renderedValue = getSectionVisibleValue(section, isRtl ? 'input-rtl' : 'input-ltr', localizedDigits);
    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;
    const sectionLength = cleanString(sectionStr).length;
    const sectionLengthInInput = sectionStr.length;

    // The ...InInput values consider the unicode characters but do include them in their indexes
    const cleanedValue = cleanString(renderedValue);
    const startInInput = positionInInput + (cleanedValue === '' ? 0 : renderedValue.indexOf(cleanedValue[0])) + section.startSeparator.length;
    const endInInput = startInInput + cleanedValue.length;
    newSections.push(_extends$3({}, section, {
      start: position,
      end: position + sectionLength,
      startInInput,
      endInInput
    }));
    position += sectionLength;
    // Move position to the end of string associated to the current section
    positionInInput += sectionLengthInInput;
  }
  return newSections;
};
const useFieldV6TextField = params => {
  const isRtl = useRtl();
  const focusTimeoutRef = React$1u.useRef(undefined);
  const selectionSyncTimeoutRef = React$1u.useRef(undefined);
  const {
    forwardedProps: {
      onFocus,
      onClick,
      onPaste,
      onBlur,
      inputRef: inputRefProp,
      placeholder: inPlaceholder
    },
    internalProps: {
      readOnly = false,
      disabled = false
    },
    parsedSelectedSections,
    activeSectionIndex,
    state,
    fieldValueManager,
    valueManager,
    applyCharacterEditing,
    resetCharacterQuery,
    updateSectionValue,
    updateValueFromValueStr,
    clearActiveSection,
    clearValue,
    setTempAndroidValueStr,
    setSelectedSections,
    getSectionsFromValue,
    areAllSectionsEmpty,
    localizedDigits
  } = params;
  const inputRef = React$1u.useRef(null);
  const handleRef = useForkRef(inputRefProp, inputRef);
  const sections = React$1u.useMemo(() => addPositionPropertiesToSections(state.sections, localizedDigits, isRtl), [state.sections, localizedDigits, isRtl]);
  const interactions = React$1u.useMemo(() => ({
    syncSelectionToDOM: () => {
      if (!inputRef.current) {
        return;
      }
      if (parsedSelectedSections == null) {
        if (inputRef.current.scrollLeft) {
          // Ensure that input content is not marked as selected.
          // setting selection range to 0 causes issues in Safari.
          // https://bugs.webkit.org/show_bug.cgi?id=224425
          inputRef.current.scrollLeft = 0;
        }
        return;
      }

      // On multi input range pickers we want to update selection range only for the active input
      // This helps to avoid the focus jumping on Safari https://github.com/mui/mui-x/issues/9003
      // because WebKit implements the `setSelectionRange` based on the spec: https://bugs.webkit.org/show_bug.cgi?id=224425
      if (inputRef.current !== getActiveElement(document)) {
        return;
      }

      // Fix scroll jumping on iOS browser: https://github.com/mui/mui-x/issues/8321
      const currentScrollTop = inputRef.current.scrollTop;
      if (parsedSelectedSections === 'all') {
        inputRef.current.select();
      } else {
        const selectedSection = sections[parsedSelectedSections];
        const selectionStart = selectedSection.type === 'empty' ? selectedSection.startInInput - selectedSection.startSeparator.length : selectedSection.startInInput;
        const selectionEnd = selectedSection.type === 'empty' ? selectedSection.endInInput + selectedSection.endSeparator.length : selectedSection.endInInput;
        if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {
          if (inputRef.current === getActiveElement(document)) {
            inputRef.current.setSelectionRange(selectionStart, selectionEnd);
          }
        }
        clearTimeout(selectionSyncTimeoutRef.current);
        selectionSyncTimeoutRef.current = setTimeout(() => {
          // handle case when the selection is not updated correctly
          // could happen on Android
          if (inputRef.current && inputRef.current === getActiveElement(document) &&
          // The section might loose all selection, where `selectionStart === selectionEnd`
          // https://github.com/mui/mui-x/pull/13652
          inputRef.current.selectionStart === inputRef.current.selectionEnd && (inputRef.current.selectionStart !== selectionStart || inputRef.current.selectionEnd !== selectionEnd)) {
            interactions.syncSelectionToDOM();
          }
        });
      }

      // Even reading this variable seems to do the trick, but also setting it just to make use of it
      inputRef.current.scrollTop = currentScrollTop;
    },
    getActiveSectionIndexFromDOM: () => {
      const browserStartIndex = inputRef.current.selectionStart ?? 0;
      const browserEndIndex = inputRef.current.selectionEnd ?? 0;
      if (browserStartIndex === 0 && browserEndIndex === 0) {
        return null;
      }
      const nextSectionIndex = browserStartIndex <= sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.
      : sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);
      return nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;
    },
    focusField: (newSelectedSection = 0) => {
      if (getActiveElement(document) === inputRef.current) {
        return;
      }
      inputRef.current?.focus();
      setSelectedSections(newSelectedSection);
    },
    setSelectedSections: newSelectedSections => setSelectedSections(newSelectedSections),
    isFieldFocused: () => inputRef.current === getActiveElement(document)
  }), [inputRef, parsedSelectedSections, sections, setSelectedSections]);
  const syncSelectionFromDOM = () => {
    const browserStartIndex = inputRef.current.selectionStart ?? 0;
    let nextSectionIndex;
    if (browserStartIndex <= sections[0].startInInput) {
      // Special case if browser index is in invisible characters at the beginning
      nextSectionIndex = 1;
    } else if (browserStartIndex >= sections[sections.length - 1].endInInput) {
      // If the click is after the last character of the input, then we want to select the 1st section.
      nextSectionIndex = 1;
    } else {
      nextSectionIndex = sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);
    }
    const sectionIndex = nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;
    setSelectedSections(sectionIndex);
  };
  const handleInputFocus = useEventCallback((...args) => {
    onFocus?.(...args);
    // The ref is guaranteed to be resolved at this point.
    const input = inputRef.current;
    clearTimeout(focusTimeoutRef.current);
    focusTimeoutRef.current = setTimeout(() => {
      // The ref changed, the component got remounted, the focus event is no longer relevant.
      if (!input || input !== inputRef.current) {
        return;
      }
      if (activeSectionIndex != null) {
        return;
      }
      if (
      // avoid selecting all sections when focusing empty field without value
      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {
        setSelectedSections('all');
      } else {
        syncSelectionFromDOM();
      }
    });
  });
  const handleInputClick = useEventCallback((event, ...args) => {
    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.
    // We avoid this by checking if the call of `handleInputClick` is actually intended, or a side effect.
    if (event.isDefaultPrevented()) {
      return;
    }
    onClick?.(event, ...args);
    syncSelectionFromDOM();
  });
  const handleInputPaste = useEventCallback(event => {
    onPaste?.(event);

    // prevent default to avoid the input `onChange` handler being called
    event.preventDefault();
    if (readOnly || disabled) {
      return;
    }
    const pastedValue = event.clipboardData.getData('text');
    if (typeof parsedSelectedSections === 'number') {
      const activeSection = state.sections[parsedSelectedSections];
      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
      const digitsOnly = /^[0-9]+$/.test(pastedValue);
      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;
      if (isValidPastedValue) {
        resetCharacterQuery();
        updateSectionValue({
          activeSection,
          newSectionValue: pastedValue,
          shouldGoToNextSection: true
        });
        return;
      }
      if (lettersOnly || digitsOnly) {
        // The pasted value corresponds to a single section, but not the expected type,
        // skip the modification
        return;
      }
    }
    resetCharacterQuery();
    updateValueFromValueStr(pastedValue);
  });
  const handleContainerBlur = useEventCallback((...args) => {
    onBlur?.(...args);
    setSelectedSections(null);
  });
  const handleInputChange = useEventCallback(event => {
    if (readOnly) {
      return;
    }
    const targetValue = event.target.value;
    if (targetValue === '') {
      resetCharacterQuery();
      clearValue();
      return;
    }
    const eventData = event.nativeEvent.data;
    // Calling `.fill(04/11/2022)` in playwright will trigger a change event with the requested content to insert in `event.nativeEvent.data`
    // usual changes have only the currently typed character in the `event.nativeEvent.data`
    const shouldUseEventData = eventData && eventData.length > 1;
    const valueStr = shouldUseEventData ? eventData : targetValue;
    const cleanValueStr = cleanString(valueStr);
    if (parsedSelectedSections === 'all') {
      setSelectedSections(activeSectionIndex);
    }

    // If no section is selected or eventData should be used, we just try to parse the new value
    // This line is mostly triggered by imperative code / application tests.
    if (activeSectionIndex == null || shouldUseEventData) {
      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);
      return;
    }
    let keyPressed;
    if (parsedSelectedSections === 'all' && cleanValueStr.length === 1) {
      keyPressed = cleanValueStr;
    } else {
      const prevValueStr = cleanString(fieldValueManager.getV6InputValueFromSections(sections, localizedDigits, isRtl));
      let startOfDiffIndex = -1;
      let endOfDiffIndex = -1;
      for (let i = 0; i < prevValueStr.length; i += 1) {
        if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {
          startOfDiffIndex = i;
        }
        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {
          endOfDiffIndex = i;
        }
      }
      const activeSection = sections[activeSectionIndex];
      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;
      if (hasDiffOutsideOfActiveSection) {
        // TODO: Support if the new date is valid
        return;
      }

      // The active section being selected, the browser has replaced its value with the key pressed by the user.
      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;
      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || '').length, activeSectionEndRelativeToNewValue);
    }
    if (keyPressed.length === 0) {
      if (isAndroid()) {
        setTempAndroidValueStr(valueStr);
      }
      resetCharacterQuery();
      clearActiveSection();
      return;
    }
    applyCharacterEditing({
      keyPressed,
      sectionIndex: activeSectionIndex
    });
  });
  const placeholder = React$1u.useMemo(() => {
    if (inPlaceholder !== undefined) {
      return inPlaceholder;
    }
    return fieldValueManager.getV6InputValueFromSections(getSectionsFromValue(valueManager.emptyValue), localizedDigits, isRtl);
  }, [inPlaceholder, fieldValueManager, getSectionsFromValue, valueManager.emptyValue, localizedDigits, isRtl]);
  const valueStr = React$1u.useMemo(() => state.tempValueStrAndroid ?? fieldValueManager.getV6InputValueFromSections(state.sections, localizedDigits, isRtl), [state.sections, fieldValueManager, state.tempValueStrAndroid, localizedDigits, isRtl]);
  React$1u.useEffect(() => {
    // Select all the sections when focused on mount (`autoFocus = true` on the input)
    if (inputRef.current && inputRef.current === getActiveElement(document)) {
      setSelectedSections('all');
    }
    return () => {
      clearTimeout(focusTimeoutRef.current);
      clearTimeout(selectionSyncTimeoutRef.current);
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  const inputMode = React$1u.useMemo(() => {
    if (activeSectionIndex == null) {
      return 'text';
    }
    if (state.sections[activeSectionIndex].contentType === 'letter') {
      return 'text';
    }
    return 'numeric';
  }, [activeSectionIndex, state.sections]);
  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);
  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;
  return {
    interactions,
    returnedValue: {
      // Forwarded
      readOnly,
      onBlur: handleContainerBlur,
      onClick: handleInputClick,
      onFocus: handleInputFocus,
      onPaste: handleInputPaste,
      inputRef: handleRef,
      // Additional
      enableAccessibleFieldDOMStructure: false,
      placeholder,
      inputMode,
      autoComplete: 'off',
      value: shouldShowPlaceholder ? '' : valueStr,
      onChange: handleInputChange
    }
  };
};

const React$1t = await importShared('react');
const useField = params => {
  const utils = useUtils();
  const {
    internalProps,
    internalProps: {
      unstableFieldRef,
      minutesStep,
      enableAccessibleFieldDOMStructure = false,
      disabled = false,
      readOnly = false
    },
    forwardedProps: {
      onKeyDown,
      error,
      clearable,
      onClear
    },
    fieldValueManager,
    valueManager,
    validator
  } = params;
  const isRtl = useRtl();
  const stateResponse = useFieldState(params);
  const {
    state,
    activeSectionIndex,
    parsedSelectedSections,
    setSelectedSections,
    clearValue,
    clearActiveSection,
    updateSectionValue,
    setTempAndroidValueStr,
    sectionsValueBoundaries,
    localizedDigits,
    timezone
  } = stateResponse;
  const characterEditingResponse = useFieldCharacterEditing({
    sections: state.sections,
    updateSectionValue,
    sectionsValueBoundaries,
    localizedDigits,
    setTempAndroidValueStr,
    timezone
  });
  const {
    resetCharacterQuery
  } = characterEditingResponse;
  const areAllSectionsEmpty = valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue);
  const useFieldTextField = enableAccessibleFieldDOMStructure ? useFieldV7TextField : useFieldV6TextField;
  const sectionOrder = React$1t.useMemo(() => getSectionOrder(state.sections, isRtl && !enableAccessibleFieldDOMStructure), [state.sections, isRtl, enableAccessibleFieldDOMStructure]);
  const {
    returnedValue,
    interactions
  } = useFieldTextField(_extends$3({}, params, stateResponse, characterEditingResponse, {
    areAllSectionsEmpty,
    sectionOrder
  }));
  const handleContainerKeyDown = useEventCallback(event => {
    onKeyDown?.(event);
    if (disabled) {
      return;
    }
    // eslint-disable-next-line default-case
    switch (true) {
      // Select all
      case (event.ctrlKey || event.metaKey) && String.fromCharCode(event.keyCode) === 'A' && !event.shiftKey && !event.altKey:
        {
          // prevent default to make sure that the next line "select all" while updating
          // the internal state at the same time.
          event.preventDefault();
          setSelectedSections('all');
          break;
        }

      // Move selection to next section
      case event.key === 'ArrowRight':
        {
          event.preventDefault();
          if (parsedSelectedSections == null) {
            setSelectedSections(sectionOrder.startIndex);
          } else if (parsedSelectedSections === 'all') {
            setSelectedSections(sectionOrder.endIndex);
          } else {
            const nextSectionIndex = sectionOrder.neighbors[parsedSelectedSections].rightIndex;
            if (nextSectionIndex !== null) {
              setSelectedSections(nextSectionIndex);
            }
          }
          break;
        }

      // Move selection to previous section
      case event.key === 'ArrowLeft':
        {
          event.preventDefault();
          if (parsedSelectedSections == null) {
            setSelectedSections(sectionOrder.endIndex);
          } else if (parsedSelectedSections === 'all') {
            setSelectedSections(sectionOrder.startIndex);
          } else {
            const nextSectionIndex = sectionOrder.neighbors[parsedSelectedSections].leftIndex;
            if (nextSectionIndex !== null) {
              setSelectedSections(nextSectionIndex);
            }
          }
          break;
        }

      // Reset the value of the selected section
      case event.key === 'Delete':
        {
          event.preventDefault();
          if (readOnly) {
            break;
          }
          if (parsedSelectedSections == null || parsedSelectedSections === 'all') {
            clearValue();
          } else {
            clearActiveSection();
          }
          resetCharacterQuery();
          break;
        }

      // Increment / decrement the selected section value
      case ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key):
        {
          event.preventDefault();
          if (readOnly || activeSectionIndex == null) {
            break;
          }

          // if all sections are selected, mark the currently editing one as selected
          if (parsedSelectedSections === 'all') {
            setSelectedSections(activeSectionIndex);
          }
          const activeSection = state.sections[activeSectionIndex];
          const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);
          const newSectionValue = adjustSectionValue(utils, timezone, activeSection, event.key, sectionsValueBoundaries, localizedDigits, activeDateManager.date, {
            minutesStep
          });
          updateSectionValue({
            activeSection,
            newSectionValue,
            shouldGoToNextSection: false
          });
          break;
        }
    }
  });
  useEnhancedEffect(() => {
    interactions.syncSelectionToDOM();
  });
  const {
    hasValidationError
  } = useValidation({
    props: internalProps,
    validator,
    timezone,
    value: state.value,
    onError: internalProps.onError
  });
  const inputError = React$1t.useMemo(() => {
    // only override when `error` is undefined.
    // in case of multi input fields, the `error` value is provided externally and will always be defined.
    if (error !== undefined) {
      return error;
    }
    return hasValidationError;
  }, [hasValidationError, error]);
  React$1t.useEffect(() => {
    if (!inputError && activeSectionIndex == null) {
      resetCharacterQuery();
    }
  }, [state.referenceValue, activeSectionIndex, inputError]); // eslint-disable-line react-hooks/exhaustive-deps

  // If `tempValueStrAndroid` is still defined for some section when running `useEffect`,
  // Then `onChange` has only been called once, which means the user pressed `Backspace` to reset the section.
  // This causes a small flickering on Android,
  // But we can't use `useEnhancedEffect` which is always called before the second `onChange` call and then would cause false positives.
  React$1t.useEffect(() => {
    if (state.tempValueStrAndroid != null && activeSectionIndex != null) {
      resetCharacterQuery();
      clearActiveSection();
    }
  }, [state.sections]); // eslint-disable-line react-hooks/exhaustive-deps

  React$1t.useImperativeHandle(unstableFieldRef, () => ({
    getSections: () => state.sections,
    getActiveSectionIndex: interactions.getActiveSectionIndexFromDOM,
    setSelectedSections: interactions.setSelectedSections,
    focusField: interactions.focusField,
    isFieldFocused: interactions.isFieldFocused
  }));
  const handleClearValue = useEventCallback((event, ...args) => {
    event.preventDefault();
    onClear?.(event, ...args);
    clearValue();
    if (!interactions.isFieldFocused()) {
      // setSelectedSections is called internally
      interactions.focusField(0);
    } else {
      setSelectedSections(sectionOrder.startIndex);
    }
  });
  const commonForwardedProps = {
    onKeyDown: handleContainerKeyDown,
    onClear: handleClearValue,
    error: inputError,
    clearable: Boolean(clearable && !areAllSectionsEmpty && !readOnly && !disabled)
  };
  const commonAdditionalProps = {
    disabled,
    readOnly
  };
  return _extends$3({}, params.forwardedProps, commonForwardedProps, commonAdditionalProps, returnedValue);
};

const _excluded$v = ["clearable", "onClear", "InputProps", "sx", "slots", "slotProps"],
  _excluded2$5 = ["ownerState"];
const React$1s = await importShared('react');
const useClearableField = props => {
  const translations = usePickersTranslations();
  const {
      clearable,
      onClear,
      InputProps,
      sx,
      slots,
      slotProps
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$v);
  const IconButton = slots?.clearButton ?? IconButton$e;
  // The spread is here to avoid this bug mui/material-ui#34056
  const _useSlotProps = useSlotProps({
      elementType: IconButton,
      externalSlotProps: slotProps?.clearButton,
      ownerState: {},
      className: 'clearButton',
      additionalProps: {
        title: translations.fieldClearLabel
      }
    }),
    iconButtonProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$5);
  const EndClearIcon = slots?.clearIcon ?? ClearIcon;
  const endClearIconProps = useSlotProps({
    elementType: EndClearIcon,
    externalSlotProps: slotProps?.clearIcon,
    ownerState: {}
  });
  return _extends$3({}, other, {
    InputProps: _extends$3({}, InputProps, {
      endAdornment: /*#__PURE__*/jsxRuntimeExports.jsxs(React$1s.Fragment, {
        children: [clearable && /*#__PURE__*/jsxRuntimeExports.jsx(InputAdornment$5, {
          position: "end",
          sx: {
            marginRight: InputProps?.endAdornment ? -1 : -1.5
          },
          children: /*#__PURE__*/jsxRuntimeExports.jsx(IconButton, _extends$3({}, iconButtonProps, {
            onClick: onClear,
            children: /*#__PURE__*/jsxRuntimeExports.jsx(EndClearIcon, _extends$3({
              fontSize: "small"
            }, endClearIconProps))
          }))
        }), InputProps?.endAdornment]
      })
    }),
    sx: [{
      '& .clearButton': {
        opacity: 1
      },
      '@media (pointer: fine)': {
        '& .clearButton': {
          opacity: 0
        },
        '&:hover, &:focus-within': {
          '.clearButton': {
            opacity: 1
          }
        }
      }
    }, ...(Array.isArray(sx) ? sx : [sx])]
  });
};

const React$1r = await importShared('react');
const SHARED_FIELD_INTERNAL_PROP_NAMES = ['value', 'defaultValue', 'referenceDate', 'format', 'formatDensity', 'onChange', 'timezone', 'onError', 'shouldRespectLeadingZeros', 'selectedSections', 'onSelectedSectionsChange', 'unstableFieldRef', 'enableAccessibleFieldDOMStructure', 'disabled', 'readOnly', 'dateSeparator'];
/**
 * Split the props received by the field component into:
 * - `internalProps` which are used by the various hooks called by the field component.
 * - `forwardedProps` which are passed to the underlying component.
 * Note that some forwarded props might be used by the hooks as well.
 * For instance, hooks like `useDateField` need props like `autoFocus` to know how to behave.
 * @template TProps, TValueType
 * @param {TProps} props The props received by the field component.
 * @param {TValueType} valueType The type of the field value ('date', 'time', or 'date-time').
 */
const useSplitFieldProps = (props, valueType) => {
  return React$1r.useMemo(() => {
    const forwardedProps = _extends$3({}, props);
    const internalProps = {};
    const extractProp = propName => {
      if (forwardedProps.hasOwnProperty(propName)) {
        // @ts-ignore
        internalProps[propName] = forwardedProps[propName];
        delete forwardedProps[propName];
      }
    };
    SHARED_FIELD_INTERNAL_PROP_NAMES.forEach(extractProp);
    if (valueType === 'date') {
      DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
    } else if (valueType === 'time') {
      TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
    } else if (valueType === 'date-time') {
      DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
      TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
      DATE_TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
    }
    return {
      forwardedProps,
      internalProps
    };
  }, [props, valueType]);
};

const React$1q = await importShared('react');
const PickersContext = /*#__PURE__*/React$1q.createContext(null);

/**
 * Provides the context for the various parts of a picker component:
 * - contextValue: the context for the picker sub-components.
 * - localizationProvider: the translations passed through the props and through a parent LocalizationProvider.
 *
 * @ignore - do not document.
 */
function PickersProvider(props) {
  const {
    contextValue,
    localeText,
    children
  } = props;
  return /*#__PURE__*/jsxRuntimeExports.jsx(PickersContext.Provider, {
    value: contextValue,
    children: /*#__PURE__*/jsxRuntimeExports.jsx(LocalizationProvider, {
      localeText: localeText,
      children: children
    })
  });
}

const useDefaultizedDateField = props => {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  return _extends$3({}, props, {
    disablePast: props.disablePast ?? false,
    disableFuture: props.disableFuture ?? false,
    format: props.format ?? utils.formats.keyboardDate,
    minDate: applyDefaultDate(utils, props.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, props.maxDate, defaultDates.maxDate)
  });
};
const useDefaultizedTimeField = props => {
  const utils = useUtils();
  const ampm = props.ampm ?? utils.is12HourCycleInCurrentLocale();
  const defaultFormat = ampm ? utils.formats.fullTime12h : utils.formats.fullTime24h;
  return _extends$3({}, props, {
    disablePast: props.disablePast ?? false,
    disableFuture: props.disableFuture ?? false,
    format: props.format ?? defaultFormat
  });
};

const useDateField = inProps => {
  const props = useDefaultizedDateField(inProps);
  const {
    forwardedProps,
    internalProps
  } = useSplitFieldProps(props, 'date');
  return useField({
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateDate,
    valueType: 'date'
  });
};

function getPickersTextFieldUtilityClass(slot) {
  return generateUtilityClass('MuiPickersTextField', slot);
}
generateUtilityClasses('MuiPickersTextField', ['root', 'focused', 'disabled', 'error', 'required']);

function getPickersInputBaseUtilityClass(slot) {
  return generateUtilityClass('MuiPickersInputBase', slot);
}
const pickersInputBaseClasses = generateUtilityClasses('MuiPickersInputBase', ['root', 'focused', 'disabled', 'error', 'notchedOutline', 'sectionContent', 'sectionBefore', 'sectionAfter', 'adornedStart', 'adornedEnd', 'input']);

function getPickersSectionListUtilityClass(slot) {
  return generateUtilityClass('MuiPickersSectionList', slot);
}
const pickersSectionListClasses = generateUtilityClasses('MuiPickersSectionList', ['root', 'section', 'sectionContent']);

const _excluded$u = ["slots", "slotProps", "elements", "sectionListRef"];
const React$1p = await importShared('react');

await importShared('prop-types');
const PickersSectionListRoot = styled("div", {
  name: "MuiPickersSectionList",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  direction: "ltr /*! @noflip */",
  outline: "none"
});
const PickersSectionListSection = styled("span", {
  name: "MuiPickersSectionList",
  slot: "Section",
  overridesResolver: (props, styles) => styles.section
})({});
const PickersSectionListSectionSeparator = styled("span", {
  name: "MuiPickersSectionList",
  slot: "SectionSeparator",
  overridesResolver: (props, styles) => styles.sectionSeparator
})({
  whiteSpace: "pre"
});
const PickersSectionListSectionContent = styled("span", {
  name: "MuiPickersSectionList",
  slot: "SectionContent",
  overridesResolver: (props, styles) => styles.sectionContent
})({
  outline: "none"
});
const useUtilityClasses$m = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    section: ["section"],
    sectionContent: ["sectionContent"]
  };
  return composeClasses(slots, getPickersSectionListUtilityClass, classes);
};
function PickersSection(props) {
  const {
    slots,
    slotProps,
    element,
    classes
  } = props;
  const Section = slots?.section ?? PickersSectionListSection;
  const sectionProps = useSlotProps({
    elementType: Section,
    externalSlotProps: slotProps?.section,
    externalForwardedProps: element.container,
    className: classes.section,
    ownerState: {}
  });
  const SectionContent = slots?.sectionContent ?? PickersSectionListSectionContent;
  const sectionContentProps = useSlotProps({
    elementType: SectionContent,
    externalSlotProps: slotProps?.sectionContent,
    externalForwardedProps: element.content,
    additionalProps: {
      suppressContentEditableWarning: true
    },
    className: classes.sectionContent,
    ownerState: {}
  });
  const SectionSeparator = slots?.sectionSeparator ?? PickersSectionListSectionSeparator;
  const sectionSeparatorBeforeProps = useSlotProps({
    elementType: SectionSeparator,
    externalSlotProps: slotProps?.sectionSeparator,
    externalForwardedProps: element.before,
    ownerState: {
      position: "before"
    }
  });
  const sectionSeparatorAfterProps = useSlotProps({
    elementType: SectionSeparator,
    externalSlotProps: slotProps?.sectionSeparator,
    externalForwardedProps: element.after,
    ownerState: {
      position: "after"
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, _extends$3({}, sectionProps, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SectionSeparator, _extends$3({}, sectionSeparatorBeforeProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(SectionContent, _extends$3({}, sectionContentProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(SectionSeparator, _extends$3({}, sectionSeparatorAfterProps))]
  }));
}
const PickersSectionList = /* @__PURE__ */ React$1p.forwardRef(function PickersSectionList2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersSectionList"
  });
  const {
    slots,
    slotProps,
    elements,
    sectionListRef
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$u);
  const classes = useUtilityClasses$m(props);
  const rootRef = React$1p.useRef(null);
  const handleRootRef = useForkRef(ref, rootRef);
  const getRoot = (methodName) => {
    if (!rootRef.current) {
      throw new Error(`MUI X: Cannot call sectionListRef.${methodName} before the mount of the component.`);
    }
    return rootRef.current;
  };
  React$1p.useImperativeHandle(sectionListRef, () => ({
    getRoot() {
      return getRoot("getRoot");
    },
    getSectionContainer(index) {
      const root = getRoot("getSectionContainer");
      return root.querySelector(`.${pickersSectionListClasses.section}[data-sectionindex="${index}"]`);
    },
    getSectionContent(index) {
      const root = getRoot("getSectionContent");
      return root.querySelector(`.${pickersSectionListClasses.section}[data-sectionindex="${index}"] .${pickersSectionListClasses.sectionContent}`);
    },
    getSectionIndexFromDOMElement(element) {
      const root = getRoot("getSectionIndexFromDOMElement");
      if (element == null || !root.contains(element)) {
        return null;
      }
      let sectionContainer = null;
      if (element.classList.contains(pickersSectionListClasses.section)) {
        sectionContainer = element;
      } else if (element.classList.contains(pickersSectionListClasses.sectionContent)) {
        sectionContainer = element.parentElement;
      }
      if (sectionContainer == null) {
        return null;
      }
      return Number(sectionContainer.dataset.sectionindex);
    }
  }));
  const Root = slots?.root ?? PickersSectionListRoot;
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps?.root,
    externalForwardedProps: other,
    additionalProps: {
      ref: handleRootRef,
      suppressContentEditableWarning: true
    },
    className: classes.root,
    ownerState: {}
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$3({}, rootProps, {
    children: rootProps.contentEditable ? elements.map(({
      content,
      before,
      after
    }) => `${before.children}${content.children}${after.children}`).join("") : /* @__PURE__ */ jsxRuntimeExports.jsx(React$1p.Fragment, {
      children: elements.map((element, elementIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSection, {
        slots,
        slotProps,
        element,
        classes
      }, elementIndex))
    })
  }));
});

const _excluded$t = ["elements", "areAllSectionsEmpty", "defaultValue", "label", "value", "onChange", "id", "autoFocus", "endAdornment", "startAdornment", "renderSuffix", "slots", "slotProps", "contentEditable", "tabIndex", "onInput", "onPaste", "onKeyDown", "fullWidth", "name", "readOnly", "inputProps", "inputRef", "sectionListRef"];
const React$1o = await importShared('react');

await importShared('prop-types');
const round = (value) => Math.round(value * 1e5) / 1e5;
const PickersInputBaseRoot = styled("div", {
  name: "MuiPickersInputBase",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => _extends$3({}, theme.typography.body1, {
  color: (theme.vars || theme).palette.text.primary,
  cursor: "text",
  padding: 0,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  letterSpacing: `${round(0.15 / 16)}em`,
  variants: [{
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }]
}));
const PickersInputBaseSectionsContainer = styled(PickersSectionListRoot, {
  name: "MuiPickersInputBase",
  slot: "SectionsContainer",
  overridesResolver: (props, styles) => styles.sectionsContainer
})(({
  theme
}) => ({
  padding: "4px 0 5px",
  fontFamily: theme.typography.fontFamily,
  fontSize: "inherit",
  lineHeight: "1.4375em",
  // 23px
  flexGrow: 1,
  outline: "none",
  display: "flex",
  flexWrap: "nowrap",
  overflow: "hidden",
  letterSpacing: "inherit",
  // Baseline behavior
  width: "182px",
  variants: [{
    props: {
      isRtl: true
    },
    style: {
      textAlign: "right /*! @noflip */"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      paddingTop: 1
    }
  }, {
    props: {
      adornedStart: false,
      focused: false,
      filled: false
    },
    style: {
      color: "currentColor",
      opacity: 0
    }
  }, {
    // Can't use the object notation because label can be null or undefined
    props: ({
      adornedStart,
      focused,
      filled,
      label
    }) => !adornedStart && !focused && !filled && label == null,
    style: theme.vars ? {
      opacity: theme.vars.opacity.inputPlaceholder
    } : {
      opacity: theme.palette.mode === "light" ? 0.42 : 0.5
    }
  }]
}));
const PickersInputBaseSection = styled(PickersSectionListSection, {
  name: "MuiPickersInputBase",
  slot: "Section",
  overridesResolver: (props, styles) => styles.section
})(({
  theme
}) => ({
  fontFamily: theme.typography.fontFamily,
  fontSize: "inherit",
  letterSpacing: "inherit",
  lineHeight: "1.4375em",
  // 23px
  display: "inline-block",
  whiteSpace: "nowrap"
}));
const PickersInputBaseSectionContent = styled(PickersSectionListSectionContent, {
  name: "MuiPickersInputBase",
  slot: "SectionContent",
  overridesResolver: (props, styles) => styles.content
})(({
  theme
}) => ({
  fontFamily: theme.typography.fontFamily,
  lineHeight: "1.4375em",
  // 23px
  letterSpacing: "inherit",
  width: "fit-content",
  outline: "none"
}));
const PickersInputBaseSectionSeparator = styled(PickersSectionListSectionSeparator, {
  name: "MuiPickersInputBase",
  slot: "Separator",
  overridesResolver: (props, styles) => styles.separator
})(() => ({
  whiteSpace: "pre",
  letterSpacing: "inherit"
}));
const PickersInputBaseInput = styled("input", {
  name: "MuiPickersInputBase",
  slot: "Input",
  overridesResolver: (props, styles) => styles.hiddenInput
})(_extends$3({}, visuallyHidden));
const useUtilityClasses$l = (ownerState) => {
  const {
    focused,
    disabled,
    error,
    classes,
    fullWidth,
    readOnly,
    color,
    size,
    endAdornment,
    startAdornment
  } = ownerState;
  const slots = {
    root: ["root", focused && !disabled && "focused", disabled && "disabled", readOnly && "readOnly", error && "error", fullWidth && "fullWidth", `color${capitalize$1(color)}`, size === "small" && "inputSizeSmall", Boolean(startAdornment) && "adornedStart", Boolean(endAdornment) && "adornedEnd"],
    notchedOutline: ["notchedOutline"],
    input: ["input"],
    sectionsContainer: ["sectionsContainer"],
    sectionContent: ["sectionContent"],
    sectionBefore: ["sectionBefore"],
    sectionAfter: ["sectionAfter"]
  };
  return composeClasses(slots, getPickersInputBaseUtilityClass, classes);
};
const PickersInputBase = /* @__PURE__ */ React$1o.forwardRef(function PickersInputBase2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersInputBase"
  });
  const {
    elements,
    areAllSectionsEmpty,
    value,
    onChange,
    id,
    endAdornment,
    startAdornment,
    renderSuffix,
    slots,
    slotProps,
    contentEditable,
    tabIndex,
    onInput,
    onPaste,
    onKeyDown,
    name,
    readOnly,
    inputProps,
    inputRef,
    sectionListRef
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$t);
  const rootRef = React$1o.useRef(null);
  const handleRootRef = useForkRef(ref, rootRef);
  const handleInputRef = useForkRef(inputProps?.ref, inputRef);
  const isRtl = useRtl();
  const muiFormControl = useFormControl();
  if (!muiFormControl) {
    throw new Error("MUI X: PickersInputBase should always be used inside a PickersTextField component");
  }
  const handleInputFocus = (event) => {
    if (muiFormControl.disabled) {
      event.stopPropagation();
      return;
    }
    muiFormControl.onFocus?.(event);
  };
  React$1o.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  React$1o.useEffect(() => {
    if (!muiFormControl) {
      return;
    }
    if (areAllSectionsEmpty) {
      muiFormControl.onEmpty();
    } else {
      muiFormControl.onFilled();
    }
  }, [muiFormControl, areAllSectionsEmpty]);
  const ownerState = _extends$3({}, props, muiFormControl, {
    isRtl
  });
  const classes = useUtilityClasses$l(ownerState);
  const InputRoot = slots?.root || PickersInputBaseRoot;
  const inputRootProps = useSlotProps({
    elementType: InputRoot,
    externalSlotProps: slotProps?.root,
    externalForwardedProps: other,
    additionalProps: {
      "aria-invalid": muiFormControl.error,
      ref: handleRootRef
    },
    className: classes.root,
    ownerState
  });
  const InputSectionsContainer = slots?.input || PickersInputBaseSectionsContainer;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(InputRoot, _extends$3({}, inputRootProps, {
    children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSectionList, {
      sectionListRef,
      elements,
      contentEditable,
      tabIndex,
      className: classes.sectionsContainer,
      onFocus: handleInputFocus,
      onBlur: muiFormControl.onBlur,
      onInput,
      onPaste,
      onKeyDown,
      slots: {
        root: InputSectionsContainer,
        section: PickersInputBaseSection,
        sectionContent: PickersInputBaseSectionContent,
        sectionSeparator: PickersInputBaseSectionSeparator
      },
      slotProps: {
        root: {
          ownerState
        },
        sectionContent: {
          className: pickersInputBaseClasses.sectionContent
        },
        sectionSeparator: ({
          position
        }) => ({
          className: position === "before" ? pickersInputBaseClasses.sectionBefore : pickersInputBaseClasses.sectionAfter
        })
      }
    }), endAdornment, renderSuffix ? renderSuffix(_extends$3({}, muiFormControl)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBaseInput, _extends$3({
      name,
      className: classes.input,
      value,
      onChange,
      id,
      "aria-hidden": "true",
      tabIndex: -1,
      readOnly,
      required: muiFormControl.required,
      disabled: muiFormControl.disabled
    }, inputProps, {
      ref: handleInputRef
    }))]
  }));
});

function getPickersOutlinedInputUtilityClass(slot) {
  return generateUtilityClass('MuiPickersOutlinedInput', slot);
}
const pickersOutlinedInputClasses = _extends$3({}, pickersInputBaseClasses, generateUtilityClasses('MuiPickersOutlinedInput', ['root', 'notchedOutline', 'input']));

const _excluded$s = ["children", "className", "label", "notched", "shrink"];
await importShared('react');
const OutlineRoot = styled('fieldset', {
  name: 'MuiPickersOutlinedInput',
  slot: 'NotchedOutline',
  overridesResolver: (props, styles) => styles.notchedOutline
})(({
  theme
}) => {
  const borderColor = theme.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
  return {
    textAlign: 'left',
    position: 'absolute',
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: '0 8px',
    pointerEvents: 'none',
    borderRadius: 'inherit',
    borderStyle: 'solid',
    borderWidth: 1,
    overflow: 'hidden',
    minWidth: '0%',
    borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor
  };
});
const OutlineLabel = styled('span')(({
  theme
}) => ({
  fontFamily: theme.typography.fontFamily,
  fontSize: 'inherit'
}));
const OutlineLegend = styled('legend')(({
  theme
}) => ({
  float: 'unset',
  // Fix conflict with bootstrap
  width: 'auto',
  // Fix conflict with bootstrap
  overflow: 'hidden',
  // Fix Horizontal scroll when label too long
  variants: [{
    props: {
      withLabel: false
    },
    style: {
      padding: 0,
      lineHeight: '11px',
      // sync with `height` in `legend` styles
      transition: theme.transitions.create('width', {
        duration: 150,
        easing: theme.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      withLabel: true
    },
    style: {
      display: 'block',
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: '0.75em',
      visibility: 'hidden',
      maxWidth: 0.01,
      transition: theme.transitions.create('max-width', {
        duration: 50,
        easing: theme.transitions.easing.easeOut
      }),
      whiteSpace: 'nowrap',
      '& > span': {
        paddingLeft: 5,
        paddingRight: 5,
        display: 'inline-block',
        opacity: 0,
        visibility: 'visible'
      }
    }
  }, {
    props: {
      withLabel: true,
      notched: true
    },
    style: {
      maxWidth: '100%',
      transition: theme.transitions.create('max-width', {
        duration: 100,
        easing: theme.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
}));

/**
 * @ignore - internal component.
 */
function Outline(props) {
  const {
      className,
      label
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$s);
  const withLabel = label != null && label !== '';
  const ownerState = _extends$3({}, props, {
    withLabel
  });
  return /*#__PURE__*/jsxRuntimeExports.jsx(OutlineRoot, _extends$3({
    "aria-hidden": true,
    className: className
  }, other, {
    ownerState: ownerState,
    children: /*#__PURE__*/jsxRuntimeExports.jsx(OutlineLegend, {
      ownerState: ownerState,
      children: withLabel ? /*#__PURE__*/jsxRuntimeExports.jsx(OutlineLabel, {
        children: label
      }) :
      /*#__PURE__*/
      // notranslate needed while Google Translate will not fix zero-width space issue
      jsxRuntimeExports.jsx(OutlineLabel, {
        className: "notranslate",
        children: "\u200B"
      })
    })
  }));
}

const _excluded$r = ["label", "autoFocus", "ownerState", "notched"];
const React$1n = await importShared('react');

await importShared('prop-types');
const PickersOutlinedInputRoot = styled(PickersInputBaseRoot, {
  name: "MuiPickersOutlinedInput",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => {
  const borderColor = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    padding: "0 14px",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    [`&:hover .${pickersOutlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${pickersOutlinedInputClasses.notchedOutline}`]: {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor
      }
    },
    [`&.${pickersOutlinedInputClasses.focused} .${pickersOutlinedInputClasses.notchedOutline}`]: {
      borderStyle: "solid",
      borderWidth: 2
    },
    [`&.${pickersOutlinedInputClasses.disabled}`]: {
      [`& .${pickersOutlinedInputClasses.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.action.disabled
      },
      "*": {
        color: (theme.vars || theme).palette.action.disabled
      }
    },
    [`&.${pickersOutlinedInputClasses.error} .${pickersOutlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.error.main
    },
    variants: Object.keys((theme.vars ?? theme).palette).filter((key) => (theme.vars ?? theme).palette[key]?.main ?? false).map((color) => ({
      props: {
        color
      },
      style: {
        [`&.${pickersOutlinedInputClasses.focused}:not(.${pickersOutlinedInputClasses.error}) .${pickersOutlinedInputClasses.notchedOutline}`]: {
          // @ts-ignore
          borderColor: (theme.vars || theme).palette[color].main
        }
      }
    }))
  };
});
const PickersOutlinedInputSectionsContainer = styled(PickersInputBaseSectionsContainer, {
  name: "MuiPickersOutlinedInput",
  slot: "SectionsContainer",
  overridesResolver: (props, styles) => styles.sectionsContainer
})({
  padding: "16.5px 0",
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 0"
    }
  }]
});
const useUtilityClasses$k = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getPickersOutlinedInputUtilityClass, classes);
  return _extends$3({}, classes, composedClasses);
};
const PickersOutlinedInput = /* @__PURE__ */ React$1n.forwardRef(function PickersOutlinedInput2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersOutlinedInput"
  });
  const {
    label,
    ownerState: ownerStateProp,
    notched
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$r);
  const muiFormControl = useFormControl();
  const ownerState = _extends$3({}, props, ownerStateProp, muiFormControl, {
    color: muiFormControl?.color || "primary"
  });
  const classes = useUtilityClasses$k(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$3({
    slots: {
      root: PickersOutlinedInputRoot,
      input: PickersOutlinedInputSectionsContainer
    },
    renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(Outline, {
      shrink: Boolean(notched || state.adornedStart || state.focused || state.filled),
      notched: Boolean(notched || state.adornedStart || state.focused || state.filled),
      className: classes.notchedOutline,
      label: label != null && label !== "" && muiFormControl?.required ? /* @__PURE__ */ jsxRuntimeExports.jsxs(React$1n.Fragment, {
        children: [label, " ", "*"]
      }) : label,
      ownerState
    })
  }, other, {
    label,
    classes,
    ref
  }));
});
PickersOutlinedInput.muiName = "Input";

/**
 * WARNING: Don't import this directly. It's imported by the code generated by
 * `@mui/interal-babel-plugin-minify-errors`. Make sure to always use string literals in `Error`
 * constructors to ensure the plugin works as expected. Supported patterns include:
 *   throw new Error('My message');
 *   throw new Error(`My message: ${foo}`);
 *   throw new Error(`My message: ${foo}` + 'another string');
 *   ...
 * @param {number} code
 */
function formatMuiErrorMessage(code, ...args) {
  const url = new URL(`https://mui.com/production-error/?code=${code}`);
  args.forEach(arg => url.searchParams.append('args[]', arg));
  return `Minified MUI error #${code}; visit ${url} for the full message.`;
}

const React$1m = await importShared('react');

// https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
function isPlainObject(item) {
  if (typeof item !== 'object' || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (/*#__PURE__*/React$1m.isValidElement(source) || reactIsExports.isValidElementType(source) || !isPlainObject(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach(key => {
    output[key] = deepClone(source[key]);
  });
  return output;
}

/**
 * Merge objects deeply.
 * It will shallow copy React elements.
 *
 * If `options.clone` is set to `false` the source object will be merged directly into the target object.
 *
 * @example
 * ```ts
 * deepmerge({ a: { b: 1 }, d: 2 }, { a: { c: 2 }, d: 4 });
 * // => { a: { b: 1, c: 2 }, d: 4 }
 * ````
 *
 * @param target The target object.
 * @param source The source object.
 * @param options The merge options.
 * @param options.clone Set to `false` to merge the source object directly into the target object.
 * @returns The merged object.
 */
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? {
    ...target
  } : target;
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach(key => {
      if (/*#__PURE__*/React$1m.isValidElement(source[key]) || reactIsExports.isValidElementType(source[key])) {
        output[key] = source[key];
      } else if (isPlainObject(source[key]) &&
      // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) {
        // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}

// Sorted ASC by size. That's important.
// It can't be configured as it's used statically for propTypes.
const sortBreakpointsValues = values => {
  const breakpointsAsArray = Object.keys(values).map(key => ({
    key,
    val: values[key]
  })) || [];
  // Sort in ascending order
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return {
      ...acc,
      [obj.key]: obj.val
    };
  }, {});
};

// Keep in mind that @media is inclusive by the CSS specification.
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536 // large screen
    },
    unit = 'px',
    step = 5,
    ...other
  } = breakpoints;
  const sortedValues = sortBreakpointsValues(values);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values[key] === 'number' ? values[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values[key] === 'number' ? values[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex]] === 'number' ? values[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    // handle first and last key separately, for better readability
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace('@media', '@media not all and');
  }
  return {
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit,
    ...other
  };
}

function sortContainerQueries(theme, css) {
  if (!theme.containerQueries) {
    return css;
  }
  const sorted = Object.keys(css).filter((key) => key.startsWith("@container")).sort((a, b) => {
    const regex = /min-width:\s*([0-9.]+)/;
    return +(a.match(regex)?.[1] || 0) - +(b.match(regex)?.[1] || 0);
  });
  if (!sorted.length) {
    return css;
  }
  return sorted.reduce((acc, key) => {
    const value = css[key];
    delete acc[key];
    acc[key] = value;
    return acc;
  }, {
    ...css
  });
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
  function attachCq(node2, name) {
    node2.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
    node2.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
    node2.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
    node2.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
    node2.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node = {};
  const containerQueries = (name) => {
    attachCq(node, name);
    return node;
  };
  attachCq(containerQueries);
  return {
    ...themeInput,
    containerQueries
  };
}

const shape = {
  borderRadius: 4
};

function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false // No need to clone deep, it's way faster.
  });
}

await importShared('prop-types');
const values = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values[key]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key) => {
      let result = typeof key === "number" ? key : values[key] || key;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  const breakpointsInOrder = breakpointsInput.keys?.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style);
}

function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = {};
  fn.filterProps = [prop];
  return fn;
}

function memoize$1(fn) {
  const cache = {};
  return arg => {
    if (cache[arg] === undefined) {
      cache[arg] = fn(arg);
    }
    return cache[arg];
  };
}

const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize$1((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b] = prop.split("");
  const property = properties[a];
  const direction = directions[b] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      if (typeof themeSpacing === "string") {
        if (themeSpacing.startsWith("var(") && val === 0) {
          return 0;
        }
        if (themeSpacing.startsWith("var(") && val === 1) {
          return themeSpacing;
        }
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs = Math.abs(val);
      const transformed = themeSpacing[abs];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      if (typeof transformed === "string" && transformed.startsWith("var(")) {
        return `calc(-1 * ${transformed})`;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue$1(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue$1(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (!keys.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;

function createSpacing(spacingInput = 8, transform = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}

function compose(...styles) {
  const handlers = styles.reduce((acc, style) => {
    style.filterProps.forEach((prop) => {
      acc[prop] = style;
    });
    return acc;
  }, {});
  const fn = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = {};
  fn.filterProps = styles.reduce((acc, style) => acc.concat(style.filterProps), []);
  return fn;
}

function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$1({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue$1(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);

const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue$1(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue$1(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue$1(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

function paletteTransform(value, userValue) {
  if (userValue === 'grey') {
    return userValue;
  }
  return value;
}
const color = style$1({
  prop: 'color',
  themeKey: 'palette',
  transform: paletteTransform
});
const bgcolor = style$1({
  prop: 'bgcolor',
  cssProperty: 'backgroundColor',
  themeKey: 'palette',
  transform: paletteTransform
});
const backgroundColor = style$1({
  prop: 'backgroundColor',
  themeKey: 'palette',
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);

function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$1({
  prop: 'width',
  transform: sizingTransform
});
const maxWidth = props => {
  if (props.maxWidth !== undefined && props.maxWidth !== null) {
    const styleFromPropValue = propValue => {
      const breakpoint = props.theme?.breakpoints?.values?.[propValue] || values[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (props.theme?.breakpoints?.unit !== 'px') {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ['maxWidth'];
const minWidth = style$1({
  prop: 'minWidth',
  transform: sizingTransform
});
const height = style$1({
  prop: 'height',
  transform: sizingTransform
});
const maxHeight = style$1({
  prop: 'maxHeight',
  transform: sizingTransform
});
const minHeight = style$1({
  prop: 'minHeight',
  transform: sizingTransform
});
style$1({
  prop: 'size',
  cssProperty: 'width',
  transform: sizingTransform
});
style$1({
  prop: 'size',
  cssProperty: 'height',
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: 'boxSizing'
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);

const defaultSxConfig = {
  // borders
  border: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderTop: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderRight: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderBottom: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderLeft: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderColor: {
    themeKey: 'palette'
  },
  borderTopColor: {
    themeKey: 'palette'
  },
  borderRightColor: {
    themeKey: 'palette'
  },
  borderBottomColor: {
    themeKey: 'palette'
  },
  borderLeftColor: {
    themeKey: 'palette'
  },
  outline: {
    themeKey: 'borders',
    transform: borderTransform
  },
  outlineColor: {
    themeKey: 'palette'
  },
  borderRadius: {
    themeKey: 'shape.borderRadius',
    style: borderRadius
  },
  // palette
  color: {
    themeKey: 'palette',
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: 'palette',
    cssProperty: 'backgroundColor',
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: 'palette',
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: value => ({
      '@media print': {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: 'zIndex'
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: 'shadows'
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: 'font'
  },
  fontFamily: {
    themeKey: 'typography'
  },
  fontSize: {
    themeKey: 'typography'
  },
  fontStyle: {
    themeKey: 'typography'
  },
  fontWeight: {
    themeKey: 'typography'
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: 'typography'
  }
};

function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every(object => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
}

// eslint-disable-next-line @typescript-eslint/naming-convention
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style
    } = options;
    if (val == null) {
      return null;
    }

    // TODO v6: remove, see https://github.com/mui/material-ui/pull/38123
    if (themeKey === 'typography' && val === 'inherit') {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style) {
      return style(props);
    }
    const styleFromPropValue = propValueFinal => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === 'string') {
        // Haven't found value
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx(props) {
    const {
      sx,
      theme = {},
      nested
    } = props || {};
    if (!sx) {
      return null; // Emotion & styled-components will neglect null
    }
    const config = theme.unstable_sxConfig ?? defaultSxConfig;

    /*
     * Receive `sxInput` as object or callback
     * and then recursively check keys & values to create media query object styles.
     * (the result will be used in `styled`)
     */
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === 'function') {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== 'object') {
        // value
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css = emptyBreakpoints;
      Object.keys(sxObject).forEach(styleKey => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== undefined) {
          if (typeof value === 'object') {
            if (config[styleKey]) {
              css = merge(css, getThemeValue(styleKey, value, theme, config));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, x => ({
                [styleKey]: x
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css[styleKey] = styleFunctionSx({
                  sx: value,
                  theme,
                  nested: true
                });
              } else {
                css = merge(css, breakpointsValues);
              }
            }
          } else {
            css = merge(css, getThemeValue(styleKey, value, theme, config));
          }
        }
      });
      if (!nested && theme.modularCssLayers) {
        return {
          '@layer sx': sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css))
        };
      }
      return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ['sx'];

/**
 * A universal utility to style components with multiple color modes. Always use it from the theme object.
 * It works with:
 *  - [Basic theme](https://mui.com/material-ui/customization/dark-mode/)
 *  - [CSS theme variables](https://mui.com/material-ui/customization/css-theme-variables/overview/)
 *  - Zero-runtime engine
 *
 * Tips: Use an array over object spread and place `theme.applyStyles()` last.
 *
 * With the styled function:
 * ✅ [{ background: '#e5e5e5' }, theme.applyStyles('dark', { background: '#1c1c1c' })]
 * 🚫 { background: '#e5e5e5', ...theme.applyStyles('dark', { background: '#1c1c1c' })}
 *
 * With the sx prop:
 * ✅ [{ background: '#e5e5e5' }, theme => theme.applyStyles('dark', { background: '#1c1c1c' })]
 * 🚫 { background: '#e5e5e5', ...theme => theme.applyStyles('dark', { background: '#1c1c1c' })}
 *
 * @example
 * 1. using with `styled`:
 * ```jsx
 *   const Component = styled('div')(({ theme }) => [
 *     { background: '#e5e5e5' },
 *     theme.applyStyles('dark', {
 *       background: '#1c1c1c',
 *       color: '#fff',
 *     }),
 *   ]);
 * ```
 *
 * @example
 * 2. using with `sx` prop:
 * ```jsx
 *   <Box sx={[
 *     { background: '#e5e5e5' },
 *     theme => theme.applyStyles('dark', {
 *        background: '#1c1c1c',
 *        color: '#fff',
 *      }),
 *     ]}
 *   />
 * ```
 *
 * @example
 * 3. theming a component:
 * ```jsx
 *   extendTheme({
 *     components: {
 *       MuiButton: {
 *         styleOverrides: {
 *           root: ({ theme }) => [
 *             { background: '#e5e5e5' },
 *             theme.applyStyles('dark', {
 *               background: '#1c1c1c',
 *               color: '#fff',
 *             }),
 *           ],
 *         },
 *       }
 *     }
 *   })
 *```
 */
function applyStyles(key, styles) {
  // @ts-expect-error this is 'any' type
  const theme = this;
  if (theme.vars) {
    if (!theme.colorSchemes?.[key] || typeof theme.getColorSchemeSelector !== 'function') {
      return {};
    }
    // If CssVarsProvider is used as a provider, returns '*:where({selector}) &'
    let selector = theme.getColorSchemeSelector(key);
    if (selector === '&') {
      return styles;
    }
    if (selector.includes('data-') || selector.includes('.')) {
      // '*' is required as a workaround for Emotion issue (https://github.com/emotion-js/emotion/issues/2836)
      selector = `*:where(${selector.replace(/\s*&$/, '')}) &`;
    }
    return {
      [selector]: styles
    };
  }
  if (theme.palette.mode === key) {
    return styles;
  }
  return {};
}

function createTheme(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {},
    ...other
  } = options;
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: 'ltr',
    components: {},
    // Inject component definitions.
    palette: {
      mode: 'light',
      ...paletteInput
    },
    spacing,
    shape: {
      ...shape,
      ...shapeInput
    }
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other?.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}

createTheme();
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}

function getPickersFilledInputUtilityClass(slot) {
  return generateUtilityClass('MuiPickersFilledInput', slot);
}
const pickersFilledInputClasses = _extends$3({}, pickersInputBaseClasses, generateUtilityClasses('MuiPickersFilledInput', ['root', 'underline', 'input']));

const _excluded$q = ["label", "autoFocus", "disableUnderline", "ownerState"];
const React$1l = await importShared('react');

await importShared('prop-types');
const PickersFilledInputRoot = styled(PickersInputBaseRoot, {
  name: "MuiPickersFilledInput",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root,
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "disableUnderline"
})(({
  theme
}) => {
  const light = theme.palette.mode === "light";
  const bottomLineColor = light ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor = light ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor,
    borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
    borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.shorter,
      easing: theme.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor
      }
    },
    [`&.${pickersFilledInputClasses.focused}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor
    },
    [`&.${pickersFilledInputClasses.disabled}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
    },
    variants: [...Object.keys((theme.vars ?? theme).palette).filter((key) => (theme.vars ?? theme).palette[key].main).map((color) => ({
      props: {
        color,
        disableUnderline: false
      },
      style: {
        "&::after": {
          // @ts-ignore
          borderBottom: `2px solid ${(theme.vars || theme).palette[color]?.main}`
        }
      }
    })), {
      props: {
        disableUnderline: false
      },
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${pickersFilledInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${pickersFilledInputClasses.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${pickersFilledInputClasses.disabled}, .${pickersFilledInputClasses.error}):before`]: {
          borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
        },
        [`&.${pickersFilledInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, {
      props: ({
        startAdornment
      }) => !!startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        endAdornment
      }) => !!endAdornment,
      style: {
        paddingRight: 12
      }
    }]
  };
});
const PickersFilledSectionsContainer = styled(PickersInputBaseSectionsContainer, {
  name: "MuiPickersFilledInput",
  slot: "sectionsContainer",
  overridesResolver: (props, styles) => styles.sectionsContainer
})({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      startAdornment
    }) => !!startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      endAdornment
    }) => !!endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: {
      hiddenLabel: true
    },
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: {
      hiddenLabel: true,
      size: "small"
    },
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }]
});
const useUtilityClasses$j = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getPickersFilledInputUtilityClass, classes);
  return _extends$3({}, classes, composedClasses);
};
const PickersFilledInput = /* @__PURE__ */ React$1l.forwardRef(function PickersFilledInput2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersFilledInput"
  });
  const {
    label,
    disableUnderline = false,
    ownerState: ownerStateProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$q);
  const muiFormControl = useFormControl();
  const ownerState = _extends$3({}, props, ownerStateProp, muiFormControl, {
    color: muiFormControl?.color || "primary"
  });
  const classes = useUtilityClasses$j(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$3({
    slots: {
      root: PickersFilledInputRoot,
      input: PickersFilledSectionsContainer
    },
    slotProps: {
      root: {
        disableUnderline
      }
    }
  }, other, {
    label,
    classes,
    ref
  }));
});
PickersFilledInput.muiName = "Input";

function getPickersInputUtilityClass(slot) {
  return generateUtilityClass('MuiPickersFilledInput', slot);
}
const pickersInputClasses = _extends$3({}, pickersInputBaseClasses, generateUtilityClasses('MuiPickersInput', ['root', 'input']));

const _excluded$p = ["label", "autoFocus", "disableUnderline", "ownerState"];
const React$1k = await importShared('react');

await importShared('prop-types');
const PickersInputRoot = styled(PickersInputBaseRoot, {
  name: "MuiPickersInput",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => {
  const light = theme.palette.mode === "light";
  let bottomLineColor = light ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme.vars) {
    bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
  }
  return {
    "label + &": {
      marginTop: 16
    },
    variants: [...Object.keys((theme.vars ?? theme).palette).filter((key) => (theme.vars ?? theme).palette[key].main).map((color) => ({
      props: {
        color
      },
      style: {
        "&::after": {
          // @ts-ignore
          borderBottom: `2px solid ${(theme.vars || theme).palette[color].main}`
        }
      }
    })), {
      props: {
        disableUnderline: false
      },
      style: {
        "&::after": {
          background: "red",
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${pickersInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${pickersInputClasses.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${pickersInputClasses.disabled}, .${pickersInputClasses.error}):before`]: {
          borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${pickersInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }]
  };
});
const useUtilityClasses$i = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getPickersInputUtilityClass, classes);
  return _extends$3({}, classes, composedClasses);
};
const PickersInput = /* @__PURE__ */ React$1k.forwardRef(function PickersInput2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersInput"
  });
  const {
    label,
    disableUnderline = false,
    ownerState: ownerStateProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$p);
  const muiFormControl = useFormControl();
  const ownerState = _extends$3({}, props, ownerStateProp, muiFormControl, {
    disableUnderline,
    color: muiFormControl?.color || "primary"
  });
  const classes = useUtilityClasses$i(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$3({
    slots: {
      root: PickersInputRoot
    }
  }, other, {
    label,
    classes,
    ref
  }));
});
PickersInput.muiName = "Input";

const _excluded$o = ["onFocus", "onBlur", "className", "color", "disabled", "error", "variant", "required", "InputProps", "inputProps", "inputRef", "sectionListRef", "elements", "areAllSectionsEmpty", "onClick", "onKeyDown", "onKeyUp", "onPaste", "onInput", "endAdornment", "startAdornment", "tabIndex", "contentEditable", "focused", "value", "onChange", "fullWidth", "id", "name", "helperText", "FormHelperTextProps", "label", "InputLabelProps"];
const React$1j = await importShared('react');

await importShared('prop-types');
const VARIANT_COMPONENT = {
  standard: PickersInput,
  filled: PickersFilledInput,
  outlined: PickersOutlinedInput
};
const PickersTextFieldRoot = styled(FormControl$n, {
  name: "MuiPickersTextField",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  maxWidth: "100%"
});
const useUtilityClasses$h = (ownerState) => {
  const {
    focused,
    disabled,
    classes,
    required
  } = ownerState;
  const slots = {
    root: ["root", focused && !disabled && "focused", disabled && "disabled", required && "required"]
  };
  return composeClasses(slots, getPickersTextFieldUtilityClass, classes);
};
const PickersTextField = /* @__PURE__ */ React$1j.forwardRef(function PickersTextField2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersTextField"
  });
  const {
    // Props used by FormControl
    onFocus,
    onBlur,
    className,
    color = "primary",
    disabled = false,
    error = false,
    variant = "outlined",
    required = false,
    // Props used by PickersInput
    InputProps,
    inputProps,
    inputRef,
    sectionListRef,
    elements,
    areAllSectionsEmpty,
    onClick,
    onKeyDown,
    onKeyUp,
    onPaste,
    onInput,
    endAdornment,
    startAdornment,
    tabIndex,
    contentEditable,
    focused,
    value,
    onChange,
    fullWidth,
    id: idProp,
    name,
    // Props used by FormHelperText
    helperText,
    FormHelperTextProps,
    // Props used by InputLabel
    label,
    InputLabelProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$o);
  const rootRef = React$1j.useRef(null);
  const handleRootRef = useForkRef(ref, rootRef);
  const id = useId(idProp);
  const helperTextId = helperText && id ? `${id}-helper-text` : void 0;
  const inputLabelId = label && id ? `${id}-label` : void 0;
  const ownerState = _extends$3({}, props, {
    color,
    disabled,
    error,
    focused,
    required,
    variant
  });
  const classes = useUtilityClasses$h(ownerState);
  const PickersInputComponent = VARIANT_COMPONENT[variant];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersTextFieldRoot, _extends$3({
    className: clsx(classes.root, className),
    ref: handleRootRef,
    focused,
    onFocus,
    onBlur,
    disabled,
    variant,
    error,
    color,
    fullWidth,
    required,
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$i, _extends$3({
      htmlFor: id,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputComponent, _extends$3({
      elements,
      areAllSectionsEmpty,
      onClick,
      onKeyDown,
      onKeyUp,
      onInput,
      onPaste,
      endAdornment,
      startAdornment,
      tabIndex,
      contentEditable,
      value,
      onChange,
      id,
      fullWidth,
      inputProps,
      inputRef,
      sectionListRef,
      label,
      name,
      role: "group",
      "aria-labelledby": inputLabelId,
      "aria-describedby": helperTextId,
      "aria-live": helperTextId ? "polite" : void 0
    }, InputProps)), helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText$k, _extends$3({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
});

const _excluded$n = ["enableAccessibleFieldDOMStructure"],
  _excluded2$4 = ["InputProps", "readOnly"],
  _excluded3$1 = ["onPaste", "onKeyDown", "inputMode", "readOnly", "InputProps", "inputProps", "inputRef"];
const convertFieldResponseIntoMuiTextFieldProps = _ref => {
  let {
      enableAccessibleFieldDOMStructure
    } = _ref,
    fieldResponse = _objectWithoutPropertiesLoose(_ref, _excluded$n);
  if (enableAccessibleFieldDOMStructure) {
    const {
        InputProps,
        readOnly
      } = fieldResponse,
      other = _objectWithoutPropertiesLoose(fieldResponse, _excluded2$4);
    return _extends$3({}, other, {
      InputProps: _extends$3({}, InputProps ?? {}, {
        readOnly
      })
    });
  }
  const {
      onPaste,
      onKeyDown,
      inputMode,
      readOnly,
      InputProps,
      inputProps,
      inputRef
    } = fieldResponse,
    other = _objectWithoutPropertiesLoose(fieldResponse, _excluded3$1);
  return _extends$3({}, other, {
    InputProps: _extends$3({}, InputProps ?? {}, {
      readOnly
    }),
    inputProps: _extends$3({}, inputProps ?? {}, {
      inputMode,
      onPaste,
      onKeyDown,
      ref: inputRef
    })
  });
};

const _excluded$m = ["slots", "slotProps", "InputProps", "inputProps"];
const React$1i = await importShared('react');

await importShared('prop-types');
const DateField = /* @__PURE__ */ React$1i.forwardRef(function DateField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiDateField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded$m);
  const ownerState = themeProps;
  const TextField = slots?.textField ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField$n);
  const textFieldProps = useSlotProps({
    elementType: TextField,
    externalSlotProps: slotProps?.textField,
    externalForwardedProps: other,
    additionalProps: {
      ref: inRef
    },
    ownerState
  });
  textFieldProps.inputProps = _extends$3({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends$3({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useDateField(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends$3({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, _extends$3({}, processedFieldProps));
});

const useTimeField = inProps => {
  const props = useDefaultizedTimeField(inProps);
  const {
    forwardedProps,
    internalProps
  } = useSplitFieldProps(props, 'time');
  return useField({
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateTime,
    valueType: 'time'
  });
};

const _excluded$l = ["slots", "slotProps", "InputProps", "inputProps"];
const React$1h = await importShared('react');

await importShared('prop-types');
const TimeField = /* @__PURE__ */ React$1h.forwardRef(function TimeField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiTimeField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded$l);
  const ownerState = themeProps;
  const TextField = slots?.textField ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField$n);
  const textFieldProps = useSlotProps({
    elementType: TextField,
    externalSlotProps: slotProps?.textField,
    externalForwardedProps: other,
    ownerState,
    additionalProps: {
      ref: inRef
    }
  });
  textFieldProps.inputProps = _extends$3({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends$3({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useTimeField(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends$3({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, _extends$3({}, processedFieldProps));
});

const React$1g = await importShared('react');
const useIsDateDisabled = ({
  shouldDisableDate,
  shouldDisableMonth,
  shouldDisableYear,
  minDate,
  maxDate,
  disableFuture,
  disablePast,
  timezone
}) => {
  const adapter = useLocalizationContext();
  return React$1g.useCallback(day => validateDate({
    adapter,
    value: day,
    timezone,
    props: {
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      minDate,
      maxDate,
      disableFuture,
      disablePast
    }
  }) !== null, [adapter, shouldDisableDate, shouldDisableMonth, shouldDisableYear, minDate, maxDate, disableFuture, disablePast, timezone]);
};

const React$1f = await importShared('react');
const createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils) => (state, action) => {
  switch (action.type) {
    case 'changeMonth':
      return _extends$3({}, state, {
        slideDirection: action.direction,
        currentMonth: action.newMonth,
        isMonthSwitchingAnimating: !reduceAnimations
      });
    case 'changeMonthTimezone':
      {
        const newTimezone = action.newTimezone;
        if (utils.getTimezone(state.currentMonth) === newTimezone) {
          return state;
        }
        let newCurrentMonth = utils.setTimezone(state.currentMonth, newTimezone);
        if (utils.getMonth(newCurrentMonth) !== utils.getMonth(state.currentMonth)) {
          newCurrentMonth = utils.setMonth(newCurrentMonth, utils.getMonth(state.currentMonth));
        }
        return _extends$3({}, state, {
          currentMonth: newCurrentMonth
        });
      }
    case 'finishMonthSwitchingAnimation':
      return _extends$3({}, state, {
        isMonthSwitchingAnimating: false
      });
    case 'changeFocusedDay':
      {
        if (state.focusedDay != null && action.focusedDay != null && utils.isSameDay(action.focusedDay, state.focusedDay)) {
          return state;
        }
        const needMonthSwitch = action.focusedDay != null && !disableSwitchToMonthOnDayFocus && !utils.isSameMonth(state.currentMonth, action.focusedDay);
        return _extends$3({}, state, {
          focusedDay: action.focusedDay,
          isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations && !action.withoutMonthSwitchingAnimation,
          currentMonth: needMonthSwitch ? utils.startOfMonth(action.focusedDay) : state.currentMonth,
          slideDirection: action.focusedDay != null && utils.isAfterDay(action.focusedDay, state.currentMonth) ? 'left' : 'right'
        });
      }
    default:
      throw new Error('missing support');
  }
};
const useCalendarState = params => {
  const {
    value,
    referenceDate: referenceDateProp,
    disableFuture,
    disablePast,
    disableSwitchToMonthOnDayFocus = false,
    maxDate,
    minDate,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate,
    timezone
  } = params;
  const utils = useUtils();
  const reducerFn = React$1f.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils)).current;
  const referenceDate = React$1f.useMemo(() => {
    return singleItemValueManager.getInitialReferenceValue({
      value,
      utils,
      timezone,
      props: params,
      referenceDate: referenceDateProp,
      granularity: SECTION_TYPE_GRANULARITY.day
    });
  },
  // We want the `referenceDate` to update on prop and `timezone` change (https://github.com/mui/mui-x/issues/10804)
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [referenceDateProp, timezone]);
  const [calendarState, dispatch] = React$1f.useReducer(reducerFn, {
    isMonthSwitchingAnimating: false,
    focusedDay: referenceDate,
    currentMonth: utils.startOfMonth(referenceDate),
    slideDirection: 'left'
  });

  // Ensure that `calendarState.currentMonth` timezone is updated when `referenceDate` (or timezone changes)
  // https://github.com/mui/mui-x/issues/10804
  React$1f.useEffect(() => {
    dispatch({
      type: 'changeMonthTimezone',
      newTimezone: utils.getTimezone(referenceDate)
    });
  }, [referenceDate, utils]);
  const handleChangeMonth = React$1f.useCallback(payload => {
    dispatch(_extends$3({
      type: 'changeMonth'
    }, payload));
    if (onMonthChange) {
      onMonthChange(payload.newMonth);
    }
  }, [onMonthChange]);
  const changeMonth = React$1f.useCallback(newDate => {
    const newDateRequested = newDate;
    if (utils.isSameMonth(newDateRequested, calendarState.currentMonth)) {
      return;
    }
    handleChangeMonth({
      newMonth: utils.startOfMonth(newDateRequested),
      direction: utils.isAfterDay(newDateRequested, calendarState.currentMonth) ? 'left' : 'right'
    });
  }, [calendarState.currentMonth, handleChangeMonth, utils]);
  const isDateDisabled = useIsDateDisabled({
    shouldDisableDate,
    minDate,
    maxDate,
    disableFuture,
    disablePast,
    timezone
  });
  const onMonthSwitchingAnimationEnd = React$1f.useCallback(() => {
    dispatch({
      type: 'finishMonthSwitchingAnimation'
    });
  }, []);
  const changeFocusedDay = useEventCallback((newFocusedDate, withoutMonthSwitchingAnimation) => {
    if (!isDateDisabled(newFocusedDate)) {
      dispatch({
        type: 'changeFocusedDay',
        focusedDay: newFocusedDate,
        withoutMonthSwitchingAnimation
      });
    }
  });
  return {
    referenceDate,
    calendarState,
    changeMonth,
    changeFocusedDay,
    isDateDisabled,
    onMonthSwitchingAnimationEnd,
    handleChangeMonth
  };
};

const getPickersFadeTransitionGroupUtilityClass = slot => generateUtilityClass('MuiPickersFadeTransitionGroup', slot);
generateUtilityClasses('MuiPickersFadeTransitionGroup', ['root']);

await importShared('react');
const useUtilityClasses$g = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root']
  };
  return composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
};
const PickersFadeTransitionGroupRoot = styled(TransitionGroup, {
  name: 'MuiPickersFadeTransitionGroup',
  slot: 'Root',
  overridesResolver: (_, styles) => styles.root
})({
  display: 'block',
  position: 'relative'
});

/**
 * @ignore - do not document.
 */
function PickersFadeTransitionGroup(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPickersFadeTransitionGroup'
  });
  const {
    children,
    className,
    reduceAnimations,
    transKey
  } = props;
  const classes = useUtilityClasses$g(props);
  const theme = useTheme$1();
  if (reduceAnimations) {
    return children;
  }
  return /*#__PURE__*/jsxRuntimeExports.jsx(PickersFadeTransitionGroupRoot, {
    className: clsx(classes.root, className),
    children: /*#__PURE__*/jsxRuntimeExports.jsx(Fade, {
      appear: false,
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: {
        appear: theme.transitions.duration.enteringScreen,
        enter: theme.transitions.duration.enteringScreen,
        exit: 0
      },
      children: children
    }, transKey)
  });
}

const getPickersSlideTransitionUtilityClass = slot => generateUtilityClass('MuiPickersSlideTransition', slot);
const pickersSlideTransitionClasses = generateUtilityClasses('MuiPickersSlideTransition', ['root', 'slideEnter-left', 'slideEnter-right', 'slideEnterActive', 'slideExit', 'slideExitActiveLeft-left', 'slideExitActiveLeft-right']);

const _excluded$k = ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"];
const React$1e = await importShared('react');
const useUtilityClasses$f = ownerState => {
  const {
    classes,
    slideDirection
  } = ownerState;
  const slots = {
    root: ['root'],
    exit: ['slideExit'],
    enterActive: ['slideEnterActive'],
    enter: [`slideEnter-${slideDirection}`],
    exitActive: [`slideExitActiveLeft-${slideDirection}`]
  };
  return composeClasses(slots, getPickersSlideTransitionUtilityClass, classes);
};
const PickersSlideTransitionRoot = styled(TransitionGroup, {
  name: 'MuiPickersSlideTransition',
  slot: 'Root',
  overridesResolver: (_, styles) => [styles.root, {
    [`.${pickersSlideTransitionClasses['slideEnter-left']}`]: styles['slideEnter-left']
  }, {
    [`.${pickersSlideTransitionClasses['slideEnter-right']}`]: styles['slideEnter-right']
  }, {
    [`.${pickersSlideTransitionClasses.slideEnterActive}`]: styles.slideEnterActive
  }, {
    [`.${pickersSlideTransitionClasses.slideExit}`]: styles.slideExit
  }, {
    [`.${pickersSlideTransitionClasses['slideExitActiveLeft-left']}`]: styles['slideExitActiveLeft-left']
  }, {
    [`.${pickersSlideTransitionClasses['slideExitActiveLeft-right']}`]: styles['slideExitActiveLeft-right']
  }]
})(({
  theme
}) => {
  const slideTransition = theme.transitions.create('transform', {
    duration: theme.transitions.duration.complex,
    easing: 'cubic-bezier(0.35, 0.8, 0.4, 1)'
  });
  return {
    display: 'block',
    position: 'relative',
    overflowX: 'hidden',
    '& > *': {
      position: 'absolute',
      top: 0,
      right: 0,
      left: 0
    },
    [`& .${pickersSlideTransitionClasses['slideEnter-left']}`]: {
      willChange: 'transform',
      transform: 'translate(100%)',
      zIndex: 1
    },
    [`& .${pickersSlideTransitionClasses['slideEnter-right']}`]: {
      willChange: 'transform',
      transform: 'translate(-100%)',
      zIndex: 1
    },
    [`& .${pickersSlideTransitionClasses.slideEnterActive}`]: {
      transform: 'translate(0%)',
      transition: slideTransition
    },
    [`& .${pickersSlideTransitionClasses.slideExit}`]: {
      transform: 'translate(0%)'
    },
    [`& .${pickersSlideTransitionClasses['slideExitActiveLeft-left']}`]: {
      willChange: 'transform',
      transform: 'translate(-100%)',
      transition: slideTransition,
      zIndex: 0
    },
    [`& .${pickersSlideTransitionClasses['slideExitActiveLeft-right']}`]: {
      willChange: 'transform',
      transform: 'translate(100%)',
      transition: slideTransition,
      zIndex: 0
    }
  };
});

/**
 * @ignore - do not document.
 */
function PickersSlideTransition(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPickersSlideTransition'
  });
  const {
      children,
      className,
      reduceAnimations,
      transKey
      // extracting `classes` from `other`
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$k);
  const classes = useUtilityClasses$f(props);
  const theme = useTheme$1();
  if (reduceAnimations) {
    return /*#__PURE__*/jsxRuntimeExports.jsx("div", {
      className: clsx(classes.root, className),
      children: children
    });
  }
  const transitionClasses = {
    exit: classes.exit,
    enterActive: classes.enterActive,
    enter: classes.enter,
    exitActive: classes.exitActive
  };
  return /*#__PURE__*/jsxRuntimeExports.jsx(PickersSlideTransitionRoot, {
    className: clsx(classes.root, className),
    childFactory: element => /*#__PURE__*/React$1e.cloneElement(element, {
      classNames: transitionClasses
    }),
    role: "presentation",
    children: /*#__PURE__*/jsxRuntimeExports.jsx(CSSTransition, _extends$3({
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: theme.transitions.duration.complex,
      classNames: transitionClasses
    }, other, {
      children: children
    }), transKey)
  });
}

const getDayCalendarUtilityClass = slot => generateUtilityClass('MuiDayCalendar', slot);
generateUtilityClasses('MuiDayCalendar', ['root', 'header', 'weekDayLabel', 'loadingContainer', 'slideTransition', 'monthContainer', 'weekContainer', 'weekNumberLabel', 'weekNumber']);

const _excluded$j = ["parentProps", "day", "focusableDay", "selectedDays", "isDateDisabled", "currentMonthNumber", "isViewFocused"],
  _excluded2$3 = ["ownerState"];
const React$1d = await importShared('react');
const useUtilityClasses$e = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    header: ['header'],
    weekDayLabel: ['weekDayLabel'],
    loadingContainer: ['loadingContainer'],
    slideTransition: ['slideTransition'],
    monthContainer: ['monthContainer'],
    weekContainer: ['weekContainer'],
    weekNumberLabel: ['weekNumberLabel'],
    weekNumber: ['weekNumber']
  };
  return composeClasses(slots, getDayCalendarUtilityClass, classes);
};
const weeksContainerHeight = (DAY_SIZE + DAY_MARGIN * 2) * 6;
const PickersCalendarDayRoot = styled('div', {
  name: 'MuiDayCalendar',
  slot: 'Root',
  overridesResolver: (_, styles) => styles.root
})({});
const PickersCalendarDayHeader = styled('div', {
  name: 'MuiDayCalendar',
  slot: 'Header',
  overridesResolver: (_, styles) => styles.header
})({
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center'
});
const PickersCalendarWeekDayLabel = styled(Typography$4, {
  name: 'MuiDayCalendar',
  slot: 'WeekDayLabel',
  overridesResolver: (_, styles) => styles.weekDayLabel
})(({
  theme
}) => ({
  width: 36,
  height: 40,
  margin: '0 2px',
  textAlign: 'center',
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  color: (theme.vars || theme).palette.text.secondary
}));
const PickersCalendarWeekNumberLabel = styled(Typography$4, {
  name: 'MuiDayCalendar',
  slot: 'WeekNumberLabel',
  overridesResolver: (_, styles) => styles.weekNumberLabel
})(({
  theme
}) => ({
  width: 36,
  height: 40,
  margin: '0 2px',
  textAlign: 'center',
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  color: theme.palette.text.disabled
}));
const PickersCalendarWeekNumber = styled(Typography$4, {
  name: 'MuiDayCalendar',
  slot: 'WeekNumber',
  overridesResolver: (_, styles) => styles.weekNumber
})(({
  theme
}) => _extends$3({}, theme.typography.caption, {
  width: DAY_SIZE,
  height: DAY_SIZE,
  padding: 0,
  margin: `0 ${DAY_MARGIN}px`,
  color: theme.palette.text.disabled,
  fontSize: '0.75rem',
  alignItems: 'center',
  justifyContent: 'center',
  display: 'inline-flex'
}));
const PickersCalendarLoadingContainer = styled('div', {
  name: 'MuiDayCalendar',
  slot: 'LoadingContainer',
  overridesResolver: (_, styles) => styles.loadingContainer
})({
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  minHeight: weeksContainerHeight
});
const PickersCalendarSlideTransition = styled(PickersSlideTransition, {
  name: 'MuiDayCalendar',
  slot: 'SlideTransition',
  overridesResolver: (_, styles) => styles.slideTransition
})({
  minHeight: weeksContainerHeight
});
const PickersCalendarWeekContainer = styled('div', {
  name: 'MuiDayCalendar',
  slot: 'MonthContainer',
  overridesResolver: (_, styles) => styles.monthContainer
})({
  overflow: 'hidden'
});
const PickersCalendarWeek = styled('div', {
  name: 'MuiDayCalendar',
  slot: 'WeekContainer',
  overridesResolver: (_, styles) => styles.weekContainer
})({
  margin: `${DAY_MARGIN}px 0`,
  display: 'flex',
  justifyContent: 'center'
});
function WrappedDay(_ref) {
  let {
      parentProps,
      day,
      focusableDay,
      selectedDays,
      isDateDisabled,
      currentMonthNumber,
      isViewFocused
    } = _ref,
    other = _objectWithoutPropertiesLoose(_ref, _excluded$j);
  const {
    disabled,
    disableHighlightToday,
    isMonthSwitchingAnimating,
    showDaysOutsideCurrentMonth,
    slots,
    slotProps,
    timezone
  } = parentProps;
  const utils = useUtils();
  const now = useNow(timezone);
  const isFocusableDay = focusableDay !== null && utils.isSameDay(day, focusableDay);
  const isSelected = selectedDays.some(selectedDay => utils.isSameDay(selectedDay, day));
  const isToday = utils.isSameDay(day, now);
  const Day = slots?.day ?? PickersDay;
  // We don't want to pass to ownerState down, to avoid re-rendering all the day whenever a prop changes.
  const _useSlotProps = useSlotProps({
      elementType: Day,
      externalSlotProps: slotProps?.day,
      additionalProps: _extends$3({
        disableHighlightToday,
        showDaysOutsideCurrentMonth,
        role: 'gridcell',
        isAnimating: isMonthSwitchingAnimating,
        // it is used in date range dragging logic by accessing `dataset.timestamp`
        'data-timestamp': utils.toJsDate(day).valueOf()
      }, other),
      ownerState: _extends$3({}, parentProps, {
        day,
        selected: isSelected
      })
    }),
    dayProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$3);
  const isDisabled = React$1d.useMemo(() => disabled || isDateDisabled(day), [disabled, isDateDisabled, day]);
  const outsideCurrentMonth = React$1d.useMemo(() => utils.getMonth(day) !== currentMonthNumber, [utils, day, currentMonthNumber]);
  const isFirstVisibleCell = React$1d.useMemo(() => {
    const startOfMonth = utils.startOfMonth(utils.setMonth(day, currentMonthNumber));
    if (!showDaysOutsideCurrentMonth) {
      return utils.isSameDay(day, startOfMonth);
    }
    return utils.isSameDay(day, utils.startOfWeek(startOfMonth));
  }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils]);
  const isLastVisibleCell = React$1d.useMemo(() => {
    const endOfMonth = utils.endOfMonth(utils.setMonth(day, currentMonthNumber));
    if (!showDaysOutsideCurrentMonth) {
      return utils.isSameDay(day, endOfMonth);
    }
    return utils.isSameDay(day, utils.endOfWeek(endOfMonth));
  }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils]);
  return /*#__PURE__*/jsxRuntimeExports.jsx(Day, _extends$3({}, dayProps, {
    day: day,
    disabled: isDisabled,
    autoFocus: isViewFocused && isFocusableDay,
    today: isToday,
    outsideCurrentMonth: outsideCurrentMonth,
    isFirstVisibleCell: isFirstVisibleCell,
    isLastVisibleCell: isLastVisibleCell,
    selected: isSelected,
    tabIndex: isFocusableDay ? 0 : -1,
    "aria-selected": isSelected,
    "aria-current": isToday ? 'date' : undefined
  }));
}

/**
 * @ignore - do not document.
 */
function DayCalendar(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiDayCalendar'
  });
  const utils = useUtils();
  const {
    onFocusedDayChange,
    className,
    currentMonth,
    selectedDays,
    focusedDay,
    loading,
    onSelectedDaysChange,
    onMonthSwitchingAnimationEnd,
    readOnly,
    reduceAnimations,
    renderLoading = () => /*#__PURE__*/jsxRuntimeExports.jsx("span", {
      children: "..."
    }),
    slideDirection,
    TransitionProps,
    disablePast,
    disableFuture,
    minDate,
    maxDate,
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    dayOfWeekFormatter = date => utils.format(date, 'weekdayShort').charAt(0).toUpperCase(),
    hasFocus,
    onFocusedViewChange,
    gridLabelId,
    displayWeekNumber,
    fixedWeekNumber,
    autoFocus,
    timezone
  } = props;
  const now = useNow(timezone);
  const classes = useUtilityClasses$e(props);
  const isRtl = useRtl();
  const isDateDisabled = useIsDateDisabled({
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    minDate,
    maxDate,
    disablePast,
    disableFuture,
    timezone
  });
  const translations = usePickersTranslations();
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: 'DayCalendar',
    state: 'hasFocus',
    controlled: hasFocus,
    default: autoFocus ?? false
  });
  const [internalFocusedDay, setInternalFocusedDay] = React$1d.useState(() => focusedDay || now);
  const handleDaySelect = useEventCallback(day => {
    if (readOnly) {
      return;
    }
    onSelectedDaysChange(day);
  });
  const focusDay = day => {
    if (!isDateDisabled(day)) {
      onFocusedDayChange(day);
      setInternalFocusedDay(day);
      onFocusedViewChange?.(true);
      setInternalHasFocus(true);
    }
  };
  const handleKeyDown = useEventCallback((event, day) => {
    switch (event.key) {
      case 'ArrowUp':
        focusDay(utils.addDays(day, -7));
        event.preventDefault();
        break;
      case 'ArrowDown':
        focusDay(utils.addDays(day, 7));
        event.preventDefault();
        break;
      case 'ArrowLeft':
        {
          const newFocusedDayDefault = utils.addDays(day, isRtl ? 1 : -1);
          const nextAvailableMonth = utils.addMonths(day, isRtl ? 1 : -1);
          const closestDayToFocus = findClosestEnabledDate({
            utils,
            date: newFocusedDayDefault,
            minDate: isRtl ? newFocusedDayDefault : utils.startOfMonth(nextAvailableMonth),
            maxDate: isRtl ? utils.endOfMonth(nextAvailableMonth) : newFocusedDayDefault,
            isDateDisabled,
            timezone
          });
          focusDay(closestDayToFocus || newFocusedDayDefault);
          event.preventDefault();
          break;
        }
      case 'ArrowRight':
        {
          const newFocusedDayDefault = utils.addDays(day, isRtl ? -1 : 1);
          const nextAvailableMonth = utils.addMonths(day, isRtl ? -1 : 1);
          const closestDayToFocus = findClosestEnabledDate({
            utils,
            date: newFocusedDayDefault,
            minDate: isRtl ? utils.startOfMonth(nextAvailableMonth) : newFocusedDayDefault,
            maxDate: isRtl ? newFocusedDayDefault : utils.endOfMonth(nextAvailableMonth),
            isDateDisabled,
            timezone
          });
          focusDay(closestDayToFocus || newFocusedDayDefault);
          event.preventDefault();
          break;
        }
      case 'Home':
        focusDay(utils.startOfWeek(day));
        event.preventDefault();
        break;
      case 'End':
        focusDay(utils.endOfWeek(day));
        event.preventDefault();
        break;
      case 'PageUp':
        focusDay(utils.addMonths(day, 1));
        event.preventDefault();
        break;
      case 'PageDown':
        focusDay(utils.addMonths(day, -1));
        event.preventDefault();
        break;
    }
  });
  const handleFocus = useEventCallback((event, day) => focusDay(day));
  const handleBlur = useEventCallback((event, day) => {
    if (internalHasFocus && utils.isSameDay(internalFocusedDay, day)) {
      onFocusedViewChange?.(false);
    }
  });
  const currentMonthNumber = utils.getMonth(currentMonth);
  const currentYearNumber = utils.getYear(currentMonth);
  const validSelectedDays = React$1d.useMemo(() => selectedDays.filter(day => !!day).map(day => utils.startOfDay(day)), [utils, selectedDays]);

  // need a new ref whenever the `key` of the transition changes: https://reactcommunity.org/react-transition-group/transition/#Transition-prop-nodeRef.
  const transitionKey = `${currentYearNumber}-${currentMonthNumber}`;
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const slideNodeRef = React$1d.useMemo(() => /*#__PURE__*/React$1d.createRef(), [transitionKey]);
  const focusableDay = React$1d.useMemo(() => {
    const startOfMonth = utils.startOfMonth(currentMonth);
    const endOfMonth = utils.endOfMonth(currentMonth);
    if (isDateDisabled(internalFocusedDay) || utils.isAfterDay(internalFocusedDay, endOfMonth) || utils.isBeforeDay(internalFocusedDay, startOfMonth)) {
      return findClosestEnabledDate({
        utils,
        date: internalFocusedDay,
        minDate: startOfMonth,
        maxDate: endOfMonth,
        disablePast,
        disableFuture,
        isDateDisabled,
        timezone
      });
    }
    return internalFocusedDay;
  }, [currentMonth, disableFuture, disablePast, internalFocusedDay, isDateDisabled, utils, timezone]);
  const weeksToDisplay = React$1d.useMemo(() => {
    const toDisplay = utils.getWeekArray(currentMonth);
    let nextMonth = utils.addMonths(currentMonth, 1);
    while (fixedWeekNumber && toDisplay.length < fixedWeekNumber) {
      const additionalWeeks = utils.getWeekArray(nextMonth);
      const hasCommonWeek = utils.isSameDay(toDisplay[toDisplay.length - 1][0], additionalWeeks[0][0]);
      additionalWeeks.slice(hasCommonWeek ? 1 : 0).forEach(week => {
        if (toDisplay.length < fixedWeekNumber) {
          toDisplay.push(week);
        }
      });
      nextMonth = utils.addMonths(nextMonth, 1);
    }
    return toDisplay;
  }, [currentMonth, fixedWeekNumber, utils]);
  return /*#__PURE__*/jsxRuntimeExports.jsxs(PickersCalendarDayRoot, {
    role: "grid",
    "aria-labelledby": gridLabelId,
    className: classes.root,
    children: [/*#__PURE__*/jsxRuntimeExports.jsxs(PickersCalendarDayHeader, {
      role: "row",
      className: classes.header,
      children: [displayWeekNumber && /*#__PURE__*/jsxRuntimeExports.jsx(PickersCalendarWeekNumberLabel, {
        variant: "caption",
        role: "columnheader",
        "aria-label": translations.calendarWeekNumberHeaderLabel,
        className: classes.weekNumberLabel,
        children: translations.calendarWeekNumberHeaderText
      }), getWeekdays(utils, now).map((weekday, i) => /*#__PURE__*/jsxRuntimeExports.jsx(PickersCalendarWeekDayLabel, {
        variant: "caption",
        role: "columnheader",
        "aria-label": utils.format(weekday, 'weekday'),
        className: classes.weekDayLabel,
        children: dayOfWeekFormatter(weekday)
      }, i.toString()))]
    }), loading ? /*#__PURE__*/jsxRuntimeExports.jsx(PickersCalendarLoadingContainer, {
      className: classes.loadingContainer,
      children: renderLoading()
    }) : /*#__PURE__*/jsxRuntimeExports.jsx(PickersCalendarSlideTransition, _extends$3({
      transKey: transitionKey,
      onExited: onMonthSwitchingAnimationEnd,
      reduceAnimations: reduceAnimations,
      slideDirection: slideDirection,
      className: clsx(className, classes.slideTransition)
    }, TransitionProps, {
      nodeRef: slideNodeRef,
      children: /*#__PURE__*/jsxRuntimeExports.jsx(PickersCalendarWeekContainer, {
        ref: slideNodeRef,
        role: "rowgroup",
        className: classes.monthContainer,
        children: weeksToDisplay.map((week, index) => /*#__PURE__*/jsxRuntimeExports.jsxs(PickersCalendarWeek, {
          role: "row",
          className: classes.weekContainer
          // fix issue of announcing row 1 as row 2
          // caused by week day labels row
          ,
          "aria-rowindex": index + 1,
          children: [displayWeekNumber && /*#__PURE__*/jsxRuntimeExports.jsx(PickersCalendarWeekNumber, {
            className: classes.weekNumber,
            role: "rowheader",
            "aria-label": translations.calendarWeekNumberAriaLabelText(utils.getWeekNumber(week[0])),
            children: translations.calendarWeekNumberText(utils.getWeekNumber(week[0]))
          }), week.map((day, dayIndex) => /*#__PURE__*/jsxRuntimeExports.jsx(WrappedDay, {
            parentProps: props,
            day: day,
            selectedDays: validSelectedDays,
            focusableDay: focusableDay,
            onKeyDown: handleKeyDown,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onDaySelect: handleDaySelect,
            isDateDisabled: isDateDisabled,
            currentMonthNumber: currentMonthNumber,
            isViewFocused: internalHasFocus
            // fix issue of announcing column 1 as column 2 when `displayWeekNumber` is enabled
            ,
            "aria-colindex": dayIndex + 1
          }, day.toString()))]
        }, `week-${week[0]}`))
      })
    }))]
  });
}

function getPickersMonthUtilityClass(slot) {
  return generateUtilityClass('MuiPickersMonth', slot);
}
const pickersMonthClasses = generateUtilityClasses('MuiPickersMonth', ['root', 'monthButton', 'disabled', 'selected']);

const _excluded$i = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "aria-label", "monthsPerRow", "slots", "slotProps"];
const React$1c = await importShared('react');
const useUtilityClasses$d = ownerState => {
  const {
    disabled,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    monthButton: ['monthButton', disabled && 'disabled', selected && 'selected']
  };
  return composeClasses(slots, getPickersMonthUtilityClass, classes);
};
const PickersMonthRoot = styled('div', {
  name: 'MuiPickersMonth',
  slot: 'Root',
  overridesResolver: (_, styles) => [styles.root]
})({
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexBasis: '33.3%',
  variants: [{
    props: {
      monthsPerRow: 4
    },
    style: {
      flexBasis: '25%'
    }
  }]
});
const MonthCalendarButton = styled('button', {
  name: 'MuiPickersMonth',
  slot: 'MonthButton',
  overridesResolver: (_, styles) => [styles.monthButton, {
    [`&.${pickersMonthClasses.disabled}`]: styles.disabled
  }, {
    [`&.${pickersMonthClasses.selected}`]: styles.selected
  }]
})(({
  theme
}) => _extends$3({
  color: 'unset',
  backgroundColor: 'transparent',
  border: 0,
  outline: 0
}, theme.typography.subtitle1, {
  margin: '8px 0',
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: 'pointer',
  '&:focus': {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
  },
  '&:hover': {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
  },
  '&:disabled': {
    cursor: 'auto',
    pointerEvents: 'none'
  },
  [`&.${pickersMonthClasses.disabled}`]: {
    color: (theme.vars || theme).palette.text.secondary
  },
  [`&.${pickersMonthClasses.selected}`]: {
    color: (theme.vars || theme).palette.primary.contrastText,
    backgroundColor: (theme.vars || theme).palette.primary.main,
    '&:focus, &:hover': {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  }
}));

/**
 * @ignore - do not document.
 */
const PickersMonth = /*#__PURE__*/React$1c.memo(function PickersMonth(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPickersMonth'
  });
  const {
      autoFocus,
      className,
      children,
      disabled,
      selected,
      value,
      tabIndex,
      onClick,
      onKeyDown,
      onFocus,
      onBlur,
      'aria-current': ariaCurrent,
      'aria-label': ariaLabel
      // We don't want to forward this prop to the root element
      ,

      slots,
      slotProps
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$i);
  const ref = React$1c.useRef(null);
  const classes = useUtilityClasses$d(props);

  // We can't forward the `autoFocus` to the button because it is a native button, not a MUI Button
  useEnhancedEffect(() => {
    if (autoFocus) {
      // `ref.current` being `null` would be a bug in MUI.
      ref.current?.focus();
    }
  }, [autoFocus]);
  const MonthButton = slots?.monthButton ?? MonthCalendarButton;
  const monthButtonProps = useSlotProps({
    elementType: MonthButton,
    externalSlotProps: slotProps?.monthButton,
    additionalProps: {
      children,
      disabled,
      tabIndex,
      ref,
      type: 'button',
      role: 'radio',
      'aria-current': ariaCurrent,
      'aria-checked': selected,
      'aria-label': ariaLabel,
      onClick: event => onClick(event, value),
      onKeyDown: event => onKeyDown(event, value),
      onFocus: event => onFocus(event, value),
      onBlur: event => onBlur(event, value)
    },
    ownerState: props,
    className: classes.monthButton
  });
  return /*#__PURE__*/jsxRuntimeExports.jsx(PickersMonthRoot, _extends$3({
    className: clsx(classes.root, className),
    ownerState: props
  }, other, {
    children: /*#__PURE__*/jsxRuntimeExports.jsx(MonthButton, _extends$3({}, monthButtonProps))
  }));
});

function getMonthCalendarUtilityClass(slot) {
  return generateUtilityClass('MuiMonthCalendar', slot);
}
generateUtilityClasses('MuiMonthCalendar', ['root']);

const _excluded$h = ["className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange", "monthsPerRow", "timezone", "gridLabelId", "slots", "slotProps"];
const React$1b = await importShared('react');

await importShared('prop-types');
const useUtilityClasses$c = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getMonthCalendarUtilityClass, classes);
};
function useMonthCalendarDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends$3({
    disableFuture: false,
    disablePast: false
  }, themeProps, {
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate)
  });
}
const MonthCalendarRoot = styled("div", {
  name: "MuiMonthCalendar",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  display: "flex",
  flexWrap: "wrap",
  alignContent: "stretch",
  padding: "0 4px",
  width: DIALOG_WIDTH,
  // avoid padding increasing width over defined
  boxSizing: "border-box"
});
const MonthCalendar = /* @__PURE__ */ React$1b.forwardRef(function MonthCalendar2(inProps, ref) {
  const props = useMonthCalendarDefaultizedProps(inProps, "MuiMonthCalendar");
  const {
    className,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onChange,
    shouldDisableMonth,
    readOnly,
    autoFocus = false,
    onMonthFocus,
    hasFocus,
    onFocusedViewChange,
    monthsPerRow = 3,
    timezone: timezoneProp,
    gridLabelId,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$h);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "MonthCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    onChange,
    valueManager: singleItemValueManager
  });
  const now = useNow(timezone);
  const isRtl = useRtl();
  const utils = useUtils();
  const referenceDate = React$1b.useMemo(
    () => singleItemValueManager.getInitialReferenceValue({
      value,
      utils,
      props,
      timezone,
      referenceDate: referenceDateProp,
      granularity: SECTION_TYPE_GRANULARITY.month
    }),
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const ownerState = props;
  const classes = useUtilityClasses$c(ownerState);
  const todayMonth = React$1b.useMemo(() => utils.getMonth(now), [utils, now]);
  const selectedMonth = React$1b.useMemo(() => {
    if (value != null) {
      return utils.getMonth(value);
    }
    return null;
  }, [value, utils]);
  const [focusedMonth, setFocusedMonth] = React$1b.useState(() => selectedMonth || utils.getMonth(referenceDate));
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: "MonthCalendar",
    state: "hasFocus",
    controlled: hasFocus,
    default: autoFocus ?? false
  });
  const changeHasFocus = useEventCallback((newHasFocus) => {
    setInternalHasFocus(newHasFocus);
    if (onFocusedViewChange) {
      onFocusedViewChange(newHasFocus);
    }
  });
  const isMonthDisabled = React$1b.useCallback((dateToValidate) => {
    const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, minDate) ? now : minDate);
    const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, maxDate) ? now : maxDate);
    const monthToValidate = utils.startOfMonth(dateToValidate);
    if (utils.isBefore(monthToValidate, firstEnabledMonth)) {
      return true;
    }
    if (utils.isAfter(monthToValidate, lastEnabledMonth)) {
      return true;
    }
    if (!shouldDisableMonth) {
      return false;
    }
    return shouldDisableMonth(monthToValidate);
  }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableMonth, utils]);
  const handleMonthSelection = useEventCallback((event, month) => {
    if (readOnly) {
      return;
    }
    const newDate = utils.setMonth(value ?? referenceDate, month);
    handleValueChange(newDate);
  });
  const focusMonth = useEventCallback((month) => {
    if (!isMonthDisabled(utils.setMonth(value ?? referenceDate, month))) {
      setFocusedMonth(month);
      changeHasFocus(true);
      if (onMonthFocus) {
        onMonthFocus(month);
      }
    }
  });
  React$1b.useEffect(() => {
    setFocusedMonth((prevFocusedMonth) => selectedMonth !== null && prevFocusedMonth !== selectedMonth ? selectedMonth : prevFocusedMonth);
  }, [selectedMonth]);
  const handleKeyDown = useEventCallback((event, month) => {
    const monthsInYear = 12;
    const monthsInRow = 3;
    switch (event.key) {
      case "ArrowUp":
        focusMonth((monthsInYear + month - monthsInRow) % monthsInYear);
        event.preventDefault();
        break;
      case "ArrowDown":
        focusMonth((monthsInYear + month + monthsInRow) % monthsInYear);
        event.preventDefault();
        break;
      case "ArrowLeft":
        focusMonth((monthsInYear + month + (isRtl ? 1 : -1)) % monthsInYear);
        event.preventDefault();
        break;
      case "ArrowRight":
        focusMonth((monthsInYear + month + (isRtl ? -1 : 1)) % monthsInYear);
        event.preventDefault();
        break;
    }
  });
  const handleMonthFocus = useEventCallback((event, month) => {
    focusMonth(month);
  });
  const handleMonthBlur = useEventCallback((event, month) => {
    if (focusedMonth === month) {
      changeHasFocus(false);
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendarRoot, _extends$3({
    ref,
    className: clsx(classes.root, className),
    ownerState,
    role: "radiogroup",
    "aria-labelledby": gridLabelId
  }, other, {
    children: getMonthsInYear(utils, value ?? referenceDate).map((month) => {
      const monthNumber = utils.getMonth(month);
      const monthText = utils.format(month, "monthShort");
      const monthLabel = utils.format(month, "month");
      const isSelected = monthNumber === selectedMonth;
      const isDisabled = disabled || isMonthDisabled(month);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonth, {
        selected: isSelected,
        value: monthNumber,
        onClick: handleMonthSelection,
        onKeyDown: handleKeyDown,
        autoFocus: internalHasFocus && monthNumber === focusedMonth,
        disabled: isDisabled,
        tabIndex: monthNumber === focusedMonth && !isDisabled ? 0 : -1,
        onFocus: handleMonthFocus,
        onBlur: handleMonthBlur,
        "aria-current": todayMonth === monthNumber ? "date" : void 0,
        "aria-label": monthLabel,
        monthsPerRow,
        slots,
        slotProps,
        children: monthText
      }, monthText);
    })
  }));
});

function getPickersYearUtilityClass(slot) {
  return generateUtilityClass('MuiPickersYear', slot);
}
const pickersYearClasses = generateUtilityClasses('MuiPickersYear', ['root', 'yearButton', 'selected', 'disabled']);

const _excluded$g = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "yearsPerRow", "slots", "slotProps"];
const React$1a = await importShared('react');
const useUtilityClasses$b = ownerState => {
  const {
    disabled,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    yearButton: ['yearButton', disabled && 'disabled', selected && 'selected']
  };
  return composeClasses(slots, getPickersYearUtilityClass, classes);
};
const PickersYearRoot = styled('div', {
  name: 'MuiPickersYear',
  slot: 'Root',
  overridesResolver: (_, styles) => [styles.root]
})({
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexBasis: '33.3%',
  variants: [{
    props: {
      yearsPerRow: 4
    },
    style: {
      flexBasis: '25%'
    }
  }]
});
const YearCalendarButton = styled('button', {
  name: 'MuiPickersYear',
  slot: 'YearButton',
  overridesResolver: (_, styles) => [styles.yearButton, {
    [`&.${pickersYearClasses.disabled}`]: styles.disabled
  }, {
    [`&.${pickersYearClasses.selected}`]: styles.selected
  }]
})(({
  theme
}) => _extends$3({
  color: 'unset',
  backgroundColor: 'transparent',
  border: 0,
  outline: 0
}, theme.typography.subtitle1, {
  margin: '6px 0',
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: 'pointer',
  '&:focus': {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.action.active, theme.palette.action.focusOpacity)
  },
  '&:hover': {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
  },
  '&:disabled': {
    cursor: 'auto',
    pointerEvents: 'none'
  },
  [`&.${pickersYearClasses.disabled}`]: {
    color: (theme.vars || theme).palette.text.secondary
  },
  [`&.${pickersYearClasses.selected}`]: {
    color: (theme.vars || theme).palette.primary.contrastText,
    backgroundColor: (theme.vars || theme).palette.primary.main,
    '&:focus, &:hover': {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  }
}));

/**
 * @ignore - internal component.
 */
const PickersYear = /*#__PURE__*/React$1a.memo(function PickersYear(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPickersYear'
  });
  const {
      autoFocus,
      className,
      children,
      disabled,
      selected,
      value,
      tabIndex,
      onClick,
      onKeyDown,
      onFocus,
      onBlur,
      'aria-current': ariaCurrent
      // We don't want to forward this prop to the root element
      ,

      slots,
      slotProps
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$g);
  const ref = React$1a.useRef(null);
  const classes = useUtilityClasses$b(props);

  // We can't forward the `autoFocus` to the button because it is a native button, not a MUI Button
  useEnhancedEffect(() => {
    if (autoFocus) {
      // `ref.current` being `null` would be a bug in MUI.
      ref.current?.focus();
    }
  }, [autoFocus]);
  const YearButton = slots?.yearButton ?? YearCalendarButton;
  const yearButtonProps = useSlotProps({
    elementType: YearButton,
    externalSlotProps: slotProps?.yearButton,
    additionalProps: {
      children,
      disabled,
      tabIndex,
      ref,
      type: 'button',
      role: 'radio',
      'aria-current': ariaCurrent,
      'aria-checked': selected,
      onClick: event => onClick(event, value),
      onKeyDown: event => onKeyDown(event, value),
      onFocus: event => onFocus(event, value),
      onBlur: event => onBlur(event, value)
    },
    ownerState: props,
    className: classes.yearButton
  });
  return /*#__PURE__*/jsxRuntimeExports.jsx(PickersYearRoot, _extends$3({
    className: clsx(classes.root, className),
    ownerState: props
  }, other, {
    children: /*#__PURE__*/jsxRuntimeExports.jsx(YearButton, _extends$3({}, yearButtonProps))
  }));
});

function getYearCalendarUtilityClass(slot) {
  return generateUtilityClass('MuiYearCalendar', slot);
}
generateUtilityClasses('MuiYearCalendar', ['root']);

const _excluded$f = ["autoFocus", "className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange", "yearsOrder", "yearsPerRow", "timezone", "gridLabelId", "slots", "slotProps"];
const React$19 = await importShared('react');

await importShared('prop-types');
const useUtilityClasses$a = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getYearCalendarUtilityClass, classes);
};
function useYearCalendarDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends$3({
    disablePast: false,
    disableFuture: false
  }, themeProps, {
    yearsPerRow: themeProps.yearsPerRow ?? 3,
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate)
  });
}
const YearCalendarRoot = styled("div", {
  name: "MuiYearCalendar",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  overflowY: "auto",
  height: "100%",
  padding: "0 4px",
  width: DIALOG_WIDTH,
  maxHeight: MAX_CALENDAR_HEIGHT,
  // avoid padding increasing width over defined
  boxSizing: "border-box",
  position: "relative"
});
const YearCalendar = /* @__PURE__ */ React$19.forwardRef(function YearCalendar2(inProps, ref) {
  const props = useYearCalendarDefaultizedProps(inProps, "MuiYearCalendar");
  const {
    autoFocus,
    className,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onChange,
    readOnly,
    shouldDisableYear,
    onYearFocus,
    hasFocus,
    onFocusedViewChange,
    yearsOrder = "asc",
    yearsPerRow,
    timezone: timezoneProp,
    gridLabelId,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$f);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "YearCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    onChange,
    valueManager: singleItemValueManager
  });
  const now = useNow(timezone);
  const isRtl = useRtl();
  const utils = useUtils();
  const referenceDate = React$19.useMemo(
    () => singleItemValueManager.getInitialReferenceValue({
      value,
      utils,
      props,
      timezone,
      referenceDate: referenceDateProp,
      granularity: SECTION_TYPE_GRANULARITY.year
    }),
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const ownerState = props;
  const classes = useUtilityClasses$a(ownerState);
  const todayYear = React$19.useMemo(() => utils.getYear(now), [utils, now]);
  const selectedYear = React$19.useMemo(() => {
    if (value != null) {
      return utils.getYear(value);
    }
    return null;
  }, [value, utils]);
  const [focusedYear, setFocusedYear] = React$19.useState(() => selectedYear || utils.getYear(referenceDate));
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: "YearCalendar",
    state: "hasFocus",
    controlled: hasFocus,
    default: autoFocus ?? false
  });
  const changeHasFocus = useEventCallback((newHasFocus) => {
    setInternalHasFocus(newHasFocus);
    if (onFocusedViewChange) {
      onFocusedViewChange(newHasFocus);
    }
  });
  const isYearDisabled = React$19.useCallback((dateToValidate) => {
    if (disablePast && utils.isBeforeYear(dateToValidate, now)) {
      return true;
    }
    if (disableFuture && utils.isAfterYear(dateToValidate, now)) {
      return true;
    }
    if (minDate && utils.isBeforeYear(dateToValidate, minDate)) {
      return true;
    }
    if (maxDate && utils.isAfterYear(dateToValidate, maxDate)) {
      return true;
    }
    if (!shouldDisableYear) {
      return false;
    }
    const yearToValidate = utils.startOfYear(dateToValidate);
    return shouldDisableYear(yearToValidate);
  }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableYear, utils]);
  const handleYearSelection = useEventCallback((event, year) => {
    if (readOnly) {
      return;
    }
    const newDate = utils.setYear(value ?? referenceDate, year);
    handleValueChange(newDate);
  });
  const focusYear = useEventCallback((year) => {
    if (!isYearDisabled(utils.setYear(value ?? referenceDate, year))) {
      setFocusedYear(year);
      changeHasFocus(true);
      onYearFocus?.(year);
    }
  });
  React$19.useEffect(() => {
    setFocusedYear((prevFocusedYear) => selectedYear !== null && prevFocusedYear !== selectedYear ? selectedYear : prevFocusedYear);
  }, [selectedYear]);
  const verticalDirection = yearsOrder !== "desc" ? yearsPerRow * 1 : yearsPerRow * -1;
  const horizontalDirection = isRtl && yearsOrder === "asc" || !isRtl && yearsOrder === "desc" ? -1 : 1;
  const handleKeyDown = useEventCallback((event, year) => {
    switch (event.key) {
      case "ArrowUp":
        focusYear(year - verticalDirection);
        event.preventDefault();
        break;
      case "ArrowDown":
        focusYear(year + verticalDirection);
        event.preventDefault();
        break;
      case "ArrowLeft":
        focusYear(year - horizontalDirection);
        event.preventDefault();
        break;
      case "ArrowRight":
        focusYear(year + horizontalDirection);
        event.preventDefault();
        break;
    }
  });
  const handleYearFocus = useEventCallback((event, year) => {
    focusYear(year);
  });
  const handleYearBlur = useEventCallback((event, year) => {
    if (focusedYear === year) {
      changeHasFocus(false);
    }
  });
  const scrollerRef = React$19.useRef(null);
  const handleRef = useForkRef(ref, scrollerRef);
  React$19.useEffect(() => {
    if (autoFocus || scrollerRef.current === null) {
      return;
    }
    const tabbableButton = scrollerRef.current.querySelector('[tabindex="0"]');
    if (!tabbableButton) {
      return;
    }
    const offsetHeight = tabbableButton.offsetHeight;
    const offsetTop = tabbableButton.offsetTop;
    const clientHeight = scrollerRef.current.clientHeight;
    const scrollTop = scrollerRef.current.scrollTop;
    const elementBottom = offsetTop + offsetHeight;
    if (offsetHeight > clientHeight || offsetTop < scrollTop) {
      return;
    }
    scrollerRef.current.scrollTop = elementBottom - clientHeight / 2 - offsetHeight / 2;
  }, [autoFocus]);
  const yearRange = utils.getYearRange([minDate, maxDate]);
  if (yearsOrder === "desc") {
    yearRange.reverse();
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendarRoot, _extends$3({
    ref: handleRef,
    className: clsx(classes.root, className),
    ownerState,
    role: "radiogroup",
    "aria-labelledby": gridLabelId
  }, other, {
    children: yearRange.map((year) => {
      const yearNumber = utils.getYear(year);
      const isSelected = yearNumber === selectedYear;
      const isDisabled = disabled || isYearDisabled(year);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYear, {
        selected: isSelected,
        value: yearNumber,
        onClick: handleYearSelection,
        onKeyDown: handleKeyDown,
        autoFocus: internalHasFocus && yearNumber === focusedYear,
        disabled: isDisabled,
        tabIndex: yearNumber === focusedYear && !isDisabled ? 0 : -1,
        onFocus: handleYearFocus,
        onBlur: handleYearBlur,
        "aria-current": todayYear === yearNumber ? "date" : void 0,
        yearsPerRow,
        slots,
        slotProps,
        children: utils.format(year, "year")
      }, utils.format(year, "year"));
    })
  }));
});

const getPickersCalendarHeaderUtilityClass = slot => generateUtilityClass('MuiPickersCalendarHeader', slot);
const pickersCalendarHeaderClasses = generateUtilityClasses('MuiPickersCalendarHeader', ['root', 'labelContainer', 'label', 'switchViewButton', 'switchViewIcon']);

const _excluded$e = ["slots", "slotProps", "currentMonth", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onMonthChange", "onViewChange", "view", "reduceAnimations", "views", "labelId", "className", "timezone", "format"], _excluded2$2 = ["ownerState"];
const React$18 = await importShared('react');

await importShared('prop-types');
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    labelContainer: ["labelContainer"],
    label: ["label"],
    switchViewButton: ["switchViewButton"],
    switchViewIcon: ["switchViewIcon"]
  };
  return composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
};
const PickersCalendarHeaderRoot = styled("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({
  display: "flex",
  alignItems: "center",
  marginTop: 12,
  marginBottom: 4,
  paddingLeft: 24,
  paddingRight: 12,
  // prevent jumping in safari
  maxHeight: 40,
  minHeight: 40
});
const PickersCalendarHeaderLabelContainer = styled("div", {
  name: "MuiPickersCalendarHeader",
  slot: "LabelContainer",
  overridesResolver: (_, styles) => styles.labelContainer
})(({
  theme
}) => _extends$3({
  display: "flex",
  overflow: "hidden",
  alignItems: "center",
  cursor: "pointer",
  marginRight: "auto"
}, theme.typography.body1, {
  fontWeight: theme.typography.fontWeightMedium
}));
const PickersCalendarHeaderLabel = styled("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Label",
  overridesResolver: (_, styles) => styles.label
})({
  marginRight: 6
});
const PickersCalendarHeaderSwitchViewButton = styled(IconButton$e, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewButton",
  overridesResolver: (_, styles) => styles.switchViewButton
})({
  marginRight: "auto",
  variants: [{
    props: {
      view: "year"
    },
    style: {
      [`.${pickersCalendarHeaderClasses.switchViewIcon}`]: {
        transform: "rotate(180deg)"
      }
    }
  }]
});
const PickersCalendarHeaderSwitchViewIcon = styled(ArrowDropDownIcon, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewIcon",
  overridesResolver: (_, styles) => styles.switchViewIcon
})(({
  theme
}) => ({
  willChange: "transform",
  transition: theme.transitions.create("transform"),
  transform: "rotate(0deg)"
}));
const PickersCalendarHeader = /* @__PURE__ */ React$18.forwardRef(function PickersCalendarHeader2(inProps, ref) {
  const translations = usePickersTranslations();
  const utils = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersCalendarHeader"
  });
  const {
    slots,
    slotProps,
    currentMonth: month,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onMonthChange,
    onViewChange,
    view,
    reduceAnimations,
    views,
    labelId,
    className,
    timezone,
    format = `${utils.formats.month} ${utils.formats.year}`
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$e);
  const ownerState = props;
  const classes = useUtilityClasses$9(props);
  const SwitchViewButton = slots?.switchViewButton ?? PickersCalendarHeaderSwitchViewButton;
  const switchViewButtonProps = useSlotProps({
    elementType: SwitchViewButton,
    externalSlotProps: slotProps?.switchViewButton,
    additionalProps: {
      size: "small",
      "aria-label": translations.calendarViewSwitchingButtonAriaLabel(view)
    },
    ownerState,
    className: classes.switchViewButton
  });
  const SwitchViewIcon = slots?.switchViewIcon ?? PickersCalendarHeaderSwitchViewIcon;
  const _useSlotProps = useSlotProps({
    elementType: SwitchViewIcon,
    externalSlotProps: slotProps?.switchViewIcon,
    ownerState,
    className: classes.switchViewIcon
  }), switchViewIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$2);
  const selectNextMonth = () => onMonthChange(utils.addMonths(month, 1), "left");
  const selectPreviousMonth = () => onMonthChange(utils.addMonths(month, -1), "right");
  const isNextMonthDisabled = useNextMonthDisabled(month, {
    disableFuture,
    maxDate,
    timezone
  });
  const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
    disablePast,
    minDate,
    timezone
  });
  const handleToggleView = () => {
    if (views.length === 1 || !onViewChange || disabled) {
      return;
    }
    if (views.length === 2) {
      onViewChange(views.find((el) => el !== view) || views[0]);
    } else {
      const nextIndexToOpen = views.indexOf(view) !== 0 ? 0 : 1;
      onViewChange(views[nextIndexToOpen]);
    }
  };
  if (views.length === 1 && views[0] === "year") {
    return null;
  }
  const label = utils.formatByString(month, format);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderRoot, _extends$3({}, other, {
    ownerState,
    className: clsx(classes.root, className),
    ref,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderLabelContainer, {
      role: "presentation",
      onClick: handleToggleView,
      ownerState,
      "aria-live": "polite",
      className: classes.labelContainer,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersFadeTransitionGroup, {
        reduceAnimations,
        transKey: label,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarHeaderLabel, {
          id: labelId,
          ownerState,
          className: classes.label,
          children: label
        })
      }), views.length > 1 && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewButton, _extends$3({}, switchViewButtonProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewIcon, _extends$3({}, switchViewIconProps))
      }))]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, {
      in: view === "day",
      appear: !reduceAnimations,
      enter: !reduceAnimations,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcher, {
        slots,
        slotProps,
        onGoToPrevious: selectPreviousMonth,
        isPreviousDisabled: isPreviousMonthDisabled,
        previousLabel: translations.previousMonth,
        onGoToNext: selectNextMonth,
        isNextDisabled: isNextMonthDisabled,
        nextLabel: translations.nextMonth
      })
    })]
  }));
});

const PREFERS_REDUCED_MOTION = '@media (prefers-reduced-motion: reduce)';

// detect if user agent has Android version < 10 or iOS version < 13
const mobileVersionMatches = typeof navigator !== 'undefined' && navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i);
const androidVersion = mobileVersionMatches && mobileVersionMatches[1] ? parseInt(mobileVersionMatches[1], 10) : null;
const iOSVersion = mobileVersionMatches && mobileVersionMatches[2] ? parseInt(mobileVersionMatches[2], 10) : null;
const slowAnimationDevices = androidVersion && androidVersion < 10 || iOSVersion && iOSVersion < 13 || false;
const useDefaultReduceAnimations = () => {
  const prefersReduced = useMediaQuery$1(PREFERS_REDUCED_MOTION, {
    defaultMatches: false
  });
  return prefersReduced || slowAnimationDevices;
};

const getDateCalendarUtilityClass = slot => generateUtilityClass('MuiDateCalendar', slot);
generateUtilityClasses('MuiDateCalendar', ['root', 'viewTransitionContainer']);

const _excluded$d = ["autoFocus", "onViewChange", "value", "defaultValue", "referenceDate", "disableFuture", "disablePast", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "fixedWeekNumber", "dayOfWeekFormatter", "slots", "slotProps", "loading", "renderLoading", "displayWeekNumber", "yearsOrder", "yearsPerRow", "monthsPerRow", "timezone"];
const React$17 = await importShared('react');

await importShared('prop-types');
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    viewTransitionContainer: ["viewTransitionContainer"]
  };
  return composeClasses(slots, getDateCalendarUtilityClass, classes);
};
function useDateCalendarDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends$3({}, themeProps, {
    loading: themeProps.loading ?? false,
    disablePast: themeProps.disablePast ?? false,
    disableFuture: themeProps.disableFuture ?? false,
    openTo: themeProps.openTo ?? "day",
    views: themeProps.views ?? ["year", "day"],
    reduceAnimations: themeProps.reduceAnimations ?? defaultReduceAnimations,
    renderLoading: themeProps.renderLoading ?? (() => /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      children: "..."
    })),
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate)
  });
}
const DateCalendarRoot = styled(PickerViewRoot, {
  name: "MuiDateCalendar",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  display: "flex",
  flexDirection: "column",
  height: VIEW_HEIGHT
});
const DateCalendarViewTransitionContainer = styled(PickersFadeTransitionGroup, {
  name: "MuiDateCalendar",
  slot: "ViewTransitionContainer",
  overridesResolver: (props, styles) => styles.viewTransitionContainer
})({});
const DateCalendar = /* @__PURE__ */ React$17.forwardRef(function DateCalendar2(inProps, ref) {
  const utils = useUtils();
  const id = useId();
  const props = useDateCalendarDefaultizedProps(inProps, "MuiDateCalendar");
  const {
    autoFocus,
    onViewChange,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableFuture,
    disablePast,
    onChange,
    onYearChange,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    view: inView,
    views,
    openTo,
    className,
    disabled,
    readOnly,
    minDate,
    maxDate,
    disableHighlightToday,
    focusedView: inFocusedView,
    onFocusedViewChange,
    showDaysOutsideCurrentMonth,
    fixedWeekNumber,
    dayOfWeekFormatter,
    slots,
    slotProps,
    loading,
    renderLoading,
    displayWeekNumber,
    yearsOrder,
    yearsPerRow,
    monthsPerRow,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "DateCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    onChange,
    valueManager: singleItemValueManager
  });
  const {
    view,
    setView,
    focusedView,
    setFocusedView,
    goToNextView,
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onChange: handleValueChange,
    onViewChange,
    autoFocus,
    focusedView: inFocusedView,
    onFocusedViewChange
  });
  const {
    referenceDate,
    calendarState,
    changeFocusedDay,
    changeMonth,
    handleChangeMonth,
    isDateDisabled,
    onMonthSwitchingAnimationEnd
  } = useCalendarState({
    value,
    referenceDate: referenceDateProp,
    reduceAnimations,
    onMonthChange,
    minDate,
    maxDate,
    shouldDisableDate,
    disablePast,
    disableFuture,
    timezone
  });
  const minDateWithDisabled = disabled && value || minDate;
  const maxDateWithDisabled = disabled && value || maxDate;
  const gridLabelId = `${id}-grid-label`;
  const hasFocus = focusedView !== null;
  const CalendarHeader = slots?.calendarHeader ?? PickersCalendarHeader;
  const calendarHeaderProps = useSlotProps({
    elementType: CalendarHeader,
    externalSlotProps: slotProps?.calendarHeader,
    additionalProps: {
      views,
      view,
      currentMonth: calendarState.currentMonth,
      onViewChange: setView,
      onMonthChange: (newMonth, direction) => handleChangeMonth({
        newMonth,
        direction
      }),
      minDate: minDateWithDisabled,
      maxDate: maxDateWithDisabled,
      disabled,
      disablePast,
      disableFuture,
      reduceAnimations,
      timezone,
      labelId: gridLabelId
    },
    ownerState: props
  });
  const handleDateMonthChange = useEventCallback((newDate) => {
    const startOfMonth = utils.startOfMonth(newDate);
    const endOfMonth = utils.endOfMonth(newDate);
    const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
      utils,
      date: newDate,
      minDate: utils.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
      maxDate: utils.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
      disablePast,
      disableFuture,
      isDateDisabled,
      timezone
    }) : newDate;
    if (closestEnabledDate) {
      setValueAndGoToNextView(closestEnabledDate, "finish");
      onMonthChange?.(startOfMonth);
    } else {
      goToNextView();
      changeMonth(startOfMonth);
    }
    changeFocusedDay(closestEnabledDate, true);
  });
  const handleDateYearChange = useEventCallback((newDate) => {
    const startOfYear = utils.startOfYear(newDate);
    const endOfYear = utils.endOfYear(newDate);
    const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
      utils,
      date: newDate,
      minDate: utils.isBefore(minDate, startOfYear) ? startOfYear : minDate,
      maxDate: utils.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
      disablePast,
      disableFuture,
      isDateDisabled,
      timezone
    }) : newDate;
    if (closestEnabledDate) {
      setValueAndGoToNextView(closestEnabledDate, "finish");
      onYearChange?.(closestEnabledDate);
    } else {
      goToNextView();
      changeMonth(startOfYear);
    }
    changeFocusedDay(closestEnabledDate, true);
  });
  const handleSelectedDayChange = useEventCallback((day) => {
    if (day) {
      return handleValueChange(mergeDateAndTime(utils, day, value ?? referenceDate), "finish", view);
    }
    return handleValueChange(day, "finish", view);
  });
  React$17.useEffect(() => {
    if (value != null && utils.isValid(value)) {
      changeMonth(value);
    }
  }, [value]);
  const ownerState = props;
  const classes = useUtilityClasses$8(ownerState);
  const baseDateValidationProps = {
    disablePast,
    disableFuture,
    maxDate,
    minDate
  };
  const commonViewProps = {
    disableHighlightToday,
    readOnly,
    disabled,
    timezone,
    gridLabelId,
    slots,
    slotProps
  };
  const prevOpenViewRef = React$17.useRef(view);
  React$17.useEffect(() => {
    if (prevOpenViewRef.current === view) {
      return;
    }
    if (focusedView === prevOpenViewRef.current) {
      setFocusedView(view, true);
    }
    prevOpenViewRef.current = view;
  }, [focusedView, setFocusedView, view]);
  const selectedDays = React$17.useMemo(() => [value], [value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DateCalendarRoot, _extends$3({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(CalendarHeader, _extends$3({}, calendarHeaderProps, {
      slots,
      slotProps
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(DateCalendarViewTransitionContainer, {
      reduceAnimations,
      className: classes.viewTransitionContainer,
      transKey: view,
      ownerState,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        children: [view === "year" && /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendar, _extends$3({}, baseDateValidationProps, commonViewProps, {
          value,
          onChange: handleDateYearChange,
          shouldDisableYear,
          hasFocus,
          onFocusedViewChange: (isViewFocused) => setFocusedView("year", isViewFocused),
          yearsOrder,
          yearsPerRow,
          referenceDate
        })), view === "month" && /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendar, _extends$3({}, baseDateValidationProps, commonViewProps, {
          hasFocus,
          className,
          value,
          onChange: handleDateMonthChange,
          shouldDisableMonth,
          onFocusedViewChange: (isViewFocused) => setFocusedView("month", isViewFocused),
          monthsPerRow,
          referenceDate
        })), view === "day" && /* @__PURE__ */ jsxRuntimeExports.jsx(DayCalendar, _extends$3({}, calendarState, baseDateValidationProps, commonViewProps, {
          onMonthSwitchingAnimationEnd,
          onFocusedDayChange: changeFocusedDay,
          reduceAnimations,
          selectedDays,
          onSelectedDaysChange: handleSelectedDayChange,
          shouldDisableDate,
          shouldDisableMonth,
          shouldDisableYear,
          hasFocus,
          onFocusedViewChange: (isViewFocused) => setFocusedView("day", isViewFocused),
          showDaysOutsideCurrentMonth,
          fixedWeekNumber,
          dayOfWeekFormatter,
          displayWeekNumber,
          loading,
          renderLoading
        }))]
      })
    })]
  }));
});

function getPickersToolbarUtilityClass(slot) {
  return generateUtilityClass('MuiPickersToolbar', slot);
}
generateUtilityClasses('MuiPickersToolbar', ['root', 'content']);

const _excluded$c = ["children", "className", "toolbarTitle", "hidden", "titleId", "isLandscape", "classes", "landscapeDirection"];
const React$16 = await importShared('react');
const useUtilityClasses$7 = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    content: ['content']
  };
  return composeClasses(slots, getPickersToolbarUtilityClass, classes);
};
const PickersToolbarRoot = styled('div', {
  name: 'MuiPickersToolbar',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'flex-start',
  justifyContent: 'space-between',
  padding: theme.spacing(2, 3),
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      height: 'auto',
      maxWidth: 160,
      padding: 16,
      justifyContent: 'flex-start',
      flexWrap: 'wrap'
    }
  }]
}));
const PickersToolbarContent = styled('div', {
  name: 'MuiPickersToolbar',
  slot: 'Content',
  overridesResolver: (props, styles) => styles.content
})({
  display: 'flex',
  flexWrap: 'wrap',
  width: '100%',
  flex: 1,
  justifyContent: 'space-between',
  alignItems: 'center',
  flexDirection: 'row',
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      justifyContent: 'flex-start',
      alignItems: 'flex-start',
      flexDirection: 'column'
    }
  }, {
    props: {
      isLandscape: true,
      landscapeDirection: 'row'
    },
    style: {
      flexDirection: 'row'
    }
  }]
});
const PickersToolbar = /*#__PURE__*/React$16.forwardRef(function PickersToolbar(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPickersToolbar'
  });
  const {
      children,
      className,
      toolbarTitle,
      hidden,
      titleId
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$c);
  const ownerState = props;
  const classes = useUtilityClasses$7(ownerState);
  if (hidden) {
    return null;
  }
  return /*#__PURE__*/jsxRuntimeExports.jsxs(PickersToolbarRoot, _extends$3({
    ref: ref,
    className: clsx(classes.root, className),
    ownerState: ownerState
  }, other, {
    children: [/*#__PURE__*/jsxRuntimeExports.jsx(Typography$4, {
      color: "text.secondary",
      variant: "overline",
      id: titleId,
      children: toolbarTitle
    }), /*#__PURE__*/jsxRuntimeExports.jsx(PickersToolbarContent, {
      className: classes.content,
      ownerState: ownerState,
      children: children
    })]
  }));
});

function getDatePickerToolbarUtilityClass(slot) {
  return generateUtilityClass('MuiDatePickerToolbar', slot);
}
generateUtilityClasses('MuiDatePickerToolbar', ['root', 'title']);

const _excluded$b = ["value", "isLandscape", "onChange", "toolbarFormat", "toolbarPlaceholder", "views", "className", "onViewChange", "view"];
const React$15 = await importShared('react');
await importShared('prop-types');
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    title: ["title"]
  };
  return composeClasses(slots, getDatePickerToolbarUtilityClass, classes);
};
const DatePickerToolbarRoot = styled(PickersToolbar, {
  name: "MuiDatePickerToolbar",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({});
const DatePickerToolbarTitle = styled(Typography$4, {
  name: "MuiDatePickerToolbar",
  slot: "Title",
  overridesResolver: (_, styles) => styles.title
})({
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      margin: "auto 16px auto auto"
    }
  }]
});
const DatePickerToolbar = /* @__PURE__ */ React$15.forwardRef(function DatePickerToolbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDatePickerToolbar"
  });
  const {
    value,
    isLandscape,
    toolbarFormat,
    toolbarPlaceholder = "––",
    views,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$b);
  const utils = useUtils();
  const translations = usePickersTranslations();
  const classes = useUtilityClasses$6(props);
  const dateText = React$15.useMemo(() => {
    if (!value) {
      return toolbarPlaceholder;
    }
    const formatFromViews = resolveDateFormat(utils, {
      format: toolbarFormat,
      views
    }, true);
    return utils.formatByString(value, formatFromViews);
  }, [value, toolbarFormat, toolbarPlaceholder, utils, views]);
  const ownerState = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DatePickerToolbarRoot, _extends$3({
    ref,
    toolbarTitle: translations.datePickerToolbarTitle,
    isLandscape,
    className: clsx(classes.root, className)
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DatePickerToolbarTitle, {
      variant: "h4",
      align: isLandscape ? "left" : "center",
      ownerState,
      className: classes.title,
      children: dateText
    })
  }));
});

const React$14 = await importShared('react');
function useDatePickerDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  const localeText = React$14.useMemo(() => {
    if (themeProps.localeText?.toolbarTitle == null) {
      return themeProps.localeText;
    }
    return _extends$3({}, themeProps.localeText, {
      datePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  return _extends$3({}, themeProps, {
    localeText
  }, applyDefaultViewProps({
    views: themeProps.views,
    openTo: themeProps.openTo,
    defaultViews: ['year', 'day'],
    defaultOpenTo: 'day'
  }), {
    disableFuture: themeProps.disableFuture ?? false,
    disablePast: themeProps.disablePast ?? false,
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate),
    slots: _extends$3({
      toolbar: DatePickerToolbar
    }, themeProps.slots)
  });
}

function getPickersPopperUtilityClass(slot) {
  return generateUtilityClass('MuiPickersPopper', slot);
}
generateUtilityClasses('MuiPickersPopper', ['root', 'paper']);

const _excluded$a = ["PaperComponent", "popperPlacement", "ownerState", "children", "paperSlotProps", "paperClasses", "onPaperClick", "onPaperTouchStart"];
const React$13 = await importShared('react');
const useUtilityClasses$5 = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    paper: ['paper']
  };
  return composeClasses(slots, getPickersPopperUtilityClass, classes);
};
const PickersPopperRoot = styled(Popper, {
  name: 'MuiPickersPopper',
  slot: 'Root',
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  zIndex: theme.zIndex.modal
}));
const PickersPopperPaper = styled(Paper$2, {
  name: 'MuiPickersPopper',
  slot: 'Paper',
  overridesResolver: (_, styles) => styles.paper
})({
  outline: 0,
  transformOrigin: 'top center',
  variants: [{
    props: ({
      placement
    }) => ['top', 'top-start', 'top-end'].includes(placement),
    style: {
      transformOrigin: 'bottom center'
    }
  }]
});
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
/**
 * Based on @mui/material/ClickAwayListener without the customization.
 * We can probably strip away even more since children won't be portaled.
 * @param {boolean} active Only listen to clicks when the popper is opened.
 * @param {(event: MouseEvent | TouchEvent) => void} onClickAway The callback to call when clicking outside the popper.
 * @returns {Array} The ref and event handler to listen to the outside clicks.
 */
function useClickAwayListener(active, onClickAway) {
  const movedRef = React$13.useRef(false);
  const syntheticEventRef = React$13.useRef(false);
  const nodeRef = React$13.useRef(null);
  const activatedRef = React$13.useRef(false);
  React$13.useEffect(() => {
    if (!active) {
      return undefined;
    }

    // Ensure that this hook is not "activated" synchronously.
    // https://github.com/facebook/react/issues/20074
    function armClickAwayListener() {
      activatedRef.current = true;
    }
    document.addEventListener('mousedown', armClickAwayListener, true);
    document.addEventListener('touchstart', armClickAwayListener, true);
    return () => {
      document.removeEventListener('mousedown', armClickAwayListener, true);
      document.removeEventListener('touchstart', armClickAwayListener, true);
      activatedRef.current = false;
    };
  }, [active]);

  // The handler doesn't take event.defaultPrevented into account:
  //
  // event.preventDefault() is meant to stop default behaviors like
  // clicking a checkbox to check it, hitting a button to submit a form,
  // and hitting left arrow to move the cursor in a text input etc.
  // Only special HTML elements have these default behaviors.
  const handleClickAway = useEventCallback(event => {
    if (!activatedRef.current) {
      return;
    }

    // Given developers can stop the propagation of the synthetic event,
    // we can only be confident with a positive value.
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);

    // 1. IE11 support, which trigger the handleClickAway even after the unbind
    // 2. The child might render null.
    // 3. Behave like a blur listener.
    if (!nodeRef.current ||
    // is a TouchEvent?
    'clientX' in event && clickedRootScrollbar(event, doc)) {
      return;
    }

    // Do not act if user performed touchmove
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;

    // If not enough, can use https://github.com/DieterHolvoet/event-propagation-path/blob/master/propagationPath.js
    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      insideDOM = !doc.documentElement.contains(event.target) || nodeRef.current.contains(event.target);
    }
    if (!insideDOM && !insideReactTree) {
      onClickAway(event);
    }
  });

  // Keep track of mouse/touch events that bubbled up through the portal.
  const handleSynthetic = () => {
    syntheticEventRef.current = true;
  };
  React$13.useEffect(() => {
    if (active) {
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener('touchstart', handleClickAway);
      doc.addEventListener('touchmove', handleTouchMove);
      return () => {
        doc.removeEventListener('touchstart', handleClickAway);
        doc.removeEventListener('touchmove', handleTouchMove);
      };
    }
    return undefined;
  }, [active, handleClickAway]);
  React$13.useEffect(() => {
    // TODO This behavior is not tested automatically
    // It's unclear whether this is due to different update semantics in test (batched in act() vs discrete on click).
    // Or if this is a timing related issues due to different Transition components
    // Once we get rid of all the manual scheduling (for example setTimeout(update, 0)) we can revisit this code+test.
    if (active) {
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener('click', handleClickAway);
      return () => {
        doc.removeEventListener('click', handleClickAway);
        // cleanup `handleClickAway`
        syntheticEventRef.current = false;
      };
    }
    return undefined;
  }, [active, handleClickAway]);
  return [nodeRef, handleSynthetic, handleSynthetic];
}
const PickersPopperPaperWrapper = /*#__PURE__*/React$13.forwardRef((props, ref) => {
  const {
      PaperComponent,
      popperPlacement,
      ownerState: inOwnerState,
      children,
      paperSlotProps,
      paperClasses,
      onPaperClick,
      onPaperTouchStart
      // picks up the style props provided by `Transition`
      // https://mui.com/material-ui/transitions/#child-requirement
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$a);
  const ownerState = _extends$3({}, inOwnerState, {
    placement: popperPlacement
  });
  const paperProps = useSlotProps({
    elementType: PaperComponent,
    externalSlotProps: paperSlotProps,
    additionalProps: {
      tabIndex: -1,
      elevation: 8,
      ref
    },
    className: paperClasses,
    ownerState
  });
  return /*#__PURE__*/jsxRuntimeExports.jsx(PaperComponent, _extends$3({}, other, paperProps, {
    onClick: event => {
      onPaperClick(event);
      paperProps.onClick?.(event);
    },
    onTouchStart: event => {
      onPaperTouchStart(event);
      paperProps.onTouchStart?.(event);
    },
    ownerState: ownerState,
    children: children
  }));
});
function PickersPopper(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPickersPopper'
  });
  const {
    anchorEl,
    children,
    containerRef = null,
    shouldRestoreFocus,
    onBlur,
    onDismiss,
    open,
    role,
    placement,
    slots,
    slotProps,
    reduceAnimations: inReduceAnimations
  } = props;
  React$13.useEffect(() => {
    function handleKeyDown(nativeEvent) {
      if (open && nativeEvent.key === 'Escape') {
        onDismiss();
      }
    }
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [onDismiss, open]);
  const lastFocusedElementRef = React$13.useRef(null);
  React$13.useEffect(() => {
    if (role === 'tooltip' || shouldRestoreFocus && !shouldRestoreFocus()) {
      return;
    }
    if (open) {
      lastFocusedElementRef.current = getActiveElement(document);
    } else if (lastFocusedElementRef.current && lastFocusedElementRef.current instanceof HTMLElement) {
      // make sure the button is flushed with updated label, before returning focus to it
      // avoids issue, where screen reader could fail to announce selected date after selection
      setTimeout(() => {
        if (lastFocusedElementRef.current instanceof HTMLElement) {
          lastFocusedElementRef.current.focus();
        }
      });
    }
  }, [open, role, shouldRestoreFocus]);
  const [clickAwayRef, onPaperClick, onPaperTouchStart] = useClickAwayListener(open, onBlur ?? onDismiss);
  const paperRef = React$13.useRef(null);
  const handleRef = useForkRef(paperRef, containerRef);
  const handlePaperRef = useForkRef(handleRef, clickAwayRef);
  const ownerState = props;
  const classes = useUtilityClasses$5(ownerState);
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const reduceAnimations = inReduceAnimations ?? defaultReduceAnimations;
  const handleKeyDown = event => {
    if (event.key === 'Escape') {
      // stop the propagation to avoid closing parent modal
      event.stopPropagation();
      onDismiss();
    }
  };
  const Transition = slots?.desktopTransition ?? reduceAnimations ? Fade : Grow;
  const FocusTrap$1 = slots?.desktopTrapFocus ?? FocusTrap;
  const Paper = slots?.desktopPaper ?? PickersPopperPaper;
  const Popper = slots?.popper ?? PickersPopperRoot;
  const popperProps = useSlotProps({
    elementType: Popper,
    externalSlotProps: slotProps?.popper,
    additionalProps: {
      transition: true,
      role,
      open,
      anchorEl,
      placement,
      onKeyDown: handleKeyDown
    },
    className: classes.root,
    ownerState: props
  });
  return /*#__PURE__*/jsxRuntimeExports.jsx(Popper, _extends$3({}, popperProps, {
    children: ({
      TransitionProps,
      placement: popperPlacement
    }) => /*#__PURE__*/jsxRuntimeExports.jsx(FocusTrap$1, _extends$3({
      open: open,
      disableAutoFocus: true
      // pickers are managing focus position manually
      // without this prop the focus is returned to the button before `aria-label` is updated
      // which would force screen readers to read too old label
      ,
      disableRestoreFocus: true,
      disableEnforceFocus: role === 'tooltip',
      isEnabled: () => true
    }, slotProps?.desktopTrapFocus, {
      children: /*#__PURE__*/jsxRuntimeExports.jsx(Transition, _extends$3({}, TransitionProps, slotProps?.desktopTransition, {
        children: /*#__PURE__*/jsxRuntimeExports.jsx(PickersPopperPaperWrapper, {
          PaperComponent: Paper,
          ownerState: ownerState,
          popperPlacement: popperPlacement,
          ref: handlePaperRef,
          onPaperClick: onPaperClick,
          onPaperTouchStart: onPaperTouchStart,
          paperClasses: classes.paper,
          paperSlotProps: slotProps?.desktopPaper,
          children: children
        })
      }))
    }))
  }));
}

const React$12 = await importShared('react');

const useOpenState = ({
  open,
  onOpen,
  onClose
}) => {
  const isControllingOpenProp = React$12.useRef(typeof open === 'boolean').current;
  const [openState, setIsOpenState] = React$12.useState(false);

  // It is required to update inner state in useEffect in order to avoid situation when
  // Our component is not mounted yet, but `open` state is set to `true` (for example initially opened)
  React$12.useEffect(() => {
    if (isControllingOpenProp) {
      if (typeof open !== 'boolean') {
        throw new Error('You must not mix controlling and uncontrolled mode for `open` prop');
      }
      setIsOpenState(open);
    }
  }, [isControllingOpenProp, open]);
  const setIsOpen = React$12.useCallback(newIsOpen => {
    if (!isControllingOpenProp) {
      setIsOpenState(newIsOpen);
    }
    if (newIsOpen && onOpen) {
      onOpen();
    }
    if (!newIsOpen && onClose) {
      onClose();
    }
  }, [isControllingOpenProp, onOpen, onClose]);
  return {
    isOpen: openState,
    setIsOpen
  };
};

const React$11 = await importShared('react');
const shouldPublishValue = (params) => {
  const {
    action,
    hasChanged,
    dateState,
    isControlled
  } = params;
  const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
  if (action.name === "setValueFromField") {
    return true;
  }
  if (action.name === "setValueFromAction") {
    if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
      return true;
    }
    return hasChanged(dateState.lastPublishedValue);
  }
  if (action.name === "setValueFromView" && action.selectionState !== "shallow") {
    if (isCurrentValueTheDefaultValue) {
      return true;
    }
    return hasChanged(dateState.lastPublishedValue);
  }
  if (action.name === "setValueFromShortcut") {
    if (isCurrentValueTheDefaultValue) {
      return true;
    }
    return hasChanged(dateState.lastPublishedValue);
  }
  return false;
};
const shouldCommitValue = (params) => {
  const {
    action,
    hasChanged,
    dateState,
    isControlled,
    closeOnSelect
  } = params;
  const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
  if (action.name === "setValueFromAction") {
    if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
      return true;
    }
    return hasChanged(dateState.lastCommittedValue);
  }
  if (action.name === "setValueFromView" && action.selectionState === "finish" && closeOnSelect) {
    if (isCurrentValueTheDefaultValue) {
      return true;
    }
    return hasChanged(dateState.lastCommittedValue);
  }
  if (action.name === "setValueFromShortcut") {
    return action.changeImportance === "accept" && hasChanged(dateState.lastCommittedValue);
  }
  return false;
};
const shouldClosePicker = (params) => {
  const {
    action,
    closeOnSelect
  } = params;
  if (action.name === "setValueFromAction") {
    return true;
  }
  if (action.name === "setValueFromView") {
    return action.selectionState === "finish" && closeOnSelect;
  }
  if (action.name === "setValueFromShortcut") {
    return action.changeImportance === "accept";
  }
  return false;
};
const usePickerValue = ({
  props,
  valueManager,
  valueType,
  wrapperVariant,
  validator
}) => {
  const {
    onAccept,
    onChange,
    value: inValueWithoutRenderTimezone,
    defaultValue: inDefaultValue,
    closeOnSelect = wrapperVariant === "desktop",
    timezone: timezoneProp,
    referenceDate
  } = props;
  const {
    current: defaultValue
  } = React$11.useRef(inDefaultValue);
  const {
    current: isControlled
  } = React$11.useRef(inValueWithoutRenderTimezone !== void 0);
  const [previousTimezoneProp, setPreviousTimezoneProp] = React$11.useState(timezoneProp);
  const utils = useUtils();
  const adapter = useLocalizationContext();
  const {
    isOpen,
    setIsOpen
  } = useOpenState(props);
  const {
    timezone,
    value: inValueWithTimezoneToRender,
    handleValueChange
  } = useValueWithTimezone({
    timezone: timezoneProp,
    value: inValueWithoutRenderTimezone,
    defaultValue,
    referenceDate,
    onChange,
    valueManager
  });
  const [dateState, setDateState] = React$11.useState(() => {
    let initialValue;
    if (inValueWithTimezoneToRender !== void 0) {
      initialValue = inValueWithTimezoneToRender;
    } else if (defaultValue !== void 0) {
      initialValue = defaultValue;
    } else {
      initialValue = valueManager.emptyValue;
    }
    return {
      draft: initialValue,
      lastPublishedValue: initialValue,
      lastCommittedValue: initialValue,
      lastControlledValue: inValueWithoutRenderTimezone,
      hasBeenModifiedSinceMount: false
    };
  });
  const timezoneFromDraftValue = valueManager.getTimezone(utils, dateState.draft);
  if (previousTimezoneProp !== timezoneProp) {
    setPreviousTimezoneProp(timezoneProp);
    if (timezoneProp && timezoneFromDraftValue && timezoneProp !== timezoneFromDraftValue) {
      setDateState((prev) => _extends$3({}, prev, {
        draft: valueManager.setTimezone(utils, timezoneProp, prev.draft)
      }));
    }
  }
  const {
    getValidationErrorForNewValue
  } = useValidation({
    props,
    validator,
    timezone,
    value: dateState.draft,
    onError: props.onError
  });
  const updateDate = useEventCallback((action) => {
    const updaterParams = {
      action,
      dateState,
      hasChanged: (comparison) => !valueManager.areValuesEqual(utils, action.value, comparison),
      isControlled,
      closeOnSelect
    };
    const shouldPublish = shouldPublishValue(updaterParams);
    const shouldCommit = shouldCommitValue(updaterParams);
    const shouldClose = shouldClosePicker(updaterParams);
    setDateState((prev) => _extends$3({}, prev, {
      draft: action.value,
      lastPublishedValue: shouldPublish ? action.value : prev.lastPublishedValue,
      lastCommittedValue: shouldCommit ? action.value : prev.lastCommittedValue,
      hasBeenModifiedSinceMount: true
    }));
    let cachedContext = null;
    const getContext = () => {
      if (!cachedContext) {
        const validationError = action.name === "setValueFromField" ? action.context.validationError : getValidationErrorForNewValue(action.value);
        cachedContext = {
          validationError
        };
        if (action.name === "setValueFromShortcut") {
          cachedContext.shortcut = action.shortcut;
        }
      }
      return cachedContext;
    };
    if (shouldPublish) {
      handleValueChange(action.value, getContext());
    }
    if (shouldCommit && onAccept) {
      onAccept(action.value, getContext());
    }
    if (shouldClose) {
      setIsOpen(false);
    }
  });
  if (dateState.lastControlledValue !== inValueWithoutRenderTimezone) {
    const isUpdateComingFromPicker = valueManager.areValuesEqual(utils, dateState.draft, inValueWithTimezoneToRender);
    setDateState((prev) => _extends$3({}, prev, {
      lastControlledValue: inValueWithoutRenderTimezone
    }, isUpdateComingFromPicker ? {} : {
      lastCommittedValue: inValueWithTimezoneToRender,
      lastPublishedValue: inValueWithTimezoneToRender,
      draft: inValueWithTimezoneToRender,
      hasBeenModifiedSinceMount: true
    }));
  }
  const handleClear = useEventCallback(() => {
    updateDate({
      value: valueManager.emptyValue,
      name: "setValueFromAction",
      pickerAction: "clear"
    });
  });
  const handleAccept = useEventCallback(() => {
    updateDate({
      value: dateState.lastPublishedValue,
      name: "setValueFromAction",
      pickerAction: "accept"
    });
  });
  const handleDismiss = useEventCallback(() => {
    updateDate({
      value: dateState.lastPublishedValue,
      name: "setValueFromAction",
      pickerAction: "dismiss"
    });
  });
  const handleCancel = useEventCallback(() => {
    updateDate({
      value: dateState.lastCommittedValue,
      name: "setValueFromAction",
      pickerAction: "cancel"
    });
  });
  const handleSetToday = useEventCallback(() => {
    updateDate({
      value: valueManager.getTodayValue(utils, timezone, valueType),
      name: "setValueFromAction",
      pickerAction: "today"
    });
  });
  const handleOpen = useEventCallback((event) => {
    event.preventDefault();
    setIsOpen(true);
  });
  const handleClose = useEventCallback((event) => {
    event?.preventDefault();
    setIsOpen(false);
  });
  const handleChange = useEventCallback((newValue, selectionState = "partial") => updateDate({
    name: "setValueFromView",
    value: newValue,
    selectionState
  }));
  const handleSelectShortcut = useEventCallback((newValue, changeImportance, shortcut) => updateDate({
    name: "setValueFromShortcut",
    value: newValue,
    changeImportance,
    shortcut
  }));
  const handleChangeFromField = useEventCallback((newValue, context) => updateDate({
    name: "setValueFromField",
    value: newValue,
    context
  }));
  const actions = {
    onClear: handleClear,
    onAccept: handleAccept,
    onDismiss: handleDismiss,
    onCancel: handleCancel,
    onSetToday: handleSetToday,
    onOpen: handleOpen,
    onClose: handleClose
  };
  const fieldResponse = {
    value: dateState.draft,
    onChange: handleChangeFromField
  };
  const viewValue = React$11.useMemo(() => valueManager.cleanValue(utils, dateState.draft), [utils, valueManager, dateState.draft]);
  const viewResponse = {
    value: viewValue,
    onChange: handleChange,
    onClose: handleClose,
    open: isOpen
  };
  const isValid = (testedValue) => {
    const error = validator({
      adapter,
      value: testedValue,
      timezone,
      props
    });
    return !valueManager.hasError(error);
  };
  const layoutResponse = _extends$3({}, actions, {
    value: viewValue,
    onChange: handleChange,
    onSelectShortcut: handleSelectShortcut,
    isValid
  });
  const contextValue = React$11.useMemo(() => ({
    onOpen: handleOpen,
    onClose: handleClose,
    open: isOpen
  }), [isOpen, handleClose, handleOpen]);
  return {
    open: isOpen,
    fieldProps: fieldResponse,
    viewProps: viewResponse,
    layoutProps: layoutResponse,
    actions,
    contextValue
  };
};

const _excluded$9 = ["className", "sx"];
const React$10 = await importShared('react');

/**
 * Props used to handle the views that are common to all pickers.
 */

/**
 * Props used to handle the views of the pickers.
 */

/**
 * Props used to handle the value of the pickers.
 */

/**
 * Manage the views of all the pickers:
 * - Handles the view switch
 * - Handles the switch between UI views and field views
 * - Handles the focus management when switching views
 */
const usePickerViews = ({
  props,
  propsFromPickerValue,
  additionalViewProps,
  autoFocusView,
  rendererInterceptor,
  fieldRef
}) => {
  const {
    onChange,
    open,
    onClose
  } = propsFromPickerValue;
  const {
    view: inView,
    views,
    openTo,
    onViewChange,
    viewRenderers,
    timezone
  } = props;
  const propsToForwardToView = _objectWithoutPropertiesLoose(props, _excluded$9);
  const {
    view,
    setView,
    defaultView,
    focusedView,
    setFocusedView,
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onChange,
    onViewChange,
    autoFocus: autoFocusView
  });
  const {
    hasUIView,
    viewModeLookup
  } = React$10.useMemo(() => views.reduce((acc, viewForReduce) => {
    let viewMode;
    if (viewRenderers[viewForReduce] != null) {
      viewMode = 'UI';
    } else {
      viewMode = 'field';
    }
    acc.viewModeLookup[viewForReduce] = viewMode;
    if (viewMode === 'UI') {
      acc.hasUIView = true;
    }
    return acc;
  }, {
    hasUIView: false,
    viewModeLookup: {}
  }), [viewRenderers, views]);
  const timeViewsCount = React$10.useMemo(() => views.reduce((acc, viewForReduce) => {
    if (viewRenderers[viewForReduce] != null && isTimeView(viewForReduce)) {
      return acc + 1;
    }
    return acc;
  }, 0), [viewRenderers, views]);
  const currentViewMode = viewModeLookup[view];
  const shouldRestoreFocus = useEventCallback(() => currentViewMode === 'UI');
  const [popperView, setPopperView] = React$10.useState(currentViewMode === 'UI' ? view : null);
  if (popperView !== view && viewModeLookup[view] === 'UI') {
    setPopperView(view);
  }
  useEnhancedEffect(() => {
    // Handle case of `DateTimePicker` without time renderers
    if (currentViewMode === 'field' && open) {
      onClose();
      setTimeout(() => {
        fieldRef?.current?.setSelectedSections(view);
        // focusing the input before the range selection is done
        // calling it outside of timeout results in an inconsistent behavior between Safari And Chrome
        fieldRef?.current?.focusField(view);
      });
    }
  }, [view]); // eslint-disable-line react-hooks/exhaustive-deps

  useEnhancedEffect(() => {
    if (!open) {
      return;
    }
    let newView = view;

    // If the current view is a field view, go to the last popper view
    if (currentViewMode === 'field' && popperView != null) {
      newView = popperView;
    }

    // If the current view is not the default view and both are UI views
    if (newView !== defaultView && viewModeLookup[newView] === 'UI' && viewModeLookup[defaultView] === 'UI') {
      newView = defaultView;
    }
    if (newView !== view) {
      setView(newView);
    }
    setFocusedView(newView, true);
  }, [open]); // eslint-disable-line react-hooks/exhaustive-deps

  const layoutProps = {
    views,
    view: popperView,
    onViewChange: setView
  };
  return {
    hasUIView,
    shouldRestoreFocus,
    layoutProps,
    renderCurrentView: () => {
      if (popperView == null) {
        return null;
      }
      const renderer = viewRenderers[popperView];
      if (renderer == null) {
        return null;
      }
      const rendererProps = _extends$3({}, propsToForwardToView, additionalViewProps, propsFromPickerValue, {
        views,
        timezone,
        onChange: setValueAndGoToNextView,
        view: popperView,
        onViewChange: setView,
        focusedView,
        onFocusedViewChange: setFocusedView,
        showViewSwitcher: timeViewsCount > 1,
        timeViewsCount
      });
      if (rendererInterceptor) {
        return rendererInterceptor(viewRenderers, popperView, rendererProps);
      }
      return renderer(rendererProps);
    }
  };
};

const React$$ = await importShared('react');
function getOrientation() {
  if (typeof window === 'undefined') {
    return 'portrait';
  }
  if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
    return Math.abs(window.screen.orientation.angle) === 90 ? 'landscape' : 'portrait';
  }

  // Support IOS safari
  if (window.orientation) {
    return Math.abs(Number(window.orientation)) === 90 ? 'landscape' : 'portrait';
  }
  return 'portrait';
}
const useIsLandscape = (views, customOrientation) => {
  const [orientation, setOrientation] = React$$.useState(getOrientation);
  useEnhancedEffect(() => {
    const eventHandler = () => {
      setOrientation(getOrientation());
    };
    window.addEventListener('orientationchange', eventHandler);
    return () => {
      window.removeEventListener('orientationchange', eventHandler);
    };
  }, []);
  if (arrayIncludes(views, ['hours', 'minutes', 'seconds'])) {
    // could not display 13:34:44 in landscape mode
    return false;
  }
  const orientationToUse = customOrientation || orientation;
  return orientationToUse === 'landscape';
};

/**
 * Props used to create the layout of the views.
 * Those props are exposed on all the pickers.
 */

/**
 * Prepare the props for the view layout (managed by `PickersLayout`)
 */
const usePickerLayoutProps = ({
  props,
  propsFromPickerValue,
  propsFromPickerViews,
  wrapperVariant
}) => {
  const {
    orientation
  } = props;
  const isLandscape = useIsLandscape(propsFromPickerViews.views, orientation);
  const isRtl = useRtl();
  const layoutProps = _extends$3({}, propsFromPickerViews, propsFromPickerValue, {
    isLandscape,
    isRtl,
    wrapperVariant,
    disabled: props.disabled,
    readOnly: props.readOnly
  });
  return {
    layoutProps
  };
};

const React$_ = await importShared('react');

function usePickerOwnerState(parameters) {
  const {
    props,
    pickerValueResponse
  } = parameters;
  return React$_.useMemo(() => ({
    value: pickerValueResponse.viewProps.value,
    open: pickerValueResponse.open,
    disabled: props.disabled ?? false,
    readOnly: props.readOnly ?? false
  }), [pickerValueResponse.viewProps.value, pickerValueResponse.open, props.disabled, props.readOnly]);
}

const usePicker = ({
  props,
  valueManager,
  valueType,
  wrapperVariant,
  additionalViewProps,
  validator,
  autoFocusView,
  rendererInterceptor,
  fieldRef
}) => {
  const pickerValueResponse = usePickerValue({
    props,
    valueManager,
    valueType,
    wrapperVariant,
    validator
  });
  const pickerViewsResponse = usePickerViews({
    props,
    additionalViewProps,
    autoFocusView,
    fieldRef,
    propsFromPickerValue: pickerValueResponse.viewProps,
    rendererInterceptor
  });
  const pickerLayoutResponse = usePickerLayoutProps({
    props,
    wrapperVariant,
    propsFromPickerValue: pickerValueResponse.layoutProps,
    propsFromPickerViews: pickerViewsResponse.layoutProps
  });
  const pickerOwnerState = usePickerOwnerState({
    props,
    pickerValueResponse
  });
  return {
    // Picker value
    open: pickerValueResponse.open,
    actions: pickerValueResponse.actions,
    fieldProps: pickerValueResponse.fieldProps,
    // Picker views
    renderCurrentView: pickerViewsResponse.renderCurrentView,
    hasUIView: pickerViewsResponse.hasUIView,
    shouldRestoreFocus: pickerViewsResponse.shouldRestoreFocus,
    // Picker layout
    layoutProps: pickerLayoutResponse.layoutProps,
    // Picker context
    contextValue: pickerValueResponse.contextValue,
    // Picker owner state
    ownerState: pickerOwnerState
  };
};

function getPickersLayoutUtilityClass(slot) {
  return generateUtilityClass('MuiPickersLayout', slot);
}
const pickersLayoutClasses = generateUtilityClasses('MuiPickersLayout', ['root', 'landscape', 'contentWrapper', 'toolbar', 'actionBar', 'tabs', 'shortcuts']);

const _excluded$8 = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
await importShared('react');

await importShared('prop-types');
function PickersActionBar(props) {
  const {
    onAccept,
    onClear,
    onCancel,
    onSetToday,
    actions
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
  const translations = usePickersTranslations();
  if (actions == null || actions.length === 0) {
    return null;
  }
  const buttons = actions?.map((actionType) => {
    switch (actionType) {
      case "clear":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$e, {
          onClick: onClear,
          children: translations.clearButtonLabel
        }, actionType);
      case "cancel":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$e, {
          onClick: onCancel,
          children: translations.cancelButtonLabel
        }, actionType);
      case "accept":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$e, {
          onClick: onAccept,
          children: translations.okButtonLabel
        }, actionType);
      case "today":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$e, {
          onClick: onSetToday,
          children: translations.todayButtonLabel
        }, actionType);
      default:
        return null;
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions$4, _extends$3({}, other, {
    children: buttons
  }));
}

const _excluded$7 = ["items", "changeImportance", "isLandscape", "onChange", "isValid"], _excluded2$1 = ["getValue"];
await importShared('react');

await importShared('prop-types');
function PickersShortcuts(props) {
  const {
    items,
    changeImportance = "accept",
    onChange,
    isValid
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$7);
  if (items == null || items.length === 0) {
    return null;
  }
  const resolvedItems = items.map((_ref) => {
    let {
      getValue
    } = _ref, item = _objectWithoutPropertiesLoose(_ref, _excluded2$1);
    const newValue = getValue({
      isValid
    });
    return _extends$3({}, item, {
      label: item.label,
      onClick: () => {
        onChange(newValue, changeImportance, item);
      },
      disabled: !isValid(newValue)
    });
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List, _extends$3({
    dense: true,
    sx: [{
      maxHeight: VIEW_HEIGHT,
      maxWidth: 200,
      overflow: "auto"
    }, ...Array.isArray(other.sx) ? other.sx : [other.sx]]
  }, other, {
    children: resolvedItems.map((item) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$3, _extends$3({}, item))
      }, item.id ?? item.label);
    })
  }));
}

await importShared('react');
function toolbarHasView(toolbarProps) {
  return toolbarProps.view !== null;
}
const useUtilityClasses$4 = ownerState => {
  const {
    classes,
    isLandscape
  } = ownerState;
  const slots = {
    root: ['root', isLandscape && 'landscape'],
    contentWrapper: ['contentWrapper'],
    toolbar: ['toolbar'],
    actionBar: ['actionBar'],
    tabs: ['tabs'],
    landscape: ['landscape'],
    shortcuts: ['shortcuts']
  };
  return composeClasses(slots, getPickersLayoutUtilityClass, classes);
};
const usePickerLayout = props => {
  const {
    wrapperVariant,
    onAccept,
    onClear,
    onCancel,
    onSetToday,
    view,
    views,
    onViewChange,
    value,
    onChange,
    onSelectShortcut,
    isValid,
    isLandscape,
    disabled,
    readOnly,
    children,
    slots,
    slotProps
    // TODO: Remove this "as" hack. It get introduced to mark `value` prop in PickersLayoutProps as not required.
    // The true type should be
    // - For pickers value: TDate | null
    // - For range pickers value: [TDate | null, TDate | null]
  } = props;
  const classes = useUtilityClasses$4(props);

  // Action bar
  const ActionBar = slots?.actionBar ?? PickersActionBar;
  const actionBarProps = useSlotProps({
    elementType: ActionBar,
    externalSlotProps: slotProps?.actionBar,
    additionalProps: {
      onAccept,
      onClear,
      onCancel,
      onSetToday,
      actions: wrapperVariant === 'desktop' ? [] : ['cancel', 'accept']
    },
    className: classes.actionBar,
    ownerState: _extends$3({}, props, {
      wrapperVariant
    })
  });
  const actionBar = /*#__PURE__*/jsxRuntimeExports.jsx(ActionBar, _extends$3({}, actionBarProps));

  // Toolbar
  const Toolbar = slots?.toolbar;
  const toolbarProps = useSlotProps({
    elementType: Toolbar,
    externalSlotProps: slotProps?.toolbar,
    additionalProps: {
      isLandscape,
      onChange,
      value,
      view,
      onViewChange,
      views,
      disabled,
      readOnly
    },
    className: classes.toolbar,
    ownerState: _extends$3({}, props, {
      wrapperVariant
    })
  });
  const toolbar = toolbarHasView(toolbarProps) && !!Toolbar ? /*#__PURE__*/jsxRuntimeExports.jsx(Toolbar, _extends$3({}, toolbarProps)) : null;

  // Content
  const content = children;

  // Tabs
  const Tabs = slots?.tabs;
  const tabs = view && Tabs ? /*#__PURE__*/jsxRuntimeExports.jsx(Tabs, _extends$3({
    view: view,
    onViewChange: onViewChange,
    className: classes.tabs
  }, slotProps?.tabs)) : null;

  // Shortcuts
  const Shortcuts = slots?.shortcuts ?? PickersShortcuts;
  const shortcutsProps = useSlotProps({
    elementType: Shortcuts,
    externalSlotProps: slotProps?.shortcuts,
    additionalProps: {
      isValid,
      isLandscape,
      onChange: onSelectShortcut
    },
    className: classes.shortcuts,
    ownerState: {
      isValid,
      isLandscape,
      onChange: onSelectShortcut,
      wrapperVariant
    }
  });
  const shortcuts = view && !!Shortcuts ? /*#__PURE__*/jsxRuntimeExports.jsx(Shortcuts, _extends$3({}, shortcutsProps)) : null;
  return {
    toolbar,
    content,
    tabs,
    actionBar,
    shortcuts
  };
};

const React$Z = await importShared('react');

await importShared('prop-types');
const useUtilityClasses$3 = (ownerState) => {
  const {
    isLandscape,
    classes
  } = ownerState;
  const slots = {
    root: ["root", isLandscape && "landscape"],
    contentWrapper: ["contentWrapper"]
  };
  return composeClasses(slots, getPickersLayoutUtilityClass, classes);
};
const PickersLayoutRoot = styled("div", {
  name: "MuiPickersLayout",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  display: "grid",
  gridAutoColumns: "max-content auto max-content",
  gridAutoRows: "max-content auto max-content",
  [`& .${pickersLayoutClasses.actionBar}`]: {
    gridColumn: "1 / 4",
    gridRow: 3
  },
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      [`& .${pickersLayoutClasses.toolbar}`]: {
        gridColumn: 1,
        gridRow: "2 / 3"
      },
      [`.${pickersLayoutClasses.shortcuts}`]: {
        gridColumn: "2 / 4",
        gridRow: 1
      }
    }
  }, {
    props: {
      isLandscape: true,
      isRtl: true
    },
    style: {
      [`& .${pickersLayoutClasses.toolbar}`]: {
        gridColumn: 3
      }
    }
  }, {
    props: {
      isLandscape: false
    },
    style: {
      [`& .${pickersLayoutClasses.toolbar}`]: {
        gridColumn: "2 / 4",
        gridRow: 1
      },
      [`& .${pickersLayoutClasses.shortcuts}`]: {
        gridColumn: 1,
        gridRow: "2 / 3"
      }
    }
  }, {
    props: {
      isLandscape: false,
      isRtl: true
    },
    style: {
      [`& .${pickersLayoutClasses.shortcuts}`]: {
        gridColumn: 3
      }
    }
  }]
});
const PickersLayoutContentWrapper = styled("div", {
  name: "MuiPickersLayout",
  slot: "ContentWrapper",
  overridesResolver: (props, styles) => styles.contentWrapper
})({
  gridColumn: 2,
  gridRow: 2,
  display: "flex",
  flexDirection: "column"
});
const PickersLayout = /* @__PURE__ */ React$Z.forwardRef(function PickersLayout2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersLayout"
  });
  const {
    toolbar,
    content,
    tabs,
    actionBar,
    shortcuts
  } = usePickerLayout(props);
  const {
    sx,
    className,
    isLandscape,
    wrapperVariant
  } = props;
  const classes = useUtilityClasses$3(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutRoot, {
    ref,
    sx,
    className: clsx(classes.root, className),
    ownerState: props,
    children: [isLandscape ? shortcuts : toolbar, isLandscape ? toolbar : shortcuts, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersLayoutContentWrapper, {
      className: classes.contentWrapper,
      children: wrapperVariant === "desktop" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(React$Z.Fragment, {
        children: [content, tabs]
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(React$Z.Fragment, {
        children: [tabs, content]
      })
    }), actionBar]
  });
});

const _excluded$6 = ["props", "getOpenDialogAriaText"],
  _excluded2 = ["ownerState"],
  _excluded3 = ["ownerState"];
const React$Y = await importShared('react');
const useDesktopPicker = _ref => {
  let {
      props,
      getOpenDialogAriaText
    } = _ref,
    pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded$6);
  const {
    slots,
    slotProps: innerSlotProps,
    className,
    sx,
    format,
    formatDensity,
    enableAccessibleFieldDOMStructure,
    selectedSections,
    onSelectedSectionsChange,
    timezone,
    name,
    label,
    inputRef,
    readOnly,
    disabled,
    autoFocus,
    localeText,
    reduceAnimations
  } = props;
  const containerRef = React$Y.useRef(null);
  const fieldRef = React$Y.useRef(null);
  const labelId = useId();
  const isToolbarHidden = innerSlotProps?.toolbar?.hidden ?? false;
  const {
    open,
    actions,
    hasUIView,
    layoutProps,
    renderCurrentView,
    shouldRestoreFocus,
    fieldProps: pickerFieldProps,
    contextValue,
    ownerState
  } = usePicker(_extends$3({}, pickerParams, {
    props,
    fieldRef,
    autoFocusView: true,
    additionalViewProps: {},
    wrapperVariant: 'desktop'
  }));
  const InputAdornment = slots.inputAdornment ?? InputAdornment$5;
  const _useSlotProps = useSlotProps({
      elementType: InputAdornment,
      externalSlotProps: innerSlotProps?.inputAdornment,
      additionalProps: {
        position: 'end'
      },
      ownerState: props
    }),
    inputAdornmentProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2);
  const OpenPickerButton = slots.openPickerButton ?? IconButton$e;
  const _useSlotProps2 = useSlotProps({
      elementType: OpenPickerButton,
      externalSlotProps: innerSlotProps?.openPickerButton,
      additionalProps: {
        disabled: disabled || readOnly,
        onClick: open ? actions.onClose : actions.onOpen,
        'aria-label': getOpenDialogAriaText(pickerFieldProps.value),
        edge: inputAdornmentProps.position
      },
      ownerState: props
    }),
    openPickerButtonProps = _objectWithoutPropertiesLoose(_useSlotProps2, _excluded3);
  const OpenPickerIcon = slots.openPickerIcon;
  const openPickerIconProps = useSlotProps({
    elementType: OpenPickerIcon,
    externalSlotProps: innerSlotProps?.openPickerIcon,
    ownerState
  });
  const Field = slots.field;
  const fieldProps = useSlotProps({
    elementType: Field,
    externalSlotProps: innerSlotProps?.field,
    additionalProps: _extends$3({}, pickerFieldProps, isToolbarHidden && {
      id: labelId
    }, {
      readOnly,
      disabled,
      className,
      sx,
      format,
      formatDensity,
      enableAccessibleFieldDOMStructure,
      selectedSections,
      onSelectedSectionsChange,
      timezone,
      label,
      name,
      autoFocus: autoFocus && !props.open,
      focused: open ? true : undefined
    }, inputRef ? {
      inputRef
    } : {}),
    ownerState: props
  });

  // TODO: Move to `useSlotProps` when https://github.com/mui/material-ui/pull/35088 will be merged
  if (hasUIView) {
    fieldProps.InputProps = _extends$3({}, fieldProps.InputProps, {
      ref: containerRef
    }, !props.disableOpenPicker && {
      [`${inputAdornmentProps.position}Adornment`]: /*#__PURE__*/jsxRuntimeExports.jsx(InputAdornment, _extends$3({}, inputAdornmentProps, {
        children: /*#__PURE__*/jsxRuntimeExports.jsx(OpenPickerButton, _extends$3({}, openPickerButtonProps, {
          children: /*#__PURE__*/jsxRuntimeExports.jsx(OpenPickerIcon, _extends$3({}, openPickerIconProps))
        }))
      }))
    });
  }
  const slotsForField = _extends$3({
    textField: slots.textField,
    clearIcon: slots.clearIcon,
    clearButton: slots.clearButton
  }, fieldProps.slots);
  const Layout = slots.layout ?? PickersLayout;
  let labelledById = labelId;
  if (isToolbarHidden) {
    if (label) {
      labelledById = `${labelId}-label`;
    } else {
      labelledById = undefined;
    }
  }
  const slotProps = _extends$3({}, innerSlotProps, {
    toolbar: _extends$3({}, innerSlotProps?.toolbar, {
      titleId: labelId
    }),
    popper: _extends$3({
      'aria-labelledby': labelledById
    }, innerSlotProps?.popper)
  });
  const handleFieldRef = useForkRef(fieldRef, fieldProps.unstableFieldRef);
  const renderPicker = () => /*#__PURE__*/jsxRuntimeExports.jsxs(PickersProvider, {
    contextValue: contextValue,
    localeText: localeText,
    children: [/*#__PURE__*/jsxRuntimeExports.jsx(Field, _extends$3({}, fieldProps, {
      slots: slotsForField,
      slotProps: slotProps,
      unstableFieldRef: handleFieldRef
    })), /*#__PURE__*/jsxRuntimeExports.jsx(PickersPopper, _extends$3({
      role: "dialog",
      placement: "bottom-start",
      anchorEl: containerRef.current
    }, actions, {
      open: open,
      slots: slots,
      slotProps: slotProps,
      shouldRestoreFocus: shouldRestoreFocus,
      reduceAnimations: reduceAnimations,
      children: /*#__PURE__*/jsxRuntimeExports.jsx(Layout, _extends$3({}, layoutProps, slotProps?.layout, {
        slots: slots,
        slotProps: slotProps,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};

await importShared('react');
const renderDateViewCalendar = ({
  view,
  onViewChange,
  views,
  focusedView,
  onFocusedViewChange,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  shouldDisableMonth,
  shouldDisableYear,
  reduceAnimations,
  onMonthChange,
  monthsPerRow,
  onYearChange,
  yearsOrder,
  yearsPerRow,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  sx,
  autoFocus,
  fixedWeekNumber,
  displayWeekNumber,
  timezone
}) => /*#__PURE__*/jsxRuntimeExports.jsx(DateCalendar, {
  view: view,
  onViewChange: onViewChange,
  views: views.filter(isDatePickerView),
  focusedView: focusedView && isDatePickerView(focusedView) ? focusedView : null,
  onFocusedViewChange: onFocusedViewChange,
  value: value,
  defaultValue: defaultValue,
  referenceDate: referenceDate,
  onChange: onChange,
  className: className,
  classes: classes,
  disableFuture: disableFuture,
  disablePast: disablePast,
  minDate: minDate,
  maxDate: maxDate,
  shouldDisableDate: shouldDisableDate,
  shouldDisableMonth: shouldDisableMonth,
  shouldDisableYear: shouldDisableYear,
  reduceAnimations: reduceAnimations,
  onMonthChange: onMonthChange,
  monthsPerRow: monthsPerRow,
  onYearChange: onYearChange,
  yearsOrder: yearsOrder,
  yearsPerRow: yearsPerRow,
  slots: slots,
  slotProps: slotProps,
  loading: loading,
  renderLoading: renderLoading,
  disableHighlightToday: disableHighlightToday,
  readOnly: readOnly,
  disabled: disabled,
  showDaysOutsideCurrentMonth: showDaysOutsideCurrentMonth,
  dayOfWeekFormatter: dayOfWeekFormatter,
  sx: sx,
  autoFocus: autoFocus,
  fixedWeekNumber: fixedWeekNumber,
  displayWeekNumber: displayWeekNumber,
  timezone: timezone
});

const React$X = await importShared('react');

const PropTypes$6 = await importShared('prop-types');
/**
 * Demos:
 *
 * - [DatePicker](https://mui.com/x/react-date-pickers/date-picker/)
 * - [Validation](https://mui.com/x/react-date-pickers/validation/)
 *
 * API:
 *
 * - [DesktopDatePicker API](https://mui.com/x/api/date-pickers/desktop-date-picker/)
 */
const DesktopDatePicker = /*#__PURE__*/React$X.forwardRef(function DesktopDatePicker(inProps, ref) {
  const translations = usePickersTranslations();
  const utils = useUtils();

  // Props with the default values common to all date pickers
  const defaultizedProps = useDatePickerDefaultizedProps(inProps, 'MuiDesktopDatePicker');
  const viewRenderers = _extends$3({
    day: renderDateViewCalendar,
    month: renderDateViewCalendar,
    year: renderDateViewCalendar
  }, defaultizedProps.viewRenderers);

  // Props with the default values specific to the desktop variant
  const props = _extends$3({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateFormat(utils, defaultizedProps, false),
    yearsPerRow: defaultizedProps.yearsPerRow ?? 4,
    slots: _extends$3({
      openPickerIcon: CalendarIcon,
      field: DateField
    }, defaultizedProps.slots),
    slotProps: _extends$3({}, defaultizedProps.slotProps, {
      field: ownerState => _extends$3({}, resolveComponentProps(defaultizedProps.slotProps?.field, ownerState), extractValidationProps(defaultizedProps), {
        ref
      }),
      toolbar: _extends$3({
        hidden: true
      }, defaultizedProps.slotProps?.toolbar)
    })
  });
  const {
    renderPicker
  } = useDesktopPicker({
    props,
    valueManager: singleItemValueManager,
    valueType: 'date',
    getOpenDialogAriaText: buildGetOpenDialogAriaText({
      utils,
      formatKey: 'fullDate',
      contextTranslation: translations.openDatePickerDialogue,
      propsTranslation: props.localeText?.openDatePickerDialogue
    }),
    validator: validateDate
  });
  return renderPicker();
});
DesktopDatePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes$6.bool,
  className: PropTypes$6.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes$6.bool,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: PropTypes$6.func,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes$6.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes$6.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes$6.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: PropTypes$6.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes$6.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes$6.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: PropTypes$6.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes$6.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: PropTypes$6.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes$6.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes$6.oneOf(['dense', 'spacious']),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes$6.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: PropTypes$6.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes$6.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: PropTypes$6.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: PropTypes$6.object,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: PropTypes$6.oneOf([3, 4]),
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes$6.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes$6.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes$6.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes$6.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes$6.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: PropTypes$6.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes$6.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes$6.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes$6.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: PropTypes$6.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes$6.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes$6.oneOf(['day', 'month', 'year']),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes$6.oneOf(['landscape', 'portrait']),
  readOnly: PropTypes$6.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes$6.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes$6.object,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span>...</span>
   */
  renderLoading: PropTypes$6.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes$6.oneOfType([PropTypes$6.oneOf(['all', 'day', 'empty', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'weekDay', 'year']), PropTypes$6.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: PropTypes$6.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: PropTypes$6.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: PropTypes$6.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: PropTypes$6.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes$6.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes$6.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes$6.oneOfType([PropTypes$6.arrayOf(PropTypes$6.oneOfType([PropTypes$6.func, PropTypes$6.object, PropTypes$6.bool])), PropTypes$6.func, PropTypes$6.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes$6.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes$6.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes$6.oneOf(['day', 'month', 'year']),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes$6.shape({
    day: PropTypes$6.func,
    month: PropTypes$6.func,
    year: PropTypes$6.func
  }),
  /**
   * Available views.
   */
  views: PropTypes$6.arrayOf(PropTypes$6.oneOf(['day', 'month', 'year']).isRequired),
  /**
   * Years are displayed in ascending (chronological) order by default.
   * If `desc`, years are displayed in descending order.
   * @default 'asc'
   */
  yearsOrder: PropTypes$6.oneOf(['asc', 'desc']),
  /**
   * Years rendered per row.
   * @default 4
   */
  yearsPerRow: PropTypes$6.oneOf([3, 4])
};

await importShared('react');
const PickersModalDialogRoot = styled(Dialog$5)({
  [`& .${dialogClasses.container}`]: {
    outline: 0
  },
  [`& .${dialogClasses.paper}`]: {
    outline: 0,
    minWidth: DIALOG_WIDTH
  }
});
const PickersModalDialogContent = styled(DialogContent$4)({
  '&:first-of-type': {
    padding: 0
  }
});
function PickersModalDialog(props) {
  const {
    children,
    onDismiss,
    open,
    slots,
    slotProps
  } = props;
  const Dialog = slots?.dialog ?? PickersModalDialogRoot;
  const Transition = slots?.mobileTransition ?? Fade;
  return /*#__PURE__*/jsxRuntimeExports.jsx(Dialog, _extends$3({
    open: open,
    onClose: onDismiss
  }, slotProps?.dialog, {
    TransitionComponent: Transition,
    TransitionProps: slotProps?.mobileTransition,
    PaperComponent: slots?.mobilePaper,
    PaperProps: slotProps?.mobilePaper,
    children: /*#__PURE__*/jsxRuntimeExports.jsx(PickersModalDialogContent, {
      children: children
    })
  }));
}

const _excluded$5 = ["props", "getOpenDialogAriaText"];
const React$W = await importShared('react');
const useMobilePicker = _ref => {
  let {
      props,
      getOpenDialogAriaText
    } = _ref,
    pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded$5);
  const {
    slots,
    slotProps: innerSlotProps,
    className,
    sx,
    format,
    formatDensity,
    enableAccessibleFieldDOMStructure,
    selectedSections,
    onSelectedSectionsChange,
    timezone,
    name,
    label,
    inputRef,
    readOnly,
    disabled,
    localeText
  } = props;
  const fieldRef = React$W.useRef(null);
  const labelId = useId();
  const isToolbarHidden = innerSlotProps?.toolbar?.hidden ?? false;
  const {
    open,
    actions,
    layoutProps,
    renderCurrentView,
    fieldProps: pickerFieldProps,
    contextValue
  } = usePicker(_extends$3({}, pickerParams, {
    props,
    fieldRef,
    autoFocusView: true,
    additionalViewProps: {},
    wrapperVariant: 'mobile'
  }));
  const Field = slots.field;
  const fieldProps = useSlotProps({
    elementType: Field,
    externalSlotProps: innerSlotProps?.field,
    additionalProps: _extends$3({}, pickerFieldProps, isToolbarHidden && {
      id: labelId
    }, !(disabled || readOnly) && {
      onClick: actions.onOpen,
      onKeyDown: onSpaceOrEnter(actions.onOpen)
    }, {
      readOnly: readOnly ?? true,
      disabled,
      className,
      sx,
      format,
      formatDensity,
      enableAccessibleFieldDOMStructure,
      selectedSections,
      onSelectedSectionsChange,
      timezone,
      label,
      name
    }, inputRef ? {
      inputRef
    } : {}),
    ownerState: props
  });

  // TODO: Move to `useSlotProps` when https://github.com/mui/material-ui/pull/35088 will be merged
  fieldProps.inputProps = _extends$3({}, fieldProps.inputProps, {
    'aria-label': getOpenDialogAriaText(pickerFieldProps.value)
  });
  const slotsForField = _extends$3({
    textField: slots.textField
  }, fieldProps.slots);
  const Layout = slots.layout ?? PickersLayout;
  let labelledById = labelId;
  if (isToolbarHidden) {
    if (label) {
      labelledById = `${labelId}-label`;
    } else {
      labelledById = undefined;
    }
  }
  const slotProps = _extends$3({}, innerSlotProps, {
    toolbar: _extends$3({}, innerSlotProps?.toolbar, {
      titleId: labelId
    }),
    mobilePaper: _extends$3({
      'aria-labelledby': labelledById
    }, innerSlotProps?.mobilePaper)
  });
  const handleFieldRef = useForkRef(fieldRef, fieldProps.unstableFieldRef);
  const renderPicker = () => /*#__PURE__*/jsxRuntimeExports.jsxs(PickersProvider, {
    contextValue: contextValue,
    localeText: localeText,
    children: [/*#__PURE__*/jsxRuntimeExports.jsx(Field, _extends$3({}, fieldProps, {
      slots: slotsForField,
      slotProps: slotProps,
      unstableFieldRef: handleFieldRef
    })), /*#__PURE__*/jsxRuntimeExports.jsx(PickersModalDialog, _extends$3({}, actions, {
      open: open,
      slots: slots,
      slotProps: slotProps,
      children: /*#__PURE__*/jsxRuntimeExports.jsx(Layout, _extends$3({}, layoutProps, slotProps?.layout, {
        slots: slots,
        slotProps: slotProps,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};

const React$V = await importShared('react');

const PropTypes$5 = await importShared('prop-types');
/**
 * Demos:
 *
 * - [DatePicker](https://mui.com/x/react-date-pickers/date-picker/)
 * - [Validation](https://mui.com/x/react-date-pickers/validation/)
 *
 * API:
 *
 * - [MobileDatePicker API](https://mui.com/x/api/date-pickers/mobile-date-picker/)
 */
const MobileDatePicker = /*#__PURE__*/React$V.forwardRef(function MobileDatePicker(inProps, ref) {
  const translations = usePickersTranslations();
  const utils = useUtils();

  // Props with the default values common to all date pickers
  const defaultizedProps = useDatePickerDefaultizedProps(inProps, 'MuiMobileDatePicker');
  const viewRenderers = _extends$3({
    day: renderDateViewCalendar,
    month: renderDateViewCalendar,
    year: renderDateViewCalendar
  }, defaultizedProps.viewRenderers);

  // Props with the default values specific to the mobile variant
  const props = _extends$3({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateFormat(utils, defaultizedProps, false),
    slots: _extends$3({
      field: DateField
    }, defaultizedProps.slots),
    slotProps: _extends$3({}, defaultizedProps.slotProps, {
      field: ownerState => _extends$3({}, resolveComponentProps(defaultizedProps.slotProps?.field, ownerState), extractValidationProps(defaultizedProps), {
        ref
      }),
      toolbar: _extends$3({
        hidden: false
      }, defaultizedProps.slotProps?.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobilePicker({
    props,
    valueManager: singleItemValueManager,
    valueType: 'date',
    getOpenDialogAriaText: buildGetOpenDialogAriaText({
      utils,
      formatKey: 'fullDate',
      contextTranslation: translations.openDatePickerDialogue,
      propsTranslation: props.localeText?.openDatePickerDialogue
    }),
    validator: validateDate
  });
  return renderPicker();
});
MobileDatePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes$5.bool,
  className: PropTypes$5.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes$5.bool,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: PropTypes$5.func,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes$5.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes$5.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes$5.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: PropTypes$5.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes$5.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes$5.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: PropTypes$5.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes$5.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: PropTypes$5.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes$5.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes$5.oneOf(['dense', 'spacious']),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes$5.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: PropTypes$5.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes$5.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: PropTypes$5.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: PropTypes$5.object,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: PropTypes$5.oneOf([3, 4]),
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes$5.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes$5.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes$5.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes$5.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes$5.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: PropTypes$5.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes$5.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes$5.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes$5.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: PropTypes$5.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes$5.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes$5.oneOf(['day', 'month', 'year']),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes$5.oneOf(['landscape', 'portrait']),
  readOnly: PropTypes$5.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes$5.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes$5.object,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span>...</span>
   */
  renderLoading: PropTypes$5.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes$5.oneOfType([PropTypes$5.oneOf(['all', 'day', 'empty', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'weekDay', 'year']), PropTypes$5.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: PropTypes$5.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: PropTypes$5.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: PropTypes$5.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: PropTypes$5.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes$5.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes$5.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes$5.oneOfType([PropTypes$5.arrayOf(PropTypes$5.oneOfType([PropTypes$5.func, PropTypes$5.object, PropTypes$5.bool])), PropTypes$5.func, PropTypes$5.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes$5.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes$5.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes$5.oneOf(['day', 'month', 'year']),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes$5.shape({
    day: PropTypes$5.func,
    month: PropTypes$5.func,
    year: PropTypes$5.func
  }),
  /**
   * Available views.
   */
  views: PropTypes$5.arrayOf(PropTypes$5.oneOf(['day', 'month', 'year']).isRequired),
  /**
   * Years are displayed in ascending (chronological) order by default.
   * If `desc`, years are displayed in descending order.
   * @default 'asc'
   */
  yearsOrder: PropTypes$5.oneOf(['asc', 'desc']),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: PropTypes$5.oneOf([3, 4])
};

const _excluded$4 = ["desktopModeMediaQuery"];
const React$U = await importShared('react');

await importShared('prop-types');
const DatePicker = /* @__PURE__ */ React$U.forwardRef(function DatePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDatePicker"
  });
  const {
    desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$4);
  const isDesktop = useMediaQuery$1(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DesktopDatePicker, _extends$3({
      ref
    }, other));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MobileDatePicker, _extends$3({
    ref
  }, other));
});

function getPickersToolbarTextUtilityClass(slot) {
  return generateUtilityClass('MuiPickersToolbarText', slot);
}
const pickersToolbarTextClasses = generateUtilityClasses('MuiPickersToolbarText', ['root', 'selected']);

const _excluded$3 = ["className", "selected", "value"];
const React$T = await importShared('react');
const useUtilityClasses$2 = ownerState => {
  const {
    classes,
    selected
  } = ownerState;
  const slots = {
    root: ['root', selected && 'selected']
  };
  return composeClasses(slots, getPickersToolbarTextUtilityClass, classes);
};
const PickersToolbarTextRoot = styled(Typography$4, {
  name: 'MuiPickersToolbarText',
  slot: 'Root',
  overridesResolver: (_, styles) => [styles.root, {
    [`&.${pickersToolbarTextClasses.selected}`]: styles.selected
  }]
})(({
  theme
}) => ({
  transition: theme.transitions.create('color'),
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${pickersToolbarTextClasses.selected}`]: {
    color: (theme.vars || theme).palette.text.primary
  }
}));
const PickersToolbarText = /*#__PURE__*/React$T.forwardRef(function PickersToolbarText(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPickersToolbarText'
  });
  const {
      className,
      value
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$3);
  const classes = useUtilityClasses$2(props);
  return /*#__PURE__*/jsxRuntimeExports.jsx(PickersToolbarTextRoot, _extends$3({
    ref: ref,
    className: clsx(classes.root, className),
    component: "span"
  }, other, {
    children: value
  }));
});

const _excluded$2 = ["align", "className", "selected", "typographyClassName", "value", "variant", "width"];
const React$S = await importShared('react');
const useUtilityClasses$1 = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root']
  };
  return composeClasses(slots, getPickersToolbarUtilityClass, classes);
};
const PickersToolbarButtonRoot = styled(Button$e, {
  name: 'MuiPickersToolbarButton',
  slot: 'Root',
  overridesResolver: (_, styles) => styles.root
})({
  padding: 0,
  minWidth: 16,
  textTransform: 'none'
});
const PickersToolbarButton = /*#__PURE__*/React$S.forwardRef(function PickersToolbarButton(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPickersToolbarButton'
  });
  const {
      align,
      className,
      selected,
      typographyClassName,
      value,
      variant,
      width
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$2);
  const classes = useUtilityClasses$1(props);
  return /*#__PURE__*/jsxRuntimeExports.jsx(PickersToolbarButtonRoot, _extends$3({
    variant: "text",
    ref: ref,
    className: clsx(classes.root, className)
  }, width ? {
    sx: {
      width
    }
  } : {}, other, {
    children: /*#__PURE__*/jsxRuntimeExports.jsx(PickersToolbarText, {
      align: align,
      className: typographyClassName,
      variant: variant,
      value: value,
      selected: selected
    })
  }));
});

function getTimePickerToolbarUtilityClass(slot) {
  return generateUtilityClass('MuiTimePickerToolbar', slot);
}
const timePickerToolbarClasses = generateUtilityClasses('MuiTimePickerToolbar', ['root', 'separator', 'hourMinuteLabel', 'hourMinuteLabelLandscape', 'hourMinuteLabelReverse', 'ampmSelection', 'ampmLandscape', 'ampmLabel']);

const _excluded$1 = ["ampm", "ampmInClock", "value", "isLandscape", "onChange", "view", "onViewChange", "views", "disabled", "readOnly", "className"];
await importShared('react');
await importShared('prop-types');
const useUtilityClasses = (ownerState) => {
  const {
    isLandscape,
    classes,
    isRtl
  } = ownerState;
  const slots = {
    root: ["root"],
    separator: ["separator"],
    hourMinuteLabel: ["hourMinuteLabel", isLandscape && "hourMinuteLabelLandscape", isRtl && "hourMinuteLabelReverse"],
    ampmSelection: ["ampmSelection", isLandscape && "ampmLandscape"],
    ampmLabel: ["ampmLabel"]
  };
  return composeClasses(slots, getTimePickerToolbarUtilityClass, classes);
};
const TimePickerToolbarRoot = styled(PickersToolbar, {
  name: "MuiTimePickerToolbar",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
const TimePickerToolbarSeparator = styled(PickersToolbarText, {
  name: "MuiTimePickerToolbar",
  slot: "Separator",
  overridesResolver: (props, styles) => styles.separator
})({
  outline: 0,
  margin: "0 4px 0 2px",
  cursor: "default"
});
const TimePickerToolbarHourMinuteLabel = styled("div", {
  name: "MuiTimePickerToolbar",
  slot: "HourMinuteLabel",
  overridesResolver: (props, styles) => [{
    [`&.${timePickerToolbarClasses.hourMinuteLabelLandscape}`]: styles.hourMinuteLabelLandscape,
    [`&.${timePickerToolbarClasses.hourMinuteLabelReverse}`]: styles.hourMinuteLabelReverse
  }, styles.hourMinuteLabel]
})({
  display: "flex",
  justifyContent: "flex-end",
  alignItems: "flex-end",
  variants: [{
    props: {
      isRtl: true
    },
    style: {
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      isLandscape: true
    },
    style: {
      marginTop: "auto"
    }
  }]
});
const TimePickerToolbarAmPmSelection = styled("div", {
  name: "MuiTimePickerToolbar",
  slot: "AmPmSelection",
  overridesResolver: (props, styles) => [{
    [`.${timePickerToolbarClasses.ampmLabel}`]: styles.ampmLabel
  }, {
    [`&.${timePickerToolbarClasses.ampmLandscape}`]: styles.ampmLandscape
  }, styles.ampmSelection]
})({
  display: "flex",
  flexDirection: "column",
  marginRight: "auto",
  marginLeft: 12,
  [`& .${timePickerToolbarClasses.ampmLabel}`]: {
    fontSize: 17
  },
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      margin: "4px 0 auto",
      flexDirection: "row",
      justifyContent: "space-around",
      flexBasis: "100%"
    }
  }]
});
function TimePickerToolbar(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTimePickerToolbar"
  });
  const {
    ampm,
    ampmInClock,
    value,
    isLandscape,
    onChange,
    view,
    onViewChange,
    views,
    disabled,
    readOnly,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
  const utils = useUtils();
  const translations = usePickersTranslations();
  const isRtl = useRtl();
  const showAmPmControl = Boolean(ampm && !ampmInClock && views.includes("hours"));
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(value, ampm, onChange);
  const formatHours = (time) => ampm ? utils.format(time, "hours12h") : utils.format(time, "hours24h");
  const ownerState = _extends$3({}, props, {
    isRtl
  });
  const classes = useUtilityClasses(ownerState);
  const separator = /* @__PURE__ */ jsxRuntimeExports.jsx(TimePickerToolbarSeparator, {
    tabIndex: -1,
    value: ":",
    variant: "h3",
    selected: false,
    className: classes.separator
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarRoot, _extends$3({
    landscapeDirection: "row",
    toolbarTitle: translations.timePickerToolbarTitle,
    isLandscape,
    ownerState,
    className: clsx(classes.root, className)
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarHourMinuteLabel, {
      className: classes.hourMinuteLabel,
      ownerState,
      children: [arrayIncludes(views, "hours") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        tabIndex: -1,
        variant: "h3",
        onClick: () => onViewChange("hours"),
        selected: view === "hours",
        value: value ? formatHours(value) : "--"
      }), arrayIncludes(views, ["hours", "minutes"]) && separator, arrayIncludes(views, "minutes") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        tabIndex: -1,
        variant: "h3",
        onClick: () => onViewChange("minutes"),
        selected: view === "minutes",
        value: value ? utils.format(value, "minutes") : "--"
      }), arrayIncludes(views, ["minutes", "seconds"]) && separator, arrayIncludes(views, "seconds") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        variant: "h3",
        onClick: () => onViewChange("seconds"),
        selected: view === "seconds",
        value: value ? utils.format(value, "seconds") : "--"
      })]
    }), showAmPmControl && /* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarAmPmSelection, {
      className: classes.ampmSelection,
      ownerState,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        disableRipple: true,
        variant: "subtitle2",
        selected: meridiemMode === "am",
        typographyClassName: classes.ampmLabel,
        value: formatMeridiem(utils, "am"),
        onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
        disabled
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        disableRipple: true,
        variant: "subtitle2",
        selected: meridiemMode === "pm",
        typographyClassName: classes.ampmLabel,
        value: formatMeridiem(utils, "pm"),
        onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
        disabled
      })]
    })]
  }));
}

const React$R = await importShared('react');
function useTimePickerDefaultizedProps(props, name) {
  const utils = useUtils();
  const themeProps = useThemeProps({
    props,
    name
  });
  const ampm = themeProps.ampm ?? utils.is12HourCycleInCurrentLocale();
  const localeText = React$R.useMemo(() => {
    if (themeProps.localeText?.toolbarTitle == null) {
      return themeProps.localeText;
    }
    return _extends$3({}, themeProps.localeText, {
      timePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  return _extends$3({}, themeProps, {
    ampm,
    localeText
  }, applyDefaultViewProps({
    views: themeProps.views,
    openTo: themeProps.openTo,
    defaultViews: ['hours', 'minutes'],
    defaultOpenTo: 'hours'
  }), {
    disableFuture: themeProps.disableFuture ?? false,
    disablePast: themeProps.disablePast ?? false,
    slots: _extends$3({
      toolbar: TimePickerToolbar
    }, themeProps.slots),
    slotProps: _extends$3({}, themeProps.slotProps, {
      toolbar: _extends$3({
        ampm,
        ampmInClock: themeProps.ampmInClock
      }, themeProps.slotProps?.toolbar)
    })
  });
}

await importShared('react');
const renderTimeViewClock = ({
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  minutesStep,
  ampm,
  ampmInClock,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  showViewSwitcher,
  disableIgnoringDatePartForTimeValidation,
  timezone
}) => /*#__PURE__*/jsxRuntimeExports.jsx(TimeClock, {
  view: view,
  onViewChange: onViewChange,
  focusedView: focusedView && isTimeView(focusedView) ? focusedView : null,
  onFocusedViewChange: onFocusedViewChange,
  views: views.filter(isTimeView),
  value: value,
  defaultValue: defaultValue,
  referenceDate: referenceDate,
  onChange: onChange,
  className: className,
  classes: classes,
  disableFuture: disableFuture,
  disablePast: disablePast,
  minTime: minTime,
  maxTime: maxTime,
  shouldDisableTime: shouldDisableTime,
  minutesStep: minutesStep,
  ampm: ampm,
  ampmInClock: ampmInClock,
  slots: slots,
  slotProps: slotProps,
  readOnly: readOnly,
  disabled: disabled,
  sx: sx,
  autoFocus: autoFocus,
  showViewSwitcher: showViewSwitcher,
  disableIgnoringDatePartForTimeValidation: disableIgnoringDatePartForTimeValidation,
  timezone: timezone
});
const renderDigitalClockTimeView = ({
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  minutesStep,
  ampm,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeSteps,
  skipDisabled,
  timezone
}) => /*#__PURE__*/jsxRuntimeExports.jsx(DigitalClock, {
  view: view,
  onViewChange: onViewChange,
  focusedView: focusedView,
  onFocusedViewChange: onFocusedViewChange,
  views: views.filter(isTimeView),
  value: value,
  defaultValue: defaultValue,
  referenceDate: referenceDate,
  onChange: onChange,
  className: className,
  classes: classes,
  disableFuture: disableFuture,
  disablePast: disablePast,
  minTime: minTime,
  maxTime: maxTime,
  shouldDisableTime: shouldDisableTime,
  minutesStep: minutesStep,
  ampm: ampm,
  slots: slots,
  slotProps: slotProps,
  readOnly: readOnly,
  disabled: disabled,
  sx: sx,
  autoFocus: autoFocus,
  disableIgnoringDatePartForTimeValidation: disableIgnoringDatePartForTimeValidation,
  timeStep: timeSteps?.minutes,
  skipDisabled: skipDisabled,
  timezone: timezone
});
const renderMultiSectionDigitalClockTimeView = ({
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  minutesStep,
  ampm,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeSteps,
  skipDisabled,
  timezone
}) => /*#__PURE__*/jsxRuntimeExports.jsx(MultiSectionDigitalClock, {
  view: view,
  onViewChange: onViewChange,
  focusedView: focusedView,
  onFocusedViewChange: onFocusedViewChange,
  views: views.filter(isTimeView),
  value: value,
  defaultValue: defaultValue,
  referenceDate: referenceDate,
  onChange: onChange,
  className: className,
  classes: classes,
  disableFuture: disableFuture,
  disablePast: disablePast,
  minTime: minTime,
  maxTime: maxTime,
  shouldDisableTime: shouldDisableTime,
  minutesStep: minutesStep,
  ampm: ampm,
  slots: slots,
  slotProps: slotProps,
  readOnly: readOnly,
  disabled: disabled,
  sx: sx,
  autoFocus: autoFocus,
  disableIgnoringDatePartForTimeValidation: disableIgnoringDatePartForTimeValidation,
  timeSteps: timeSteps,
  skipDisabled: skipDisabled,
  timezone: timezone
});

const resolveViews = (ampm, views, shouldUseSingleColumn) => {
  if (shouldUseSingleColumn) {
    return views.filter(view => !isInternalTimeView(view) || view === 'hours');
  }
  return ampm ? [...views, 'meridiem'] : views;
};
const resolveShouldRenderTimeInASingleColumn = (timeSteps, threshold) => 24 * 60 / ((timeSteps.hours ?? 1) * (timeSteps.minutes ?? 5)) <= threshold;
function resolveTimeViewsResponse({
  thresholdToRenderTimeInASingleColumn: inThreshold,
  ampm,
  timeSteps: inTimeSteps,
  views
}) {
  const thresholdToRenderTimeInASingleColumn = inThreshold ?? 24;
  const timeSteps = _extends$3({
    hours: 1,
    minutes: 5,
    seconds: 5
  }, inTimeSteps);
  const shouldRenderTimeInASingleColumn = resolveShouldRenderTimeInASingleColumn(timeSteps, thresholdToRenderTimeInASingleColumn);
  return {
    thresholdToRenderTimeInASingleColumn,
    timeSteps,
    shouldRenderTimeInASingleColumn,
    views: resolveViews(ampm, views, shouldRenderTimeInASingleColumn)
  };
}

const React$Q = await importShared('react');

const PropTypes$4 = await importShared('prop-types');
/**
 * Demos:
 *
 * - [TimePicker](https://mui.com/x/react-date-pickers/time-picker/)
 * - [Validation](https://mui.com/x/react-date-pickers/validation/)
 *
 * API:
 *
 * - [DesktopTimePicker API](https://mui.com/x/api/date-pickers/desktop-time-picker/)
 */
const DesktopTimePicker = /*#__PURE__*/React$Q.forwardRef(function DesktopTimePicker(inProps, ref) {
  const translations = usePickersTranslations();
  const utils = useUtils();

  // Props with the default values common to all time pickers
  const defaultizedProps = useTimePickerDefaultizedProps(inProps, 'MuiDesktopTimePicker');
  const {
    shouldRenderTimeInASingleColumn,
    views: resolvedViews,
    timeSteps
  } = resolveTimeViewsResponse(defaultizedProps);
  const renderTimeView = shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView : renderMultiSectionDigitalClockTimeView;
  const viewRenderers = _extends$3({
    hours: renderTimeView,
    minutes: renderTimeView,
    seconds: renderTimeView,
    meridiem: renderTimeView
  }, defaultizedProps.viewRenderers);
  const ampmInClock = defaultizedProps.ampmInClock ?? true;
  const actionBarActions = shouldRenderTimeInASingleColumn ? [] : ['accept'];
  // Need to avoid adding the `meridiem` view when unexpected renderer is specified
  const shouldHoursRendererContainMeridiemView = viewRenderers.hours?.name === renderMultiSectionDigitalClockTimeView.name;
  const views = !shouldHoursRendererContainMeridiemView ? resolvedViews.filter(view => view !== 'meridiem') : resolvedViews;

  // Props with the default values specific to the desktop variant
  const props = _extends$3({}, defaultizedProps, {
    ampmInClock,
    timeSteps,
    viewRenderers,
    format: resolveTimeFormat(utils, defaultizedProps),
    // Setting only `hours` time view in case of single column time picker
    // Allows for easy view lifecycle management
    views: shouldRenderTimeInASingleColumn ? ['hours'] : views,
    slots: _extends$3({
      field: TimeField,
      openPickerIcon: ClockIcon
    }, defaultizedProps.slots),
    slotProps: _extends$3({}, defaultizedProps.slotProps, {
      field: ownerState => _extends$3({}, resolveComponentProps(defaultizedProps.slotProps?.field, ownerState), extractValidationProps(defaultizedProps), {
        ref
      }),
      toolbar: _extends$3({
        hidden: true,
        ampmInClock
      }, defaultizedProps.slotProps?.toolbar),
      actionBar: _extends$3({
        actions: actionBarActions
      }, defaultizedProps.slotProps?.actionBar)
    })
  });
  const {
    renderPicker
  } = useDesktopPicker({
    props,
    valueManager: singleItemValueManager,
    valueType: 'time',
    getOpenDialogAriaText: buildGetOpenDialogAriaText({
      utils,
      formatKey: 'fullTime',
      contextTranslation: translations.openTimePickerDialogue,
      propsTranslation: props.localeText?.openTimePickerDialogue
    }),
    validator: validateTime
  });
  return renderPicker();
});
DesktopTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: PropTypes$4.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: PropTypes$4.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes$4.bool,
  className: PropTypes$4.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes$4.bool,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes$4.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes$4.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes$4.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: PropTypes$4.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes$4.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes$4.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes$4.any,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes$4.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes$4.oneOf(['dense', 'spacious']),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes$4.node,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes$4.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: PropTypes$4.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: PropTypes$4.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: PropTypes$4.number,
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes$4.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes$4.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes$4.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes$4.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes$4.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes$4.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes$4.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes$4.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes$4.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes$4.oneOf(['hours', 'meridiem', 'minutes', 'seconds']),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes$4.oneOf(['landscape', 'portrait']),
  readOnly: PropTypes$4.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes$4.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes$4.object,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes$4.oneOfType([PropTypes$4.oneOf(['all', 'day', 'empty', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'weekDay', 'year']), PropTypes$4.number]),
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: PropTypes$4.func,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: PropTypes$4.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes$4.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes$4.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes$4.oneOfType([PropTypes$4.arrayOf(PropTypes$4.oneOfType([PropTypes$4.func, PropTypes$4.object, PropTypes$4.bool])), PropTypes$4.func, PropTypes$4.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: PropTypes$4.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: PropTypes$4.shape({
    hours: PropTypes$4.number,
    minutes: PropTypes$4.number,
    seconds: PropTypes$4.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes$4.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes$4.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes$4.oneOf(['hours', 'meridiem', 'minutes', 'seconds']),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes$4.shape({
    hours: PropTypes$4.func,
    meridiem: PropTypes$4.func,
    minutes: PropTypes$4.func,
    seconds: PropTypes$4.func
  }),
  /**
   * Available views.
   */
  views: PropTypes$4.arrayOf(PropTypes$4.oneOf(['hours', 'minutes', 'seconds']).isRequired)
};

const React$P = await importShared('react');

const PropTypes$3 = await importShared('prop-types');
/**
 * Demos:
 *
 * - [TimePicker](https://mui.com/x/react-date-pickers/time-picker/)
 * - [Validation](https://mui.com/x/react-date-pickers/validation/)
 *
 * API:
 *
 * - [MobileTimePicker API](https://mui.com/x/api/date-pickers/mobile-time-picker/)
 */
const MobileTimePicker = /*#__PURE__*/React$P.forwardRef(function MobileTimePicker(inProps, ref) {
  const translations = usePickersTranslations();
  const utils = useUtils();

  // Props with the default values common to all time pickers
  const defaultizedProps = useTimePickerDefaultizedProps(inProps, 'MuiMobileTimePicker');
  const viewRenderers = _extends$3({
    hours: renderTimeViewClock,
    minutes: renderTimeViewClock,
    seconds: renderTimeViewClock
  }, defaultizedProps.viewRenderers);
  const ampmInClock = defaultizedProps.ampmInClock ?? false;

  // Props with the default values specific to the mobile variant
  const props = _extends$3({}, defaultizedProps, {
    ampmInClock,
    viewRenderers,
    format: resolveTimeFormat(utils, defaultizedProps),
    slots: _extends$3({
      field: TimeField
    }, defaultizedProps.slots),
    slotProps: _extends$3({}, defaultizedProps.slotProps, {
      field: ownerState => _extends$3({}, resolveComponentProps(defaultizedProps.slotProps?.field, ownerState), extractValidationProps(defaultizedProps), {
        ref
      }),
      toolbar: _extends$3({
        hidden: false,
        ampmInClock
      }, defaultizedProps.slotProps?.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobilePicker({
    props,
    valueManager: singleItemValueManager,
    valueType: 'time',
    getOpenDialogAriaText: buildGetOpenDialogAriaText({
      utils,
      formatKey: 'fullTime',
      contextTranslation: translations.openTimePickerDialogue,
      propsTranslation: props.localeText?.openTimePickerDialogue
    }),
    validator: validateTime
  });
  return renderPicker();
});
MobileTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: PropTypes$3.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: PropTypes$3.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes$3.bool,
  className: PropTypes$3.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes$3.bool,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes$3.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes$3.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes$3.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: PropTypes$3.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes$3.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes$3.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes$3.any,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes$3.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes$3.oneOf(['dense', 'spacious']),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes$3.node,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes$3.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: PropTypes$3.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: PropTypes$3.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: PropTypes$3.number,
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes$3.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes$3.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes$3.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes$3.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes$3.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes$3.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes$3.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes$3.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes$3.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes$3.oneOf(['hours', 'minutes', 'seconds']),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes$3.oneOf(['landscape', 'portrait']),
  readOnly: PropTypes$3.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes$3.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes$3.object,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes$3.oneOfType([PropTypes$3.oneOf(['all', 'day', 'empty', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'weekDay', 'year']), PropTypes$3.number]),
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: PropTypes$3.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes$3.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes$3.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes$3.oneOfType([PropTypes$3.arrayOf(PropTypes$3.oneOfType([PropTypes$3.func, PropTypes$3.object, PropTypes$3.bool])), PropTypes$3.func, PropTypes$3.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes$3.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes$3.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes$3.oneOf(['hours', 'minutes', 'seconds']),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes$3.shape({
    hours: PropTypes$3.func,
    minutes: PropTypes$3.func,
    seconds: PropTypes$3.func
  }),
  /**
   * Available views.
   */
  views: PropTypes$3.arrayOf(PropTypes$3.oneOf(['hours', 'minutes', 'seconds']).isRequired)
};

const _excluded = ["desktopModeMediaQuery"];
const React$O = await importShared('react');

await importShared('prop-types');
const TimePicker = /* @__PURE__ */ React$O.forwardRef(function TimePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTimePicker"
  });
  const {
    desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const isDesktop = useMediaQuery$1(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DesktopTimePicker, _extends$3({
      ref
    }, other));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MobileTimePicker, _extends$3({
    ref
  }, other));
});

const React$N = await importShared('react');
class ConfigDatePicker extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        this.setState({ value });
    }
    renderItem(_error, disabled /* , defaultValue */) {
        return (React$N.createElement(DatePicker, { sx: theme => ({
                width: '100%',
                borderBottom: `1px solid ${theme.palette.text.primary}`,
                '& fieldset': {
                    display: 'none',
                },
                '& input': {
                    padding: `${theme.spacing(1.5)} 0 4px 0`,
                },
                '& .MuiInputAdornment-root': {
                    marginLeft: 0,
                    marginTop: 1, // it is already in spaces
                },
                '& label': {
                    transform: 'translate(0px, -9px) scale(0.75)',
                },
            }), format: this.props.oContext.systemConfig.dateFormat.toLowerCase().replace('mm', 'MM'), disabled: !!disabled, value: this.state.value, onChange: value => {
                this.setState({ value }, () => this.onChange(this.props.attr, this.state.value));
            }, label: this.getText(this.props.schema.label) }));
    }
}

const React$M = await importShared('react');
class ConfigDeviceManager extends ConfigGeneric {
    renderItem() {
        const schema = this.props.schema;
        if (!schema) {
            return null;
        }
        if (this.props.oContext.DeviceManager) {
            const DeviceManager = this.props.oContext.DeviceManager;
            return (React$M.createElement(DeviceManager, { uploadImagesToInstance: `${this.props.oContext.adapterName}.${this.props.oContext.instance}`, title: this.getText(this.props.schema.label), socket: this.props.oContext.socket, selectedInstance: `${this.props.oContext.adapterName}.${this.props.oContext.instance}`, themeName: this.props.themeName, theme: this.props.oContext.theme, themeType: this.props.oContext.themeType, isFloatComma: this.props.oContext.isFloatComma, dateFormat: this.props.oContext.dateFormat }));
        }
        return React$M.createElement("div", null, "DeviceManager not found");
    }
}

const React$L = await importShared('react');
const {InputLabel: InputLabel$c,MenuItem: MenuItem$b,FormHelperText: FormHelperText$c,FormControl: FormControl$e,Select: Select$a,IconButton: IconButton$b,ListItemText: ListItemText$2,ListItemIcon: ListItemIcon$1} = await importShared('@mui/material');

const {Refresh:IconRefresh,UploadFile:IconUpload,Delete:IconDelete,PlayArrow:IconPlay$1,MusicNote:IconAudio,Videocam:IconVideo$1,Article:IconText$1,Code:IconCode$1,UploadFile:UploadIcon} = await importShared('@mui/icons-material');

const {DialogConfirm: DialogConfirm$3,Utils: Utils$a,I18n: I18n$q} = await importShared('@iobroker/adapter-react-v5');
const styles$r = {
    fullWidth: {
        width: '100%',
    },
    uploadDiv: {
        position: 'relative',
        width: '100%',
    },
    uploadDivDragging: {
        opacity: 1,
        background: 'rgba(128,255,128,0.1)',
    },
    uploadCenterDiv: {
        margin: 5,
        border: '3px dashed grey',
        borderRadius: 5,
        width: '100%',
        height: '100%',
        position: 'absolute',
        display: 'flex',
    },
    uploadCenterIcon: {
        paddingTop: 10,
        width: 48,
        height: 48,
    },
    uploadCenterText: {
        fontSize: 16,
    },
    uploadCenterTextAndIcon: {
        textAlign: 'center',
        position: 'absolute',
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
    },
    disabledOpacity: {
        opacity: 0.3,
        cursor: 'default',
    },
    error: {
        border: '2px solid red',
    },
    deleteButton: {},
    selectedImage: {
        height: 40,
        width: 40,
        display: 'inline-block',
        marginRight: 8,
    },
};
const IMAGE_EXT$1 = ['jpg', 'jpeg', 'svg', 'png', 'webp', 'gif', 'apng', 'avif', 'webp'];
const AUDIO_EXT$1 = ['mp3', 'ogg', 'wav', 'aac'];
const VIDEO_EXT$1 = ['avi', 'mp4', 'mov'];
const DOC_EXT$1 = ['txt', 'log', 'html', 'htm'];
const JS_EXT$1 = ['json', 'js', 'ts'];
class ConfigFileSelector extends ConfigGeneric {
    dropzoneRef;
    imagePrefix;
    objectID;
    path;
    constructor(props) {
        super(props);
        this.dropzoneRef = React$L.createRef();
        this.imagePrefix = this.props.oContext.imagePrefix === undefined ? './files' : this.props.oContext.imagePrefix;
    }
    componentDidMount() {
        super.componentDidMount();
        this.objectID = (this.props.schema.objectID || '0_userdata.0').replace('%INSTANCE%', (this.props.oContext.instance || 0).toString());
        this.path = this.props.schema.upload;
        if (this.path) {
            if (this.path === '/') {
                this.path = '';
            }
            else if (!this.path.endsWith('/')) {
                this.path = `${this.path}/`;
            }
        }
        // read files
        void this.updateFiles().then(() => {
            const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
            this.setState({ value });
            // subscribe on this folder
            this.props.oContext.socket
                .subscribeFiles(this.objectID, `${this.path}/*`, this.onFolderChanged)
                .catch(e => console.error(`Cannot subscribe: ${e}`));
        });
    }
    onFolderChanged = (_id, fileName) => {
        if (this.path && fileName.startsWith(this.path)) {
            this.updateFiles().catch(e => console.error(`Cannot update files: ${e}`));
        }
    };
    componentWillUnmount() {
        this.props.oContext.socket
            .subscribeFiles(this.objectID, `${this.path}/*`, this.onFolderChanged)
            .catch(e => console.error(`Cannot subscribe: ${e}`));
        super.componentWillUnmount();
    }
    async updateFiles() {
        const files = await this.readFiles(this.props.schema.pattern);
        await new Promise(resolve => this.setState({ files }, resolve));
    }
    async readFolder(folderName, files, filter) {
        try {
            const dirFiles = await this.props.oContext.socket.readDir(this.objectID, folderName.replace(/^\//, '') || null);
            for (let f = 0; f < dirFiles.length; f++) {
                const file = dirFiles[f];
                if (file.isDir) {
                    // read it
                    await this.readFolder(`${folderName + file.file}/`, files, filter);
                }
                else {
                    let ok = false;
                    if (filter === '*.*' && file.file.includes('.')) {
                        ok = true;
                    }
                    else if (!filter || filter === '*') {
                        ok = true;
                    }
                    else if (filter === '.*' && file.file.startsWith('.')) {
                        ok = true;
                    }
                    else {
                        const regExp = new RegExp(`^${filter.replace(/\./g, '\\.').replace(/\*/g, '.*')}$`);
                        ok = regExp.test(file.file);
                    }
                    if (ok) {
                        files.push({
                            name: folderName + file.file,
                            size: file.stats ? Utils$a.formatBytes(file.stats.size) : '--',
                        });
                    }
                }
            }
        }
        catch (e) {
            console.error(`Cannot read "${folderName}": ${e}`);
        }
        return files;
    }
    async readFiles(pattern) {
        const files = [];
        pattern = pattern || this.props.schema.pattern;
        if (!pattern) {
            pattern = '**/*.*';
        }
        let filter;
        const pos = pattern.lastIndexOf('/');
        if (pos === -1) {
            filter = pattern;
        }
        else {
            filter = pattern.substring(pos + 1);
        }
        if (pattern.startsWith('**')) {
            // read all folders
            await this.readFolder('/', files, filter);
        }
        else {
            const pos_ = pattern.lastIndexOf('/');
            if (pos_ === -1) {
                await this.readFolder('/', files, filter);
            }
            else {
                const folder = pattern.substring(0, pos_ + 1);
                await this.readFolder(folder, files, filter);
            }
        }
        return files;
    }
    onDrop(acceptedFiles) {
        const file = acceptedFiles[0];
        const reader = new FileReader();
        const maxSize = this.props.schema.maxSize || 2 * 1024 * 1024;
        reader.onabort = () => console.log('file reading was aborted');
        reader.onerror = () => console.log('file reading has failed');
        reader.onload = ( /* e: ProgressEvent<FileReader> */) => {
            if (file.size > maxSize) {
                window.alert(I18n$q.t('File is too big. Max %sk allowed. Try use SVG.', Math.round(maxSize / 1024)));
                return;
            }
            this.props.oContext.socket
                .writeFile64(this.objectID, this.path + file.name, reader.result)
                .then(() => this.updateFiles())
                .then(() => 
            // Automatically select the new uploaded file
            this.setState({ value: this.path + file.name }, () => this.onChange(this.props.attr, this.path + file.name)))
                .catch(e => window.alert(`Cannot upload file: ${e}`));
        };
        reader.readAsArrayBuffer(file);
    }
    renderDeleteDialog() {
        if (!this.state.deleteFile) {
            return null;
        }
        return (React$L.createElement(DialogConfirm$3, { title: I18n$q.t('ra_Are you sure?'), text: I18n$q.t('ra_File will be deleted'), ok: I18n$q.t('ra_Delete'), cancel: I18n$q.t('ra_Cancel'), onClose: isOk => {
                const deleteFile = this.state.deleteFile;
                this.setState({ deleteFile: '' }, () => {
                    if (isOk) {
                        this.props.oContext.socket
                            .deleteFile(this.objectID, deleteFile)
                            .then(() => this.updateFiles())
                            .catch(e => window.alert(`Cannot delete file: ${e}`));
                    }
                });
            } }));
    }
    static base64ToArrayBuffer(base64) {
        const binaryString = window.atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }
    loadFile() {
        return this.props.oContext.socket.readFile(this.objectID, this.state.value, true);
    }
    play() {
        void this.loadFile().then(data => {
            if (typeof AudioContext !== 'undefined') {
                const oContext = new AudioContext();
                const buf = ConfigFileSelector.base64ToArrayBuffer(data.file);
                void oContext.decodeAudioData(buf, (buffer) => {
                    const source = oContext.createBufferSource(); // creates a sound source
                    source.buffer = buffer; // tell the source which sound to play
                    source.connect(oContext.destination); // connect the source to the oContext's destination (the speakers)
                    source.start(0);
                }, (err) => window.alert(`Cannot play: ${err.message}`));
            }
        });
    }
    getFileIcon(item) {
        if (!item?.extension) {
            return null;
        }
        if (IMAGE_EXT$1.includes(item.extension)) {
            return (React$L.createElement("div", { style: {
                    ...styles$r.selectedImage,
                    backgroundImage: `url(${this.imagePrefix}/${this.objectID}/${item.value})`,
                    backgroundSize: 'contain',
                    backgroundRepeat: 'no-repeat',
                } }));
        }
        if (AUDIO_EXT$1.includes(item.extension)) {
            return React$L.createElement(IconAudio, null);
        }
        if (DOC_EXT$1.includes(item.extension)) {
            return React$L.createElement(IconText$1, null);
        }
        if (VIDEO_EXT$1.includes(item.extension)) {
            return React$L.createElement(IconVideo$1, null);
        }
        if (JS_EXT$1.includes(item.extension)) {
            return React$L.createElement(IconCode$1, null);
        }
        return null;
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (!this.state.files) {
            return null;
        }
        const folders = [];
        if (!this.props.schema.withFolder) {
            this.state.files.forEach(file => {
                const pos = file.name.lastIndexOf('/');
                if (pos === -1) {
                    if (!folders.includes('/')) {
                        folders.push('/');
                    }
                }
                else {
                    const folder = file.name.substring(0, pos + 1);
                    if (!folders.includes(folder)) {
                        folders.push(folder);
                    }
                }
            });
        }
        const selectOptions = this.state.files.map(file => ({
            value: file.name,
            label: !this.props.schema.withFolder && folders.length === 1
                ? `${file.name.substring(folders[0].length)}`
                : `${file.name}${this.props.schema.noSize ? '' : `(${file.size})`}`,
            extension: file.name.toLowerCase().split('.').pop(),
        }));
        if (!this.props.schema.noNone) {
            selectOptions.unshift({ label: I18n$q.t('ra_none'), value: '' });
        }
        const item = selectOptions.find(_item => _item.value === this.state.value);
        let buttons = 0;
        if (this.props.schema.upload) {
            buttons++;
        }
        if (this.props.schema.refresh) {
            buttons++;
        }
        const play = this.state.value &&
            (this.state.value.endsWith('.mp3') ||
                this.state.value.endsWith('.ogg') ||
                this.state.value.endsWith('.wav'));
        // show play button
        if (play) {
            buttons++;
        }
        const element = (React$L.createElement("div", { style: styles$r.fullWidth },
            React$L.createElement(FormControl$e, { variant: "standard", style: { width: `calc(100% - ${buttons * 42}px)` } },
                this.props.schema.label ? React$L.createElement(InputLabel$c, null, this.getText(this.props.schema.label)) : null,
                React$L.createElement(Select$a, { variant: "standard", error: !!error, disabled: !!disabled, value: this.state.value || '_', renderValue: () => (React$L.createElement(React$L.Fragment, null,
                        this.getFileIcon(item),
                        React$L.createElement("span", null, item?.label || ''))), onChange: e => {
                        this.setState({ value: e.target.value === '_' ? '' : e.target.value }, () => this.onChange(this.props.attr, this.state.value));
                    } }, selectOptions.map(it => (React$L.createElement(MenuItem$b, { key: it.value, value: it.value },
                    React$L.createElement(ListItemIcon$1, null, this.getFileIcon(it)),
                    React$L.createElement(ListItemText$2, null, it.label),
                    this.props.schema.delete && item.value ? (React$L.createElement(IconButton$b, { style: styles$r.deleteButton, size: "small", onClick: () => this.setState({ deleteFile: item.value }) },
                        React$L.createElement(IconDelete, null))) : null)))),
                this.props.schema.help ? (React$L.createElement(FormHelperText$c, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null),
            this.props.schema.refresh && (React$L.createElement(IconButton$b, { onClick: () => this.updateFiles() },
                React$L.createElement(IconRefresh, null))),
            this.props.schema.upload && (React$L.createElement(IconButton$b, { onClick: () => this.dropzoneRef.current?.open() },
                React$L.createElement(IconUpload, null))),
            play && (React$L.createElement(IconButton$b, { style: { color: '#00FF00' }, onClick: () => this.play() },
                React$L.createElement(IconPlay$1, null)))));
        if (!this.props.schema.upload) {
            return (React$L.createElement(React$L.Fragment, null,
                element,
                this.renderDeleteDialog()));
        }
        let accept = { '*/*': [] };
        if (this.props.schema.fileTypes === 'image') {
            accept = {
                'image/*': ['.png', '.jpg', '.svg', '.gif', '.apng', '.avif', '.webp'],
            };
        }
        else if (this.props.schema.fileTypes === 'audio') {
            accept = {
                'audio/*': ['.mp3', '.ogg', '.wav', '.mp4'],
            };
        }
        else if (this.props.schema.fileTypes === 'text') {
            accept = {
                'text/plain': ['.txt'],
            };
        }
        if (this.props.schema.pattern) {
            const last = this.props.schema.pattern.split('/').pop().toLowerCase().replace(/.*\./, '');
            if (last === 'png' ||
                last === 'jpg' ||
                last === 'svg' ||
                last === 'gif' ||
                last === 'apng' ||
                last === 'avif' ||
                last === 'webp') {
                accept = {
                    'image/*': ['.png', '.jpg', '.svg', '.gif', '.apng', '.avif', '.webp'],
                };
            }
            else if (last === 'mp3' || last === 'ogg' || last === 'wav') {
                accept = {
                    'audio/*': ['.mp3', '.ogg', '.wav', '.mp4'],
                };
            }
            else if (last === 'ics') {
                accept = {
                    'text/calendar': ['.ics'],
                };
            }
            else if (last === 'txt') {
                accept = {
                    'text/plain': ['.txt'],
                };
            }
            else if (last === 'pem') {
                accept = {
                    'text/plain': ['.pem'],
                };
            }
            else {
                accept = {
                    '*/*': [`.${last}`],
                };
            }
        }
        return (React$L.createElement(Dropzone, { ref: this.dropzoneRef, multiple: false, accept: accept, noKeyboard: true, noClick: true, maxSize: this.props.schema.maxSize || 2 * 1024 * 1024, onDragEnter: () => {
                this.setState({ uploadFile: 'dragging' });
            }, onDragLeave: () => this.setState({ uploadFile: true }), onDrop: (acceptedFiles, errors) => {
                this.setState({ uploadFile: false });
                if (!acceptedFiles.length) {
                    window.alert(errors?.[0]?.errors?.[0]?.message || I18n$q.t('Cannot upload'));
                }
                else {
                    this.onDrop(acceptedFiles);
                }
            } }, ({ getRootProps, getInputProps }) => (React$L.createElement("div", { style: {
                ...styles$r.uploadDiv,
                ...(this.state.uploadFile === 'dragging' ? styles$r.uploadDivDragging : undefined),
                ...(disabled ? styles$r.disabledOpacity : undefined),
            }, ...getRootProps() },
            React$L.createElement("input", { ...getInputProps() }),
            this.state.uploadFile === 'dragging' ? (React$L.createElement("div", { style: {
                    ...styles$r.uploadCenterDiv,
                    ...(this.state.uploadError ? styles$r.error : undefined),
                } },
                React$L.createElement("div", { style: styles$r.uploadCenterTextAndIcon },
                    React$L.createElement(UploadIcon, { style: styles$r.uploadCenterIcon }),
                    React$L.createElement("div", { style: styles$r.uploadCenterText }, this.state.uploadFile === 'dragging'
                        ? I18n$q.t('ra_Drop file here')
                        : I18n$q.t('ra_Place your files here or click here to open the browse dialog'))))) : null,
            element,
            this.renderDeleteDialog()))));
    }
}

const React$K = await importShared('react');

const {Button: Button$a,TextField: TextField$h,IconButton: IconButton$a} = await importShared('@mui/material');

const {Article:IconText,Code:IconCode,PlayArrow:IconPlay,Videocam:IconVideo} = await importShared('@mui/icons-material');

const {DialogSelectFile} = await importShared('@iobroker/adapter-react-v5');
const styles$q = {
    fullWidth: {
        width: '100%',
    },
    fullWidthOneButton: {
        width: 'calc(100% - 69px)',
        marginRight: 4,
    },
    fullWidthIcon: {
        width: 'calc(100% - 119px)',
        marginRight: 4,
    },
    selectedImage: {
        height: 40,
        width: 40,
        display: 'inline-block',
        marginRight: 8,
    },
};
const IMAGE_EXT = ['jpg', 'jpeg', 'svg', 'png', 'webp', 'gif', 'apng', 'avif', 'webp'];
const AUDIO_EXT = ['mp3', 'ogg', 'wav', 'aac'];
const VIDEO_EXT = ['avi', 'mp4', 'mov'];
const DOC_EXT = ['txt', 'log', 'html', 'htm'];
const JS_EXT = ['json', 'js', 'ts'];
class ConfigFile extends ConfigGeneric {
    imagePrefix = '../..';
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        this.imagePrefix = this.props.oContext.imagePrefix === undefined ? './files' : this.props.oContext.imagePrefix;
        this.setState({ value: value ?? '' });
    }
    static getDerivedStateFromProps(props, state) {
        const value = ConfigGeneric.getValue(props.data, props.attr);
        if (value === null ||
            value === undefined ||
            value.toString().trim() !== (state.value || '').toString().trim()) {
            return { value: value ?? '' };
        }
        return null;
    }
    loadFile() {
        const pos = this.state.value.indexOf('/');
        if (pos !== -1) {
            const adapter = this.state.value.substring(0, pos);
            const path = this.state.value.substring(pos + 1);
            return this.props.oContext.socket.readFile(adapter, path, true);
        }
        return Promise.resolve(null);
    }
    play() {
        void this.loadFile().then(data => {
            if (typeof AudioContext !== 'undefined' && data?.file) {
                const oContext = new AudioContext();
                const buf = ConfigFileSelector.base64ToArrayBuffer(data.file);
                void oContext.decodeAudioData(buf, (buffer) => {
                    const source = oContext.createBufferSource(); // creates a sound source
                    source.buffer = buffer; // tell the source which sounds to play
                    source.connect(oContext.destination); // connect the source to the oContext's destination (the speakers)
                    source.start(0);
                }, (err) => window.alert(`Cannot play: ${err.message}`));
            }
        });
    }
    getIcon() {
        const extension = this.state.value.split('.').pop().toLowerCase();
        if (IMAGE_EXT.includes(extension)) {
            return (React$K.createElement("div", { style: {
                    ...styles$q.selectedImage,
                    backgroundImage: `url(${this.imagePrefix}/${this.state.value})`,
                    backgroundSize: 'contain',
                    backgroundRepeat: 'no-repeat',
                } }));
        }
        if (AUDIO_EXT.includes(extension)) {
            return (React$K.createElement(IconButton$a, { style: { color: '#00FF00' }, onClick: () => this.play() },
                React$K.createElement(IconPlay, null)));
        }
        if (DOC_EXT.includes(extension)) {
            return React$K.createElement(IconText, null);
        }
        if (VIDEO_EXT.includes(extension)) {
            return React$K.createElement(IconVideo, null);
        }
        if (JS_EXT.includes(extension)) {
            return React$K.createElement(IconCode, null);
        }
        return null;
    }
    renderFileBrowser() {
        if (!this.state.showFileBrowser) {
            return null;
        }
        return (React$K.createElement(DialogSelectFile, { imagePrefix: this.props.oContext.imagePrefix, socket: this.props.oContext.socket, selected: this.state.value, onClose: () => this.setState({ showFileBrowser: false }), onOk: _value => {
                const value = Array.isArray(_value) ? _value[0] : _value;
                this.setState({ value }, () => this.onChange(this.props.attr, this.props.schema.trim === false ? value : (value || '').trim()));
            }, selectOnlyFolders: this.props.schema.selectOnlyFolders, allowUpload: this.props.schema.allowUpload, allowDownload: this.props.schema.allowDownload, allowCreateFolder: this.props.schema.allowCreateFolder, allowView: this.props.schema.allowView, showToolbar: this.props.schema.showToolbar, limitPath: this.props.schema.limitPath, theme: this.props.oContext.theme }));
    }
    renderItem(error, disabled /* , defaultValue */) {
        const icon = this.getIcon();
        return (React$K.createElement("div", { style: styles$q.fullWidth },
            icon,
            React$K.createElement(TextField$h, { variant: "standard", style: icon ? styles$q.fullWidthIcon : styles$q.fullWidthOneButton, value: this.state.value === null || this.state.value === undefined ? '' : this.state.value, error: !!error, disabled: !!disabled, slotProps: {
                    htmlInput: {
                        maxLength: this.props.schema.maxLength || this.props.schema.max || undefined,
                        readOnly: !!this.props.schema.disableEdit,
                    },
                }, onChange: e => {
                    const value = e.target.value;
                    this.setState({ value }, () => this.onChange(this.props.attr, this.props.schema.trim === false ? value : (value || '').trim()));
                }, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }),
            React$K.createElement(Button$a, { disabled: disabled, variant: "outlined", onClick: () => this.setState({ showFileBrowser: true }) }, "..."),
            this.renderFileBrowser()));
    }
}

const React$J = await importShared('react');

const {InputLabel: InputLabel$b,MenuItem: MenuItem$a,FormHelperText: FormHelperText$b,FormControl: FormControl$d,Select: Select$9} = await importShared('@mui/material');

const {TextWithIcon: TextWithIcon$1,I18n: I18n$p} = await importShared('@iobroker/adapter-react-v5');
class ConfigFunc extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        void this.props.oContext.socket.getEnums('functions').then(enums => {
            const selectOptions = Object.keys(enums).map(id => ({
                value: this.props.schema.short ? id.replace('enum.functions.', '') : id,
                label: this.getText(enums[id].common.name),
                obj: enums[id],
            }));
            if (this.props.schema.allowDeactivate !== false) {
                selectOptions.unshift({ label: I18n$p.t(ConfigGeneric.NONE_LABEL), value: ConfigGeneric.NONE_VALUE });
            }
            this.setState({ value, selectOptions });
        });
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (!this.state.selectOptions) {
            return null;
        }
        const item = this.state.selectOptions.find(it => it.value === this.state.value);
        return (React$J.createElement(FormControl$d, { variant: "standard", fullWidth: true },
            this.props.schema.label ? React$J.createElement(InputLabel$b, null, this.getText(this.props.schema.label)) : null,
            React$J.createElement(Select$9, { variant: "standard", error: !!error, disabled: !!disabled, value: this.state.value || '_', renderValue: () => item ? (item.obj ? (React$J.createElement(TextWithIcon$1, { value: item.obj, themeType: this.props.oContext.themeType, lang: I18n$p.getLanguage() })) : (item.label)) : (''), onChange: e => {
                    this.setState({ value: e.target.value === '_' ? '' : e.target.value }, () => this.onChange(this.props.attr, this.state.value));
                } }, this.state.selectOptions.map(it => (React$J.createElement(MenuItem$a, { key: it.value, value: it.value, style: it.value === ConfigGeneric.DIFFERENT_VALUE ? { opacity: 0.5 } : {} }, it.obj ? (React$J.createElement(TextWithIcon$1, { value: it.obj, themeType: this.props.oContext.themeType, lang: I18n$p.getLanguage() })) : (it.label))))),
            this.props.schema.help ? (React$J.createElement(FormHelperText$b, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$I = await importShared('react');

const {InputLabel: InputLabel$a,TextField: TextField$g,FormHelperText: FormHelperText$a,MenuItem: MenuItem$9,FormControl: FormControl$c,Select: Select$8} = await importShared('@mui/material');

const {I18n: I18n$o} = await importShared('@iobroker/adapter-react-v5');
class ConfigIP extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        this.props.oContext.socket
            .getHostByIp(this.props.common.host)
            .then(ips => {
            // [{name, address, family}]
            if (!this.props.schema.listenOnAllPorts) {
                ips = ips.filter(item => item.address !== '0.0.0.0' && item.address !== '::');
            }
            if (this.props.schema.onlyIp4) {
                ips = ips.filter(item => item.family === 'ipv4');
            }
            else if (this.props.schema.onlyIp6) {
                ips = ips.filter(item => item.family === 'ipv6');
            }
            if (this.props.schema.noInternal) {
                ips = ips.filter(item => !item.internal);
            }
            ips.forEach(item => {
                if (item.address === '0.0.0.0') {
                    item.name = `[IPv4] 0.0.0.0 - ${I18n$o.t('ra_Listen on all IPs')}`;
                }
                else if (item.address === '::') {
                    item.name = `[IPv6] :: - ${I18n$o.t('ra_Listen on all IPs')}`;
                }
            });
            this.setState({ ips });
        })
            .catch(e => console.error(e));
    }
    renderItem(error, disabled /* , defaultValue */) {
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        const item = this.state.ips?.find(it => it.address === value);
        return (React$I.createElement(FormControl$c, { fullWidth: true, variant: "standard" },
            this.state.ips && this.props.schema.label ? (React$I.createElement(InputLabel$a, null, this.getText(this.props.schema.label))) : null,
            !this.state.ips ? (React$I.createElement(TextField$g, { fullWidth: true, variant: "standard", error: !!error, disabled: !!disabled, value: value, onChange: e => this.onChange(this.props.attr, e.target.value), label: this.getText(this.props.schema.label) })) : (React$I.createElement(Select$8, { variant: "standard", error: !!error, disabled: !!disabled, value: value, renderValue: val => item?.name || val, onChange: e => this.onChange(this.props.attr, e.target.value) }, this.state.ips?.map((it, i) => (React$I.createElement(MenuItem$9, { key: i, value: it.address }, it.name))))),
            this.props.schema.help ? (React$I.createElement(FormHelperText$a, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$H = await importShared('react');
class ConfigImageSendTo extends ConfigGeneric {
    initialized = false;
    localContext;
    componentDidMount() {
        super.componentDidMount();
        this.askInstance();
    }
    askInstance() {
        if (this.props.alive) {
            let data = this.props.schema.data;
            if (data === undefined && this.props.schema.jsonData) {
                const dataStr = this.getPattern(this.props.schema.jsonData, null, true);
                if (dataStr) {
                    try {
                        data = JSON.parse(dataStr);
                    }
                    catch {
                        console.error(`Cannot parse json data: ${JSON.stringify(data)}`);
                    }
                }
            }
            if (data === undefined) {
                data = null;
            }
            void this.props.oContext.socket
                .sendTo(`${this.props.oContext.adapterName}.${this.props.oContext.instance}`, this.props.schema.command || 'send', data)
                .then(image => this.setState({ image: image || '' }));
        }
    }
    getContext() {
        const localContext = {};
        if (Array.isArray(this.props.schema.alsoDependsOn)) {
            this.props.schema.alsoDependsOn.forEach(attr => (localContext[attr] = ConfigGeneric.getValue(this.props.data, attr)));
        }
        return JSON.stringify(localContext);
    }
    renderItem( /* error, disabled, defaultValue */) {
        if (this.props.alive) {
            const localContext = this.getContext();
            if (localContext !== this.localContext || !this.initialized) {
                this.localContext = localContext;
                setTimeout(() => this.askInstance(), this.initialized ? 300 : 50);
                this.initialized = true;
            }
        }
        if (this.state.image === undefined) {
            return null;
        }
        return (React$H.createElement("img", { alt: "dynamic content", src: this.state.image, style: { width: this.props.schema.width || '100%', height: this.props.schema.height } }));
    }
}

const React$G = await importShared('react');

const {InputLabel: InputLabel$9,FormHelperText: FormHelperText$9,FormControl: FormControl$b} = await importShared('@mui/material');

const {UploadImage} = await importShared('@iobroker/adapter-react-v5');
class ConfigImageUpload extends ConfigGeneric {
    index;
    constructor(props) {
        super(props);
        this.index = Date.now();
    }
    componentDidMount() {
        super.componentDidMount();
        if (this.props.schema.base64) {
            const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
            this.setState({ value });
        }
        else {
            void this.props.oContext.socket
                .fileExists(`${this.props.oContext.adapterName}.${this.props.oContext.instance}`, this.props.attr)
                .then(exist => exist && this.loadImage());
        }
    }
    _getUrl(update) {
        if (update) {
            this.index = Date.now();
        }
        let url = `files/${this.props.oContext.adapterName}.${this.props.oContext.instance}/${this.props.attr}?t=${this.index}`;
        if (window.location.port === '3000') {
            url = `${window.location.protocol}//${window.location.hostname}:8081/${url}`;
        }
        return url;
    }
    loadImage() {
        void fetch(this._getUrl())
            .then(res => res.blob())
            .then(blob => {
            const reader = new FileReader();
            reader.onload = () => {
                this.setState({ value: reader.result });
            };
            reader.readAsDataURL(blob);
        })
            .catch(e => console.error(e));
    }
    renderItem(error, disabled /* , defaultValue */) {
        return (React$G.createElement(FormControl$b, { fullWidth: true, variant: "standard" },
            this.props.schema.label ? (React$G.createElement(InputLabel$9, { shrink: true }, this.getText(this.props.schema.label))) : null,
            React$G.createElement(UploadImage, { error: !!error, disabled: disabled, accept: this.props.schema.accept, crop: this.props.schema.crop, maxSize: this.props.schema.maxSize || 256 * 1024, icon: this.state.value || undefined, removeIconFunc: () => this.setState({ value: null }, () => {
                    if (this.props.schema.base64) {
                        const mayBePromise = this.onChange(this.props.attr, this.state.value);
                        if (mayBePromise instanceof Promise) {
                            void mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
                        }
                    }
                    else {
                        // delete file to /instance/attr
                        void this.props.oContext.socket
                            .deleteFile(`${this.props.oContext.adapterName}.${this.props.oContext.instance}`, this.props.attr)
                            .catch(e => console.error(e));
                    }
                }), onChange: base64 => this.setState({ value: base64 }, () => {
                    if (this.props.schema.base64) {
                        const mayBePromise = this.onChange(this.props.attr, this.state.value);
                        if (mayBePromise instanceof Promise) {
                            void mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
                        }
                    }
                    else if (base64.startsWith('data')) {
                        base64 = base64.split(',')[1];
                    }
                    // upload file to /instance/attr
                    this.props.oContext.socket
                        .writeFile64(`${this.props.oContext.adapterName}.${this.props.oContext.instance}`, this.props.attr, base64)
                        .catch(e => console.error(e));
                }) }),
            this.props.schema.help ? (React$G.createElement(FormHelperText$9, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$F = await importShared('react');

const {Box: Box$9} = await importShared('@mui/material');

const {InfoBox} = await importShared('@iobroker/adapter-react-v5');
class ConfigInfoBox extends ConfigGeneric {
    renderItem() {
        return (React$F.createElement(InfoBox, { type: this.props.schema.boxType || 'info', closeable: this.props.schema.closeable !== undefined ? this.props.schema.closeable : true, storeId: this.props.schema.closed !== undefined
                ? undefined
                : `${!!this.props.oContext.adapterName} ${this.props.attr}`, closed: this.props.schema.closed, style: { width: '100%', ...this.props.schema.style } },
            this.props.schema.title ? (React$F.createElement(Box$9, { component: "div", sx: { fontWeight: 'bold', fontSize: 'larger' } }, this.getText(this.props.schema.title))) : null,
            this.getText(this.props.schema.text)));
    }
}

const React$E = await importShared('react');

const {InputLabel: InputLabel$8,MenuItem: MenuItem$8,FormHelperText: FormHelperText$8,FormControl: FormControl$a,Select: Select$7} = await importShared('@mui/material');

const {I18n: I18n$n} = await importShared('@iobroker/adapter-react-v5');
const styles$p = {
    icon: {
        width: 20,
        height: 20,
        marginRight: 4,
    },
};
class ConfigInstanceSelect extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        let adapter = this.props.schema.adapter;
        if (adapter === '_dataSources') {
            adapter = undefined;
        }
        void this.props.oContext.socket
            .getAdapterInstances(adapter, true)
            .then(async (instances) => {
            if (this.props.schema.adapter === '_dataSources') {
                // get only "data-sources", like history, sql, influx
                instances = instances.filter(instance => instance?.common?.getHistory);
            }
            else if (this.props.schema.adapter) {
                instances = instances.filter(instance => instance?._id.startsWith(`system.adapter.${this.props.schema.adapter}.`));
            }
            else if (this.props.schema.adapters && Array.isArray(this.props.schema.adapters)) {
                instances = instances.filter(instance => this.props.schema.adapters.includes(instance?.common?.name));
            }
            if (this.props.schema.onlyEnabled) {
                instances = instances.filter(instance => instance?.common?.enabled);
            }
            const selectOptions = instances.map(instance => ({
                value: this.props.schema.long
                    ? instance._id
                    : this.props.schema.short
                        ? instance._id.split('.').pop()
                        : instance._id.replace(/^system\.adapter\./, ''),
                label: `${instance.common.name} [${instance._id.replace(/^system\.adapter\./, '')}]`,
                icon: `adapter/${instance.common.name}/${instance.common.icon}`,
            }));
            selectOptions.sort((a, b) => {
                if (a.value > b.value) {
                    return 1;
                }
                if (a.value < b.value) {
                    return -1;
                }
                return 0;
            });
            if (this.props.schema.allowDeactivate !== false) {
                selectOptions.unshift({ label: I18n$n.t(ConfigGeneric.NONE_LABEL), value: ConfigGeneric.NONE_VALUE });
            }
            if (this.props.schema.all) {
                selectOptions.unshift({ label: I18n$n.t('sch_all'), value: '*' });
            }
            this.setState({ value: value || '', selectOptions });
            await this.props.oContext.socket.subscribeObject(`system.adapter.${adapter ? `${adapter}.` : ''}*`, this.onInstancesUpdate);
        })
            .catch(e => console.error(`Cannot get instances: ${e}`));
    }
    componentWillUnmount() {
        void this.props.oContext.socket.unsubscribeObject('system.adapter.*', this.onInstancesUpdate).then(() => { });
        super.componentWillUnmount();
    }
    onInstancesUpdate = (id, obj) => {
        if (!id.match(/^system\.adapter\.[-_a-z\d]+\.\d+$/)) {
            return;
        }
        const _id = this.props.schema.long
            ? id
            : this.props.schema.short
                ? id.split('.').pop()
                : id.replace(/^system\.adapter\./, '');
        const index = this.state.selectOptions.findIndex(item => item.value === _id);
        if (!obj) {
            // deleted
            if (index !== -1) {
                const selectOptions = JSON.parse(JSON.stringify(this.state.selectOptions));
                const newState = {};
                if (this.state.value === selectOptions[index].value) {
                    newState.value = ConfigGeneric.NONE_VALUE;
                }
                selectOptions.splice(index, 1);
                newState.selectOptions = selectOptions;
                this.setState(newState);
            }
        }
        else {
            if (this.props.schema.adapter === '_dataSources' && (!obj.common || !obj.common.getHistory)) {
                return;
            }
            if (index === -1) {
                const selectOptions = JSON.parse(JSON.stringify(this.state.selectOptions));
                const name = typeof obj.common.name === 'object'
                    ? obj.common.name[I18n$n.getLanguage()] || obj.common.name.en
                    : obj.common.name;
                selectOptions.push({
                    value: this.props.schema.long
                        ? obj._id
                        : this.props.schema.short
                            ? obj._id.split('.').pop()
                            : obj._id.replace(/^system\.adapter\./, ''),
                    label: `${name} [${obj._id.replace(/^system\.adapter\./, '')}]`,
                    icon: `adapter/${name}/${obj.common.icon}`,
                });
                selectOptions.sort((a, b) => (a.label > b.label ? 1 : a.label < b.label ? -1 : 0));
                this.setState({ selectOptions });
            }
        }
    };
    renderItem(error, disabled /* , defaultValue */) {
        if (!this.state.selectOptions) {
            return null;
        }
        const item = this.state.selectOptions?.find(it => it.value === this.state.value);
        return (React$E.createElement(FormControl$a, { fullWidth: true, key: this.props.attr, variant: "standard" },
            this.props.schema.label ? (React$E.createElement(InputLabel$8, { shrink: true }, this.getText(this.props.schema.label))) : null,
            React$E.createElement(Select$7, { variant: "standard", error: !!error, displayEmpty: true, disabled: !!disabled, value: this.state.value, renderValue: () => (React$E.createElement("span", { style: { display: 'flex' } },
                    item?.icon ? (React$E.createElement("img", { src: `./${item.icon}`, alt: item.value, style: styles$p.icon })) : null,
                    this.getText(item?.label, true))), onChange: e => this.setState({ value: e.target.value }, () => this.onChange(this.props.attr, this.state.value)) }, this.state.selectOptions.map(it => (React$E.createElement(MenuItem$8, { key: it.value, value: it.value, style: it.value === ConfigGeneric.NONE_VALUE ? { opacity: 0.5 } : {} },
                it.icon ? (React$E.createElement("img", { src: `./${it.icon}`, alt: it.value, style: styles$p.icon })) : null,
                this.getText(it.label, true))))),
            this.props.schema.help ? (React$E.createElement(FormHelperText$8, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$D = await importShared('react');

const {InputLabel: InputLabel$7,TextField: TextField$f,FormHelperText: FormHelperText$7,MenuItem: MenuItem$7,FormControl: FormControl$9,Select: Select$6} = await importShared('@mui/material');
const styles$o = {
    address: {
        fontSize: 'smaller',
        opacity: 0.5,
        marginLeft: 8,
    },
};
class ConfigInterface extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        this.props.oContext.socket
            .getObject(`system.host.${this.props.common.host}`)
            .then(obj => {
            const interfaces = [];
            if (obj?.native?.hardware?.networkInterfaces) {
                const list = obj.native.hardware.networkInterfaces;
                Object.keys(list).forEach(inter => {
                    if (this.props.schema.ignoreInternal && !list[inter].find(_ip => !_ip.internal)) {
                        return;
                    }
                    if (this.props.schema.ignoreLoopback &&
                        list[inter].find(_ip => _ip.address === '127.0.0.1' || _ip.address === '::1')) {
                        return;
                    }
                    // find ipv4 address
                    let ip = list[inter].find(_ip => _ip.family === 'IPv4');
                    ip = ip || list[inter].find(_ip => _ip.family === 'IPv6');
                    interfaces.push({ value: inter, address: ip.address });
                });
            }
            this.setState({ interfaces });
        })
            .catch(e => window.alert(`Cannot read interfaces: ${e}`));
    }
    renderItem(error, disabled /* , defaultValue */) {
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        const item = this.state.interfaces?.find(it => it.value === value);
        return (React$D.createElement(FormControl$9, { fullWidth: true, variant: "standard" },
            this.state.interfaces?.length && this.props.schema.label ? (React$D.createElement(InputLabel$7, null, this.getText(this.props.schema.label))) : null,
            !this.state.interfaces?.length ? (React$D.createElement(TextField$f, { fullWidth: true, variant: "standard", error: !!error, disabled: !!disabled, value: value, onChange: e => this.onChange(this.props.attr, e.target.value), label: this.getText(this.props.schema.label) })) : (React$D.createElement(Select$6, { variant: "standard", error: !!error, disabled: !!disabled, value: value, renderValue: val => {
                    if (item) {
                        return (React$D.createElement("span", null,
                            item.value,
                            React$D.createElement("span", { style: styles$o.address }, item.address)));
                    }
                    return val;
                }, onChange: e => this.onChange(this.props.attr, e.target.value) }, this.state.interfaces.map((it, i) => (React$D.createElement(MenuItem$7, { key: i, value: it.value },
                React$D.createElement("span", null,
                    it.value,
                    React$D.createElement("span", { style: styles$o.address }, it.address))))))),
            this.props.schema.help ? (React$D.createElement(FormHelperText$7, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$C = await importShared('react');
const {useEffect,useState} = React$C;

const {Dialog: Dialog$2,DialogActions: DialogActions$2,DialogContent: DialogContent$2,DialogTitle: DialogTitle$2,IconButton: IconButton$9,TextField: TextField$e,Button: Button$9,useMediaQuery,useTheme} = await importShared('@mui/material');

const {Check:CheckIcon,Close:CloseIcon$3,Language:LanguageIcon} = await importShared('@mui/icons-material');

const {I18n: I18n$m} = await importShared('@iobroker/adapter-react-v5');

const styles$n = {
    modalDialog: {
        minWidth: 400,
        maxWidth: 800,
    },
    overflowHidden: {
        display: 'flex',
        overflow: 'hidden',
    },
    titleIcon: {
        marginRight: 5,
    },
    content: {
        fontSize: 16,
    },
    languageButton: {
        position: 'absolute',
        right: 8,
        top: 8,
    },
    languageButtonActive: {
        color: 'primary.main',
    },
};
const CustomModal = ({ toggleTranslation, noTranslation, title, fullWidth, help, maxWidth, progress, icon, applyDisabled, applyButton, onClose, children, titleButtonApply, titleButtonClose, onApply, textInput, defaultValue, overflowHidden, }) => {
    const [value, setValue] = useState(defaultValue);
    useEffect(() => {
        setValue(defaultValue);
    }, [defaultValue]);
    const muiTheme = useTheme();
    const isSmallScreen = useMediaQuery(muiTheme.breakpoints.down('md'));
    let Icon = null;
    if (icon) {
        Icon = icon;
    }
    return (React$C.createElement(Dialog$2, { open: true, maxWidth: isSmallScreen ? false : maxWidth || 'md', fullWidth: !!fullWidth, fullScreen: isSmallScreen, disableEscapeKeyDown: false, onClose: onClose, sx: { '& .MuiPaper-root': isSmallScreen ? {} : styles$n.modalDialog /* paper: classes.background */ } },
        title && (React$C.createElement(DialogTitle$2, null,
            icon ? React$C.createElement(Icon, { style: styles$n.titleIcon }) : null,
            title,
            I18n$m.getLanguage() !== 'en' && toggleTranslation ? (React$C.createElement(IconButton$9, { size: "large", style: { ...styles$n.languageButton, ...(noTranslation ? styles$n.languageButtonActive : {}) }, onClick: () => toggleTranslation(), title: I18n$m.t('Disable/Enable translation') },
                React$C.createElement(LanguageIcon, null))) : null)),
        React$C.createElement(DialogContent$2, { sx: { ...(overflowHidden ? styles$n.overflowHidden : {}), ...styles$n.content }, style: { paddingTop: 8 } },
            textInput && (React$C.createElement(TextField$e
            // className={className}
            , { 
                // className={className}
                autoComplete: "off", fullWidth: true, autoFocus: true, variant: "outlined", size: "medium", 
                // rows={10}
                multiline: true, value: value, onChange: e => setValue(e.target.value) })),
            children,
            help ? React$C.createElement("div", null, help) : null),
        React$C.createElement(DialogActions$2, null,
            applyButton !== false && (React$C.createElement(Button$9, { startIcon: React$C.createElement(CheckIcon, null), disabled: progress || (applyDisabled && defaultValue === value), onClick: () => onApply && onApply(textInput ? value : ''), variant: "contained", color: "primary" }, I18n$m.t(titleButtonApply || 'Ok'))),
            React$C.createElement(Button$9, { color: "grey", onClick: () => onClose && onClose(), disabled: progress, variant: "contained", startIcon: React$C.createElement(CloseIcon$3, null) }, I18n$m.t(titleButtonClose || 'Cancel')))));
};

var lib = {};

var ace$4 = {};

var ace$3 = {exports: {}};

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

(function (module, exports) {
	/**
	 * Define a module along with a payload
	 * @param module a name for the payload
	 * @param payload a function to call with (require, exports, module) params
	 */

	(function() {

	var ACE_NAMESPACE = "ace";

	var global = (function() { return this; })();
	if (!global && typeof window != "undefined") global = window; // strict mode


	var define = function(module, deps, payload) {
	    if (typeof module !== "string") {
	        if (define.original)
	            define.original.apply(this, arguments);
	        else {
	            console.error("dropping module because define wasn\'t a string.");
	            console.trace();
	        }
	        return;
	    }
	    if (arguments.length == 2)
	        payload = deps;
	    if (!define.modules[module]) {
	        define.payloads[module] = payload;
	        define.modules[module] = null;
	    }
	};

	define.modules = {};
	define.payloads = {};

	/**
	 * Get at functionality define()ed using the function above
	 */
	var _require = function(parentId, module, callback) {
	    if (typeof module === "string") {
	        var payload = lookup(parentId, module);
	        if (payload != undefined) {
	            callback && callback();
	            return payload;
	        }
	    } else if (Object.prototype.toString.call(module) === "[object Array]") {
	        var params = [];
	        for (var i = 0, l = module.length; i < l; ++i) {
	            var dep = lookup(parentId, module[i]);
	            if (dep == undefined && require.original)
	                return;
	            params.push(dep);
	        }
	        return callback && callback.apply(null, params) || true;
	    }
	};

	var require = function(module, callback) {
	    var packagedModule = _require("", module, callback);
	    if (packagedModule == undefined && require.original)
	        return require.original.apply(this, arguments);
	    return packagedModule;
	};

	var normalizeModule = function(parentId, moduleName) {
	    // normalize plugin requires
	    if (moduleName.indexOf("!") !== -1) {
	        var chunks = moduleName.split("!");
	        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
	    }
	    // normalize relative requires
	    if (moduleName.charAt(0) == ".") {
	        var base = parentId.split("/").slice(0, -1).join("/");
	        moduleName = base + "/" + moduleName;

	        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
	            var previous = moduleName;
	            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
	        }
	    }
	    return moduleName;
	};

	/**
	 * Internal function to lookup moduleNames and resolve them by calling the
	 * definition function if needed.
	 */
	var lookup = function(parentId, moduleName) {
	    moduleName = normalizeModule(parentId, moduleName);

	    var module = define.modules[moduleName];
	    if (!module) {
	        module = define.payloads[moduleName];
	        if (typeof module === 'function') {
	            var exports = {};
	            var mod = {
	                id: moduleName,
	                uri: '',
	                exports: exports,
	                packaged: true
	            };

	            var req = function(module, callback) {
	                return _require(moduleName, module, callback);
	            };

	            var returnValue = module(req, exports, mod);
	            exports = returnValue || mod.exports;
	            define.modules[moduleName] = exports;
	            delete define.payloads[moduleName];
	        }
	        module = define.modules[moduleName] = exports || module;
	    }
	    return module;
	};

	function exportAce(ns) {
	    var root = global;
	    {
	        if (!global[ns])
	            global[ns] = {};
	        root = global[ns];
	    }

	    if (!root.define || !root.define.packaged) {
	        define.original = root.define;
	        root.define = define;
	        root.define.packaged = true;
	    }

	    if (!root.require || !root.require.packaged) {
	        require.original = root.require;
	        root.require = require;
	        root.require.packaged = true;
	    }
	}

	exportAce(ACE_NAMESPACE);

	})();

	ace.define("ace/lib/es6-shim",["require","exports","module"], function(require, exports, module){function defineProp(obj, name, val) {
	    Object.defineProperty(obj, name, {
	        value: val,
	        enumerable: false,
	        writable: true,
	        configurable: true
	    });
	}
	if (!String.prototype.startsWith) {
	    defineProp(String.prototype, "startsWith", function (searchString, position) {
	        position = position || 0;
	        return this.lastIndexOf(searchString, position) === position;
	    });
	}
	if (!String.prototype.endsWith) {
	    defineProp(String.prototype, "endsWith", function (searchString, position) {
	        var subjectString = this;
	        if (position === undefined || position > subjectString.length) {
	            position = subjectString.length;
	        }
	        position -= searchString.length;
	        var lastIndex = subjectString.indexOf(searchString, position);
	        return lastIndex !== -1 && lastIndex === position;
	    });
	}
	if (!String.prototype.repeat) {
	    defineProp(String.prototype, "repeat", function (count) {
	        var result = "";
	        var string = this;
	        while (count > 0) {
	            if (count & 1)
	                result += string;
	            if ((count >>= 1))
	                string += string;
	        }
	        return result;
	    });
	}
	if (!String.prototype.includes) {
	    defineProp(String.prototype, "includes", function (str, position) {
	        return this.indexOf(str, position) != -1;
	    });
	}
	if (!Object.assign) {
	    Object.assign = function (target) {
	        if (target === undefined || target === null) {
	            throw new TypeError("Cannot convert undefined or null to object");
	        }
	        var output = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	            var source = arguments[index];
	            if (source !== undefined && source !== null) {
	                Object.keys(source).forEach(function (key) {
	                    output[key] = source[key];
	                });
	            }
	        }
	        return output;
	    };
	}
	if (!Object.values) {
	    Object.values = function (o) {
	        return Object.keys(o).map(function (k) {
	            return o[k];
	        });
	    };
	}
	if (!Array.prototype.find) {
	    defineProp(Array.prototype, "find", function (predicate) {
	        var len = this.length;
	        var thisArg = arguments[1];
	        for (var k = 0; k < len; k++) {
	            var kValue = this[k];
	            if (predicate.call(thisArg, kValue, k, this)) {
	                return kValue;
	            }
	        }
	    });
	}
	if (!Array.prototype.findIndex) {
	    defineProp(Array.prototype, "findIndex", function (predicate) {
	        var len = this.length;
	        var thisArg = arguments[1];
	        for (var k = 0; k < len; k++) {
	            var kValue = this[k];
	            if (predicate.call(thisArg, kValue, k, this)) {
	                return k;
	            }
	        }
	    });
	}
	if (!Array.prototype.includes) {
	    defineProp(Array.prototype, "includes", function (item, position) {
	        return this.indexOf(item, position) != -1;
	    });
	}
	if (!Array.prototype.fill) {
	    defineProp(Array.prototype, "fill", function (value) {
	        var O = this;
	        var len = O.length >>> 0;
	        var start = arguments[1];
	        var relativeStart = start >> 0;
	        var k = relativeStart < 0
	            ? Math.max(len + relativeStart, 0)
	            : Math.min(relativeStart, len);
	        var end = arguments[2];
	        var relativeEnd = end === undefined ? len : end >> 0;
	        var final = relativeEnd < 0
	            ? Math.max(len + relativeEnd, 0)
	            : Math.min(relativeEnd, len);
	        while (k < final) {
	            O[k] = value;
	            k++;
	        }
	        return O;
	    });
	}
	if (!Array.of) {
	    defineProp(Array, "of", function () {
	        return Array.prototype.slice.call(arguments);
	    });
	}

	});

	ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/es6-shim"], function(require, exports, module){// vim:set ts=4 sts=4 sw=4 st:
	require("./es6-shim");

	});

	ace.define("ace/lib/deep_copy",["require","exports","module"], function(require, exports, module){exports.deepCopy = function deepCopy(obj) {
	    if (typeof obj !== "object" || !obj)
	        return obj;
	    var copy;
	    if (Array.isArray(obj)) {
	        copy = [];
	        for (var key = 0; key < obj.length; key++) {
	            copy[key] = deepCopy(obj[key]);
	        }
	        return copy;
	    }
	    if (Object.prototype.toString.call(obj) !== "[object Object]")
	        return obj;
	    copy = {};
	    for (var key in obj)
	        copy[key] = deepCopy(obj[key]);
	    return copy;
	};

	});

	ace.define("ace/lib/lang",["require","exports","module","ace/lib/deep_copy"], function(require, exports, module){	exports.last = function (a) {
	    return a[a.length - 1];
	};
	exports.stringReverse = function (string) {
	    return string.split("").reverse().join("");
	};
	exports.stringRepeat = function (string, count) {
	    var result = '';
	    while (count > 0) {
	        if (count & 1)
	            result += string;
	        if (count >>= 1)
	            string += string;
	    }
	    return result;
	};
	var trimBeginRegexp = /^\s\s*/;
	var trimEndRegexp = /\s\s*$/;
	exports.stringTrimLeft = function (string) {
	    return string.replace(trimBeginRegexp, '');
	};
	exports.stringTrimRight = function (string) {
	    return string.replace(trimEndRegexp, '');
	};
	exports.copyObject = function (obj) {
	    var copy = {};
	    for (var key in obj) {
	        copy[key] = obj[key];
	    }
	    return copy;
	};
	exports.copyArray = function (array) {
	    var copy = [];
	    for (var i = 0, l = array.length; i < l; i++) {
	        if (array[i] && typeof array[i] == "object")
	            copy[i] = this.copyObject(array[i]);
	        else
	            copy[i] = array[i];
	    }
	    return copy;
	};
	exports.deepCopy = require("./deep_copy").deepCopy;
	exports.arrayToMap = function (arr) {
	    var map = {};
	    for (var i = 0; i < arr.length; i++) {
	        map[arr[i]] = 1;
	    }
	    return map;
	};
	exports.createMap = function (props) {
	    var map = Object.create(null);
	    for (var i in props) {
	        map[i] = props[i];
	    }
	    return map;
	};
	exports.arrayRemove = function (array, value) {
	    for (var i = 0; i <= array.length; i++) {
	        if (value === array[i]) {
	            array.splice(i, 1);
	        }
	    }
	};
	exports.escapeRegExp = function (str) {
	    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
	};
	exports.escapeHTML = function (str) {
	    return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
	};
	exports.getMatchOffsets = function (string, regExp) {
	    var matches = [];
	    string.replace(regExp, function (str) {
	        matches.push({
	            offset: arguments[arguments.length - 2],
	            length: str.length
	        });
	    });
	    return matches;
	};
	exports.deferredCall = function (fcn) {
	    var timer = null;
	    var callback = function () {
	        timer = null;
	        fcn();
	    };
	    var deferred = function (timeout) {
	        deferred.cancel();
	        timer = setTimeout(callback, timeout || 0);
	        return deferred;
	    };
	    deferred.schedule = deferred;
	    deferred.call = function () {
	        this.cancel();
	        fcn();
	        return deferred;
	    };
	    deferred.cancel = function () {
	        clearTimeout(timer);
	        timer = null;
	        return deferred;
	    };
	    deferred.isPending = function () {
	        return timer;
	    };
	    return deferred;
	};
	exports.delayedCall = function (fcn, defaultTimeout) {
	    var timer = null;
	    var callback = function () {
	        timer = null;
	        fcn();
	    };
	    var _self = function (timeout) {
	        if (timer == null)
	            timer = setTimeout(callback, timeout || defaultTimeout);
	    };
	    _self.delay = function (timeout) {
	        timer && clearTimeout(timer);
	        timer = setTimeout(callback, timeout || defaultTimeout);
	    };
	    _self.schedule = _self;
	    _self.call = function () {
	        this.cancel();
	        fcn();
	    };
	    _self.cancel = function () {
	        timer && clearTimeout(timer);
	        timer = null;
	    };
	    _self.isPending = function () {
	        return timer;
	    };
	    return _self;
	};
	exports.supportsLookbehind = function () {
	    try {
	        new RegExp('(?<=.)');
	    }
	    catch (e) {
	        return false;
	    }
	    return true;
	};
	exports.skipEmptyMatch = function (line, last, supportsUnicodeFlag) {
	    return supportsUnicodeFlag && line.codePointAt(last) > 0xffff ? 2 : 1;
	};

	});

	ace.define("ace/lib/useragent",["require","exports","module"], function(require, exports, module){	exports.OS = {
	    LINUX: "LINUX",
	    MAC: "MAC",
	    WINDOWS: "WINDOWS"
	};
	exports.getOS = function () {
	    if (exports.isMac) {
	        return exports.OS.MAC;
	    }
	    else if (exports.isLinux) {
	        return exports.OS.LINUX;
	    }
	    else {
	        return exports.OS.WINDOWS;
	    }
	};
	var _navigator = typeof navigator == "object" ? navigator : {};
	var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
	var ua = _navigator.userAgent || "";
	var appName = _navigator.appName || "";
	exports.isWin = (os == "win");
	exports.isMac = (os == "mac");
	exports.isLinux = (os == "linux");
	exports.isIE =
	    (appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0)
	        ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1])
	        : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie
	exports.isOldIE = exports.isIE && exports.isIE < 9;
	exports.isGecko = exports.isMozilla = ua.match(/ Gecko\/\d+/);
	exports.isOpera = typeof opera == "object" && Object.prototype.toString.call(window["opera"]) == "[object Opera]";
	exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
	exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
	exports.isSafari = parseFloat(ua.split(" Safari/")[1]) && !exports.isChrome || undefined;
	exports.isEdge = parseFloat(ua.split(" Edge/")[1]) || undefined;
	exports.isAIR = ua.indexOf("AdobeAIR") >= 0;
	exports.isAndroid = ua.indexOf("Android") >= 0;
	exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
	exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window["MSStream"];
	if (exports.isIOS)
	    exports.isMac = true;
	exports.isMobile = exports.isIOS || exports.isAndroid;

	});

	ace.define("ace/lib/dom",["require","exports","module","ace/lib/useragent"], function(require, exports, module){	var useragent = require("./useragent");
	var XHTML_NS = "http://www.w3.org/1999/xhtml";
	exports.buildDom = function buildDom(arr, parent, refs) {
	    if (typeof arr == "string" && arr) {
	        var txt = document.createTextNode(arr);
	        if (parent)
	            parent.appendChild(txt);
	        return txt;
	    }
	    if (!Array.isArray(arr)) {
	        if (arr && arr.appendChild && parent)
	            parent.appendChild(arr);
	        return arr;
	    }
	    if (typeof arr[0] != "string" || !arr[0]) {
	        var els = [];
	        for (var i = 0; i < arr.length; i++) {
	            var ch = buildDom(arr[i], parent, refs);
	            ch && els.push(ch);
	        }
	        return els;
	    }
	    var el = document.createElement(arr[0]);
	    var options = arr[1];
	    var childIndex = 1;
	    if (options && typeof options == "object" && !Array.isArray(options))
	        childIndex = 2;
	    for (var i = childIndex; i < arr.length; i++)
	        buildDom(arr[i], el, refs);
	    if (childIndex == 2) {
	        Object.keys(options).forEach(function (n) {
	            var val = options[n];
	            if (n === "class") {
	                el.className = Array.isArray(val) ? val.join(" ") : val;
	            }
	            else if (typeof val == "function" || n == "value" || n[0] == "$") {
	                el[n] = val;
	            }
	            else if (n === "ref") {
	                if (refs)
	                    refs[val] = el;
	            }
	            else if (n === "style") {
	                if (typeof val == "string")
	                    el.style.cssText = val;
	            }
	            else if (val != null) {
	                el.setAttribute(n, val);
	            }
	        });
	    }
	    if (parent)
	        parent.appendChild(el);
	    return el;
	};
	exports.getDocumentHead = function (doc) {
	    if (!doc)
	        doc = document;
	    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
	};
	exports.createElement = function (tag, ns) {
	    return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
	};
	exports.removeChildren = function (element) {
	    element.innerHTML = "";
	};
	exports.createTextNode = function (textContent, element) {
	    var doc = element ? element.ownerDocument : document;
	    return doc.createTextNode(textContent);
	};
	exports.createFragment = function (element) {
	    var doc = element ? element.ownerDocument : document;
	    return doc.createDocumentFragment();
	};
	exports.hasCssClass = function (el, name) {
	    var classes = (el.className + "").split(/\s+/g);
	    return classes.indexOf(name) !== -1;
	};
	exports.addCssClass = function (el, name) {
	    if (!exports.hasCssClass(el, name)) {
	        el.className += " " + name;
	    }
	};
	exports.removeCssClass = function (el, name) {
	    var classes = el.className.split(/\s+/g);
	    while (true) {
	        var index = classes.indexOf(name);
	        if (index == -1) {
	            break;
	        }
	        classes.splice(index, 1);
	    }
	    el.className = classes.join(" ");
	};
	exports.toggleCssClass = function (el, name) {
	    var classes = el.className.split(/\s+/g), add = true;
	    while (true) {
	        var index = classes.indexOf(name);
	        if (index == -1) {
	            break;
	        }
	        add = false;
	        classes.splice(index, 1);
	    }
	    if (add)
	        classes.push(name);
	    el.className = classes.join(" ");
	    return add;
	};
	exports.setCssClass = function (node, className, include) {
	    if (include) {
	        exports.addCssClass(node, className);
	    }
	    else {
	        exports.removeCssClass(node, className);
	    }
	};
	exports.hasCssString = function (id, doc) {
	    var index = 0, sheets;
	    doc = doc || document;
	    if ((sheets = doc.querySelectorAll("style"))) {
	        while (index < sheets.length) {
	            if (sheets[index++].id === id) {
	                return true;
	            }
	        }
	    }
	};
	exports.removeElementById = function (id, doc) {
	    doc = doc || document;
	    if (doc.getElementById(id)) {
	        doc.getElementById(id).remove();
	    }
	};
	var strictCSP;
	var cssCache = [];
	exports.useStrictCSP = function (value) {
	    strictCSP = value;
	    if (value == false)
	        insertPendingStyles();
	    else if (!cssCache)
	        cssCache = [];
	};
	function insertPendingStyles() {
	    var cache = cssCache;
	    cssCache = null;
	    cache && cache.forEach(function (item) {
	        importCssString(item[0], item[1]);
	    });
	}
	function importCssString(cssText, id, target) {
	    if (typeof document == "undefined")
	        return;
	    if (cssCache) {
	        if (target) {
	            insertPendingStyles();
	        }
	        else if (target === false) {
	            return cssCache.push([cssText, id]);
	        }
	    }
	    if (strictCSP)
	        return;
	    var container = target;
	    if (!target || !target.getRootNode) {
	        container = document;
	    }
	    else {
	        container = target.getRootNode();
	        if (!container || container == target)
	            container = document;
	    }
	    var doc = container.ownerDocument || container;
	    if (id && exports.hasCssString(id, container))
	        return null;
	    if (id)
	        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
	    var style = exports.createElement("style");
	    style.appendChild(doc.createTextNode(cssText));
	    if (id)
	        style.id = id;
	    if (container == doc)
	        container = exports.getDocumentHead(doc);
	    container.insertBefore(style, container.firstChild);
	}
	exports.importCssString = importCssString;
	exports.importCssStylsheet = function (uri, doc) {
	    exports.buildDom(["link", { rel: "stylesheet", href: uri }], exports.getDocumentHead(doc));
	};
	exports.scrollbarWidth = function (doc) {
	    var inner = exports.createElement("ace_inner");
	    inner.style.width = "100%";
	    inner.style.minWidth = "0px";
	    inner.style.height = "200px";
	    inner.style.display = "block";
	    var outer = exports.createElement("ace_outer");
	    var style = outer.style;
	    style.position = "absolute";
	    style.left = "-10000px";
	    style.overflow = "hidden";
	    style.width = "200px";
	    style.minWidth = "0px";
	    style.height = "150px";
	    style.display = "block";
	    outer.appendChild(inner);
	    var body = (doc && doc.documentElement) || (document && document.documentElement);
	    if (!body)
	        return 0;
	    body.appendChild(outer);
	    var noScrollbar = inner.offsetWidth;
	    style.overflow = "scroll";
	    var withScrollbar = inner.offsetWidth;
	    if (noScrollbar === withScrollbar) {
	        withScrollbar = outer.clientWidth;
	    }
	    body.removeChild(outer);
	    return noScrollbar - withScrollbar;
	};
	exports.computedStyle = function (element, style) {
	    return window.getComputedStyle(element, "") || {};
	};
	exports.setStyle = function (styles, property, value) {
	    if (styles[property] !== value) {
	        styles[property] = value;
	    }
	};
	exports.HAS_CSS_ANIMATION = false;
	exports.HAS_CSS_TRANSFORMS = false;
	exports.HI_DPI = useragent.isWin
	    ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5
	    : true;
	if (useragent.isChromeOS)
	    exports.HI_DPI = false;
	if (typeof document !== "undefined") {
	    var div = document.createElement("div");
	    if (exports.HI_DPI && div.style.transform !== undefined)
	        exports.HAS_CSS_TRANSFORMS = true;
	    if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
	        exports.HAS_CSS_ANIMATION = true;
	    div = null;
	}
	if (exports.HAS_CSS_TRANSFORMS) {
	    exports.translate = function (element, tx, ty) {
	        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
	    };
	}
	else {
	    exports.translate = function (element, tx, ty) {
	        element.style.top = Math.round(ty) + "px";
	        element.style.left = Math.round(tx) + "px";
	    };
	}

	});

	ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(require, exports, module){/*
	 * based on code from:
	 *
	 * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
	 * Available via the MIT or new BSD license.
	 * see: http://github.com/jrburke/requirejs for details
	 */
	var dom = require("./dom");
	exports.get = function (url, callback) {
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, true);
	    xhr.onreadystatechange = function () {
	        if (xhr.readyState === 4) {
	            callback(xhr.responseText);
	        }
	    };
	    xhr.send(null);
	};
	exports.loadScript = function (path, callback) {
	    var head = dom.getDocumentHead();
	    var s = document.createElement('script');
	    s.src = path;
	    head.appendChild(s);
	    s.onload = s.onreadystatechange = function (_, isAbort) {
	        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
	            s = s.onload = s.onreadystatechange = null;
	            if (!isAbort)
	                callback();
	        }
	    };
	};
	exports.qualifyURL = function (url) {
	    var a = document.createElement('a');
	    a.href = url;
	    return a.href;
	};

	});

	ace.define("ace/lib/oop",["require","exports","module"], function(require, exports, module){	exports.inherits = function (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	            value: ctor,
	            enumerable: false,
	            writable: true,
	            configurable: true
	        }
	    });
	};
	exports.mixin = function (obj, mixin) {
	    for (var key in mixin) {
	        obj[key] = mixin[key];
	    }
	    return obj;
	};
	exports.implement = function (proto, mixin) {
	    exports.mixin(proto, mixin);
	};

	});

	ace.define("ace/lib/event_emitter",["require","exports","module"], function(require, exports, module){	var EventEmitter = {};
	var stopPropagation = function () { this.propagationStopped = true; };
	var preventDefault = function () { this.defaultPrevented = true; };
	EventEmitter._emit =
	    EventEmitter._dispatchEvent = function (eventName, e) {
	        this._eventRegistry || (this._eventRegistry = {});
	        this._defaultHandlers || (this._defaultHandlers = {});
	        var listeners = this._eventRegistry[eventName] || [];
	        var defaultHandler = this._defaultHandlers[eventName];
	        if (!listeners.length && !defaultHandler)
	            return;
	        if (typeof e != "object" || !e)
	            e = {};
	        if (!e.type)
	            e.type = eventName;
	        if (!e.stopPropagation)
	            e.stopPropagation = stopPropagation;
	        if (!e.preventDefault)
	            e.preventDefault = preventDefault;
	        listeners = listeners.slice();
	        for (var i = 0; i < listeners.length; i++) {
	            listeners[i](e, this);
	            if (e.propagationStopped)
	                break;
	        }
	        if (defaultHandler && !e.defaultPrevented)
	            return defaultHandler(e, this);
	    };
	EventEmitter._signal = function (eventName, e) {
	    var listeners = (this._eventRegistry || {})[eventName];
	    if (!listeners)
	        return;
	    listeners = listeners.slice();
	    for (var i = 0; i < listeners.length; i++)
	        listeners[i](e, this);
	};
	EventEmitter.once = function (eventName, callback) {
	    var _self = this;
	    this.on(eventName, function newCallback() {
	        _self.off(eventName, newCallback);
	        callback.apply(null, arguments);
	    });
	    if (!callback) {
	        return new Promise(function (resolve) {
	            callback = resolve;
	        });
	    }
	};
	EventEmitter.setDefaultHandler = function (eventName, callback) {
	    var handlers = this._defaultHandlers;
	    if (!handlers)
	        handlers = this._defaultHandlers = { _disabled_: {} };
	    if (handlers[eventName]) {
	        var old = handlers[eventName];
	        var disabled = handlers._disabled_[eventName];
	        if (!disabled)
	            handlers._disabled_[eventName] = disabled = [];
	        disabled.push(old);
	        var i = disabled.indexOf(callback);
	        if (i != -1)
	            disabled.splice(i, 1);
	    }
	    handlers[eventName] = callback;
	};
	EventEmitter.removeDefaultHandler = function (eventName, callback) {
	    var handlers = this._defaultHandlers;
	    if (!handlers)
	        return;
	    var disabled = handlers._disabled_[eventName];
	    if (handlers[eventName] == callback) {
	        if (disabled)
	            this.setDefaultHandler(eventName, disabled.pop());
	    }
	    else if (disabled) {
	        var i = disabled.indexOf(callback);
	        if (i != -1)
	            disabled.splice(i, 1);
	    }
	};
	EventEmitter.on =
	    EventEmitter.addEventListener = function (eventName, callback, capturing) {
	        this._eventRegistry = this._eventRegistry || {};
	        var listeners = this._eventRegistry[eventName];
	        if (!listeners)
	            listeners = this._eventRegistry[eventName] = [];
	        if (listeners.indexOf(callback) == -1)
	            listeners[capturing ? "unshift" : "push"](callback);
	        return callback;
	    };
	EventEmitter.off =
	    EventEmitter.removeListener =
	        EventEmitter.removeEventListener = function (eventName, callback) {
	            this._eventRegistry = this._eventRegistry || {};
	            var listeners = this._eventRegistry[eventName];
	            if (!listeners)
	                return;
	            var index = listeners.indexOf(callback);
	            if (index !== -1)
	                listeners.splice(index, 1);
	        };
	EventEmitter.removeAllListeners = function (eventName) {
	    if (!eventName)
	        this._eventRegistry = this._defaultHandlers = undefined;
	    if (this._eventRegistry)
	        this._eventRegistry[eventName] = undefined;
	    if (this._defaultHandlers)
	        this._defaultHandlers[eventName] = undefined;
	};
	exports.EventEmitter = EventEmitter;

	});

	ace.define("ace/lib/report_error",["require","exports","module"], function(require, exports, module){exports.reportError = function reportError(msg, data) {
	    var e = new Error(msg);
	    e["data"] = data;
	    if (typeof console == "object" && console.error)
	        console.error(e);
	    setTimeout(function () { throw e; });
	};

	});

	ace.define("ace/lib/default_english_messages",["require","exports","module"], function(require, exports, module){var defaultEnglishMessages = {
	    "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
	    "autocomplete.popup.aria-label": "Autocomplete suggestions",
	    "autocomplete.popup.item.aria-roledescription": "item",
	    "autocomplete.loading": "Loading...",
	    "editor.scroller.aria-roledescription": "editor",
	    "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
	    "editor.gutter.aria-roledescription": "editor gutter",
	    "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
	    "error-marker.good-state": "Looks good!",
	    "prompt.recently-used": "Recently used",
	    "prompt.other-commands": "Other commands",
	    "prompt.no-matching-commands": "No matching commands",
	    "search-box.find.placeholder": "Search for",
	    "search-box.find-all.text": "All",
	    "search-box.replace.placeholder": "Replace with",
	    "search-box.replace-next.text": "Replace",
	    "search-box.replace-all.text": "All",
	    "search-box.toggle-replace.title": "Toggle Replace mode",
	    "search-box.toggle-regexp.title": "RegExp Search",
	    "search-box.toggle-case.title": "CaseSensitive Search",
	    "search-box.toggle-whole-word.title": "Whole Word Search",
	    "search-box.toggle-in-selection.title": "Search In Selection",
	    "search-box.search-counter": "$0 of $1",
	    "text-input.aria-roledescription": "editor",
	    "text-input.aria-label": "Cursor at row $0",
	    "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
	    "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
	    "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
	    "gutter.code-folding.closed.title": "Unfold code",
	    "gutter.code-folding.open.title": "Fold code",
	    "gutter.annotation.aria-label.error": "Error, read annotations row $0",
	    "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
	    "gutter.annotation.aria-label.info": "Info, read annotations row $0",
	    "inline-fold.closed.title": "Unfold code",
	    "gutter-tooltip.aria-label.error.singular": "error",
	    "gutter-tooltip.aria-label.error.plural": "errors",
	    "gutter-tooltip.aria-label.warning.singular": "warning",
	    "gutter-tooltip.aria-label.warning.plural": "warnings",
	    "gutter-tooltip.aria-label.info.singular": "information message",
	    "gutter-tooltip.aria-label.info.plural": "information messages",
	    "gutter.annotation.aria-label.security": "Security finding, read annotations row $0",
	    "gutter.annotation.aria-label.hint": "Suggestion, read annotations row $0",
	    "gutter-tooltip.aria-label.security.singular": "security finding",
	    "gutter-tooltip.aria-label.security.plural": "security findings",
	    "gutter-tooltip.aria-label.hint.singular": "suggestion",
	    "gutter-tooltip.aria-label.hint.plural": "suggestions",
	    "editor.tooltip.disable-editing": "Editing is disabled"
	};
	exports.defaultEnglishMessages = defaultEnglishMessages;

	});

	ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter","ace/lib/report_error","ace/lib/default_english_messages"], function(require, exports, module){"no use strict";
	var oop = require("./oop");
	var EventEmitter = require("./event_emitter").EventEmitter;
	var reportError = require("./report_error").reportError;
	var defaultEnglishMessages = require("./default_english_messages").defaultEnglishMessages;
	var optionsProvider = {
	    setOptions: function (optList) {
	        Object.keys(optList).forEach(function (key) {
	            this.setOption(key, optList[key]);
	        }, this);
	    },
	    getOptions: function (optionNames) {
	        var result = {};
	        if (!optionNames) {
	            var options = this.$options;
	            optionNames = Object.keys(options).filter(function (key) {
	                return !options[key].hidden;
	            });
	        }
	        else if (!Array.isArray(optionNames)) {
	            optionNames = Object.keys(optionNames);
	        }
	        optionNames.forEach(function (key) {
	            result[key] = this.getOption(key);
	        }, this);
	        return result;
	    },
	    setOption: function (name, value) {
	        if (this["$" + name] === value)
	            return;
	        var opt = this.$options[name];
	        if (!opt) {
	            return warn('misspelled option "' + name + '"');
	        }
	        if (opt.forwardTo)
	            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
	        if (!opt.handlesSet)
	            this["$" + name] = value;
	        if (opt && opt.set)
	            opt.set.call(this, value);
	    },
	    getOption: function (name) {
	        var opt = this.$options[name];
	        if (!opt) {
	            return warn('misspelled option "' + name + '"');
	        }
	        if (opt.forwardTo)
	            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
	        return opt && opt.get ? opt.get.call(this) : this["$" + name];
	    }
	};
	function warn(message) {
	    if (typeof console != "undefined" && console.warn)
	        console.warn.apply(console, arguments);
	}
	var messages;
	var nlsPlaceholders;
	var AppConfig = /** @class */ (function () {
	    function AppConfig() {
	        this.$defaultOptions = {};
	        messages = defaultEnglishMessages;
	        nlsPlaceholders = "dollarSigns";
	    }
	    AppConfig.prototype.defineOptions = function (obj, path, options) {
	        if (!obj.$options)
	            this.$defaultOptions[path] = obj.$options = {};
	        Object.keys(options).forEach(function (key) {
	            var opt = options[key];
	            if (typeof opt == "string")
	                opt = { forwardTo: opt };
	            opt.name || (opt.name = key);
	            obj.$options[opt.name] = opt;
	            if ("initialValue" in opt)
	                obj["$" + opt.name] = opt.initialValue;
	        });
	        oop.implement(obj, optionsProvider);
	        return this;
	    };
	    AppConfig.prototype.resetOptions = function (obj) {
	        Object.keys(obj.$options).forEach(function (key) {
	            var opt = obj.$options[key];
	            if ("value" in opt)
	                obj.setOption(key, opt.value);
	        });
	    };
	    AppConfig.prototype.setDefaultValue = function (path, name, value) {
	        if (!path) {
	            for (path in this.$defaultOptions)
	                if (this.$defaultOptions[path][name])
	                    break;
	            if (!this.$defaultOptions[path][name])
	                return false;
	        }
	        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
	        if (opts[name]) {
	            if (opts.forwardTo)
	                this.setDefaultValue(opts.forwardTo, name, value);
	            else
	                opts[name].value = value;
	        }
	    };
	    AppConfig.prototype.setDefaultValues = function (path, optionHash) {
	        Object.keys(optionHash).forEach(function (key) {
	            this.setDefaultValue(path, key, optionHash[key]);
	        }, this);
	    };
	    AppConfig.prototype.setMessages = function (value, options) {
	        messages = value;
	        if (options && options.placeholders) {
	            nlsPlaceholders = options.placeholders;
	        }
	    };
	    AppConfig.prototype.nls = function (key, defaultString, params) {
	        if (!messages[key]) {
	            warn("No message found for the key '" + key + "' in messages with id " + messages.$id + ", trying to find a translation for the default string '" + defaultString + "'.");
	            if (!messages[defaultString]) {
	                warn("No message found for the default string '" + defaultString + "' in the provided messages. Falling back to the default English message.");
	            }
	        }
	        var translated = messages[key] || messages[defaultString] || defaultString;
	        if (params) {
	            if (nlsPlaceholders === "dollarSigns") {
	                translated = translated.replace(/\$(\$|[\d]+)/g, function (_, dollarMatch) {
	                    if (dollarMatch == "$")
	                        return "$";
	                    return params[dollarMatch];
	                });
	            }
	            if (nlsPlaceholders === "curlyBrackets") {
	                translated = translated.replace(/\{([^\}]+)\}/g, function (_, curlyBracketMatch) {
	                    return params[curlyBracketMatch];
	                });
	            }
	        }
	        return translated;
	    };
	    return AppConfig;
	}());
	AppConfig.prototype.warn = warn;
	AppConfig.prototype.reportError = reportError;
	oop.implement(AppConfig.prototype, EventEmitter);
	exports.AppConfig = AppConfig;

	});

	ace.define("ace/theme/textmate-css",["require","exports","module"], function(require, exports, module){module.exports = ".ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC\") right repeat-y;\n}\n";

	});

	ace.define("ace/theme/textmate",["require","exports","module","ace/theme/textmate-css","ace/lib/dom"], function(require, exports, module){	exports.isDark = false;
	exports.cssClass = "ace-tm";
	exports.cssText = require("./textmate-css");
	exports.$id = "ace/theme/textmate";
	var dom = require("../lib/dom");
	dom.importCssString(exports.cssText, exports.cssClass, false);

	});

	ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/net","ace/lib/dom","ace/lib/app_config","ace/theme/textmate"], function(require, exports, module){"no use strict";
	var lang = require("./lib/lang");
	var net = require("./lib/net");
	var dom = require("./lib/dom");
	var AppConfig = require("./lib/app_config").AppConfig;
	module.exports = exports = new AppConfig();
	var options = {
	    packaged: false,
	    workerPath: null,
	    modePath: null,
	    themePath: null,
	    basePath: "",
	    suffix: ".js",
	    $moduleUrls: {},
	    loadWorkerFromBlob: true,
	    sharedPopups: false,
	    useStrictCSP: null
	};
	exports.get = function (key) {
	    if (!options.hasOwnProperty(key))
	        throw new Error("Unknown config key: " + key);
	    return options[key];
	};
	exports.set = function (key, value) {
	    if (options.hasOwnProperty(key))
	        options[key] = value;
	    else if (this.setDefaultValue("", key, value) == false)
	        throw new Error("Unknown config key: " + key);
	    if (key == "useStrictCSP")
	        dom.useStrictCSP(value);
	};
	exports.all = function () {
	    return lang.copyObject(options);
	};
	exports.$modes = {};
	exports.moduleUrl = function (name, component) {
	    if (options.$moduleUrls[name])
	        return options.$moduleUrls[name];
	    var parts = name.split("/");
	    component = component || parts[parts.length - 2] || "";
	    var sep = component == "snippets" ? "/" : "-";
	    var base = parts[parts.length - 1];
	    if (component == "worker" && sep == "-") {
	        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
	        base = base.replace(re, "");
	    }
	    if ((!base || base == component) && parts.length > 1)
	        base = parts[parts.length - 2];
	    var path = options[component + "Path"];
	    if (path == null) {
	        path = options.basePath;
	    }
	    else if (sep == "/") {
	        component = sep = "";
	    }
	    if (path && path.slice(-1) != "/")
	        path += "/";
	    return path + component + sep + base + this.get("suffix");
	};
	exports.setModuleUrl = function (name, subst) {
	    return options.$moduleUrls[name] = subst;
	};
	var loader = function (moduleName, cb) {
	    if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
	        return cb(null, require("./theme/textmate"));
	    if (customLoader)
	        return customLoader(moduleName, cb);
	    console.error("loader is not configured");
	};
	var customLoader;
	exports.setLoader = function (cb) {
	    customLoader = cb;
	};
	exports.dynamicModules = Object.create(null);
	exports.$loading = {};
	exports.$loaded = {};
	exports.loadModule = function (moduleId, onLoad) {
	    var loadedModule;
	    if (Array.isArray(moduleId)) {
	        var moduleType = moduleId[0];
	        var moduleName = moduleId[1];
	    }
	    else if (typeof moduleId == "string") {
	        var moduleName = moduleId;
	    }
	    var load = function (module) {
	        if (module && !exports.$loading[moduleName])
	            return onLoad && onLoad(module);
	        if (!exports.$loading[moduleName])
	            exports.$loading[moduleName] = [];
	        exports.$loading[moduleName].push(onLoad);
	        if (exports.$loading[moduleName].length > 1)
	            return;
	        var afterLoad = function () {
	            loader(moduleName, function (err, module) {
	                if (module)
	                    exports.$loaded[moduleName] = module;
	                exports._emit("load.module", { name: moduleName, module: module });
	                var listeners = exports.$loading[moduleName];
	                exports.$loading[moduleName] = null;
	                listeners.forEach(function (onLoad) {
	                    onLoad && onLoad(module);
	                });
	            });
	        };
	        if (!exports.get("packaged"))
	            return afterLoad();
	        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
	        reportErrorIfPathIsNotConfigured();
	    };
	    if (exports.dynamicModules[moduleName]) {
	        exports.dynamicModules[moduleName]().then(function (module) {
	            if (module.default) {
	                load(module.default);
	            }
	            else {
	                load(module);
	            }
	        });
	    }
	    else {
	        try {
	            loadedModule = this.$require(moduleName);
	        }
	        catch (e) { }
	        load(loadedModule || exports.$loaded[moduleName]);
	    }
	};
	exports.$require = function (moduleName) {
	    if (typeof module["require"] == "function") {
	        var req = "require";
	        return module[req](moduleName);
	    }
	};
	exports.setModuleLoader = function (moduleName, onLoad) {
	    exports.dynamicModules[moduleName] = onLoad;
	};
	var reportErrorIfPathIsNotConfigured = function () {
	    if (!options.basePath && !options.workerPath
	        && !options.modePath && !options.themePath
	        && !Object.keys(options.$moduleUrls).length) {
	        console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
	        reportErrorIfPathIsNotConfigured = function () { };
	    }
	};
	exports.version = "1.43.3";

	});

	ace.define("ace/loader_build",["require","exports","module","ace/lib/fixoldbrowsers","ace/config"], function(require, exports, module) {

	require("./lib/fixoldbrowsers");
	var config = require("./config");
	config.setLoader(function(moduleName, cb) {
	    require([moduleName], function(module) {
	        cb(null, module);
	    });
	});

	var global = (function() {
	    return this || typeof window != "undefined" && window;
	})();

	module.exports = function(ace) {
	    config.init = init;
	    config.$require = require;
	    ace.require = require;
	};
	init(true);function init(packaged) {

	    if (!global || !global.document)
	        return;
	    
	    config.set("packaged", packaged || require.packaged || module.packaged || (global.define && undefined.packaged));

	    var scriptOptions = {};
	    var scriptUrl = "";
	    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
	    var currentDocument = currentScript && currentScript.ownerDocument || document;
	    
	    if (currentScript && currentScript.src) {
	        scriptUrl = currentScript.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "";
	    }
	    
	    var scripts = currentDocument.getElementsByTagName("script");
	    for (var i=0; i<scripts.length; i++) {
	        var script = scripts[i];

	        var src = script.src || script.getAttribute("src");
	        if (!src)
	            continue;

	        var attributes = script.attributes;
	        for (var j=0, l=attributes.length; j < l; j++) {
	            var attr = attributes[j];
	            if (attr.name.indexOf("data-ace-") === 0) {
	                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
	            }
	        }

	        var m = src.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
	        if (m)
	            scriptUrl = m[1];
	    }

	    if (scriptUrl) {
	        scriptOptions.base = scriptOptions.base || scriptUrl;
	        scriptOptions.packaged = true;
	    }

	    scriptOptions.basePath = scriptOptions.base;
	    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
	    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
	    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
	    delete scriptOptions.base;

	    for (var key in scriptOptions)
	        if (typeof scriptOptions[key] !== "undefined")
	            config.set(key, scriptOptions[key]);
	}

	function deHyphenate(str) {
	    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
	}
	});

	ace.define("ace/range",["require","exports","module"], function(require, exports, module){	var Range = /** @class */ (function () {
	    function Range(startRow, startColumn, endRow, endColumn) {
	        this.start = {
	            row: startRow,
	            column: startColumn
	        };
	        this.end = {
	            row: endRow,
	            column: endColumn
	        };
	    }
	    Range.prototype.isEqual = function (range) {
	        return this.start.row === range.start.row &&
	            this.end.row === range.end.row &&
	            this.start.column === range.start.column &&
	            this.end.column === range.end.column;
	    };
	    Range.prototype.toString = function () {
	        return ("Range: [" + this.start.row + "/" + this.start.column +
	            "] -> [" + this.end.row + "/" + this.end.column + "]");
	    };
	    Range.prototype.contains = function (row, column) {
	        return this.compare(row, column) == 0;
	    };
	    Range.prototype.compareRange = function (range) {
	        var cmp, end = range.end, start = range.start;
	        cmp = this.compare(end.row, end.column);
	        if (cmp == 1) {
	            cmp = this.compare(start.row, start.column);
	            if (cmp == 1) {
	                return 2;
	            }
	            else if (cmp == 0) {
	                return 1;
	            }
	            else {
	                return 0;
	            }
	        }
	        else if (cmp == -1) {
	            return -2;
	        }
	        else {
	            cmp = this.compare(start.row, start.column);
	            if (cmp == -1) {
	                return -1;
	            }
	            else if (cmp == 1) {
	                return 42;
	            }
	            else {
	                return 0;
	            }
	        }
	    };
	    Range.prototype.comparePoint = function (p) {
	        return this.compare(p.row, p.column);
	    };
	    Range.prototype.containsRange = function (range) {
	        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
	    };
	    Range.prototype.intersects = function (range) {
	        var cmp = this.compareRange(range);
	        return (cmp == -1 || cmp == 0 || cmp == 1);
	    };
	    Range.prototype.isEnd = function (row, column) {
	        return this.end.row == row && this.end.column == column;
	    };
	    Range.prototype.isStart = function (row, column) {
	        return this.start.row == row && this.start.column == column;
	    };
	    Range.prototype.setStart = function (row, column) {
	        if (typeof row == "object") {
	            this.start.column = row.column;
	            this.start.row = row.row;
	        }
	        else {
	            this.start.row = row;
	            this.start.column = column;
	        }
	    };
	    Range.prototype.setEnd = function (row, column) {
	        if (typeof row == "object") {
	            this.end.column = row.column;
	            this.end.row = row.row;
	        }
	        else {
	            this.end.row = row;
	            this.end.column = column;
	        }
	    };
	    Range.prototype.inside = function (row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isEnd(row, column) || this.isStart(row, column)) {
	                return false;
	            }
	            else {
	                return true;
	            }
	        }
	        return false;
	    };
	    Range.prototype.insideStart = function (row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isEnd(row, column)) {
	                return false;
	            }
	            else {
	                return true;
	            }
	        }
	        return false;
	    };
	    Range.prototype.insideEnd = function (row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isStart(row, column)) {
	                return false;
	            }
	            else {
	                return true;
	            }
	        }
	        return false;
	    };
	    Range.prototype.compare = function (row, column) {
	        if (!this.isMultiLine()) {
	            if (row === this.start.row) {
	                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
	            }
	        }
	        if (row < this.start.row)
	            return -1;
	        if (row > this.end.row)
	            return 1;
	        if (this.start.row === row)
	            return column >= this.start.column ? 0 : -1;
	        if (this.end.row === row)
	            return column <= this.end.column ? 0 : 1;
	        return 0;
	    };
	    Range.prototype.compareStart = function (row, column) {
	        if (this.start.row == row && this.start.column == column) {
	            return -1;
	        }
	        else {
	            return this.compare(row, column);
	        }
	    };
	    Range.prototype.compareEnd = function (row, column) {
	        if (this.end.row == row && this.end.column == column) {
	            return 1;
	        }
	        else {
	            return this.compare(row, column);
	        }
	    };
	    Range.prototype.compareInside = function (row, column) {
	        if (this.end.row == row && this.end.column == column) {
	            return 1;
	        }
	        else if (this.start.row == row && this.start.column == column) {
	            return -1;
	        }
	        else {
	            return this.compare(row, column);
	        }
	    };
	    Range.prototype.clipRows = function (firstRow, lastRow) {
	        if (this.end.row > lastRow)
	            var end = { row: lastRow + 1, column: 0 };
	        else if (this.end.row < firstRow)
	            var end = { row: firstRow, column: 0 };
	        if (this.start.row > lastRow)
	            var start = { row: lastRow + 1, column: 0 };
	        else if (this.start.row < firstRow)
	            var start = { row: firstRow, column: 0 };
	        return Range.fromPoints(start || this.start, end || this.end);
	    };
	    Range.prototype.extend = function (row, column) {
	        var cmp = this.compare(row, column);
	        if (cmp == 0)
	            return this;
	        else if (cmp == -1)
	            var start = { row: row, column: column };
	        else
	            var end = { row: row, column: column };
	        return Range.fromPoints(start || this.start, end || this.end);
	    };
	    Range.prototype.isEmpty = function () {
	        return (this.start.row === this.end.row && this.start.column === this.end.column);
	    };
	    Range.prototype.isMultiLine = function () {
	        return (this.start.row !== this.end.row);
	    };
	    Range.prototype.clone = function () {
	        return Range.fromPoints(this.start, this.end);
	    };
	    Range.prototype.collapseRows = function () {
	        if (this.end.column == 0)
	            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
	        else
	            return new Range(this.start.row, 0, this.end.row, 0);
	    };
	    Range.prototype.toScreenRange = function (session) {
	        var screenPosStart = session.documentToScreenPosition(this.start);
	        var screenPosEnd = session.documentToScreenPosition(this.end);
	        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
	    };
	    Range.prototype.moveBy = function (row, column) {
	        this.start.row += row;
	        this.start.column += column;
	        this.end.row += row;
	        this.end.column += column;
	    };
	    return Range;
	}());
	Range.fromPoints = function (start, end) {
	    return new Range(start.row, start.column, end.row, end.column);
	};
	Range.comparePoints = function (p1, p2) {
	    return p1.row - p2.row || p1.column - p2.column;
	};
	exports.Range = Range;

	});

	ace.define("ace/lib/keys",["require","exports","module","ace/lib/oop"], function(require, exports, module){	var oop = require("./oop");
	var Keys = {
	    MODIFIER_KEYS: {
	        16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',
	        91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'
	    },
	    KEY_MODS: {
	        "ctrl": 1, "alt": 2, "option": 2, "shift": 4,
	        "super": 8, "meta": 8, "command": 8, "cmd": 8,
	        "control": 1
	    },
	    FUNCTION_KEYS: {
	        8: "Backspace",
	        9: "Tab",
	        13: "Return",
	        19: "Pause",
	        27: "Esc",
	        32: "Space",
	        33: "PageUp",
	        34: "PageDown",
	        35: "End",
	        36: "Home",
	        37: "Left",
	        38: "Up",
	        39: "Right",
	        40: "Down",
	        44: "Print",
	        45: "Insert",
	        46: "Delete",
	        '-13': "NumpadEnter",
	        144: "Numlock",
	        145: "Scrolllock"
	    },
	    PRINTABLE_KEYS: {
	        32: ' ', 59: ';', 61: '=', 107: '+', 109: '-', 110: '.',
	        186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
	        219: '[', 220: '\\', 221: ']', 222: "'", 111: '/', 106: '*'
	    }
	};
	var codeToKeyCode = {
	    Command: 224,
	    Backspace: 8,
	    Tab: 9,
	    Return: 13,
	    Enter: 13,
	    Pause: 19,
	    Escape: 27,
	    PageUp: 33,
	    PageDown: 34,
	    End: 35,
	    Home: 36,
	    Insert: 45,
	    Delete: 46,
	    ArrowLeft: 37,
	    ArrowUp: 38,
	    ArrowRight: 39,
	    ArrowDown: 40,
	    Backquote: 192,
	    Minus: 189,
	    Equal: 187,
	    BracketLeft: 219,
	    Backslash: 220,
	    BracketRight: 221,
	    Semicolon: 186,
	    Quote: 222,
	    Comma: 188,
	    Period: 190,
	    Slash: 191,
	    Space: 32,
	    NumpadAdd: 107,
	    NumpadDecimal: 110,
	    NumpadSubtract: 109,
	    NumpadDivide: 111,
	    NumpadMultiply: 106
	};
	for (var i = 0; i < 10; i++) {
	    codeToKeyCode["Digit" + i] = 48 + i;
	    codeToKeyCode["Numpad" + i] = 96 + i;
	    Keys.PRINTABLE_KEYS[48 + i] = "" + i;
	    Keys.FUNCTION_KEYS[96 + i] = "Numpad" + i;
	}
	for (var i = 65; i < 91; i++) {
	    var chr = String.fromCharCode(i + 32);
	    codeToKeyCode["Key" + chr.toUpperCase()] = i;
	    Keys.PRINTABLE_KEYS[i] = chr;
	}
	for (var i = 1; i < 13; i++) {
	    codeToKeyCode["F" + i] = 111 + i;
	    Keys.FUNCTION_KEYS[111 + i] = "F" + i;
	}
	var modifiers = {
	    Shift: 16,
	    Control: 17,
	    Alt: 18,
	    Meta: 224
	};
	for (var mod in modifiers) {
	    codeToKeyCode[mod] = codeToKeyCode[mod + "Left"]
	        = codeToKeyCode[mod + "Right"] = modifiers[mod];
	}
	exports.$codeToKeyCode = codeToKeyCode;
	Keys.PRINTABLE_KEYS[173] = '-';
	for (var j in Keys.FUNCTION_KEYS) {
	    var name = Keys.FUNCTION_KEYS[j].toLowerCase();
	    Keys[name] = parseInt(j, 10);
	}
	for (var j in Keys.PRINTABLE_KEYS) {
	    var name = Keys.PRINTABLE_KEYS[j].toLowerCase();
	    Keys[name] = parseInt(j, 10);
	}
	oop.mixin(Keys, Keys.MODIFIER_KEYS);
	oop.mixin(Keys, Keys.PRINTABLE_KEYS);
	oop.mixin(Keys, Keys.FUNCTION_KEYS);
	Keys.enter = Keys["return"];
	Keys.escape = Keys.esc;
	Keys.del = Keys["delete"];
	(function () {
	    var mods = ["cmd", "ctrl", "alt", "shift"];
	    for (var i = Math.pow(2, mods.length); i--;) {
	        Keys.KEY_MODS[i] = mods.filter(function (x) {
	            return i & Keys.KEY_MODS[x];
	        }).join("-") + "-";
	    }
	})();
	Keys.KEY_MODS[0] = "";
	Keys.KEY_MODS[-1] = "input-";
	oop.mixin(exports, Keys);
	exports.default = exports;
	exports.keyCodeToString = function (keyCode) {
	    var keyString = Keys[keyCode];
	    if (typeof keyString != "string")
	        keyString = String.fromCharCode(keyCode);
	    return keyString.toLowerCase();
	};

	});

	ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module){ var keys = require("./keys");
	var useragent = require("./useragent");
	var pressedKeys = null;
	var ts = 0;
	var activeListenerOptions;
	function detectListenerOptionsSupport() {
	    activeListenerOptions = false;
	    try {
	        document.createComment("").addEventListener("test", function () { }, {
	            get passive() {
	                activeListenerOptions = { passive: false };
	                return true;
	            }
	        });
	    }
	    catch (e) { }
	}
	function getListenerOptions() {
	    if (activeListenerOptions == undefined)
	        detectListenerOptionsSupport();
	    return activeListenerOptions;
	}
	function EventListener(elem, type, callback) {
	    this.elem = elem;
	    this.type = type;
	    this.callback = callback;
	}
	EventListener.prototype.destroy = function () {
	    removeListener(this.elem, this.type, this.callback);
	    this.elem = this.type = this.callback = undefined;
	};
	var addListener = exports.addListener = function (elem, type, callback, destroyer) {
	    elem.addEventListener(type, callback, getListenerOptions());
	    if (destroyer)
	        destroyer.$toDestroy.push(new EventListener(elem, type, callback));
	};
	var removeListener = exports.removeListener = function (elem, type, callback) {
	    elem.removeEventListener(type, callback, getListenerOptions());
	};
	exports.stopEvent = function (e) {
	    exports.stopPropagation(e);
	    exports.preventDefault(e);
	    return false;
	};
	exports.stopPropagation = function (e) {
	    if (e.stopPropagation)
	        e.stopPropagation();
	};
	exports.preventDefault = function (e) {
	    if (e.preventDefault)
	        e.preventDefault();
	};
	exports.getButton = function (e) {
	    if (e.type == "dblclick")
	        return 0;
	    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
	        return 2;
	    return e.button;
	};
	exports.capture = function (el, eventHandler, releaseCaptureHandler) {
	    var ownerDocument = el && el.ownerDocument || document;
	    function onMouseUp(e) {
	        eventHandler && eventHandler(e);
	        releaseCaptureHandler && releaseCaptureHandler(e);
	        removeListener(ownerDocument, "mousemove", eventHandler);
	        removeListener(ownerDocument, "mouseup", onMouseUp);
	        removeListener(ownerDocument, "dragstart", onMouseUp);
	    }
	    addListener(ownerDocument, "mousemove", eventHandler);
	    addListener(ownerDocument, "mouseup", onMouseUp);
	    addListener(ownerDocument, "dragstart", onMouseUp);
	    return onMouseUp;
	};
	exports.addMouseWheelListener = function (el, callback, destroyer) {
	    addListener(el, "wheel", function (e) {
	        var factor = 0.15;
	        var deltaX = e.deltaX || 0;
	        var deltaY = e.deltaY || 0;
	        switch (e.deltaMode) {
	            case e.DOM_DELTA_PIXEL:
	                e.wheelX = deltaX * factor;
	                e.wheelY = deltaY * factor;
	                break;
	            case e.DOM_DELTA_LINE:
	                var linePixels = 15;
	                e.wheelX = deltaX * linePixels;
	                e.wheelY = deltaY * linePixels;
	                break;
	            case e.DOM_DELTA_PAGE:
	                var pagePixels = 150;
	                e.wheelX = deltaX * pagePixels;
	                e.wheelY = deltaY * pagePixels;
	                break;
	        }
	        callback(e);
	    }, destroyer);
	};
	exports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName, destroyer) {
	    var clicks = 0;
	    var startX, startY, timer;
	    var eventNames = {
	        2: "dblclick",
	        3: "tripleclick",
	        4: "quadclick"
	    };
	    function onMousedown(e) {
	        if (exports.getButton(e) !== 0) {
	            clicks = 0;
	        }
	        else if (e.detail > 1) {
	            clicks++;
	            if (clicks > 4)
	                clicks = 1;
	        }
	        else {
	            clicks = 1;
	        }
	        if (useragent.isIE) {
	            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
	            if (!timer || isNewClick)
	                clicks = 1;
	            if (timer)
	                clearTimeout(timer);
	            timer = setTimeout(function () { timer = null; }, timeouts[clicks - 1] || 600);
	            if (clicks == 1) {
	                startX = e.clientX;
	                startY = e.clientY;
	            }
	        }
	        e._clicks = clicks;
	        eventHandler[callbackName]("mousedown", e);
	        if (clicks > 4)
	            clicks = 0;
	        else if (clicks > 1)
	            return eventHandler[callbackName](eventNames[clicks], e);
	    }
	    if (!Array.isArray(elements))
	        elements = [elements];
	    elements.forEach(function (el) {
	        addListener(el, "mousedown", onMousedown, destroyer);
	    });
	};
	function getModifierHash(e) {
	    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
	}
	exports.getModifierString = function (e) {
	    return keys.KEY_MODS[getModifierHash(e)];
	};
	function normalizeCommandKeys(callback, e, keyCode) {
	    var hashId = getModifierHash(e);
	    if (!keyCode && e.code) {
	        keyCode = keys.$codeToKeyCode[e.code] || keyCode;
	    }
	    if (!useragent.isMac && pressedKeys) {
	        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
	            hashId |= 8;
	        if (pressedKeys.altGr) {
	            if ((3 & hashId) != 3)
	                pressedKeys.altGr = 0;
	            else
	                return;
	        }
	        if (keyCode === 18 || keyCode === 17) {
	            var location = e.location;
	            if (keyCode === 17 && location === 1) {
	                if (pressedKeys[keyCode] == 1)
	                    ts = e.timeStamp;
	            }
	            else if (keyCode === 18 && hashId === 3 && location === 2) {
	                var dt = e.timeStamp - ts;
	                if (dt < 50)
	                    pressedKeys.altGr = true;
	            }
	        }
	    }
	    if (keyCode in keys.MODIFIER_KEYS) {
	        keyCode = -1;
	    }
	    if (!hashId && keyCode === 13) {
	        if (e.location === 3) {
	            callback(e, hashId, -keyCode);
	            if (e.defaultPrevented)
	                return;
	        }
	    }
	    if (useragent.isChromeOS && hashId & 8) {
	        callback(e, hashId, keyCode);
	        if (e.defaultPrevented)
	            return;
	        else
	            hashId &= -9;
	    }
	    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
	        return false;
	    }
	    return callback(e, hashId, keyCode);
	}
	exports.addCommandKeyListener = function (el, callback, destroyer) {
	    var lastDefaultPrevented = null;
	    addListener(el, "keydown", function (e) {
	        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
	        var result = normalizeCommandKeys(callback, e, e.keyCode);
	        lastDefaultPrevented = e.defaultPrevented;
	        return result;
	    }, destroyer);
	    addListener(el, "keypress", function (e) {
	        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
	            exports.stopEvent(e);
	            lastDefaultPrevented = null;
	        }
	    }, destroyer);
	    addListener(el, "keyup", function (e) {
	        pressedKeys[e.keyCode] = null;
	    }, destroyer);
	    if (!pressedKeys) {
	        resetPressedKeys();
	        addListener(window, "focus", resetPressedKeys);
	    }
	};
	function resetPressedKeys() {
	    pressedKeys = Object.create(null);
	}
	if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
	    var postMessageId = 1;
	    exports.nextTick = function (callback, win) {
	        win = win || window;
	        var messageName = "zero-timeout-message-" + (postMessageId++);
	        var listener = function (e) {
	            if (e.data == messageName) {
	                exports.stopPropagation(e);
	                removeListener(win, "message", listener);
	                callback();
	            }
	        };
	        addListener(win, "message", listener);
	        win.postMessage(messageName, "*");
	    };
	}
	exports.$idleBlocked = false;
	exports.onIdle = function (cb, timeout) {
	    return setTimeout(function handler() {
	        if (!exports.$idleBlocked) {
	            cb();
	        }
	        else {
	            setTimeout(handler, 100);
	        }
	    }, timeout);
	};
	exports.$idleBlockId = null;
	exports.blockIdle = function (delay) {
	    if (exports.$idleBlockId)
	        clearTimeout(exports.$idleBlockId);
	    exports.$idleBlocked = true;
	    exports.$idleBlockId = setTimeout(function () {
	        exports.$idleBlocked = false;
	    }, delay || 100);
	};
	exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
	    || window["mozRequestAnimationFrame"]
	    || window["webkitRequestAnimationFrame"]
	    || window["msRequestAnimationFrame"]
	    || window["oRequestAnimationFrame"]);
	if (exports.nextFrame)
	    exports.nextFrame = exports.nextFrame.bind(window);
	else
	    exports.nextFrame = function (callback) {
	        setTimeout(callback, 17);
	    };

	});

	ace.define("ace/clipboard",["require","exports","module"], function(require, exports, module){	var $cancelT;
	module.exports = {
	    lineMode: false,
	    pasteCancelled: function () {
	        if ($cancelT && $cancelT > Date.now() - 50)
	            return true;
	        return $cancelT = false;
	    },
	    cancel: function () {
	        $cancelT = Date.now();
	    }
	};

	});

	ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/config","ace/lib/useragent","ace/lib/dom","ace/lib/lang","ace/clipboard","ace/lib/keys"], function(require, exports, module){	var event = require("../lib/event");
	var nls = require("../config").nls;
	var useragent = require("../lib/useragent");
	var dom = require("../lib/dom");
	var lang = require("../lib/lang");
	var clipboard = require("../clipboard");
	var BROKEN_SETDATA = useragent.isChrome < 18;
	var USE_IE_MIME_TYPE = useragent.isIE;
	var HAS_FOCUS_ARGS = useragent.isChrome > 63;
	var MAX_LINE_LENGTH = 400;
	var KEYS = require("../lib/keys");
	var MODS = KEYS.KEY_MODS;
	var isIOS = useragent.isIOS;
	var valueResetRegex = isIOS ? /\s/ : /\n/;
	var isMobile = useragent.isMobile;
	var TextInput = /** @class */ (function () {
	    function TextInput(parentNode, host) {
	        var _this = this;
	        this.host = host;
	        this.text = dom.createElement("textarea");
	        this.text.className = "ace_text-input";
	        this.text.setAttribute("wrap", "off");
	        this.text.setAttribute("autocomplete", "off");
	        this.text.setAttribute("autocorrect", "off");
	        this.text.setAttribute("autocapitalize", "off");
	        this.text.setAttribute("spellcheck", "false");
	        this.text.style.opacity = "0";
	        parentNode.insertBefore(this.text, parentNode.firstChild); this.copied = false;
	        this.pasted = false;
	        this.inComposition = false;
	        this.sendingText = false;
	        this.tempStyle = '';
	        if (!isMobile)
	            this.text.style.fontSize = "1px";
	        this.commandMode = false;
	        this.ignoreFocusEvents = false;
	        this.lastValue = "";
	        this.lastSelectionStart = 0;
	        this.lastSelectionEnd = 0;
	        this.lastRestoreEnd = 0;
	        this.rowStart = Number.MAX_SAFE_INTEGER;
	        this.rowEnd = Number.MIN_SAFE_INTEGER;
	        this.numberOfExtraLines = 0;
	        try {
	            this.$isFocused = document.activeElement === this.text;
	        }
	        catch (e) {
	        }
	        this.cancelComposition = this.cancelComposition.bind(this);
	        this.setAriaOptions({ role: "textbox" });
	        event.addListener(this.text, "blur", function (e) {
	            if (_this.ignoreFocusEvents)
	                return;
	            host.onBlur(e);
	            _this.$isFocused = false;
	        }, host);
	        event.addListener(this.text, "focus", function (e) {
	            if (_this.ignoreFocusEvents)
	                return;
	            _this.$isFocused = true;
	            if (useragent.isEdge) {
	                try {
	                    if (!document.hasFocus())
	                        return;
	                }
	                catch (e) {
	                }
	            }
	            host.onFocus(e);
	            if (useragent.isEdge)
	                setTimeout(_this.resetSelection.bind(_this));
	            else
	                _this.resetSelection();
	        }, host); this.$focusScroll = false;
	        host.on("beforeEndOperation", function () {
	            var curOp = host.curOp;
	            var commandName = curOp && curOp.command && curOp.command.name;
	            if (commandName == "insertstring")
	                return;
	            var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
	            if (_this.inComposition && isUserAction) {
	                _this.lastValue = _this.text.value = "";
	                _this.onCompositionEnd();
	            }
	            _this.resetSelection();
	        });
	        host.on("changeSelection", this.setAriaLabel.bind(this));
	        this.resetSelection = isIOS ? this.$resetSelectionIOS : this.$resetSelection;
	        if (this.$isFocused)
	            host.onFocus();
	        this.inputHandler = null;
	        this.afterContextMenu = false;
	        event.addCommandKeyListener(this.text, function (e, hashId, keyCode) {
	            if (_this.inComposition)
	                return;
	            return host.onCommandKey(e, hashId, keyCode);
	        }, host);
	        event.addListener(this.text, "select", this.onSelect.bind(this), host);
	        event.addListener(this.text, "input", this.onInput.bind(this), host);
	        event.addListener(this.text, "cut", this.onCut.bind(this), host);
	        event.addListener(this.text, "copy", this.onCopy.bind(this), host);
	        event.addListener(this.text, "paste", this.onPaste.bind(this), host);
	        if (!('oncut' in this.text) || !('oncopy' in this.text) || !('onpaste' in this.text)) {
	            event.addListener(parentNode, "keydown", function (e) {
	                if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
	                    return;
	                switch (e.keyCode) {
	                    case 67:
	                        _this.onCopy(e);
	                        break;
	                    case 86:
	                        _this.onPaste(e);
	                        break;
	                    case 88:
	                        _this.onCut(e);
	                        break;
	                }
	            }, host);
	        }
	        this.syncComposition = lang.delayedCall(this.onCompositionUpdate.bind(this), 50).schedule.bind(null, null); //TODO: check this
	        event.addListener(this.text, "compositionstart", this.onCompositionStart.bind(this), host);
	        event.addListener(this.text, "compositionupdate", this.onCompositionUpdate.bind(this), host);
	        event.addListener(this.text, "keyup", this.onKeyup.bind(this), host);
	        event.addListener(this.text, "keydown", this.syncComposition.bind(this), host);
	        event.addListener(this.text, "compositionend", this.onCompositionEnd.bind(this), host);
	        this.closeTimeout;
	        event.addListener(this.text, "mouseup", this.$onContextMenu.bind(this), host);
	        event.addListener(this.text, "mousedown", function (e) {
	            e.preventDefault();
	            _this.onContextMenuClose();
	        }, host);
	        event.addListener(host.renderer.scroller, "contextmenu", this.$onContextMenu.bind(this), host);
	        event.addListener(this.text, "contextmenu", this.$onContextMenu.bind(this), host);
	        if (isIOS)
	            this.addIosSelectionHandler(parentNode, host, this.text);
	    }
	    TextInput.prototype.addIosSelectionHandler = function (parentNode, host, text) {
	        var _this = this;
	        var typingResetTimeout = null;
	        var typing = false;
	        text.addEventListener("keydown", function (e) {
	            if (typingResetTimeout)
	                clearTimeout(typingResetTimeout);
	            typing = true;
	        }, true);
	        text.addEventListener("keyup", function (e) {
	            typingResetTimeout = setTimeout(function () {
	                typing = false;
	            }, 100);
	        }, true);
	        var detectArrowKeys = function (e) {
	            if (document.activeElement !== text)
	                return;
	            if (typing || _this.inComposition || host.$mouseHandler.isMousePressed)
	                return;
	            if (_this.copied) {
	                return;
	            }
	            var selectionStart = text.selectionStart;
	            var selectionEnd = text.selectionEnd;
	            var key = null;
	            var modifier = 0;
	            if (selectionStart == 0) {
	                key = KEYS.up;
	            }
	            else if (selectionStart == 1) {
	                key = KEYS.home;
	            }
	            else if (selectionEnd > _this.lastSelectionEnd && _this.lastValue[selectionEnd] == "\n") {
	                key = KEYS.end;
	            }
	            else if (selectionStart < _this.lastSelectionStart && _this.lastValue[selectionStart - 1] == " ") {
	                key = KEYS.left;
	                modifier = MODS.option;
	            }
	            else if (selectionStart < _this.lastSelectionStart || (selectionStart == _this.lastSelectionStart
	                && _this.lastSelectionEnd != _this.lastSelectionStart && selectionStart == selectionEnd)) {
	                key = KEYS.left;
	            }
	            else if (selectionEnd > _this.lastSelectionEnd && _this.lastValue.slice(0, selectionEnd).split("\n").length > 2) {
	                key = KEYS.down;
	            }
	            else if (selectionEnd > _this.lastSelectionEnd && _this.lastValue[selectionEnd - 1] == " ") {
	                key = KEYS.right;
	                modifier = MODS.option;
	            }
	            else if (selectionEnd > _this.lastSelectionEnd || (selectionEnd == _this.lastSelectionEnd
	                && _this.lastSelectionEnd != _this.lastSelectionStart && selectionStart == selectionEnd)) {
	                key = KEYS.right;
	            }
	            if (selectionStart !== selectionEnd)
	                modifier |= MODS.shift;
	            if (key) {
	                var result = host.onCommandKey({}, modifier, key);
	                if (!result && host.commands) {
	                    key = KEYS.keyCodeToString(key);
	                    var command = host.commands.findKeyCommand(modifier, key);
	                    if (command)
	                        host.execCommand(command);
	                }
	                _this.lastSelectionStart = selectionStart;
	                _this.lastSelectionEnd = selectionEnd;
	                _this.resetSelection("");
	            }
	        };
	        document.addEventListener("selectionchange", detectArrowKeys);
	        host.on("destroy", function () {
	            document.removeEventListener("selectionchange", detectArrowKeys);
	        });
	    };
	    TextInput.prototype.onContextMenuClose = function () {
	        var _this = this;
	        clearTimeout(this.closeTimeout);
	        this.closeTimeout = setTimeout(function () {
	            if (_this.tempStyle) {
	                _this.text.style.cssText = _this.tempStyle;
	                _this.tempStyle = '';
	            }
	            _this.host.renderer.$isMousePressed = false;
	            if (_this.host.renderer.$keepTextAreaAtCursor)
	                _this.host.renderer.$moveTextAreaToCursor();
	        }, 0);
	    };
	    TextInput.prototype.$onContextMenu = function (e) {
	        this.host.textInput.onContextMenu(e);
	        this.onContextMenuClose();
	    };
	    TextInput.prototype.onKeyup = function (e) {
	        if (e.keyCode == 27 && this.text.value.length < this.text.selectionStart) {
	            if (!this.inComposition)
	                this.lastValue = this.text.value;
	            this.lastSelectionStart = this.lastSelectionEnd = -1;
	            this.resetSelection();
	        }
	        this.syncComposition();
	    };
	    TextInput.prototype.cancelComposition = function () {
	        this.ignoreFocusEvents = true;
	        this.text.blur();
	        this.text.focus();
	        this.ignoreFocusEvents = false;
	    };
	    TextInput.prototype.onCompositionStart = function (e) {
	        if (this.inComposition || !this.host.onCompositionStart || this.host.$readOnly)
	            return;
	        this.inComposition = {};
	        if (this.commandMode)
	            return;
	        if (e.data)
	            this.inComposition.useTextareaForIME = false;
	        setTimeout(this.onCompositionUpdate.bind(this), 0);
	        this.host._signal("compositionStart");
	        this.host.on("mousedown", this.cancelComposition); //TODO:
	        var range = this.host.getSelectionRange();
	        range.end.row = range.start.row;
	        range.end.column = range.start.column;
	        this.inComposition.markerRange = range;
	        this.inComposition.selectionStart = this.lastSelectionStart;
	        this.host.onCompositionStart(this.inComposition);
	        if (this.inComposition.useTextareaForIME) {
	            this.lastValue = this.text.value = "";
	            this.lastSelectionStart = 0;
	            this.lastSelectionEnd = 0;
	        }
	        else {
	            if (this.text.msGetInputContext)
	                this.inComposition.context = this.text.msGetInputContext();
	            if (this.text.getInputContext)
	                this.inComposition.context = this.text.getInputContext();
	        }
	    };
	    TextInput.prototype.onCompositionUpdate = function () {
	        if (!this.inComposition || !this.host.onCompositionUpdate || this.host.$readOnly)
	            return;
	        if (this.commandMode)
	            return this.cancelComposition();
	        if (this.inComposition.useTextareaForIME) {
	            this.host.onCompositionUpdate(this.text.value);
	        }
	        else {
	            var data = this.text.value;
	            this.sendText(data);
	            if (this.inComposition.markerRange) {
	                if (this.inComposition.context) {
	                    this.inComposition.markerRange.start.column = this.inComposition.selectionStart = this.inComposition.context.compositionStartOffset;
	                }
	                this.inComposition.markerRange.end.column = this.inComposition.markerRange.start.column
	                    + this.lastSelectionEnd - this.inComposition.selectionStart + this.lastRestoreEnd;
	            }
	        }
	    };
	    TextInput.prototype.onCompositionEnd = function (e) {
	        if (!this.host.onCompositionEnd || this.host.$readOnly)
	            return;
	        this.inComposition = false;
	        this.host.onCompositionEnd();
	        this.host.off("mousedown", this.cancelComposition);
	        if (e)
	            this.onInput();
	    };
	    TextInput.prototype.onCut = function (e) {
	        this.doCopy(e, true);
	    };
	    TextInput.prototype.onCopy = function (e) {
	        this.doCopy(e, false);
	    };
	    TextInput.prototype.onPaste = function (e) {
	        var data = this.handleClipboardData(e);
	        if (clipboard.pasteCancelled())
	            return;
	        if (typeof data == "string") {
	            if (data)
	                this.host.onPaste(data, e);
	            if (useragent.isIE)
	                setTimeout(this.resetSelection);
	            event.preventDefault(e);
	        }
	        else {
	            this.text.value = "";
	            this.pasted = true;
	        }
	    };
	    TextInput.prototype.doCopy = function (e, isCut) {
	        var _this = this;
	        var data = this.host.getCopyText();
	        if (!data)
	            return event.preventDefault(e);
	        if (this.handleClipboardData(e, data)) {
	            if (isIOS) {
	                this.resetSelection(data);
	                this.copied = data;
	                setTimeout(function () {
	                    _this.copied = false;
	                }, 10);
	            }
	            isCut ? this.host.onCut() : this.host.onCopy();
	            event.preventDefault(e);
	        }
	        else {
	            this.copied = true;
	            this.text.value = data;
	            this.text.select();
	            setTimeout(function () {
	                _this.copied = false;
	                _this.resetSelection();
	                isCut ? _this.host.onCut() : _this.host.onCopy();
	            });
	        }
	    };
	    TextInput.prototype.handleClipboardData = function (e, data, forceIEMime) {
	        var clipboardData = e.clipboardData || window["clipboardData"];
	        if (!clipboardData || BROKEN_SETDATA)
	            return;
	        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
	        try {
	            if (data) {
	                return clipboardData.setData(mime, data) !== false;
	            }
	            else {
	                return clipboardData.getData(mime);
	            }
	        }
	        catch (e) {
	            if (!forceIEMime)
	                return this.handleClipboardData(e, data, true);
	        }
	    };
	    TextInput.prototype.onInput = function (e) {
	        if (this.inComposition)
	            return this.onCompositionUpdate();
	        if (e && e.inputType) {
	            if (e.inputType == "historyUndo")
	                return this.host.execCommand("undo");
	            if (e.inputType == "historyRedo")
	                return this.host.execCommand("redo");
	        }
	        var data = this.text.value;
	        var inserted = this.sendText(data, true);
	        if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && this.lastSelectionStart
	            < 1 && this.lastSelectionStart == this.lastSelectionEnd) {
	            this.resetSelection();
	        }
	    };
	    TextInput.prototype.sendText = function (value, fromInput) {
	        if (this.afterContextMenu)
	            this.afterContextMenu = false;
	        if (this.pasted) {
	            this.resetSelection();
	            if (value)
	                this.host.onPaste(value);
	            this.pasted = false;
	            return "";
	        }
	        else {
	            var selectionStart = this.text.selectionStart;
	            var selectionEnd = this.text.selectionEnd;
	            var extendLeft = this.lastSelectionStart;
	            var extendRight = this.lastValue.length - this.lastSelectionEnd;
	            var inserted = value;
	            var restoreStart = value.length - selectionStart;
	            var restoreEnd = value.length - selectionEnd;
	            var i = 0;
	            while (extendLeft > 0 && this.lastValue[i] == value[i]) {
	                i++;
	                extendLeft--;
	            }
	            inserted = inserted.slice(i);
	            i = 1;
	            while (extendRight > 0 && this.lastValue.length - i > this.lastSelectionStart - 1
	                && this.lastValue[this.lastValue.length - i] == value[value.length - i]) {
	                i++;
	                extendRight--;
	            }
	            restoreStart -= i - 1;
	            restoreEnd -= i - 1;
	            var endIndex = inserted.length - i + 1;
	            if (endIndex < 0) {
	                extendLeft = -endIndex;
	                endIndex = 0;
	            }
	            inserted = inserted.slice(0, endIndex);
	            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
	                return "";
	            this.sendingText = true;
	            var shouldReset = false;
	            if (useragent.isAndroid && inserted == ". ") {
	                inserted = "  ";
	                shouldReset = true;
	            }
	            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || this.commandMode) {
	                this.host.onTextInput(inserted);
	            }
	            else {
	                this.host.onTextInput(inserted, {
	                    extendLeft: extendLeft,
	                    extendRight: extendRight,
	                    restoreStart: restoreStart,
	                    restoreEnd: restoreEnd
	                });
	            }
	            this.sendingText = false;
	            this.lastValue = value;
	            this.lastSelectionStart = selectionStart;
	            this.lastSelectionEnd = selectionEnd;
	            this.lastRestoreEnd = restoreEnd;
	            return shouldReset ? "\n" : inserted;
	        }
	    };
	    TextInput.prototype.onSelect = function (e) {
	        var _this = this;
	        if (this.inComposition)
	            return;
	        var isAllSelected = function (text) {
	            return text.selectionStart === 0 && text.selectionEnd >= _this.lastValue.length && text.value
	                === _this.lastValue && _this.lastValue && text.selectionEnd !== _this.lastSelectionEnd;
	        };
	        if (this.copied) {
	            this.copied = false;
	        }
	        else if (isAllSelected(this.text)) {
	            this.host.selectAll();
	            this.resetSelection();
	        }
	        else if (isMobile && this.text.selectionStart != this.lastSelectionStart) {
	            this.resetSelection();
	        }
	    };
	    TextInput.prototype.$resetSelectionIOS = function (value) {
	        if (!this.$isFocused || (this.copied && !value) || this.sendingText)
	            return;
	        if (!value)
	            value = "";
	        var newValue = "\n ab" + value + "cde fg\n";
	        if (newValue != this.text.value)
	            this.text.value = this.lastValue = newValue;
	        var selectionStart = 4;
	        var selectionEnd = 4 + (value.length || (this.host.selection.isEmpty() ? 0 : 1));
	        if (this.lastSelectionStart != selectionStart || this.lastSelectionEnd != selectionEnd) {
	            this.text.setSelectionRange(selectionStart, selectionEnd);
	        }
	        this.lastSelectionStart = selectionStart;
	        this.lastSelectionEnd = selectionEnd;
	    };
	    TextInput.prototype.$resetSelection = function () {
	        var _this = this;
	        if (this.inComposition || this.sendingText)
	            return;
	        if (!this.$isFocused && !this.afterContextMenu)
	            return;
	        this.inComposition = true;
	        var selectionStart = 0;
	        var selectionEnd = 0;
	        var line = "";
	        var positionToSelection = function (row, column) {
	            var selection = column;
	            for (var i = 1; i <= row - _this.rowStart && i < 2 * _this.numberOfExtraLines + 1; i++) {
	                selection += _this.host.session.getLine(row - i).length + 1;
	            }
	            return selection;
	        };
	        if (this.host.session) {
	            var selection = this.host.selection;
	            var range = selection.getRange();
	            var row = selection.cursor.row;
	            if (row === this.rowEnd + 1) {
	                this.rowStart = this.rowEnd + 1;
	                this.rowEnd = this.rowStart + 2 * this.numberOfExtraLines;
	            }
	            else if (row === this.rowStart - 1) {
	                this.rowEnd = this.rowStart - 1;
	                this.rowStart = this.rowEnd - 2 * this.numberOfExtraLines;
	            }
	            else if (row < this.rowStart - 1 || row > this.rowEnd + 1) {
	                this.rowStart = row > this.numberOfExtraLines ? row - this.numberOfExtraLines : 0;
	                this.rowEnd = row > this.numberOfExtraLines ? row + this.numberOfExtraLines : 2
	                    * this.numberOfExtraLines;
	            }
	            var lines = [];
	            for (var i = this.rowStart; i <= this.rowEnd; i++) {
	                lines.push(this.host.session.getLine(i));
	            }
	            line = lines.join('\n');
	            selectionStart = positionToSelection(range.start.row, range.start.column);
	            selectionEnd = positionToSelection(range.end.row, range.end.column);
	            if (range.start.row < this.rowStart) {
	                var prevLine = this.host.session.getLine(this.rowStart - 1);
	                selectionStart = range.start.row < this.rowStart - 1 ? 0 : selectionStart;
	                selectionEnd += prevLine.length + 1;
	                line = prevLine + "\n" + line;
	            }
	            else if (range.end.row > this.rowEnd) {
	                var nextLine = this.host.session.getLine(this.rowEnd + 1);
	                selectionEnd = range.end.row > this.rowEnd + 1 ? nextLine.length : range.end.column;
	                selectionEnd += line.length + 1;
	                line = line + "\n" + nextLine;
	            }
	            else if (isMobile && row > 0) {
	                line = "\n" + line;
	                selectionEnd += 1;
	                selectionStart += 1;
	            }
	            if (line.length > MAX_LINE_LENGTH) {
	                if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
	                    line = line.slice(0, MAX_LINE_LENGTH);
	                }
	                else {
	                    line = "\n";
	                    if (selectionStart == selectionEnd) {
	                        selectionStart = selectionEnd = 0;
	                    }
	                    else {
	                        selectionStart = 0;
	                        selectionEnd = 1;
	                    }
	                }
	            }
	            var newValue = line + "\n\n";
	            if (newValue != this.lastValue) {
	                this.text.value = this.lastValue = newValue;
	                this.lastSelectionStart = this.lastSelectionEnd = newValue.length;
	            }
	        }
	        if (this.afterContextMenu) {
	            this.lastSelectionStart = this.text.selectionStart;
	            this.lastSelectionEnd = this.text.selectionEnd;
	        }
	        if (this.lastSelectionEnd != selectionEnd || this.lastSelectionStart != selectionStart || this.text.selectionEnd
	            != this.lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
	        ) {
	            try {
	                this.text.setSelectionRange(selectionStart, selectionEnd);
	                this.lastSelectionStart = selectionStart;
	                this.lastSelectionEnd = selectionEnd;
	            }
	            catch (e) {
	            }
	        }
	        this.inComposition = false;
	    };
	    TextInput.prototype.setHost = function (newHost) {
	        this.host = newHost;
	    };
	    TextInput.prototype.setNumberOfExtraLines = function (number) {
	        this.rowStart = Number.MAX_SAFE_INTEGER;
	        this.rowEnd = Number.MIN_SAFE_INTEGER;
	        if (number < 0) {
	            this.numberOfExtraLines = 0;
	            return;
	        }
	        this.numberOfExtraLines = number;
	    };
	    TextInput.prototype.setAriaLabel = function () {
	        var ariaLabel = "";
	        if (this.host.$textInputAriaLabel) {
	            ariaLabel += "".concat(this.host.$textInputAriaLabel, ", ");
	        }
	        if (this.host.session) {
	            var row = this.host.session.selection.cursor.row;
	            ariaLabel += nls("text-input.aria-label", "Cursor at row $0", [row + 1]);
	        }
	        this.text.setAttribute("aria-label", ariaLabel);
	    };
	    TextInput.prototype.setAriaOptions = function (options) {
	        if (options.activeDescendant) {
	            this.text.setAttribute("aria-haspopup", "true");
	            this.text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
	            this.text.setAttribute("aria-activedescendant", options.activeDescendant);
	        }
	        else {
	            this.text.setAttribute("aria-haspopup", "false");
	            this.text.setAttribute("aria-autocomplete", "both");
	            this.text.removeAttribute("aria-activedescendant");
	        }
	        if (options.role) {
	            this.text.setAttribute("role", options.role);
	        }
	        if (options.setLabel) {
	            this.text.setAttribute("aria-roledescription", nls("text-input.aria-roledescription", "editor"));
	            this.setAriaLabel();
	        }
	    };
	    TextInput.prototype.focus = function () {
	        var _this = this;
	        this.setAriaOptions({
	            setLabel: this.host.renderer.enableKeyboardAccessibility
	        });
	        if (this.tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
	            return this.text.focus({ preventScroll: true });
	        var top = this.text.style.top;
	        this.text.style.position = "fixed";
	        this.text.style.top = "0px";
	        try {
	            var isTransformed = this.text.getBoundingClientRect().top != 0;
	        }
	        catch (e) {
	            return;
	        }
	        var ancestors = [];
	        if (isTransformed) {
	            var t = this.text.parentElement;
	            while (t && t.nodeType == 1) {
	                ancestors.push(t);
	                t.setAttribute("ace_nocontext", "true");
	                if (!t.parentElement && t.getRootNode)
	                    t = t.getRootNode()["host"];
	                else
	                    t = t.parentElement;
	            }
	        }
	        this.text.focus({ preventScroll: true });
	        if (isTransformed) {
	            ancestors.forEach(function (p) {
	                p.removeAttribute("ace_nocontext");
	            });
	        }
	        setTimeout(function () {
	            _this.text.style.position = "";
	            if (_this.text.style.top == "0px")
	                _this.text.style.top = top;
	        }, 0);
	    };
	    TextInput.prototype.blur = function () {
	        this.text.blur();
	    };
	    TextInput.prototype.isFocused = function () {
	        return this.$isFocused;
	    };
	    TextInput.prototype.setInputHandler = function (cb) {
	        this.inputHandler = cb;
	    };
	    TextInput.prototype.getInputHandler = function () {
	        return this.inputHandler;
	    };
	    TextInput.prototype.getElement = function () {
	        return this.text;
	    };
	    TextInput.prototype.setCommandMode = function (value) {
	        this.commandMode = value;
	        this.text.readOnly = false;
	    };
	    TextInput.prototype.setReadOnly = function (readOnly) {
	        if (!this.commandMode)
	            this.text.readOnly = readOnly;
	    };
	    TextInput.prototype.setCopyWithEmptySelection = function (value) {
	    };
	    TextInput.prototype.onContextMenu = function (e) {
	        this.afterContextMenu = true;
	        this.resetSelection();
	        this.host._emit("nativecontextmenu", {
	            target: this.host,
	            domEvent: e
	        });
	        this.moveToMouse(e, true);
	    };
	    TextInput.prototype.moveToMouse = function (e, bringToFront) {
	        var _this = this;
	        if (!this.tempStyle)
	            this.tempStyle = this.text.style.cssText;
	        this.text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "")
	            + "text-indent: -" + (this.lastSelectionStart + this.lastSelectionEnd) * this.host.renderer.characterWidth
	            * 0.5 + "px;";
	        var rect = this.host.container.getBoundingClientRect();
	        var style = dom.computedStyle(this.host.container);
	        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
	        var left = rect.left + (parseInt(style.borderLeftWidth) || 0);
	        var maxTop = rect.bottom - top - this.text.clientHeight - 2;
	        var move = function (e) {
	            dom.translate(_this.text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
	        };
	        move(e);
	        if (e.type != "mousedown")
	            return;
	        this.host.renderer.$isMousePressed = true;
	        clearTimeout(this.closeTimeout);
	        if (useragent.isWin)
	            event.capture(this.host.container, move, this.onContextMenuClose.bind(this));
	    };
	    TextInput.prototype.destroy = function () {
	        if (this.text.parentElement)
	            this.text.parentElement.removeChild(this.text);
	    };
	    return TextInput;
	}());
	exports.TextInput = TextInput;
	exports.$setUserAgentForTests = function (_isMobile, _isIOS) {
	    isMobile = _isMobile;
	    isIOS = _isIOS;
	};

	});

	ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/useragent"], function(require, exports, module){	var useragent = require("../lib/useragent");
	var DRAG_OFFSET = 0; // pixels
	var SCROLL_COOLDOWN_T = 550; // milliseconds
	var DefaultHandlers = /** @class */ (function () {
	    function DefaultHandlers(mouseHandler) {
	        mouseHandler.$clickSelection = null;
	        var editor = mouseHandler.editor;
	        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
	        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
	        editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
	        editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
	        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
	        var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
	            "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];
	        exports.forEach(function (x) {
	            mouseHandler[x] = this[x];
	        }, this);
	        mouseHandler["selectByLines"] = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
	        mouseHandler["selectByWords"] = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
	    }
	    DefaultHandlers.prototype.onMouseDown = function (ev) {
	        var inSelection = ev.inSelection();
	        var pos = ev.getDocumentPosition();
	        this.mousedownEvent = ev;
	        var editor = this.editor;
	        var button = ev.getButton();
	        if (button !== 0) {
	            var selectionRange = editor.getSelectionRange();
	            var selectionEmpty = selectionRange.isEmpty();
	            if (selectionEmpty || button == 1)
	                editor.selection.moveToPosition(pos);
	            if (button == 2) {
	                editor.textInput.onContextMenu(ev.domEvent);
	                if (!useragent.isMozilla)
	                    ev.preventDefault();
	            }
	            return;
	        }
	        this.mousedownEvent.time = Date.now();
	        if (inSelection && !editor.isFocused()) {
	            editor.focus();
	            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
	                this.setState("focusWait");
	                this.captureMouse(ev);
	                return;
	            }
	        }
	        this.captureMouse(ev);
	        this.startSelect(pos, ev.domEvent._clicks > 1);
	        return ev.preventDefault();
	    };
	    DefaultHandlers.prototype.startSelect = function (pos, waitForClickSelection) {
	        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
	        var editor = this.editor;
	        if (!this.mousedownEvent)
	            return;
	        if (this.mousedownEvent.getShiftKey())
	            editor.selection.selectToPosition(pos);
	        else if (!waitForClickSelection)
	            editor.selection.moveToPosition(pos);
	        if (!waitForClickSelection)
	            this.select();
	        editor.setStyle("ace_selecting");
	        this.setState("select");
	    };
	    DefaultHandlers.prototype.select = function () {
	        var anchor, editor = this.editor;
	        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
	        if (this.$clickSelection) {
	            var cmp = this.$clickSelection.comparePoint(cursor);
	            if (cmp == -1) {
	                anchor = this.$clickSelection.end;
	            }
	            else if (cmp == 1) {
	                anchor = this.$clickSelection.start;
	            }
	            else {
	                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
	                cursor = orientedRange.cursor;
	                anchor = orientedRange.anchor;
	            }
	            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
	        }
	        editor.selection.selectToPosition(cursor);
	        editor.renderer.scrollCursorIntoView();
	    };
	    DefaultHandlers.prototype.extendSelectionBy = function (unitName) {
	        var anchor, editor = this.editor;
	        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
	        var range = editor.selection[unitName](cursor.row, cursor.column);
	        if (this.$clickSelection) {
	            var cmpStart = this.$clickSelection.comparePoint(range.start);
	            var cmpEnd = this.$clickSelection.comparePoint(range.end);
	            if (cmpStart == -1 && cmpEnd <= 0) {
	                anchor = this.$clickSelection.end;
	                if (range.end.row != cursor.row || range.end.column != cursor.column)
	                    cursor = range.start;
	            }
	            else if (cmpEnd == 1 && cmpStart >= 0) {
	                anchor = this.$clickSelection.start;
	                if (range.start.row != cursor.row || range.start.column != cursor.column)
	                    cursor = range.end;
	            }
	            else if (cmpStart == -1 && cmpEnd == 1) {
	                cursor = range.end;
	                anchor = range.start;
	            }
	            else {
	                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
	                cursor = orientedRange.cursor;
	                anchor = orientedRange.anchor;
	            }
	            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
	        }
	        editor.selection.selectToPosition(cursor);
	        editor.renderer.scrollCursorIntoView();
	    };
	    DefaultHandlers.prototype.selectByLinesEnd = function () {
	        this.$clickSelection = null;
	        this.editor.unsetStyle("ace_selecting");
	    };
	    DefaultHandlers.prototype.focusWait = function () {
	        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	        var time = Date.now();
	        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
	            this.startSelect(this.mousedownEvent.getDocumentPosition());
	    };
	    DefaultHandlers.prototype.onDoubleClick = function (ev) {
	        var pos = ev.getDocumentPosition();
	        var editor = this.editor;
	        var session = editor.session;
	        var range = session.getBracketRange(pos);
	        if (range) {
	            if (range.isEmpty()) {
	                range.start.column--;
	                range.end.column++;
	            }
	            this.setState("select");
	        }
	        else {
	            range = editor.selection.getWordRange(pos.row, pos.column);
	            this.setState("selectByWords");
	        }
	        this.$clickSelection = range;
	        this.select();
	    };
	    DefaultHandlers.prototype.onTripleClick = function (ev) {
	        var pos = ev.getDocumentPosition();
	        var editor = this.editor;
	        this.setState("selectByLines");
	        var range = editor.getSelectionRange();
	        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
	            this.$clickSelection = editor.selection.getLineRange(range.start.row);
	            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
	        }
	        else {
	            this.$clickSelection = editor.selection.getLineRange(pos.row);
	        }
	        this.select();
	    };
	    DefaultHandlers.prototype.onQuadClick = function (ev) {
	        var editor = this.editor;
	        editor.selectAll();
	        this.$clickSelection = editor.getSelectionRange();
	        this.setState("selectAll");
	    };
	    DefaultHandlers.prototype.onMouseWheel = function (ev) {
	        if (ev.getAccelKey())
	            return;
	        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
	            ev.wheelX = ev.wheelY;
	            ev.wheelY = 0;
	        }
	        var editor = this.editor;
	        if (!this.$lastScroll)
	            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
	        var prevScroll = this.$lastScroll;
	        var t = ev.domEvent.timeStamp;
	        var dt = t - prevScroll.t;
	        var vx = dt ? ev.wheelX / dt : prevScroll.vx;
	        var vy = dt ? ev.wheelY / dt : prevScroll.vy;
	        if (dt < SCROLL_COOLDOWN_T) {
	            vx = (vx + prevScroll.vx) / 2;
	            vy = (vy + prevScroll.vy) / 2;
	        }
	        var direction = Math.abs(vx / vy);
	        var canScroll = false;
	        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
	            canScroll = true;
	        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
	            canScroll = true;
	        if (canScroll) {
	            prevScroll.allowed = t;
	        }
	        else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
	            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)
	                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
	            if (isSlower) {
	                canScroll = true;
	                prevScroll.allowed = t;
	            }
	            else {
	                prevScroll.allowed = 0;
	            }
	        }
	        prevScroll.t = t;
	        prevScroll.vx = vx;
	        prevScroll.vy = vy;
	        if (canScroll) {
	            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	            return ev.stop();
	        }
	    };
	    return DefaultHandlers;
	}());
	DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
	DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
	DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;
	exports.DefaultHandlers = DefaultHandlers;
	function calcDistance(ax, ay, bx, by) {
	    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
	}
	function calcRangeOrientation(range, cursor) {
	    if (range.start.row == range.end.row)
	        var cmp = 2 * cursor.column - range.start.column - range.end.column;
	    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
	        var cmp = cursor.column - 4;
	    else
	        var cmp = 2 * cursor.row - range.start.row - range.end.row;
	    if (cmp < 0)
	        return { cursor: range.start, anchor: range.end };
	    else
	        return { cursor: range.end, anchor: range.start };
	}

	});

	ace.define("ace/lib/scroll",["require","exports","module"], function(require, exports, module){exports.preventParentScroll = function preventParentScroll(event) {
	    event.stopPropagation();
	    var target = event.currentTarget;
	    var contentOverflows = target.scrollHeight > target.clientHeight;
	    if (!contentOverflows) {
	        event.preventDefault();
	    }
	};

	});

	ace.define("ace/tooltip",["require","exports","module","ace/lib/dom","ace/lib/event","ace/range","ace/lib/scroll"], function(require, exports, module){	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values = (this && this.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var dom = require("./lib/dom");
	require("./lib/event");
	var Range = require("./range").Range;
	var preventParentScroll = require("./lib/scroll").preventParentScroll;
	var CLASSNAME = "ace_tooltip";
	var Tooltip = /** @class */ (function () {
	    function Tooltip(parentNode) {
	        this.isOpen = false;
	        this.$element = null;
	        this.$parentNode = parentNode;
	    }
	    Tooltip.prototype.$init = function () {
	        this.$element = dom.createElement("div");
	        this.$element.className = CLASSNAME;
	        this.$element.style.display = "none";
	        this.$parentNode.appendChild(this.$element);
	        return this.$element;
	    };
	    Tooltip.prototype.getElement = function () {
	        return this.$element || this.$init();
	    };
	    Tooltip.prototype.setText = function (text) {
	        this.getElement().textContent = text;
	    };
	    Tooltip.prototype.setHtml = function (html) {
	        this.getElement().innerHTML = html;
	    };
	    Tooltip.prototype.setPosition = function (x, y) {
	        var el = this.getElement();
	        var rootRect = el.offsetParent && el.offsetParent.getBoundingClientRect();
	        el.style.left = x - (rootRect ? rootRect.left : 0) + "px";
	        el.style.top = y - (rootRect ? rootRect.top : 0) + "px";
	    };
	    Tooltip.prototype.setClassName = function (className) {
	        dom.addCssClass(this.getElement(), className);
	    };
	    Tooltip.prototype.setTheme = function (theme) {
	        this.$element.className = CLASSNAME + " " +
	            (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
	    };
	    Tooltip.prototype.show = function (text, x, y) {
	        if (text != null)
	            this.setText(text);
	        if (x != null && y != null)
	            this.setPosition(x, y);
	        if (!this.isOpen) {
	            this.getElement().style.display = "block";
	            this.isOpen = true;
	        }
	    };
	    Tooltip.prototype.hide = function (e) {
	        if (this.isOpen) {
	            this.getElement().style.display = "none";
	            this.getElement().className = CLASSNAME;
	            this.isOpen = false;
	        }
	    };
	    Tooltip.prototype.getHeight = function () {
	        return this.getElement().offsetHeight;
	    };
	    Tooltip.prototype.getWidth = function () {
	        return this.getElement().offsetWidth;
	    };
	    Tooltip.prototype.destroy = function () {
	        this.isOpen = false;
	        if (this.$element && this.$element.parentNode) {
	            this.$element.parentNode.removeChild(this.$element);
	        }
	    };
	    return Tooltip;
	}());
	var PopupManager = /** @class */ (function () {
	    function PopupManager() {
	        this.popups = [];
	    }
	    PopupManager.prototype.addPopup = function (popup) {
	        this.popups.push(popup);
	        this.updatePopups();
	    };
	    PopupManager.prototype.removePopup = function (popup) {
	        var index = this.popups.indexOf(popup);
	        if (index !== -1) {
	            this.popups.splice(index, 1);
	            this.updatePopups();
	        }
	    };
	    PopupManager.prototype.updatePopups = function () {
	        var e_1, _a, e_2, _b;
	        this.popups.sort(function (a, b) { return b.priority - a.priority; });
	        var visiblepopups = [];
	        try {
	            for (var _c = __values(this.popups), _d = _c.next(); !_d.done; _d = _c.next()) {
	                var popup = _d.value;
	                var shouldDisplay = true;
	                try {
	                    for (var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()) {
	                        var visiblePopup = visiblepopups_1_1.value;
	                        if (this.doPopupsOverlap(visiblePopup, popup)) {
	                            shouldDisplay = false;
	                            break;
	                        }
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b = visiblepopups_1.return)) _b.call(visiblepopups_1);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	                if (shouldDisplay) {
	                    visiblepopups.push(popup);
	                }
	                else {
	                    popup.hide();
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    PopupManager.prototype.doPopupsOverlap = function (popupA, popupB) {
	        var rectA = popupA.getElement().getBoundingClientRect();
	        var rectB = popupB.getElement().getBoundingClientRect();
	        return (rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom
	            > rectB.top);
	    };
	    return PopupManager;
	}());
	var popupManager = new PopupManager();
	exports.popupManager = popupManager;
	exports.Tooltip = Tooltip;
	var HoverTooltip = /** @class */ (function (_super) {
	    __extends(HoverTooltip, _super);
	    function HoverTooltip(parentNode) {
	        if (parentNode === void 0) { parentNode = document.body; }
	        var _this = _super.call(this, parentNode) || this;
	        _this.timeout = undefined;
	        _this.lastT = 0;
	        _this.idleTime = 350;
	        _this.lastEvent = undefined;
	        _this.onMouseOut = _this.onMouseOut.bind(_this);
	        _this.onMouseMove = _this.onMouseMove.bind(_this);
	        _this.waitForHover = _this.waitForHover.bind(_this);
	        _this.hide = _this.hide.bind(_this);
	        var el = _this.getElement();
	        el.style.whiteSpace = "pre-wrap";
	        el.style.pointerEvents = "auto";
	        el.addEventListener("mouseout", _this.onMouseOut);
	        el.tabIndex = -1;
	        el.addEventListener("blur", function () {
	            if (!el.contains(document.activeElement))
	                this.hide();
	        }.bind(_this));
	        el.addEventListener("wheel", preventParentScroll);
	        return _this;
	    }
	    HoverTooltip.prototype.addToEditor = function (editor) {
	        editor.on("mousemove", this.onMouseMove);
	        editor.on("mousedown", this.hide);
	        editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
	    };
	    HoverTooltip.prototype.removeFromEditor = function (editor) {
	        editor.off("mousemove", this.onMouseMove);
	        editor.off("mousedown", this.hide);
	        editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
	        if (this.timeout) {
	            clearTimeout(this.timeout);
	            this.timeout = null;
	        }
	    };
	    HoverTooltip.prototype.onMouseMove = function (e, editor) {
	        this.lastEvent = e;
	        this.lastT = Date.now();
	        var isMousePressed = editor.$mouseHandler.isMousePressed;
	        if (this.isOpen) {
	            var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
	            if (!this.range
	                || !this.range.contains(pos.row, pos.column)
	                || isMousePressed
	                || this.isOutsideOfText(this.lastEvent)) {
	                this.hide();
	            }
	        }
	        if (this.timeout || isMousePressed)
	            return;
	        this.lastEvent = e;
	        this.timeout = setTimeout(this.waitForHover, this.idleTime);
	    };
	    HoverTooltip.prototype.waitForHover = function () {
	        if (this.timeout)
	            clearTimeout(this.timeout);
	        var dt = Date.now() - this.lastT;
	        if (this.idleTime - dt > 10) {
	            this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
	            return;
	        }
	        this.timeout = null;
	        if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
	            this.$gatherData(this.lastEvent, this.lastEvent.editor);
	        }
	    };
	    HoverTooltip.prototype.isOutsideOfText = function (e) {
	        var editor = e.editor;
	        var docPos = e.getDocumentPosition();
	        var line = editor.session.getLine(docPos.row);
	        if (docPos.column == line.length) {
	            var screenPos = editor.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);
	            var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);
	            if (clippedPos.column != screenPos.column
	                || clippedPos.row != screenPos.row) {
	                return true;
	            }
	        }
	        return false;
	    };
	    HoverTooltip.prototype.setDataProvider = function (value) {
	        this.$gatherData = value;
	    };
	    HoverTooltip.prototype.showForRange = function (editor, range, domNode, startingEvent) {
	        var MARGIN = 10;
	        if (startingEvent && startingEvent != this.lastEvent)
	            return;
	        if (this.isOpen && document.activeElement == this.getElement())
	            return;
	        var renderer = editor.renderer;
	        if (!this.isOpen) {
	            popupManager.addPopup(this);
	            this.$registerCloseEvents();
	            this.setTheme(renderer.theme);
	        }
	        this.isOpen = true;
	        this.addMarker(range, editor.session);
	        this.range = Range.fromPoints(range.start, range.end);
	        var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);
	        var rect = renderer.scroller.getBoundingClientRect();
	        if (position.pageX < rect.left)
	            position.pageX = rect.left;
	        var element = this.getElement();
	        element.innerHTML = "";
	        element.appendChild(domNode);
	        element.style.maxHeight = "";
	        element.style.display = "block";
	        var labelHeight = element.clientHeight;
	        var labelWidth = element.clientWidth;
	        var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;
	        var isAbove = true;
	        if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {
	            isAbove = false;
	        }
	        element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + "px";
	        element.style.top = isAbove ? "" : position.pageY + renderer.lineHeight + "px";
	        element.style.bottom = isAbove ? window.innerHeight - position.pageY + "px" : "";
	        element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
	    };
	    HoverTooltip.prototype.addMarker = function (range, session) {
	        if (this.marker) {
	            this.$markerSession.removeMarker(this.marker);
	        }
	        this.$markerSession = session;
	        this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
	    };
	    HoverTooltip.prototype.hide = function (e) {
	        if (!e && document.activeElement == this.getElement())
	            return;
	        if (e && e.target && (e.type != "keydown" || e.ctrlKey || e.metaKey) && this.$element.contains(e.target))
	            return;
	        this.lastEvent = null;
	        if (this.timeout)
	            clearTimeout(this.timeout);
	        this.timeout = null;
	        this.addMarker(null);
	        if (this.isOpen) {
	            this.$removeCloseEvents();
	            this.getElement().style.display = "none";
	            this.isOpen = false;
	            popupManager.removePopup(this);
	        }
	    };
	    HoverTooltip.prototype.$registerCloseEvents = function () {
	        window.addEventListener("keydown", this.hide, true);
	        window.addEventListener("wheel", this.hide, true);
	        window.addEventListener("mousedown", this.hide, true);
	    };
	    HoverTooltip.prototype.$removeCloseEvents = function () {
	        window.removeEventListener("keydown", this.hide, true);
	        window.removeEventListener("wheel", this.hide, true);
	        window.removeEventListener("mousedown", this.hide, true);
	    };
	    HoverTooltip.prototype.onMouseOut = function (e) {
	        if (this.timeout) {
	            clearTimeout(this.timeout);
	            this.timeout = null;
	        }
	        this.lastEvent = null;
	        if (!this.isOpen)
	            return;
	        if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))
	            return;
	        if (e && e.currentTarget.contains(e.relatedTarget))
	            return;
	        if (!e.relatedTarget.classList.contains("ace_content"))
	            this.hide();
	    };
	    return HoverTooltip;
	}(Tooltip));
	exports.HoverTooltip = HoverTooltip;

	});

	ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/tooltip","ace/config"], function(require, exports, module){	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values = (this && this.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var dom = require("../lib/dom");
	var event = require("../lib/event");
	var Tooltip = require("../tooltip").Tooltip;
	var nls = require("../config").nls;
	var GUTTER_TOOLTIP_LEFT_OFFSET = 5;
	var GUTTER_TOOLTIP_TOP_OFFSET = 3;
	exports.GUTTER_TOOLTIP_LEFT_OFFSET = GUTTER_TOOLTIP_LEFT_OFFSET;
	exports.GUTTER_TOOLTIP_TOP_OFFSET = GUTTER_TOOLTIP_TOP_OFFSET;
	function GutterHandler(mouseHandler) {
	    var editor = mouseHandler.editor;
	    var gutter = editor.renderer.$gutterLayer;
	    var tooltip = new GutterTooltip(editor, true);
	    mouseHandler.editor.setDefaultHandler("guttermousedown", function (e) {
	        if (!editor.isFocused() || e.getButton() != 0)
	            return;
	        var gutterRegion = gutter.getRegion(e);
	        if (gutterRegion == "foldWidgets")
	            return;
	        var row = e.getDocumentPosition().row;
	        var selection = editor.session.selection;
	        if (e.getShiftKey())
	            selection.selectTo(row, 0);
	        else {
	            if (e.domEvent.detail == 2) {
	                editor.selectAll();
	                return e.preventDefault();
	            }
	            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
	        }
	        mouseHandler.setState("selectByLines");
	        mouseHandler.captureMouse(e);
	        return e.preventDefault();
	    });
	    var tooltipTimeout, mouseEvent;
	    function showTooltip() {
	        var row = mouseEvent.getDocumentPosition().row;
	        var maxRow = editor.session.getLength();
	        if (row == maxRow) {
	            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
	            var pos = mouseEvent.$pos;
	            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
	                return hideTooltip();
	        }
	        tooltip.showTooltip(row);
	        if (!tooltip.isOpen)
	            return;
	        editor.on("mousewheel", hideTooltip);
	        editor.on("changeSession", hideTooltip);
	        window.addEventListener("keydown", hideTooltip, true);
	        if (mouseHandler.$tooltipFollowsMouse) {
	            moveTooltip(mouseEvent);
	        }
	        else {
	            var gutterRow = mouseEvent.getGutterRow();
	            var gutterCell = gutter.$lines.get(gutterRow);
	            if (gutterCell) {
	                var gutterElement = gutterCell.element.querySelector(".ace_gutter_annotation");
	                var rect = gutterElement.getBoundingClientRect();
	                var style = tooltip.getElement().style;
	                style.left = (rect.right - GUTTER_TOOLTIP_LEFT_OFFSET) + "px";
	                style.top = (rect.bottom - GUTTER_TOOLTIP_TOP_OFFSET) + "px";
	            }
	            else {
	                moveTooltip(mouseEvent);
	            }
	        }
	    }
	    function hideTooltip(e) {
	        if (e && e.type === "keydown" && (e.ctrlKey || e.metaKey))
	            return;
	        if (e && e.type === "mouseout" && (!e.relatedTarget || tooltip.getElement().contains(e.relatedTarget)))
	            return;
	        if (tooltipTimeout)
	            tooltipTimeout = clearTimeout(tooltipTimeout);
	        if (tooltip.isOpen) {
	            tooltip.hideTooltip();
	            editor.off("mousewheel", hideTooltip);
	            editor.off("changeSession", hideTooltip);
	            window.removeEventListener("keydown", hideTooltip, true);
	        }
	    }
	    function moveTooltip(e) {
	        tooltip.setPosition(e.x, e.y);
	    }
	    mouseHandler.editor.setDefaultHandler("guttermousemove", function (e) {
	        var target = e.domEvent.target || e.domEvent.srcElement;
	        if (dom.hasCssClass(target, "ace_fold-widget") || dom.hasCssClass(target, "ace_custom-widget"))
	            return hideTooltip();
	        if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse)
	            moveTooltip(e);
	        mouseEvent = e;
	        if (tooltipTimeout)
	            return;
	        tooltipTimeout = setTimeout(function () {
	            tooltipTimeout = null;
	            if (mouseEvent && !mouseHandler.isMousePressed)
	                showTooltip();
	        }, 50);
	    });
	    event.addListener(editor.renderer.$gutter, "mouseout", function (e) {
	        mouseEvent = null;
	        if (!tooltip.isOpen)
	            return;
	        tooltipTimeout = setTimeout(function () {
	            tooltipTimeout = null;
	            hideTooltip(e);
	        }, 50);
	    }, editor);
	}
	exports.GutterHandler = GutterHandler;
	var GutterTooltip = /** @class */ (function (_super) {
	    __extends(GutterTooltip, _super);
	    function GutterTooltip(editor, isHover) {
	        if (isHover === void 0) { isHover = false; }
	        var _this = _super.call(this, editor.container) || this;
	        _this.id = "gt" + (++GutterTooltip.$uid);
	        _this.editor = editor;
	        _this.visibleTooltipRow;
	        var el = _this.getElement();
	        el.setAttribute("role", "tooltip");
	        el.setAttribute("id", _this.id);
	        el.style.pointerEvents = "auto";
	        if (isHover) {
	            _this.onMouseOut = _this.onMouseOut.bind(_this);
	            el.addEventListener("mouseout", _this.onMouseOut);
	        }
	        return _this;
	    }
	    GutterTooltip.prototype.onMouseOut = function (e) {
	        if (!this.isOpen)
	            return;
	        if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))
	            return;
	        if (e && e.currentTarget.contains(e.relatedTarget))
	            return;
	        this.hideTooltip();
	    };
	    GutterTooltip.prototype.setPosition = function (x, y) {
	        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
	        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
	        var width = this.getWidth();
	        var height = this.getHeight();
	        x += 15;
	        y += 15;
	        if (x + width > windowWidth) {
	            x -= (x + width) - windowWidth;
	        }
	        if (y + height > windowHeight) {
	            y -= 20 + height;
	        }
	        Tooltip.prototype.setPosition.call(this, x, y);
	    };
	    Object.defineProperty(GutterTooltip, "annotationLabels", {
	        get: function () {
	            return {
	                error: {
	                    singular: nls("gutter-tooltip.aria-label.error.singular", "error"),
	                    plural: nls("gutter-tooltip.aria-label.error.plural", "errors")
	                },
	                security: {
	                    singular: nls("gutter-tooltip.aria-label.security.singular", "security finding"),
	                    plural: nls("gutter-tooltip.aria-label.security.plural", "security findings")
	                },
	                warning: {
	                    singular: nls("gutter-tooltip.aria-label.warning.singular", "warning"),
	                    plural: nls("gutter-tooltip.aria-label.warning.plural", "warnings")
	                },
	                info: {
	                    singular: nls("gutter-tooltip.aria-label.info.singular", "information message"),
	                    plural: nls("gutter-tooltip.aria-label.info.plural", "information messages")
	                },
	                hint: {
	                    singular: nls("gutter-tooltip.aria-label.hint.singular", "suggestion"),
	                    plural: nls("gutter-tooltip.aria-label.hint.plural", "suggestions")
	                }
	            };
	        },
	        enumerable: false,
	        configurable: true
	    });
	    GutterTooltip.prototype.showTooltip = function (row) {
	        var _a;
	        var gutter = this.editor.renderer.$gutterLayer;
	        var annotationsInRow = gutter.$annotations[row];
	        var annotation;
	        if (annotationsInRow)
	            annotation = {
	                displayText: Array.from(annotationsInRow.displayText),
	                type: Array.from(annotationsInRow.type)
	            };
	        else
	            annotation = { displayText: [], type: [] };
	        var fold = gutter.session.getFoldLine(row);
	        if (fold && gutter.$showFoldedAnnotations) {
	            var annotationsInFold = { error: [], security: [], warning: [], info: [], hint: [] };
	            var severityRank = { error: 1, security: 2, warning: 3, info: 4, hint: 5 };
	            var mostSevereAnnotationTypeInFold;
	            for (var i = row + 1; i <= fold.end.row; i++) {
	                if (!gutter.$annotations[i])
	                    continue;
	                for (var j = 0; j < gutter.$annotations[i].text.length; j++) {
	                    var annotationType = gutter.$annotations[i].type[j];
	                    annotationsInFold[annotationType].push(gutter.$annotations[i].text[j]);
	                    if (!mostSevereAnnotationTypeInFold ||
	                        severityRank[annotationType] < severityRank[mostSevereAnnotationTypeInFold]) {
	                        mostSevereAnnotationTypeInFold = annotationType;
	                    }
	                }
	            }
	            if (["error", "security", "warning"].includes(mostSevereAnnotationTypeInFold)) {
	                var summaryFoldedAnnotations = "".concat(GutterTooltip.annotationsToSummaryString(annotationsInFold), " in folded code.");
	                annotation.displayText.push(summaryFoldedAnnotations);
	                annotation.type.push(mostSevereAnnotationTypeInFold + "_fold");
	            }
	        }
	        if (annotation.displayText.length === 0)
	            return this.hideTooltip();
	        var annotationMessages = { error: [], security: [], warning: [], info: [], hint: [] };
	        var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
	        for (var i = 0; i < annotation.displayText.length; i++) {
	            var lineElement = dom.createElement("span");
	            var iconElement = dom.createElement("span");
	            (_a = iconElement.classList).add.apply(_a, ["ace_".concat(annotation.type[i]), iconClassName]);
	            iconElement.setAttribute("aria-label", "".concat(GutterTooltip.annotationLabels[annotation.type[i].replace("_fold", "")].singular));
	            iconElement.setAttribute("role", "img");
	            iconElement.appendChild(dom.createTextNode(" "));
	            lineElement.appendChild(iconElement);
	            lineElement.appendChild(dom.createTextNode(annotation.displayText[i]));
	            lineElement.appendChild(dom.createElement("br"));
	            annotationMessages[annotation.type[i].replace("_fold", "")].push(lineElement);
	        }
	        var tooltipElement = this.getElement();
	        dom.removeChildren(tooltipElement);
	        annotationMessages.error.forEach(function (el) { return tooltipElement.appendChild(el); });
	        annotationMessages.security.forEach(function (el) { return tooltipElement.appendChild(el); });
	        annotationMessages.warning.forEach(function (el) { return tooltipElement.appendChild(el); });
	        annotationMessages.info.forEach(function (el) { return tooltipElement.appendChild(el); });
	        annotationMessages.hint.forEach(function (el) { return tooltipElement.appendChild(el); });
	        tooltipElement.setAttribute("aria-live", "polite");
	        if (!this.isOpen) {
	            this.setTheme(this.editor.renderer.theme);
	            this.setClassName("ace_gutter-tooltip");
	        }
	        var annotationNode = this.$findLinkedAnnotationNode(row);
	        if (annotationNode) {
	            annotationNode.setAttribute("aria-describedby", this.id);
	        }
	        this.show();
	        this.visibleTooltipRow = row;
	        this.editor._signal("showGutterTooltip", this);
	    };
	    GutterTooltip.prototype.$findLinkedAnnotationNode = function (row) {
	        var cell = this.$findCellByRow(row);
	        if (cell) {
	            var element = cell.element;
	            if (element.childNodes.length > 2) {
	                return element.childNodes[2];
	            }
	        }
	    };
	    GutterTooltip.prototype.$findCellByRow = function (row) {
	        return this.editor.renderer.$gutterLayer.$lines.cells.find(function (el) { return el.row === row; });
	    };
	    GutterTooltip.prototype.hideTooltip = function () {
	        if (!this.isOpen) {
	            return;
	        }
	        this.$element.removeAttribute("aria-live");
	        this.hide();
	        if (this.visibleTooltipRow != undefined) {
	            var annotationNode = this.$findLinkedAnnotationNode(this.visibleTooltipRow);
	            if (annotationNode) {
	                annotationNode.removeAttribute("aria-describedby");
	            }
	        }
	        this.visibleTooltipRow = undefined;
	        this.editor._signal("hideGutterTooltip", this);
	    };
	    GutterTooltip.annotationsToSummaryString = function (annotations) {
	        var e_1, _a;
	        var summary = [];
	        var annotationTypes = ["error", "security", "warning", "info", "hint"];
	        try {
	            for (var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()) {
	                var annotationType = annotationTypes_1_1.value;
	                if (!annotations[annotationType].length)
	                    continue;
	                var label = annotations[annotationType].length === 1 ? GutterTooltip.annotationLabels[annotationType].singular : GutterTooltip.annotationLabels[annotationType].plural;
	                summary.push("".concat(annotations[annotationType].length, " ").concat(label));
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a = annotationTypes_1.return)) _a.call(annotationTypes_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return summary.join(", ");
	    };
	    return GutterTooltip;
	}(Tooltip));
	GutterTooltip.$uid = 0;
	exports.GutterTooltip = GutterTooltip;

	});

	ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module){	var event = require("../lib/event");
	var useragent = require("../lib/useragent");
	var MouseEvent = /** @class */ (function () {
	    function MouseEvent(domEvent, editor) { this.speed; this.wheelX; this.wheelY;
	        this.domEvent = domEvent;
	        this.editor = editor;
	        this.x = this.clientX = domEvent.clientX;
	        this.y = this.clientY = domEvent.clientY;
	        this.$pos = null;
	        this.$inSelection = null;
	        this.propagationStopped = false;
	        this.defaultPrevented = false;
	    }
	    MouseEvent.prototype.stopPropagation = function () {
	        event.stopPropagation(this.domEvent);
	        this.propagationStopped = true;
	    };
	    MouseEvent.prototype.preventDefault = function () {
	        event.preventDefault(this.domEvent);
	        this.defaultPrevented = true;
	    };
	    MouseEvent.prototype.stop = function () {
	        this.stopPropagation();
	        this.preventDefault();
	    };
	    MouseEvent.prototype.getDocumentPosition = function () {
	        if (this.$pos)
	            return this.$pos;
	        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
	        return this.$pos;
	    };
	    MouseEvent.prototype.getGutterRow = function () {
	        var documentRow = this.getDocumentPosition().row;
	        var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);
	        var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
	        return screenRow - screenTopRow;
	    };
	    MouseEvent.prototype.inSelection = function () {
	        if (this.$inSelection !== null)
	            return this.$inSelection;
	        var editor = this.editor;
	        var selectionRange = editor.getSelectionRange();
	        if (selectionRange.isEmpty())
	            this.$inSelection = false;
	        else {
	            var pos = this.getDocumentPosition();
	            this.$inSelection = selectionRange.contains(pos.row, pos.column);
	        }
	        return this.$inSelection;
	    };
	    MouseEvent.prototype.getButton = function () {
	        return event.getButton(this.domEvent);
	    };
	    MouseEvent.prototype.getShiftKey = function () {
	        return this.domEvent.shiftKey;
	    };
	    MouseEvent.prototype.getAccelKey = function () {
	        return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
	    };
	    return MouseEvent;
	}());
	exports.MouseEvent = MouseEvent;

	});

	ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(require, exports, module){	var dom = require("../lib/dom");
	var event = require("../lib/event");
	var useragent = require("../lib/useragent");
	var AUTOSCROLL_DELAY = 200;
	var SCROLL_CURSOR_DELAY = 200;
	var SCROLL_CURSOR_HYSTERESIS = 5;
	function DragdropHandler(mouseHandler) {
	    var editor = mouseHandler.editor;
	    var dragImage = dom.createElement("div");
	    dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
	    dragImage.textContent = "\xa0";
	    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
	    exports.forEach(function (x) {
	        mouseHandler[x] = this[x];
	    }, this);
	    editor.on("mousedown", this.onMouseDown.bind(mouseHandler));
	    var mouseTarget = editor.container;
	    var dragSelectionMarker, x, y;
	    var timerId, range;
	    var dragCursor, counter = 0;
	    var dragOperation;
	    var isInternal;
	    var autoScrollStartTime;
	    var cursorMovedTime;
	    var cursorPointOnCaretMoved;
	    this.onDragStart = function (e) {
	        if (this.cancelDrag || !mouseTarget.draggable) {
	            var self = this;
	            setTimeout(function () {
	                self.startSelect();
	                self.captureMouse(e);
	            }, 0);
	            return e.preventDefault();
	        }
	        range = editor.getSelectionRange();
	        var dataTransfer = e.dataTransfer;
	        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
	        editor.container.appendChild(dragImage);
	        dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
	        setTimeout(function () {
	            editor.container.removeChild(dragImage);
	        });
	        dataTransfer.clearData();
	        dataTransfer.setData("Text", editor.session.getTextRange());
	        isInternal = true;
	        this.setState("drag");
	    };
	    this.onDragEnd = function (e) {
	        mouseTarget.draggable = false;
	        isInternal = false;
	        this.setState(null);
	        if (!editor.getReadOnly()) {
	            var dropEffect = e.dataTransfer.dropEffect;
	            if (!dragOperation && dropEffect == "move")
	                editor.session.remove(editor.getSelectionRange());
	            editor.$resetCursorStyle();
	        }
	        this.editor.unsetStyle("ace_dragging");
	        this.editor.renderer.setCursorStyle("");
	    };
	    this.onDragEnter = function (e) {
	        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
	            return;
	        x = e.clientX;
	        y = e.clientY;
	        if (!dragSelectionMarker)
	            addDragMarker();
	        counter++;
	        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
	        return event.preventDefault(e);
	    };
	    this.onDragOver = function (e) {
	        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
	            return;
	        x = e.clientX;
	        y = e.clientY;
	        if (!dragSelectionMarker) {
	            addDragMarker();
	            counter++;
	        }
	        if (onMouseMoveTimer !== null)
	            onMouseMoveTimer = null;
	        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
	        return event.preventDefault(e);
	    };
	    this.onDragLeave = function (e) {
	        counter--;
	        if (counter <= 0 && dragSelectionMarker) {
	            clearDragMarker();
	            dragOperation = null;
	            return event.preventDefault(e);
	        }
	    };
	    this.onDrop = function (e) {
	        if (!dragCursor)
	            return;
	        var dataTransfer = e.dataTransfer;
	        if (isInternal) {
	            switch (dragOperation) {
	                case "move":
	                    if (range.contains(dragCursor.row, dragCursor.column)) {
	                        range = {
	                            start: dragCursor,
	                            end: dragCursor
	                        };
	                    }
	                    else {
	                        range = editor.moveText(range, dragCursor);
	                    }
	                    break;
	                case "copy":
	                    range = editor.moveText(range, dragCursor, true);
	                    break;
	            }
	        }
	        else {
	            var dropData = dataTransfer.getData('Text');
	            range = {
	                start: dragCursor,
	                end: editor.session.insert(dragCursor, dropData)
	            };
	            editor.focus();
	            dragOperation = null;
	        }
	        clearDragMarker();
	        return event.preventDefault(e);
	    };
	    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
	    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
	    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
	    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
	    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
	    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);
	    function scrollCursorIntoView(cursor, prevCursor) {
	        var now = Date.now();
	        var vMovement = !prevCursor || cursor.row != prevCursor.row;
	        var hMovement = !prevCursor || cursor.column != prevCursor.column;
	        if (!cursorMovedTime || vMovement || hMovement) {
	            editor.moveCursorToPosition(cursor);
	            cursorMovedTime = now;
	            cursorPointOnCaretMoved = { x: x, y: y };
	        }
	        else {
	            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
	            if (distance > SCROLL_CURSOR_HYSTERESIS) {
	                cursorMovedTime = null;
	            }
	            else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
	                editor.renderer.scrollCursorIntoView();
	                cursorMovedTime = null;
	            }
	        }
	    }
	    function autoScroll(cursor, prevCursor) {
	        var now = Date.now();
	        var lineHeight = editor.renderer.layerConfig.lineHeight;
	        var characterWidth = editor.renderer.layerConfig.characterWidth;
	        var editorRect = editor.renderer.scroller.getBoundingClientRect();
	        var offsets = {
	            x: {
	                left: x - editorRect.left,
	                right: editorRect.right - x
	            },
	            y: {
	                top: y - editorRect.top,
	                bottom: editorRect.bottom - y
	            }
	        };
	        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
	        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
	        var scrollCursor = { row: cursor.row, column: cursor.column };
	        if (nearestXOffset / characterWidth <= 2) {
	            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : 2);
	        }
	        if (nearestYOffset / lineHeight <= 1) {
	            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : 1);
	        }
	        var vScroll = cursor.row != scrollCursor.row;
	        var hScroll = cursor.column != scrollCursor.column;
	        var vMovement = !prevCursor || cursor.row != prevCursor.row;
	        if (vScroll || (hScroll && !vMovement)) {
	            if (!autoScrollStartTime)
	                autoScrollStartTime = now;
	            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
	                editor.renderer.scrollCursorIntoView(scrollCursor);
	        }
	        else {
	            autoScrollStartTime = null;
	        }
	    }
	    function onDragInterval() {
	        var prevCursor = dragCursor;
	        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
	        scrollCursorIntoView(dragCursor, prevCursor);
	        autoScroll(dragCursor, prevCursor);
	    }
	    function addDragMarker() {
	        range = editor.selection.toOrientedRange();
	        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
	        editor.clearSelection();
	        if (editor.isFocused())
	            editor.renderer.$cursorLayer.setBlinking(false);
	        clearInterval(timerId);
	        onDragInterval();
	        timerId = setInterval(onDragInterval, 20);
	        counter = 0;
	        event.addListener(document, "mousemove", onMouseMove);
	    }
	    function clearDragMarker() {
	        clearInterval(timerId);
	        editor.session.removeMarker(dragSelectionMarker);
	        dragSelectionMarker = null;
	        editor.selection.fromOrientedRange(range);
	        if (editor.isFocused() && !isInternal)
	            editor.$resetCursorStyle();
	        range = null;
	        dragCursor = null;
	        counter = 0;
	        autoScrollStartTime = null;
	        cursorMovedTime = null;
	        event.removeListener(document, "mousemove", onMouseMove);
	    }
	    var onMouseMoveTimer = null;
	    function onMouseMove() {
	        if (onMouseMoveTimer == null) {
	            onMouseMoveTimer = setTimeout(function () {
	                if (onMouseMoveTimer != null && dragSelectionMarker)
	                    clearDragMarker();
	            }, 20);
	        }
	    }
	    function canAccept(dataTransfer) {
	        var types = dataTransfer.types;
	        return !types || Array.prototype.some.call(types, function (type) {
	            return type == 'text/plain' || type == 'Text';
	        });
	    }
	    function getDropEffect(e) {
	        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
	        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];
	        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
	        var effectAllowed = "uninitialized";
	        try {
	            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
	        }
	        catch (e) { }
	        var dropEffect = "none";
	        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "copy";
	        else if (moveAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "move";
	        else if (copyAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "copy";
	        return dropEffect;
	    }
	}
	(function () {
	    this.dragWait = function () {
	        var interval = Date.now() - this.mousedownEvent.time;
	        if (interval > this.editor.getDragDelay())
	            this.startDrag();
	    };
	    this.dragWaitEnd = function () {
	        var target = this.editor.container;
	        target.draggable = false;
	        this.startSelect(this.mousedownEvent.getDocumentPosition());
	        this.selectEnd();
	    };
	    this.dragReadyEnd = function (e) {
	        this.editor.$resetCursorStyle();
	        this.editor.unsetStyle("ace_dragging");
	        this.editor.renderer.setCursorStyle("");
	        this.dragWaitEnd();
	    };
	    this.startDrag = function () {
	        this.cancelDrag = false;
	        var editor = this.editor;
	        var target = editor.container;
	        target.draggable = true;
	        editor.renderer.$cursorLayer.setBlinking(false);
	        editor.setStyle("ace_dragging");
	        var cursorStyle = useragent.isWin ? "default" : "move";
	        editor.renderer.setCursorStyle(cursorStyle);
	        this.setState("dragReady");
	    };
	    this.onMouseDrag = function (e) {
	        var target = this.editor.container;
	        if (useragent.isIE && this.state == "dragReady") {
	            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	            if (distance > 3)
	                target.dragDrop();
	        }
	        if (this.state === "dragWait") {
	            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	            if (distance > 0) {
	                target.draggable = false;
	                this.startSelect(this.mousedownEvent.getDocumentPosition());
	            }
	        }
	    };
	    this.onMouseDown = function (e) {
	        if (!this.$dragEnabled)
	            return;
	        this.mousedownEvent = e;
	        var editor = this.editor;
	        var inSelection = e.inSelection();
	        var button = e.getButton();
	        var clickCount = e.domEvent.detail || 1;
	        if (clickCount === 1 && button === 0 && inSelection) {
	            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
	                return;
	            this.mousedownEvent.time = Date.now();
	            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
	            if ("unselectable" in eventTarget)
	                eventTarget.unselectable = "on";
	            if (editor.getDragDelay()) {
	                if (useragent.isWebKit) {
	                    this.cancelDrag = true;
	                    var mouseTarget = editor.container;
	                    mouseTarget.draggable = true;
	                }
	                this.setState("dragWait");
	            }
	            else {
	                this.startDrag();
	            }
	            this.captureMouse(e, this.onMouseDrag.bind(this));
	            e.defaultPrevented = true;
	        }
	    };
	}).call(DragdropHandler.prototype);
	function calcDistance(ax, ay, bx, by) {
	    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
	}
	exports.DragdropHandler = DragdropHandler;

	});

	ace.define("ace/mouse/touch_handler",["require","exports","module","ace/mouse/mouse_event","ace/lib/event","ace/lib/dom"], function(require, exports, module){	var MouseEvent = require("./mouse_event").MouseEvent;
	var event = require("../lib/event");
	var dom = require("../lib/dom");
	exports.addTouchListeners = function (el, editor) {
	    var mode = "scroll";
	    var startX;
	    var startY;
	    var touchStartT;
	    var lastT;
	    var longTouchTimer;
	    var animationTimer;
	    var animationSteps = 0;
	    var pos;
	    var clickCount = 0;
	    var vX = 0;
	    var vY = 0;
	    var pressed;
	    var contextMenu;
	    function createContextMenu() {
	        var clipboard = window.navigator && window.navigator.clipboard;
	        var isOpen = false;
	        var updateMenu = function () {
	            var selected = editor.getCopyText();
	            var hasUndo = editor.session.getUndoManager().hasUndo();
	            contextMenu.replaceChild(dom.buildDom(isOpen ? ["span",
	                !selected && canExecuteCommand("selectall") && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
	                selected && canExecuteCommand("copy") && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
	                selected && canExecuteCommand("cut") && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
	                clipboard && canExecuteCommand("paste") && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
	                hasUndo && canExecuteCommand("undo") && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
	                canExecuteCommand("find") && ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
	                canExecuteCommand("openCommandPalette") && ["span", { class: "ace_mobile-button", action: "openCommandPalette" }, "Palette"]
	            ] : ["span"]), contextMenu.firstChild);
	        };
	        var canExecuteCommand = function (/** @type {string} */ cmd) {
	            return editor.commands.canExecute(cmd, editor);
	        };
	        var handleClick = function (e) {
	            var action = e.target.getAttribute("action");
	            if (action == "more" || !isOpen) {
	                isOpen = !isOpen;
	                return updateMenu();
	            }
	            if (action == "paste") {
	                clipboard.readText().then(function (text) {
	                    editor.execCommand(action, text);
	                });
	            }
	            else if (action) {
	                if (action == "cut" || action == "copy") {
	                    if (clipboard)
	                        clipboard.writeText(editor.getCopyText());
	                    else
	                        document.execCommand("copy");
	                }
	                editor.execCommand(action);
	            }
	            contextMenu.firstChild.style.display = "none";
	            isOpen = false;
	            if (action != "openCommandPalette")
	                editor.focus();
	        };
	        contextMenu = dom.buildDom(["div",
	            {
	                class: "ace_mobile-menu",
	                ontouchstart: function (e) {
	                    mode = "menu";
	                    e.stopPropagation();
	                    e.preventDefault();
	                    editor.textInput.focus();
	                },
	                ontouchend: function (e) {
	                    e.stopPropagation();
	                    e.preventDefault();
	                    handleClick(e);
	                },
	                onclick: handleClick
	            },
	            ["span"],
	            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
	        ], editor.container);
	    }
	    function showContextMenu() {
	        if (!editor.getOption("enableMobileMenu")) {
	            if (contextMenu) {
	                hideContextMenu();
	            }
	            return;
	        }
	        if (!contextMenu)
	            createContextMenu();
	        var cursor = editor.selection.cursor;
	        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
	        var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
	        var scrollLeft = editor.renderer.scrollLeft;
	        var rect = editor.container.getBoundingClientRect();
	        contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
	        if (pagePos.pageX - rect.left < rect.width - 70) {
	            contextMenu.style.left = "";
	            contextMenu.style.right = "10px";
	        }
	        else {
	            contextMenu.style.right = "";
	            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
	        }
	        contextMenu.style.display = "";
	        contextMenu.firstChild.style.display = "none";
	        editor.on("input", hideContextMenu);
	    }
	    function hideContextMenu(e) {
	        if (contextMenu)
	            contextMenu.style.display = "none";
	        editor.off("input", hideContextMenu);
	    }
	    function handleLongTap() {
	        longTouchTimer = null;
	        clearTimeout(longTouchTimer);
	        var range = editor.selection.getRange();
	        var inSelection = range.contains(pos.row, pos.column);
	        if (range.isEmpty() || !inSelection) {
	            editor.selection.moveToPosition(pos);
	            editor.selection.selectWord();
	        }
	        mode = "wait";
	        showContextMenu();
	    }
	    function switchToSelectionMode() {
	        longTouchTimer = null;
	        clearTimeout(longTouchTimer);
	        editor.selection.moveToPosition(pos);
	        var range = clickCount >= 2
	            ? editor.selection.getLineRange(pos.row)
	            : editor.session.getBracketRange(pos);
	        if (range && !range.isEmpty()) {
	            editor.selection.setRange(range);
	        }
	        else {
	            editor.selection.selectWord();
	        }
	        mode = "wait";
	    }
	    event.addListener(el, "contextmenu", function (e) {
	        if (!pressed)
	            return;
	        var textarea = editor.textInput.getElement();
	        textarea.focus();
	    }, editor);
	    event.addListener(el, "touchstart", function (e) {
	        var touches = e.touches;
	        if (longTouchTimer || touches.length > 1) {
	            clearTimeout(longTouchTimer);
	            longTouchTimer = null;
	            touchStartT = -1;
	            mode = "zoom";
	            return;
	        }
	        pressed = editor.$mouseHandler.isMousePressed = true;
	        var h = editor.renderer.layerConfig.lineHeight;
	        var w = editor.renderer.layerConfig.lineHeight;
	        var t = e.timeStamp;
	        lastT = t;
	        var touchObj = touches[0];
	        var x = touchObj.clientX;
	        var y = touchObj.clientY;
	        if (Math.abs(startX - x) + Math.abs(startY - y) > h)
	            touchStartT = -1;
	        startX = e.clientX = x;
	        startY = e.clientY = y;
	        vX = vY = 0;
	        var ev = new MouseEvent(e, editor);
	        pos = ev.getDocumentPosition();
	        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
	            clickCount++;
	            e.preventDefault();
	            e.button = 0;
	            switchToSelectionMode();
	        }
	        else {
	            clickCount = 0;
	            var cursor = editor.selection.cursor;
	            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
	            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
	            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
	            var rect = editor.renderer.scroller.getBoundingClientRect();
	            var offsetTop = editor.renderer.layerConfig.offset;
	            var offsetLeft = editor.renderer.scrollLeft;
	            var weightedDistance = function (x, y) {
	                x = x / w;
	                y = y / h - 0.75;
	                return x * x + y * y;
	            };
	            if (e.clientX < rect.left) {
	                mode = "zoom";
	                return;
	            }
	            var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);
	            var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);
	            if (diff1 < 3.5 && diff2 < 3.5)
	                mode = diff1 > diff2 ? "cursor" : "anchor";
	            if (diff2 < 3.5)
	                mode = "anchor";
	            else if (diff1 < 3.5)
	                mode = "cursor";
	            else
	                mode = "scroll";
	            longTouchTimer = setTimeout(handleLongTap, 450);
	        }
	        touchStartT = t;
	    }, editor);
	    event.addListener(el, "touchend", function (e) {
	        pressed = editor.$mouseHandler.isMousePressed = false;
	        if (animationTimer)
	            clearInterval(animationTimer);
	        if (mode == "zoom") {
	            mode = "";
	            animationSteps = 0;
	        }
	        else if (longTouchTimer) {
	            editor.selection.moveToPosition(pos);
	            animationSteps = 0;
	            showContextMenu();
	        }
	        else if (mode == "scroll") {
	            animate();
	            hideContextMenu();
	        }
	        else {
	            showContextMenu();
	        }
	        clearTimeout(longTouchTimer);
	        longTouchTimer = null;
	    }, editor);
	    event.addListener(el, "touchmove", function (e) {
	        if (longTouchTimer) {
	            clearTimeout(longTouchTimer);
	            longTouchTimer = null;
	        }
	        var touches = e.touches;
	        if (touches.length > 1 || mode == "zoom")
	            return;
	        var touchObj = touches[0];
	        var wheelX = startX - touchObj.clientX;
	        var wheelY = startY - touchObj.clientY;
	        if (mode == "wait") {
	            if (wheelX * wheelX + wheelY * wheelY > 4)
	                mode = "cursor";
	            else
	                return e.preventDefault();
	        }
	        startX = touchObj.clientX;
	        startY = touchObj.clientY;
	        e.clientX = touchObj.clientX;
	        e.clientY = touchObj.clientY;
	        var t = e.timeStamp;
	        var dt = t - lastT;
	        lastT = t;
	        if (mode == "scroll") {
	            var mouseEvent = new MouseEvent(e, editor);
	            mouseEvent.speed = 1;
	            mouseEvent.wheelX = wheelX;
	            mouseEvent.wheelY = wheelY;
	            if (10 * Math.abs(wheelX) < Math.abs(wheelY))
	                wheelX = 0;
	            if (10 * Math.abs(wheelY) < Math.abs(wheelX))
	                wheelY = 0;
	            if (dt != 0) {
	                vX = wheelX / dt;
	                vY = wheelY / dt;
	            }
	            editor._emit("mousewheel", mouseEvent);
	            if (!mouseEvent.propagationStopped) {
	                vX = vY = 0;
	            }
	        }
	        else {
	            var ev = new MouseEvent(e, editor);
	            var pos = ev.getDocumentPosition();
	            if (mode == "cursor")
	                editor.selection.moveCursorToPosition(pos);
	            else if (mode == "anchor")
	                editor.selection.setSelectionAnchor(pos.row, pos.column);
	            editor.renderer.scrollCursorIntoView(pos);
	            e.preventDefault();
	        }
	    }, editor);
	    function animate() {
	        animationSteps += 60;
	        animationTimer = setInterval(function () {
	            if (animationSteps-- <= 0) {
	                clearInterval(animationTimer);
	                animationTimer = null;
	            }
	            if (Math.abs(vX) < 0.01)
	                vX = 0;
	            if (Math.abs(vY) < 0.01)
	                vY = 0;
	            if (animationSteps < 20)
	                vX = 0.9 * vX;
	            if (animationSteps < 20)
	                vY = 0.9 * vY;
	            var oldScrollTop = editor.session.getScrollTop();
	            editor.renderer.scrollBy(10 * vX, 10 * vY);
	            if (oldScrollTop == editor.session.getScrollTop())
	                animationSteps = 0;
	        }, 10);
	    }
	};

	});

	ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/mouse/touch_handler","ace/config"], function(require, exports, module){	var event = require("../lib/event");
	var useragent = require("../lib/useragent");
	var DefaultHandlers = require("./default_handlers").DefaultHandlers;
	var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
	var MouseEvent = require("./mouse_event").MouseEvent;
	var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
	var addTouchListeners = require("./touch_handler").addTouchListeners;
	var config = require("../config");
	var MouseHandler = /** @class */ (function () {
	    function MouseHandler(editor) { this.$dragDelay; this.$dragEnabled; this.$mouseMoved; this.mouseEvent; this.$focusTimeout;
	        var _self = this;
	        this.editor = editor;
	        new DefaultHandlers(this);
	        new DefaultGutterHandler(this);
	        new DragdropHandler(this);
	        var focusEditor = function (e) {
	            var windowBlurred = !document.hasFocus || !document.hasFocus()
	                || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
	            if (windowBlurred)
	                window.focus();
	            editor.focus();
	            setTimeout(function () {
	                if (!editor.isFocused())
	                    editor.focus();
	            });
	        };
	        var mouseTarget = editor.renderer.getMouseEventTarget();
	        event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
	        event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
	        event.addMultiMouseDownListener([
	            mouseTarget,
	            editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
	            editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
	            editor.textInput && editor.textInput.getElement()
	        ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
	        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
	        addTouchListeners(editor.container, editor);
	        var gutterEl = editor.renderer.$gutter;
	        event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
	        event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
	        event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
	        event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);
	        event.addListener(mouseTarget, "mousedown", focusEditor, editor);
	        event.addListener(gutterEl, "mousedown", focusEditor, editor);
	        if (useragent.isIE && editor.renderer.scrollBarV) {
	            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
	            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
	        }
	        editor.on("mousemove", function (e) {
	            if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
	                return;
	            var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
	            var range = editor.session.selection.getRange();
	            var renderer = editor.renderer;
	            if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
	                renderer.setCursorStyle("default");
	            }
	            else {
	                renderer.setCursorStyle("");
	            }
	        }, //@ts-expect-error TODO: seems mistyping - should be boolean
	        editor);
	    }
	    MouseHandler.prototype.onMouseEvent = function (name, e) {
	        if (!this.editor.session)
	            return;
	        this.editor._emit(name, new MouseEvent(e, this.editor));
	    };
	    MouseHandler.prototype.onMouseMove = function (name, e) {
	        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
	        if (!listeners || !listeners.length)
	            return;
	        this.editor._emit(name, new MouseEvent(e, this.editor));
	    };
	    MouseHandler.prototype.onMouseWheel = function (name, e) {
	        var mouseEvent = new MouseEvent(e, this.editor);
	        mouseEvent.speed = this.$scrollSpeed * 2;
	        mouseEvent.wheelX = e.wheelX;
	        mouseEvent.wheelY = e.wheelY;
	        this.editor._emit(name, mouseEvent);
	    };
	    MouseHandler.prototype.setState = function (state) {
	        this.state = state;
	    };
	    MouseHandler.prototype.captureMouse = function (ev, mouseMoveHandler) {
	        this.x = ev.x;
	        this.y = ev.y;
	        this.isMousePressed = true;
	        var editor = this.editor;
	        var renderer = this.editor.renderer;
	        renderer.$isMousePressed = true;
	        var self = this;
	        var continueCapture = true;
	        var onMouseMove = function (e) {
	            if (!e)
	                return;
	            if (useragent.isWebKit && !e.which && self.releaseMouse)
	                return self.releaseMouse();
	            self.x = e.clientX;
	            self.y = e.clientY;
	            mouseMoveHandler && mouseMoveHandler(e);
	            self.mouseEvent = new MouseEvent(e, self.editor);
	            self.$mouseMoved = true;
	        };
	        var onCaptureEnd = function (e) {
	            editor.off("beforeEndOperation", onOperationEnd);
	            continueCapture = false;
	            if (editor.session)
	                onCaptureUpdate();
	            self[self.state + "End"] && self[self.state + "End"](e);
	            self.state = "";
	            self.isMousePressed = renderer.$isMousePressed = false;
	            if (renderer.$keepTextAreaAtCursor)
	                renderer.$moveTextAreaToCursor();
	            self.$onCaptureMouseMove = self.releaseMouse = null;
	            e && self.onMouseEvent("mouseup", e);
	            editor.endOperation();
	        };
	        var onCaptureUpdate = function () {
	            self[self.state] && self[self.state]();
	            self.$mouseMoved = false;
	        };
	        var onCaptureInterval = function () {
	            if (continueCapture) {
	                onCaptureUpdate();
	                event.nextFrame(onCaptureInterval);
	            }
	        };
	        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
	            return setTimeout(function () { onCaptureEnd(ev); });
	        }
	        var onOperationEnd = function (e) {
	            if (!self.releaseMouse)
	                return;
	            if (editor.curOp.command.name && editor.curOp.selectionChanged) {
	                self[self.state + "End"] && self[self.state + "End"]();
	                self.state = "";
	                self.releaseMouse();
	            }
	        };
	        editor.on("beforeEndOperation", onOperationEnd);
	        editor.startOperation({ command: { name: "mouse" } });
	        self.$onCaptureMouseMove = onMouseMove;
	        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
	        onCaptureInterval();
	    };
	    MouseHandler.prototype.cancelContextMenu = function () {
	        var stop = function (e) {
	            if (e && e.domEvent && e.domEvent.type != "contextmenu")
	                return;
	            this.editor.off("nativecontextmenu", stop);
	            if (e && e.domEvent)
	                event.stopEvent(e.domEvent);
	        }.bind(this);
	        setTimeout(stop, 10);
	        this.editor.on("nativecontextmenu", stop);
	    };
	    MouseHandler.prototype.destroy = function () {
	        if (this.releaseMouse)
	            this.releaseMouse();
	    };
	    return MouseHandler;
	}());
	MouseHandler.prototype.releaseMouse = null;
	config.defineOptions(MouseHandler.prototype, "mouseHandler", {
	    scrollSpeed: { initialValue: 2 },
	    dragDelay: { initialValue: (useragent.isMac ? 150 : 0) },
	    dragEnabled: { initialValue: true },
	    focusTimeout: { initialValue: 0 },
	    tooltipFollowsMouse: { initialValue: true }
	});
	exports.MouseHandler = MouseHandler;

	});

	ace.define("ace/mouse/fold_handler",["require","exports","module","ace/lib/dom"], function(require, exports, module){	var dom = require("../lib/dom");
	var FoldHandler = /** @class */ (function () {
	    function FoldHandler(editor) {
	        editor.on("click", function (e) {
	            var position = e.getDocumentPosition();
	            var session = editor.session;
	            var fold = session.getFoldAt(position.row, position.column, 1);
	            if (fold) {
	                if (e.getAccelKey())
	                    session.removeFold(fold);
	                else
	                    session.expandFold(fold);
	                e.stop();
	            }
	            var target = e.domEvent && e.domEvent.target;
	            if (target && dom.hasCssClass(target, "ace_inline_button")) {
	                if (dom.hasCssClass(target, "ace_toggle_wrap")) {
	                    session.setOption("wrap", !session.getUseWrapMode());
	                    editor.renderer.scrollCursorIntoView();
	                }
	            }
	        });
	        editor.on("gutterclick", function (e) {
	            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
	            if (gutterRegion == "foldWidgets") {
	                var row = e.getDocumentPosition().row;
	                var session = editor.session;
	                if (session.foldWidgets && session.foldWidgets[row])
	                    editor.session.onFoldWidgetClick(row, e);
	                if (!editor.isFocused())
	                    editor.focus();
	                e.stop();
	            }
	        });
	        editor.on("gutterdblclick", function (e) {
	            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
	            if (gutterRegion == "foldWidgets") {
	                var row = e.getDocumentPosition().row;
	                var session = editor.session;
	                var data = session.getParentFoldRangeData(row, true);
	                var range = data.range || data.firstRange;
	                if (range) {
	                    row = range.start.row;
	                    var fold = session.getFoldAt(row, session.getLine(row).length, 1);
	                    if (fold) {
	                        session.removeFold(fold);
	                    }
	                    else {
	                        session.addFold("...", range);
	                        editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
	                    }
	                }
	                e.stop();
	            }
	        });
	    }
	    return FoldHandler;
	}());
	exports.FoldHandler = FoldHandler;

	});

	ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(require, exports, module){	var keyUtil = require("../lib/keys");
	var event = require("../lib/event");
	var KeyBinding = /** @class */ (function () {
	    function KeyBinding(editor) {
	        this.$editor = editor;
	        this.$data = { editor: editor };
	        this.$handlers = [];
	        this.setDefaultHandler(editor.commands);
	    }
	    KeyBinding.prototype.setDefaultHandler = function (kb) {
	        this.removeKeyboardHandler(this.$defaultHandler);
	        this.$defaultHandler = kb;
	        this.addKeyboardHandler(kb, 0);
	    };
	    KeyBinding.prototype.setKeyboardHandler = function (kb) {
	        var h = this.$handlers;
	        if (h[h.length - 1] == kb)
	            return;
	        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
	            this.removeKeyboardHandler(h[h.length - 1]);
	        this.addKeyboardHandler(kb, 1);
	    };
	    KeyBinding.prototype.addKeyboardHandler = function (kb, pos) {
	        if (!kb)
	            return;
	        if (typeof kb == "function" && !kb.handleKeyboard)
	            kb.handleKeyboard = kb;
	        var i = this.$handlers.indexOf(kb);
	        if (i != -1)
	            this.$handlers.splice(i, 1);
	        if (pos == undefined)
	            this.$handlers.push(kb);
	        else
	            this.$handlers.splice(pos, 0, kb);
	        if (i == -1 && kb.attach)
	            kb.attach(this.$editor);
	    };
	    KeyBinding.prototype.removeKeyboardHandler = function (kb) {
	        var i = this.$handlers.indexOf(kb);
	        if (i == -1)
	            return false;
	        this.$handlers.splice(i, 1);
	        kb.detach && kb.detach(this.$editor);
	        return true;
	    };
	    KeyBinding.prototype.getKeyboardHandler = function () {
	        return this.$handlers[this.$handlers.length - 1];
	    };
	    KeyBinding.prototype.getStatusText = function () {
	        var data = this.$data;
	        var editor = data.editor;
	        return this.$handlers.map(function (h) {
	            return h.getStatusText && h.getStatusText(editor, data) || "";
	        }).filter(Boolean).join(" ");
	    };
	    KeyBinding.prototype.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
	        var toExecute;
	        var success = false;
	        var commands = this.$editor.commands;
	        for (var i = this.$handlers.length; i--;) {
	            toExecute = this.$handlers[i].handleKeyboard(
	            this.$data, hashId, keyString, keyCode, e);
	            if (!toExecute || !toExecute.command)
	                continue;
	            if (toExecute.command == "null") {
	                success = true;
	            }
	            else {
	                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
	            }
	            if (success && e && hashId != -1 &&
	                toExecute["passEvent"] != true && toExecute.command["passEvent"] != true) {
	                event.stopEvent(e);
	            }
	            if (success)
	                break;
	        }
	        if (!success && hashId == -1) {
	            toExecute = { command: "insertstring" };
	            success = commands.exec("insertstring", this.$editor, keyString);
	        }
	        if (success && this.$editor._signal)
	            this.$editor._signal("keyboardActivity", toExecute);
	        return success;
	    };
	    KeyBinding.prototype.onCommandKey = function (e, hashId, keyCode) {
	        var keyString = keyUtil.keyCodeToString(keyCode);
	        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
	    };
	    KeyBinding.prototype.onTextInput = function (text) {
	        return this.$callKeyboardHandlers(-1, text);
	    };
	    return KeyBinding;
	}());
	exports.KeyBinding = KeyBinding;

	});

	ace.define("ace/lib/bidiutil",["require","exports","module"], function(require, exports, module){	var dir = 0, hiLevel = 0;
	var lastArabic = false, hasUBAT_B = false, hasUBAT_S = false;
	var impTab_LTR = [ [0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 0x11, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 0x15, 0x15, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]
	];
	var impTab_RTL = [ [2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 0x21, 3, 1, 1]
	];
	var LTR = 0, RTL = 1;
	var L = 0;
	var R = 1;
	var EN = 2;
	var AN = 3;
	var ON = 4;
	var B = 5;
	var S = 6;
	var AL = 7;
	var WS = 8;
	var CS = 9;
	var ES = 10;
	var ET = 11;
	var NSM = 12;
	var LRE = 13;
	var RLE = 14;
	var PDF = 15;
	var LRO = 16;
	var RLO = 17;
	var BN = 18;
	var UnicodeTBL00 = [
	    BN, BN, BN, BN, BN, BN, BN, BN, BN, S, B, S, WS, B, BN, BN,
	    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, B, B, B, S,
	    WS, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,
	    EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,
	    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,
	    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, ON,
	    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,
	    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, BN,
	    BN, BN, BN, BN, BN, B, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
	    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
	    CS, ON, ET, ET, ET, ET, ON, ON, ON, ON, L, ON, ON, BN, ON, ON,
	    ET, ET, EN, EN, ON, L, ON, ON, ON, EN, L, ON, ON, ON, ON, ON
	];
	var UnicodeTBL20 = [
	    WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, BN, BN, BN, L, R,
	    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
	    ON, ON, ON, ON, ON, ON, ON, ON, WS, B, LRE, RLE, PDF, LRO, RLO, CS,
	    ET, ET, ET, ET, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
	    ON, ON, ON, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
	    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS
	];
	function _computeLevels(chars, levels, len, charTypes) {
	    var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
	    if (!charTypes) {
	        for (i = 0, charTypes = []; i < len; i++) {
	            charTypes[i] = _getCharacterType(chars[i]);
	        }
	    }
	    hiLevel = dir;
	    lastArabic = false;
	    hasUBAT_B = false;
	    hasUBAT_S = false;
	    for (ix = 0; ix < len; ix++) {
	        prevState = newState;
	        classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
	        newState = impTab[prevState][newClass];
	        action = newState & 0xF0;
	        newState &= 0x0F;
	        levels[ix] = newLevel = impTab[newState][5];
	        if (action > 0) {
	            if (action == 0x10) {
	                for (i = condPos; i < ix; i++) {
	                    levels[i] = 1;
	                }
	                condPos = -1;
	            }
	            else {
	                condPos = -1;
	            }
	        }
	        cond = impTab[newState][6];
	        if (cond) {
	            if (condPos == -1) {
	                condPos = ix;
	            }
	        }
	        else {
	            if (condPos > -1) {
	                for (i = condPos; i < ix; i++) {
	                    levels[i] = newLevel;
	                }
	                condPos = -1;
	            }
	        }
	        if (charTypes[ix] == B) {
	            levels[ix] = 0;
	        }
	        hiLevel |= newLevel;
	    }
	    if (hasUBAT_S) {
	        for (i = 0; i < len; i++) {
	            if (charTypes[i] == S) {
	                levels[i] = dir;
	                for (var j = i - 1; j >= 0; j--) {
	                    if (charTypes[j] == WS) {
	                        levels[j] = dir;
	                    }
	                    else {
	                        break;
	                    }
	                }
	            }
	        }
	    }
	}
	function _invertLevel(lev, levels, _array) {
	    if (hiLevel < lev) {
	        return;
	    }
	    if (lev == 1 && dir == RTL && !hasUBAT_B) {
	        _array.reverse();
	        return;
	    }
	    var len = _array.length, start = 0, end, lo, hi, tmp;
	    while (start < len) {
	        if (levels[start] >= lev) {
	            end = start + 1;
	            while (end < len && levels[end] >= lev) {
	                end++;
	            }
	            for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
	                tmp = _array[lo];
	                _array[lo] = _array[hi];
	                _array[hi] = tmp;
	            }
	            start = end;
	        }
	        start++;
	    }
	}
	function _getCharClass(chars, types, classes, ix) {
	    var cType = types[ix], wType, nType, len, i;
	    switch (cType) {
	        case L:
	        case R:
	            lastArabic = false;
	        case ON:
	        case AN:
	            return cType;
	        case EN:
	            return lastArabic ? AN : EN;
	        case AL:
	            lastArabic = true;
	            return R;
	        case WS:
	            return ON;
	        case CS:
	            if (ix < 1 || (ix + 1) >= types.length ||
	                ((wType = classes[ix - 1]) != EN && wType != AN) ||
	                ((nType = types[ix + 1]) != EN && nType != AN)) {
	                return ON;
	            }
	            if (lastArabic) {
	                nType = AN;
	            }
	            return nType == wType ? nType : ON;
	        case ES:
	            wType = ix > 0 ? classes[ix - 1] : B;
	            if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN) {
	                return EN;
	            }
	            return ON;
	        case ET:
	            if (ix > 0 && classes[ix - 1] == EN) {
	                return EN;
	            }
	            if (lastArabic) {
	                return ON;
	            }
	            i = ix + 1;
	            len = types.length;
	            while (i < len && types[i] == ET) {
	                i++;
	            }
	            if (i < len && types[i] == EN) {
	                return EN;
	            }
	            return ON;
	        case NSM:
	            len = types.length;
	            i = ix + 1;
	            while (i < len && types[i] == NSM) {
	                i++;
	            }
	            if (i < len) {
	                var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;
	                wType = types[i];
	                if (rtlCandidate && (wType == R || wType == AL)) {
	                    return R;
	                }
	            }
	            if (ix < 1 || (wType = types[ix - 1]) == B) {
	                return ON;
	            }
	            return classes[ix - 1];
	        case B:
	            lastArabic = false;
	            hasUBAT_B = true;
	            return dir;
	        case S:
	            hasUBAT_S = true;
	            return ON;
	        case LRE:
	        case RLE:
	        case LRO:
	        case RLO:
	        case PDF:
	            lastArabic = false;
	        case BN:
	            return ON;
	    }
	}
	function _getCharacterType(ch) {
	    var uc = ch.charCodeAt(0), hi = uc >> 8;
	    if (hi == 0) {
	        return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
	    }
	    else if (hi == 5) {
	        return (/[\u0591-\u05f4]/.test(ch) ? R : L);
	    }
	    else if (hi == 6) {
	        if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
	            return NSM;
	        else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
	            return AN;
	        else if (uc == 0x066A)
	            return ET;
	        else if (/[\u06f0-\u06f9]/.test(ch))
	            return EN;
	        else
	            return AL;
	    }
	    else if (hi == 0x20 && uc <= 0x205F) {
	        return UnicodeTBL20[uc & 0xFF];
	    }
	    else if (hi == 0xFE) {
	        return (uc >= 0xFE70 ? AL : ON);
	    }
	    return ON;
	}
	exports.L = L;
	exports.R = R;
	exports.EN = EN;
	exports.ON_R = 3;
	exports.AN = 4;
	exports.R_H = 5;
	exports.B = 6;
	exports.RLE = 7;
	exports.DOT = "\xB7";
	exports.doBidiReorder = function (text, textCharTypes, isRtl) {
	    if (text.length < 2)
	        return {};
	    var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
	    dir = isRtl ? RTL : LTR;
	    _computeLevels(chars, levels, chars.length, textCharTypes);
	    for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)
	        ;
	    _invertLevel(2, levels, logicalFromVisual);
	    _invertLevel(1, levels, logicalFromVisual);
	    for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
	        if (textCharTypes[i] === AN) {
	            levels[i] = exports.AN;
	        }
	        else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE)
	            || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
	            levels[i] = exports.ON_R;
	        }
	        else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
	            levels[i - 1] = levels[i] = exports.R_H;
	            i++;
	        }
	    }
	    if (chars[chars.length - 1] === exports.DOT)
	        levels[chars.length - 1] = exports.B;
	    if (chars[0] === '\u202B')
	        levels[0] = exports.RLE;
	    for (var i = 0; i < logicalFromVisual.length; i++) {
	        bidiLevels[i] = levels[logicalFromVisual[i]];
	    }
	    return { 'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels };
	};
	exports.hasBidiCharacters = function (text, textCharTypes) {
	    var ret = false;
	    for (var i = 0; i < text.length; i++) {
	        textCharTypes[i] = _getCharacterType(text.charAt(i));
	        if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
	            ret = true;
	    }
	    return ret;
	};
	exports.getVisualFromLogicalIdx = function (logIdx, rowMap) {
	    for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
	        if (rowMap.logicalFromVisual[i] == logIdx)
	            return i;
	    }
	    return 0;
	};

	});

	ace.define("ace/bidihandler",["require","exports","module","ace/lib/bidiutil","ace/lib/lang"], function(require, exports, module){	var bidiUtil = require("./lib/bidiutil");
	var lang = require("./lib/lang");
	var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
	var BidiHandler = /** @class */ (function () {
	    function BidiHandler(session) {
	        this.session = session;
	        this.bidiMap = {};
	        this.currentRow = null;
	        this.bidiUtil = bidiUtil;
	        this.charWidths = [];
	        this.EOL = "\xAC";
	        this.showInvisibles = true;
	        this.isRtlDir = false;
	        this.$isRtl = false;
	        this.line = "";
	        this.wrapIndent = 0;
	        this.EOF = "\xB6";
	        this.RLE = "\u202B";
	        this.contentWidth = 0;
	        this.fontMetrics = null;
	        this.rtlLineOffset = 0;
	        this.wrapOffset = 0;
	        this.isMoveLeftOperation = false;
	        this.seenBidi = bidiRE.test(session.getValue());
	    }
	    BidiHandler.prototype.isBidiRow = function (screenRow, docRow, splitIndex) {
	        if (!this.seenBidi)
	            return false;
	        if (screenRow !== this.currentRow) {
	            this.currentRow = screenRow;
	            this.updateRowLine(docRow, splitIndex);
	            this.updateBidiMap();
	        }
	        return this.bidiMap.bidiLevels;
	    };
	    BidiHandler.prototype.onChange = function (delta) {
	        if (!this.seenBidi) {
	            if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
	                this.seenBidi = true;
	                this.currentRow = null;
	            }
	        }
	        else {
	            this.currentRow = null;
	        }
	    };
	    BidiHandler.prototype.getDocumentRow = function () {
	        var docRow = 0;
	        var rowCache = this.session.$screenRowCache;
	        if (rowCache.length) {
	            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
	            if (index >= 0)
	                docRow = this.session.$docRowCache[index];
	        }
	        return docRow;
	    };
	    BidiHandler.prototype.getSplitIndex = function () {
	        var splitIndex = 0;
	        var rowCache = this.session.$screenRowCache;
	        if (rowCache.length) {
	            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
	            while (this.currentRow - splitIndex > 0) {
	                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
	                if (currentIndex !== prevIndex)
	                    break;
	                prevIndex = currentIndex;
	                splitIndex++;
	            }
	        }
	        else {
	            splitIndex = this.currentRow;
	        }
	        return splitIndex;
	    };
	    BidiHandler.prototype.updateRowLine = function (docRow, splitIndex) {
	        if (docRow === undefined)
	            docRow = this.getDocumentRow();
	        var isLastRow = (docRow === this.session.getLength() - 1), endOfLine = isLastRow ? this.EOF : this.EOL;
	        this.wrapIndent = 0;
	        this.line = this.session.getLine(docRow);
	        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
	        if (this.session.$useWrapMode) {
	            var splits = this.session.$wrapData[docRow];
	            if (splits) {
	                if (splitIndex === undefined)
	                    splitIndex = this.getSplitIndex();
	                if (splitIndex > 0 && splits.length) {
	                    this.wrapIndent = splits.indent;
	                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
	                    this.line = (splitIndex < splits.length) ?
	                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :
	                        this.line.substring(splits[splits.length - 1]);
	                }
	                else {
	                    this.line = this.line.substring(0, splits[splitIndex]);
	                }
	                if (splitIndex == splits.length) {
	                    this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;
	                }
	            }
	        }
	        else {
	            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
	        }
	        var session = this.session, shift = 0, size;
	        this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function (ch, i) {
	            if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
	                size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
	                shift += size - 1;
	                return lang.stringRepeat(bidiUtil.DOT, size);
	            }
	            return ch;
	        });
	        if (this.isRtlDir) {
	            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;
	            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
	        }
	    };
	    BidiHandler.prototype.updateBidiMap = function () {
	        var textCharTypes = [];
	        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
	            this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
	        }
	        else {
	            this.bidiMap = {};
	        }
	    };
	    BidiHandler.prototype.markAsDirty = function () {
	        this.currentRow = null;
	    };
	    BidiHandler.prototype.updateCharacterWidths = function (fontMetrics) {
	        if (this.characterWidth === fontMetrics.$characterSize.width)
	            return;
	        this.fontMetrics = fontMetrics;
	        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
	        var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");
	        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
	        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
	        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
	        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
	        this.currentRow = null;
	    };
	    BidiHandler.prototype.setShowInvisibles = function (showInvisibles) {
	        this.showInvisibles = showInvisibles;
	        this.currentRow = null;
	    };
	    BidiHandler.prototype.setEolChar = function (eolChar) {
	        this.EOL = eolChar;
	    };
	    BidiHandler.prototype.setContentWidth = function (width) {
	        this.contentWidth = width;
	    };
	    BidiHandler.prototype.isRtlLine = function (row) {
	        if (this.$isRtl)
	            return true;
	        if (row != undefined)
	            return (this.session.getLine(row).charAt(0) == this.RLE);
	        else
	            return this.isRtlDir;
	    };
	    BidiHandler.prototype.setRtlDirection = function (editor, isRtlDir) {
	        var cursor = editor.getCursorPosition();
	        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
	            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
	                editor.session.doc.removeInLine(row, 0, 1);
	            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
	                editor.session.doc.insert({ column: 0, row: row }, editor.session.$bidiHandler.RLE);
	        }
	    };
	    BidiHandler.prototype.getPosLeft = function (col) {
	        col -= this.wrapIndent;
	        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;
	        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;
	        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
	        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
	            visualIdx++;
	        for (var i = 0; i < visualIdx; i++) {
	            left += this.charWidths[levels[i]];
	        }
	        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))
	            left += this.charWidths[levels[visualIdx]];
	        if (this.wrapIndent)
	            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
	        if (this.isRtlDir)
	            left += this.rtlLineOffset;
	        return left;
	    };
	    BidiHandler.prototype.getSelections = function (startCol, endCol) {
	        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
	        if (this.wrapIndent)
	            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
	        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
	            logIdx = map.logicalFromVisual[visIdx];
	            level = levels[visIdx];
	            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
	            if (isSelected && !isSelectedPrev) {
	                selectionStart = offset;
	            }
	            else if (!isSelected && isSelectedPrev) {
	                selections.push({ left: selectionStart, width: offset - selectionStart });
	            }
	            offset += this.charWidths[level];
	            isSelectedPrev = isSelected;
	        }
	        if (isSelected && (visIdx === levels.length)) {
	            selections.push({ left: selectionStart, width: offset - selectionStart });
	        }
	        if (this.isRtlDir) {
	            for (var i = 0; i < selections.length; i++) {
	                selections[i].left += this.rtlLineOffset;
	            }
	        }
	        return selections;
	    };
	    BidiHandler.prototype.offsetToCol = function (posX) {
	        if (this.isRtlDir)
	            posX -= this.rtlLineOffset;
	        var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
	        if (this.wrapIndent)
	            posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
	        while (posX > offset + charWidth / 2) {
	            offset += charWidth;
	            if (visualIdx === levels.length - 1) {
	                charWidth = 0;
	                break;
	            }
	            charWidth = this.charWidths[levels[++visualIdx]];
	        }
	        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)) {
	            if (posX < offset)
	                visualIdx--;
	            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
	        }
	        else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)) {
	            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
	                : this.bidiMap.logicalFromVisual[visualIdx - 1]);
	        }
	        else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
	            || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))) {
	            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
	        }
	        else {
	            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
	                visualIdx--;
	            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
	        }
	        if (logicalIdx === 0 && this.isRtlDir)
	            logicalIdx++;
	        return (logicalIdx + this.wrapIndent);
	    };
	    return BidiHandler;
	}());
	exports.BidiHandler = BidiHandler;

	});

	ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(require, exports, module){	var oop = require("./lib/oop");
	var lang = require("./lib/lang");
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var Range = require("./range").Range;
	var Selection = /** @class */ (function () {
	    function Selection(session) {
	        this.session = session;
	        this.doc = session.getDocument();
	        this.clearSelection();
	        this.cursor = this.lead = this.doc.createAnchor(0, 0);
	        this.anchor = this.doc.createAnchor(0, 0);
	        this.$silent = false;
	        var self = this;
	        this.cursor.on("change", function (e) {
	            self.$cursorChanged = true;
	            if (!self.$silent)
	                self._emit("changeCursor");
	            if (!self.$isEmpty && !self.$silent)
	                self._emit("changeSelection");
	            if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
	                self.$desiredColumn = null;
	        });
	        this.anchor.on("change", function () {
	            self.$anchorChanged = true;
	            if (!self.$isEmpty && !self.$silent)
	                self._emit("changeSelection");
	        });
	    }
	    Selection.prototype.isEmpty = function () {
	        return this.$isEmpty || (this.anchor.row == this.lead.row &&
	            this.anchor.column == this.lead.column);
	    };
	    Selection.prototype.isMultiLine = function () {
	        return !this.$isEmpty && this.anchor.row != this.cursor.row;
	    };
	    Selection.prototype.getCursor = function () {
	        return this.lead.getPosition();
	    };
	    Selection.prototype.setAnchor = function (row, column) {
	        this.$isEmpty = false;
	        this.anchor.setPosition(row, column);
	    };
	    Selection.prototype.getAnchor = function () {
	        if (this.$isEmpty)
	            return this.getSelectionLead();
	        return this.anchor.getPosition();
	    };
	    Selection.prototype.getSelectionLead = function () {
	        return this.lead.getPosition();
	    };
	    Selection.prototype.isBackwards = function () {
	        var anchor = this.anchor;
	        var lead = this.lead;
	        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
	    };
	    Selection.prototype.getRange = function () {
	        var anchor = this.anchor;
	        var lead = this.lead;
	        if (this.$isEmpty)
	            return Range.fromPoints(lead, lead);
	        return this.isBackwards()
	            ? Range.fromPoints(lead, anchor)
	            : Range.fromPoints(anchor, lead);
	    };
	    Selection.prototype.clearSelection = function () {
	        if (!this.$isEmpty) {
	            this.$isEmpty = true;
	            this._emit("changeSelection");
	        }
	    };
	    Selection.prototype.selectAll = function () {
	        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
	    };
	    Selection.prototype.setRange = function (range, reverse) {
	        var start = reverse ? range.end : range.start;
	        var end = reverse ? range.start : range.end;
	        this.$setSelection(start.row, start.column, end.row, end.column);
	    };
	    Selection.prototype.$setSelection = function (anchorRow, anchorColumn, cursorRow, cursorColumn) {
	        if (this.$silent)
	            return;
	        var wasEmpty = this.$isEmpty;
	        var wasMultiselect = this.inMultiSelectMode;
	        this.$silent = true;
	        this.$cursorChanged = this.$anchorChanged = false;
	        this.anchor.setPosition(anchorRow, anchorColumn);
	        this.cursor.setPosition(cursorRow, cursorColumn);
	        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
	        this.$silent = false;
	        if (this.$cursorChanged)
	            this._emit("changeCursor");
	        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
	            this._emit("changeSelection");
	    };
	    Selection.prototype.$moveSelection = function (mover) {
	        var lead = this.lead;
	        if (this.$isEmpty)
	            this.setSelectionAnchor(lead.row, lead.column);
	        mover.call(this);
	    };
	    Selection.prototype.selectTo = function (row, column) {
	        this.$moveSelection(function () {
	            this.moveCursorTo(row, column);
	        });
	    };
	    Selection.prototype.selectToPosition = function (pos) {
	        this.$moveSelection(function () {
	            this.moveCursorToPosition(pos);
	        });
	    };
	    Selection.prototype.moveTo = function (row, column) {
	        this.clearSelection();
	        this.moveCursorTo(row, column);
	    };
	    Selection.prototype.moveToPosition = function (pos) {
	        this.clearSelection();
	        this.moveCursorToPosition(pos);
	    };
	    Selection.prototype.selectUp = function () {
	        this.$moveSelection(this.moveCursorUp);
	    };
	    Selection.prototype.selectDown = function () {
	        this.$moveSelection(this.moveCursorDown);
	    };
	    Selection.prototype.selectRight = function () {
	        this.$moveSelection(this.moveCursorRight);
	    };
	    Selection.prototype.selectLeft = function () {
	        this.$moveSelection(this.moveCursorLeft);
	    };
	    Selection.prototype.selectLineStart = function () {
	        this.$moveSelection(this.moveCursorLineStart);
	    };
	    Selection.prototype.selectLineEnd = function () {
	        this.$moveSelection(this.moveCursorLineEnd);
	    };
	    Selection.prototype.selectFileEnd = function () {
	        this.$moveSelection(this.moveCursorFileEnd);
	    };
	    Selection.prototype.selectFileStart = function () {
	        this.$moveSelection(this.moveCursorFileStart);
	    };
	    Selection.prototype.selectWordRight = function () {
	        this.$moveSelection(this.moveCursorWordRight);
	    };
	    Selection.prototype.selectWordLeft = function () {
	        this.$moveSelection(this.moveCursorWordLeft);
	    };
	    Selection.prototype.getWordRange = function (row, column) {
	        if (typeof column == "undefined") {
	            var cursor = row || this.lead;
	            row = cursor.row;
	            column = cursor.column;
	        }
	        return this.session.getWordRange(row, column);
	    };
	    Selection.prototype.selectWord = function () {
	        this.setSelectionRange(this.getWordRange());
	    };
	    Selection.prototype.selectAWord = function () {
	        var cursor = this.getCursor();
	        var range = this.session.getAWordRange(cursor.row, cursor.column);
	        this.setSelectionRange(range);
	    };
	    Selection.prototype.getLineRange = function (row, excludeLastChar) {
	        var rowStart = typeof row == "number" ? row : this.lead.row;
	        var rowEnd;
	        var foldLine = this.session.getFoldLine(rowStart);
	        if (foldLine) {
	            rowStart = foldLine.start.row;
	            rowEnd = foldLine.end.row;
	        }
	        else {
	            rowEnd = rowStart;
	        }
	        if (excludeLastChar === true)
	            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
	        else
	            return new Range(rowStart, 0, rowEnd + 1, 0);
	    };
	    Selection.prototype.selectLine = function () {
	        this.setSelectionRange(this.getLineRange());
	    };
	    Selection.prototype.moveCursorUp = function () {
	        this.moveCursorBy(-1, 0);
	    };
	    Selection.prototype.moveCursorDown = function () {
	        this.moveCursorBy(1, 0);
	    };
	    Selection.prototype.wouldMoveIntoSoftTab = function (cursor, tabSize, direction) {
	        var start = cursor.column;
	        var end = cursor.column + tabSize;
	        if (direction < 0) {
	            start = cursor.column - tabSize;
	            end = cursor.column;
	        }
	        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
	    };
	    Selection.prototype.moveCursorLeft = function () {
	        var cursor = this.lead.getPosition(), fold;
	        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
	            this.moveCursorTo(fold.start.row, fold.start.column);
	        }
	        else if (cursor.column === 0) {
	            if (cursor.row > 0) {
	                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
	            }
	        }
	        else {
	            var tabSize = this.session.getTabSize();
	            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
	                this.moveCursorBy(0, -tabSize);
	            }
	            else {
	                this.moveCursorBy(0, -1);
	            }
	        }
	    };
	    Selection.prototype.moveCursorRight = function () {
	        var cursor = this.lead.getPosition(), fold;
	        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
	            this.moveCursorTo(fold.end.row, fold.end.column);
	        }
	        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
	            if (this.lead.row < this.doc.getLength() - 1) {
	                this.moveCursorTo(this.lead.row + 1, 0);
	            }
	        }
	        else {
	            var tabSize = this.session.getTabSize();
	            var cursor = this.lead;
	            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
	                this.moveCursorBy(0, tabSize);
	            }
	            else {
	                this.moveCursorBy(0, 1);
	            }
	        }
	    };
	    Selection.prototype.moveCursorLineStart = function () {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var screenRow = this.session.documentToScreenRow(row, column);
	        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
	        var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
	        var leadingSpace = beforeCursor.match(/^\s*/);
	        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
	            firstColumnPosition.column += leadingSpace[0].length;
	        this.moveCursorToPosition(firstColumnPosition);
	    };
	    Selection.prototype.moveCursorLineEnd = function () {
	        var lead = this.lead;
	        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
	        if (this.lead.column == lineEnd.column) {
	            var line = this.session.getLine(lineEnd.row);
	            if (lineEnd.column == line.length) {
	                var textEnd = line.search(/\s+$/);
	                if (textEnd > 0)
	                    lineEnd.column = textEnd;
	            }
	        }
	        this.moveCursorTo(lineEnd.row, lineEnd.column);
	    };
	    Selection.prototype.moveCursorFileEnd = function () {
	        var row = this.doc.getLength() - 1;
	        var column = this.doc.getLine(row).length;
	        this.moveCursorTo(row, column);
	    };
	    Selection.prototype.moveCursorFileStart = function () {
	        this.moveCursorTo(0, 0);
	    };
	    Selection.prototype.moveCursorLongWordRight = function () {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var line = this.doc.getLine(row);
	        var rightOfCursor = line.substring(column);
	        this.session.nonTokenRe.lastIndex = 0;
	        this.session.tokenRe.lastIndex = 0;
	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold) {
	            this.moveCursorTo(fold.end.row, fold.end.column);
	            return;
	        }
	        if (this.session.nonTokenRe.exec(rightOfCursor)) {
	            column += this.session.nonTokenRe.lastIndex;
	            this.session.nonTokenRe.lastIndex = 0;
	            rightOfCursor = line.substring(column);
	        }
	        if (column >= line.length) {
	            this.moveCursorTo(row, line.length);
	            this.moveCursorRight();
	            if (row < this.doc.getLength() - 1)
	                this.moveCursorWordRight();
	            return;
	        }
	        if (this.session.tokenRe.exec(rightOfCursor)) {
	            column += this.session.tokenRe.lastIndex;
	            this.session.tokenRe.lastIndex = 0;
	        }
	        this.moveCursorTo(row, column);
	    };
	    Selection.prototype.moveCursorLongWordLeft = function () {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var fold;
	        if (fold = this.session.getFoldAt(row, column, -1)) {
	            this.moveCursorTo(fold.start.row, fold.start.column);
	            return;
	        }
	        var str = this.session.getFoldStringAt(row, column, -1);
	        if (str == null) {
	            str = this.doc.getLine(row).substring(0, column);
	        }
	        var leftOfCursor = lang.stringReverse(str);
	        this.session.nonTokenRe.lastIndex = 0;
	        this.session.tokenRe.lastIndex = 0;
	        if (this.session.nonTokenRe.exec(leftOfCursor)) {
	            column -= this.session.nonTokenRe.lastIndex;
	            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
	            this.session.nonTokenRe.lastIndex = 0;
	        }
	        if (column <= 0) {
	            this.moveCursorTo(row, 0);
	            this.moveCursorLeft();
	            if (row > 0)
	                this.moveCursorWordLeft();
	            return;
	        }
	        if (this.session.tokenRe.exec(leftOfCursor)) {
	            column -= this.session.tokenRe.lastIndex;
	            this.session.tokenRe.lastIndex = 0;
	        }
	        this.moveCursorTo(row, column);
	    };
	    Selection.prototype.$shortWordEndIndex = function (rightOfCursor) {
	        var index = 0, ch;
	        var whitespaceRe = /\s/;
	        var tokenRe = this.session.tokenRe;
	        tokenRe.lastIndex = 0;
	        if (this.session.tokenRe.exec(rightOfCursor)) {
	            index = this.session.tokenRe.lastIndex;
	        }
	        else {
	            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
	                index++;
	            if (index < 1) {
	                tokenRe.lastIndex = 0;
	                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
	                    tokenRe.lastIndex = 0;
	                    index++;
	                    if (whitespaceRe.test(ch)) {
	                        if (index > 2) {
	                            index--;
	                            break;
	                        }
	                        else {
	                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
	                                index++;
	                            if (index > 2)
	                                break;
	                        }
	                    }
	                }
	            }
	        }
	        tokenRe.lastIndex = 0;
	        return index;
	    };
	    Selection.prototype.moveCursorShortWordRight = function () {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var line = this.doc.getLine(row);
	        var rightOfCursor = line.substring(column);
	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold)
	            return this.moveCursorTo(fold.end.row, fold.end.column);
	        if (column == line.length) {
	            var l = this.doc.getLength();
	            do {
	                row++;
	                rightOfCursor = this.doc.getLine(row);
	            } while (row < l && /^\s*$/.test(rightOfCursor));
	            if (!/^\s+/.test(rightOfCursor))
	                rightOfCursor = "";
	            column = 0;
	        }
	        var index = this.$shortWordEndIndex(rightOfCursor);
	        this.moveCursorTo(row, column + index);
	    };
	    Selection.prototype.moveCursorShortWordLeft = function () {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var fold;
	        if (fold = this.session.getFoldAt(row, column, -1))
	            return this.moveCursorTo(fold.start.row, fold.start.column);
	        var line = this.session.getLine(row).substring(0, column);
	        if (column === 0) {
	            do {
	                row--;
	                line = this.doc.getLine(row);
	            } while (row > 0 && /^\s*$/.test(line));
	            column = line.length;
	            if (!/\s+$/.test(line))
	                line = "";
	        }
	        var leftOfCursor = lang.stringReverse(line);
	        var index = this.$shortWordEndIndex(leftOfCursor);
	        return this.moveCursorTo(row, column - index);
	    };
	    Selection.prototype.moveCursorWordRight = function () {
	        if (this.session.$selectLongWords)
	            this.moveCursorLongWordRight();
	        else
	            this.moveCursorShortWordRight();
	    };
	    Selection.prototype.moveCursorWordLeft = function () {
	        if (this.session.$selectLongWords)
	            this.moveCursorLongWordLeft();
	        else
	            this.moveCursorShortWordLeft();
	    };
	    Selection.prototype.moveCursorBy = function (rows, chars) {
	        var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
	        var offsetX;
	        if (chars === 0) {
	            if (rows !== 0) {
	                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
	                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
	                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
	                }
	                else {
	                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
	                }
	            }
	            if (this.$desiredColumn)
	                screenPos.column = this.$desiredColumn;
	            else
	                this.$desiredColumn = screenPos.column;
	        }
	        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
	            var widget = this.session.lineWidgets[this.lead.row];
	            if (rows < 0)
	                rows -= widget.rowsAbove || 0;
	            else if (rows > 0)
	                rows += widget.rowCount - (widget.rowsAbove || 0);
	        }
	        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
	        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) ;
	        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
	    };
	    Selection.prototype.moveCursorToPosition = function (position) {
	        this.moveCursorTo(position.row, position.column);
	    };
	    Selection.prototype.moveCursorTo = function (row, column, keepDesiredColumn) {
	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold) {
	            row = fold.start.row;
	            column = fold.start.column;
	        }
	        this.$keepDesiredColumnOnChange = true;
	        var line = this.session.getLine(row);
	        if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
	            if (this.lead.row == row && this.lead.column == column + 1)
	                column = column - 1;
	            else
	                column = column + 1;
	        }
	        this.lead.setPosition(row, column);
	        this.$keepDesiredColumnOnChange = false;
	        if (!keepDesiredColumn)
	            this.$desiredColumn = null;
	    };
	    Selection.prototype.moveCursorToScreen = function (row, column, keepDesiredColumn) {
	        var pos = this.session.screenToDocumentPosition(row, column);
	        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
	    };
	    Selection.prototype.detach = function () {
	        this.lead.detach();
	        this.anchor.detach();
	    };
	    Selection.prototype.fromOrientedRange = function (range) {
	        this.setSelectionRange(range, range.cursor == range.start);
	        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
	    };
	    Selection.prototype.toOrientedRange = function (range) {
	        var r = this.getRange();
	        if (range) {
	            range.start.column = r.start.column;
	            range.start.row = r.start.row;
	            range.end.column = r.end.column;
	            range.end.row = r.end.row;
	        }
	        else {
	            range = r;
	        }
	        range.cursor = this.isBackwards() ? range.start : range.end;
	        range.desiredColumn = this.$desiredColumn;
	        return range;
	    };
	    Selection.prototype.getRangeOfMovements = function (func) {
	        var start = this.getCursor();
	        try {
	            func(this);
	            var end = this.getCursor();
	            return Range.fromPoints(start, end);
	        }
	        catch (e) {
	            return Range.fromPoints(start, start);
	        }
	        finally {
	            this.moveCursorToPosition(start);
	        }
	    };
	    Selection.prototype.toJSON = function () {
	        if (this.rangeCount) { var data = this.ranges.map(function (r) {
	                var r1 = r.clone();
	                r1.isBackwards = r.cursor == r.start;
	                return r1;
	            });
	        }
	        else { var data = this.getRange();
	            data.isBackwards = this.isBackwards();
	        }
	        return data;
	    };
	    Selection.prototype.fromJSON = function (data) {
	        if (data.start == undefined) {
	            if (this.rangeList && data.length > 1) {
	                this.toSingleRange(data[0]);
	                for (var i = data.length; i--;) {
	                    var r = Range.fromPoints(data[i].start, data[i].end);
	                    if (data[i].isBackwards)
	                        r.cursor = r.start;
	                    this.addRange(r, true);
	                }
	                return;
	            }
	            else {
	                data = data[0];
	            }
	        }
	        if (this.rangeList)
	            this.toSingleRange(data);
	        this.setSelectionRange(data, data.isBackwards);
	    };
	    Selection.prototype.isEqual = function (data) {
	        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
	            return false;
	        if (!data.length || !this.ranges)
	            return this.getRange().isEqual(data);
	        for (var i = this.ranges.length; i--;) {
	            if (!this.ranges[i].isEqual(data[i]))
	                return false;
	        }
	        return true;
	    };
	    return Selection;
	}());
	Selection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;
	Selection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;
	Selection.prototype.setSelectionRange = Selection.prototype.setRange;
	oop.implement(Selection.prototype, EventEmitter);
	exports.Selection = Selection;

	});

	ace.define("ace/tokenizer",["require","exports","module","ace/lib/report_error"], function(require, exports, module){	var reportError = require("./lib/report_error").reportError;
	var MAX_TOKEN_COUNT = 2000;
	var Tokenizer = /** @class */ (function () {
	    function Tokenizer(rules) {
	        this.splitRegex;
	        this.states = rules;
	        this.regExps = {};
	        this.matchMappings = {};
	        for (var key in this.states) {
	            var state = this.states[key];
	            var ruleRegExps = [];
	            var matchTotal = 0;
	            var mapping = this.matchMappings[key] = { defaultToken: "text" };
	            var flag = "g";
	            var splitterRurles = [];
	            for (var i = 0; i < state.length; i++) {
	                var rule = state[i];
	                if (rule.defaultToken)
	                    mapping.defaultToken = rule.defaultToken;
	                if (rule.caseInsensitive && flag.indexOf("i") === -1)
	                    flag += "i";
	                if (rule.unicode && flag.indexOf("u") === -1)
	                    flag += "u";
	                if (rule.regex == null)
	                    continue;
	                if (rule.regex instanceof RegExp)
	                    rule.regex = rule.regex.toString().slice(1, -1);
	                var adjustedregex = rule.regex;
	                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
	                if (Array.isArray(rule.token)) {
	                    if (rule.token.length == 1 || matchcount == 1) {
	                        rule.token = rule.token[0];
	                    }
	                    else if (matchcount - 1 != rule.token.length) {
	                        this.reportError("number of classes and regexp groups doesn't match", {
	                            rule: rule,
	                            groupCount: matchcount - 1
	                        });
	                        rule.token = rule.token[0];
	                    }
	                    else {
	                        rule.tokenArray = rule.token;
	                        rule.token = null;
	                        rule.onMatch = this.$arrayTokens;
	                    }
	                }
	                else if (typeof rule.token == "function" && !rule.onMatch) {
	                    if (matchcount > 1)
	                        rule.onMatch = this.$applyToken;
	                    else
	                        rule.onMatch = rule.token;
	                }
	                if (matchcount > 1) {
	                    if (/\\\d/.test(rule.regex)) {
	                        adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
	                            return "\\" + (parseInt(digit, 10) + matchTotal + 1);
	                        });
	                    }
	                    else {
	                        matchcount = 1;
	                        adjustedregex = this.removeCapturingGroups(rule.regex);
	                    }
	                    if (!rule.splitRegex && typeof rule.token != "string")
	                        splitterRurles.push(rule); // flag will be known only at the very end
	                }
	                mapping[matchTotal] = i;
	                matchTotal += matchcount;
	                ruleRegExps.push(adjustedregex);
	                if (!rule.onMatch)
	                    rule.onMatch = null;
	            }
	            if (!ruleRegExps.length) {
	                mapping[0] = 0;
	                ruleRegExps.push("$");
	            }
	            splitterRurles.forEach(function (rule) {
	                rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
	            }, this);
	            this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
	        }
	    }
	    Tokenizer.prototype.$setMaxTokenCount = function (m) {
	        MAX_TOKEN_COUNT = m | 0;
	    };
	    Tokenizer.prototype.$applyToken = function (str) {
	        var values = this.splitRegex.exec(str).slice(1);
	        var types = this.token.apply(this, values);
	        if (typeof types === "string")
	            return [{ type: types, value: str }];
	        var tokens = [];
	        for (var i = 0, l = types.length; i < l; i++) {
	            if (values[i])
	                tokens[tokens.length] = {
	                    type: types[i],
	                    value: values[i]
	                };
	        }
	        return tokens;
	    };
	    Tokenizer.prototype.$arrayTokens = function (str) {
	        if (!str)
	            return [];
	        var values = this.splitRegex.exec(str);
	        if (!values)
	            return "text";
	        var tokens = [];
	        var types = this.tokenArray;
	        for (var i = 0, l = types.length; i < l; i++) {
	            if (values[i + 1])
	                tokens[tokens.length] = {
	                    type: types[i],
	                    value: values[i + 1]
	                };
	        }
	        return tokens;
	    };
	    Tokenizer.prototype.removeCapturingGroups = function (src) {
	        var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function (x, y) { return y ? "(?:" : x; });
	        return r;
	    };
	    Tokenizer.prototype.createSplitterRegexp = function (src, flag) {
	        if (src.indexOf("(?=") != -1) {
	            var stack = 0;
	            var inChClass = false;
	            var lastCapture = {};
	            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
	                if (inChClass) {
	                    inChClass = square != "]";
	                }
	                else if (square) {
	                    inChClass = true;
	                }
	                else if (parenClose) {
	                    if (stack == lastCapture.stack) {
	                        lastCapture.end = index + 1;
	                        lastCapture.stack = -1;
	                    }
	                    stack--;
	                }
	                else if (parenOpen) {
	                    stack++;
	                    if (parenOpen.length != 1) {
	                        lastCapture.stack = stack;
	                        lastCapture.start = index;
	                    }
	                }
	                return m;
	            });
	            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
	                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
	        }
	        if (src.charAt(0) != "^")
	            src = "^" + src;
	        if (src.charAt(src.length - 1) != "$")
	            src += "$";
	        return new RegExp(src, (flag || "").replace("g", ""));
	    };
	    Tokenizer.prototype.getLineTokens = function (line, startState) {
	        if (startState && typeof startState != "string") {
	            var stack = startState.slice(0);
	            startState = stack[0];
	            if (startState === "#tmp") {
	                stack.shift();
	                startState = stack.shift();
	            }
	        }
	        else
	            var stack = [];
	        var currentState = /**@type{string}*/ (startState) || "start";
	        var state = this.states[currentState];
	        if (!state) {
	            currentState = "start";
	            state = this.states[currentState];
	        }
	        var mapping = this.matchMappings[currentState];
	        var re = this.regExps[currentState];
	        re.lastIndex = 0;
	        var match, tokens = [];
	        var lastIndex = 0;
	        var matchAttempts = 0;
	        var token = { type: null, value: "" };
	        while (match = re.exec(line)) {
	            var type = mapping.defaultToken;
	            var rule = null;
	            var value = match[0];
	            var index = re.lastIndex;
	            if (index - value.length > lastIndex) {
	                var skipped = line.substring(lastIndex, index - value.length);
	                if (token.type == type) {
	                    token.value += skipped;
	                }
	                else {
	                    if (token.type)
	                        tokens.push(token);
	                    token = { type: type, value: skipped };
	                }
	            }
	            for (var i = 0; i < match.length - 2; i++) {
	                if (match[i + 1] === undefined)
	                    continue;
	                rule = state[mapping[i]];
	                if (rule.onMatch)
	                    type = rule.onMatch(value, currentState, stack, line);
	                else
	                    type = rule.token;
	                if (rule.next) {
	                    if (typeof rule.next == "string") {
	                        currentState = rule.next;
	                    }
	                    else {
	                        currentState = rule.next(currentState, stack);
	                    }
	                    state = this.states[currentState];
	                    if (!state) {
	                        this.reportError("state doesn't exist", currentState);
	                        currentState = "start";
	                        state = this.states[currentState];
	                    }
	                    mapping = this.matchMappings[currentState];
	                    lastIndex = index;
	                    re = this.regExps[currentState];
	                    re.lastIndex = index;
	                }
	                if (rule.consumeLineEnd)
	                    lastIndex = index;
	                break;
	            }
	            if (value) {
	                if (typeof type === "string") {
	                    if ((!rule || rule.merge !== false) && token.type === type) {
	                        token.value += value;
	                    }
	                    else {
	                        if (token.type)
	                            tokens.push(token);
	                        token = { type: type, value: value };
	                    }
	                }
	                else if (type) {
	                    if (token.type)
	                        tokens.push(token);
	                    token = { type: null, value: "" };
	                    for (var i = 0; i < type.length; i++)
	                        tokens.push(type[i]);
	                }
	            }
	            if (lastIndex == line.length)
	                break;
	            lastIndex = index;
	            if (matchAttempts++ > MAX_TOKEN_COUNT) {
	                if (matchAttempts > 2 * line.length) {
	                    this.reportError("infinite loop with in ace tokenizer", {
	                        startState: startState,
	                        line: line
	                    });
	                }
	                while (lastIndex < line.length) {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {
	                        value: line.substring(lastIndex, lastIndex += 500),
	                        type: "overflow"
	                    };
	                }
	                currentState = "start";
	                stack = [];
	                break;
	            }
	        }
	        if (token.type)
	            tokens.push(token);
	        if (stack.length > 1) {
	            if (stack[0] !== currentState)
	                stack.unshift("#tmp", currentState);
	        }
	        return {
	            tokens: tokens,
	            state: stack.length ? stack : currentState
	        };
	    };
	    return Tokenizer;
	}());
	Tokenizer.prototype.reportError = reportError;
	exports.Tokenizer = Tokenizer;

	});

	ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/deep_copy"], function(require, exports, module){	var deepCopy = require("../lib/deep_copy").deepCopy;
	var TextHighlightRules;
	TextHighlightRules = function () {
	    this.$rules = {
	        "start": [{
	                token: "empty_line",
	                regex: '^$'
	            }, {
	                defaultToken: "text"
	            }]
	    };
	};
	(function () {
	    this.addRules = function (rules, prefix) {
	        if (!prefix) {
	            for (var key in rules)
	                this.$rules[key] = rules[key];
	            return;
	        }
	        for (var key in rules) {
	            var state = rules[key];
	            for (var i = 0; i < state.length; i++) {
	                var rule = state[i];
	                if (rule.next || rule.onMatch) {
	                    if (typeof rule.next == "string") {
	                        if (rule.next.indexOf(prefix) !== 0)
	                            rule.next = prefix + rule.next;
	                    }
	                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
	                        rule.nextState = prefix + rule.nextState;
	                }
	            }
	            this.$rules[prefix + key] = state;
	        }
	    };
	    this.getRules = function () {
	        return this.$rules;
	    };
	    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
	        var embedRules = typeof HighlightRules == "function"
	            ? new HighlightRules().getRules()
	            : HighlightRules;
	        if (states) {
	            for (var i = 0; i < states.length; i++)
	                states[i] = prefix + states[i];
	        }
	        else {
	            states = [];
	            for (var key in embedRules)
	                states.push(prefix + key);
	        }
	        this.addRules(embedRules, prefix);
	        if (escapeRules) {
	            var addRules = Array.prototype[append ? "push" : "unshift"];
	            for (var i = 0; i < states.length; i++)
	                addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));
	        }
	        if (!this.$embeds)
	            this.$embeds = [];
	        this.$embeds.push(prefix);
	    };
	    this.getEmbeds = function () {
	        return this.$embeds;
	    };
	    var pushState = function (currentState, stack) {
	        if (currentState != "start" || stack.length)
	            stack.unshift(this.nextState, currentState);
	        return this.nextState;
	    };
	    var popState = function (currentState, stack) {
	        stack.shift();
	        return stack.shift() || "start";
	    };
	    this.normalizeRules = function () {
	        var id = 0;
	        var rules = this.$rules;
	        function processState(key) {
	            var state = rules[key];
	            state["processed"] = true;
	            for (var i = 0; i < state.length; i++) {
	                var rule = state[i];
	                var toInsert = null;
	                if (Array.isArray(rule)) {
	                    toInsert = rule;
	                    rule = {};
	                }
	                if (!rule.regex && rule.start) {
	                    rule.regex = rule.start;
	                    if (!rule.next)
	                        rule.next = [];
	                    rule.next.push({
	                        defaultToken: rule.token
	                    }, {
	                        token: rule.token + ".end",
	                        regex: rule.end || rule.start,
	                        next: "pop"
	                    });
	                    rule.token = rule.token + ".start";
	                    rule.push = true;
	                }
	                var next = rule.next || rule.push;
	                if (next && Array.isArray(next)) {
	                    var stateName = rule.stateName;
	                    if (!stateName) {
	                        stateName = rule.token;
	                        if (typeof stateName != "string")
	                            stateName = stateName[0] || "";
	                        if (rules[stateName])
	                            stateName += id++;
	                    }
	                    rules[stateName] = next;
	                    rule.next = stateName;
	                    processState(stateName);
	                }
	                else if (next == "pop") {
	                    rule.next = popState;
	                }
	                if (rule.push) {
	                    rule.nextState = rule.next || rule.push;
	                    rule.next = pushState;
	                    delete rule.push;
	                }
	                if (rule.rules) {
	                    for (var r in rule.rules) {
	                        if (rules[r]) {
	                            if (rules[r].push)
	                                rules[r].push.apply(rules[r], rule.rules[r]);
	                        }
	                        else {
	                            rules[r] = rule.rules[r];
	                        }
	                    }
	                }
	                var includeName = typeof rule == "string" ? rule : rule.include;
	                if (includeName) {
	                    if (includeName === "$self")
	                        includeName = "start";
	                    if (Array.isArray(includeName))
	                        toInsert = includeName.map(function (x) { return rules[x]; });
	                    else
	                        toInsert = rules[includeName];
	                }
	                if (toInsert) {
	                    var args = [i, 1].concat(toInsert);
	                    if (rule.noEscape)
	                        args = args.filter(function (x) { return !x.next; });
	                    state.splice.apply(state, args);
	                    i--;
	                }
	                if (rule.keywordMap) {
	                    rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
	                    delete rule.defaultToken;
	                }
	            }
	        }
	        Object.keys(rules).forEach(processState, this);
	    };
	    this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {
	        var keywords = Object.create(null);
	        this.$keywordList = [];
	        Object.keys(map).forEach(function (className) {
	            var a = map[className];
	            var list = a.split(splitChar || "|");
	            for (var i = list.length; i--;) {
	                var word = list[i];
	                this.$keywordList.push(word);
	                if (ignoreCase)
	                    word = word.toLowerCase();
	                keywords[word] = className;
	            }
	        }, this);
	        map = null;
	        return ignoreCase
	            ? function (value) { return keywords[value.toLowerCase()] || defaultToken; }
	            : function (value) { return keywords[value] || defaultToken; };
	    };
	    this.getKeywords = function () {
	        return this.$keywords;
	    };
	}).call(TextHighlightRules.prototype);
	exports.TextHighlightRules = TextHighlightRules;

	});

	ace.define("ace/mode/behaviour",["require","exports","module"], function(require, exports, module){	var Behaviour;
	Behaviour = function () {
	    this.$behaviours = {};
	};
	(function () {
	    this.add = function (name, action, callback) {
	        switch (undefined) {
	            case this.$behaviours:
	                this.$behaviours = {};
	            case this.$behaviours[name]:
	                this.$behaviours[name] = {};
	        }
	        this.$behaviours[name][action] = callback;
	    };
	    this.addBehaviours = function (behaviours) {
	        for (var key in behaviours) {
	            for (var action in behaviours[key]) {
	                this.add(key, action, behaviours[key][action]);
	            }
	        }
	    };
	    this.remove = function (name) {
	        if (this.$behaviours && this.$behaviours[name]) {
	            delete this.$behaviours[name];
	        }
	    };
	    this.inherit = function (mode, filter) {
	        if (typeof mode === "function") {
	            var behaviours = new mode().getBehaviours(filter);
	        }
	        else {
	            var behaviours = mode.getBehaviours(filter);
	        }
	        this.addBehaviours(behaviours);
	    };
	    this.getBehaviours = function (filter) {
	        if (!filter) {
	            return this.$behaviours;
	        }
	        else {
	            var ret = {};
	            for (var i = 0; i < filter.length; i++) {
	                if (this.$behaviours[filter[i]]) {
	                    ret[filter[i]] = this.$behaviours[filter[i]];
	                }
	            }
	            return ret;
	        }
	    };
	}).call(Behaviour.prototype);
	exports.Behaviour = Behaviour;

	});

	ace.define("ace/token_iterator",["require","exports","module","ace/range"], function(require, exports, module){	var Range = require("./range").Range;
	var TokenIterator = /** @class */ (function () {
	    function TokenIterator(session, initialRow, initialColumn) {
	        this.$session = session;
	        this.$row = initialRow;
	        this.$rowTokens = session.getTokens(initialRow);
	        var token = session.getTokenAt(initialRow, initialColumn);
	        this.$tokenIndex = token ? token.index : -1;
	    }
	    TokenIterator.prototype.stepBackward = function () {
	        this.$tokenIndex -= 1;
	        while (this.$tokenIndex < 0) {
	            this.$row -= 1;
	            if (this.$row < 0) {
	                this.$row = 0;
	                return null;
	            }
	            this.$rowTokens = this.$session.getTokens(this.$row);
	            this.$tokenIndex = this.$rowTokens.length - 1;
	        }
	        return this.$rowTokens[this.$tokenIndex];
	    };
	    TokenIterator.prototype.stepForward = function () {
	        this.$tokenIndex += 1;
	        var rowCount;
	        while (this.$tokenIndex >= this.$rowTokens.length) {
	            this.$row += 1;
	            if (!rowCount)
	                rowCount = this.$session.getLength();
	            if (this.$row >= rowCount) {
	                this.$row = rowCount - 1;
	                return null;
	            }
	            this.$rowTokens = this.$session.getTokens(this.$row);
	            this.$tokenIndex = 0;
	        }
	        return this.$rowTokens[this.$tokenIndex];
	    };
	    TokenIterator.prototype.getCurrentToken = function () {
	        return this.$rowTokens[this.$tokenIndex];
	    };
	    TokenIterator.prototype.getCurrentTokenRow = function () {
	        return this.$row;
	    };
	    TokenIterator.prototype.getCurrentTokenColumn = function () {
	        var rowTokens = this.$rowTokens;
	        var tokenIndex = this.$tokenIndex;
	        var column = rowTokens[tokenIndex].start;
	        if (column !== undefined)
	            return column;
	        column = 0;
	        while (tokenIndex > 0) {
	            tokenIndex -= 1;
	            column += rowTokens[tokenIndex].value.length;
	        }
	        return column;
	    };
	    TokenIterator.prototype.getCurrentTokenPosition = function () {
	        return { row: this.$row, column: this.getCurrentTokenColumn() };
	    };
	    TokenIterator.prototype.getCurrentTokenRange = function () {
	        var token = this.$rowTokens[this.$tokenIndex];
	        var column = this.getCurrentTokenColumn();
	        return new Range(this.$row, column, this.$row, column + token.value.length);
	    };
	    return TokenIterator;
	}());
	exports.TokenIterator = TokenIterator;

	});

	ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module){	var oop = require("../../lib/oop");
	var Behaviour = require("../behaviour").Behaviour;
	var TokenIterator = require("../../token_iterator").TokenIterator;
	var lang = require("../../lib/lang");
	var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
	var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];
	var context;
	var contextCache = {};
	var defaultQuotes = { '"': '"', "'": "'" };
	var initContext = function (editor) {
	    var id = -1;
	    if (editor.multiSelect) {
	        id = editor.selection.index;
	        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
	            contextCache = { rangeCount: editor.multiSelect.rangeCount };
	    }
	    if (contextCache[id])
	        return context = contextCache[id];
	    context = contextCache[id] = {
	        autoInsertedBrackets: 0,
	        autoInsertedRow: -1,
	        autoInsertedLineEnd: "",
	        maybeInsertedBrackets: 0,
	        maybeInsertedRow: -1,
	        maybeInsertedLineStart: "",
	        maybeInsertedLineEnd: ""
	    };
	};
	var getWrapped = function (selection, selected, opening, closing) {
	    var rowDiff = selection.end.row - selection.start.row;
	    return {
	        text: opening + selected + closing,
	        selection: [
	            0,
	            selection.start.column + 1,
	            rowDiff,
	            selection.end.column + (rowDiff ? 0 : 1)
	        ]
	    };
	};
	var CstyleBehaviour;
	CstyleBehaviour = function (options) {
	    options = options || {};
	    this.add("braces", "insertion", function (state, action, editor, session, text) {
	        var cursor = editor.getCursorPosition();
	        var line = session.doc.getLine(cursor.row);
	        if (text == '{') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            var token = session.getTokenAt(cursor.row, cursor.column);
	            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '{', '}');
	            }
	            else if (token && /(?:string)\.quasi|\.xml/.test(token.type)) {
	                var excludeTokens = [
	                    /tag\-(?:open|name)/, /attribute\-name/
	                ];
	                if (excludeTokens.some(function (el) { return el.test(token.type); }) || /(string)\.quasi/.test(token.type)
	                    && token.value[cursor.column - token.start - 1] !== '$')
	                    return;
	                CstyleBehaviour.recordAutoInsert(editor, session, "}");
	                return {
	                    text: '{}',
	                    selection: [1, 1]
	                };
	            }
	            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options.braces) {
	                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
	                    return {
	                        text: '{}',
	                        selection: [1, 1]
	                    };
	                }
	                else {
	                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
	                    return {
	                        text: '{',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	        else if (text == '}') {
	            initContext(editor);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == '}') {
	                var matching = session.$findOpeningBracket('}', { column: cursor.column + 1, row: cursor.row });
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	        else if (text == "\n" || text == "\r\n") {
	            initContext(editor);
	            var closing = "";
	            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
	                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
	                CstyleBehaviour.clearMaybeInsertedClosing();
	            }
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar === '}') {
	                var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, '}');
	                if (!openBracePos)
	                    return null;
	                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
	            }
	            else if (closing) {
	                var next_indent = this.$getIndent(line);
	            }
	            else {
	                CstyleBehaviour.clearMaybeInsertedClosing();
	                return;
	            }
	            var indent = next_indent + session.getTabString();
	            return {
	                text: '\n' + indent + '\n' + next_indent + closing,
	                selection: [1, indent.length, 1, indent.length]
	            };
	        }
	        else {
	            CstyleBehaviour.clearMaybeInsertedClosing();
	        }
	    });
	    this.add("braces", "deletion", function (state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '{') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.end.column, range.end.column + 1);
	            if (rightChar == '}') {
	                range.end.column++;
	                return range;
	            }
	            else {
	                context.maybeInsertedBrackets--;
	            }
	        }
	    });
	    this.add("parens", "insertion", function (state, action, editor, session, text) {
	        if (text == '(') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '(', ')');
	            }
	            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, ")");
	                return {
	                    text: '()',
	                    selection: [1, 1]
	                };
	            }
	        }
	        else if (text == ')') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ')') {
	                var matching = session.$findOpeningBracket(')', { column: cursor.column + 1, row: cursor.row });
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });
	    this.add("parens", "deletion", function (state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '(') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ')') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });
	    this.add("brackets", "insertion", function (state, action, editor, session, text) {
	        if (text == '[') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '[', ']');
	            }
	            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, "]");
	                return {
	                    text: '[]',
	                    selection: [1, 1]
	                };
	            }
	        }
	        else if (text == ']') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ']') {
	                var matching = session.$findOpeningBracket(']', { column: cursor.column + 1, row: cursor.row });
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });
	    this.add("brackets", "deletion", function (state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '[') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ']') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });
	    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
	        var quotes = session.$mode.$quotes || defaultQuotes;
	        if (text.length == 1 && quotes[text]) {
	            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
	                return;
	            initContext(editor);
	            var quote = text;
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, quote, quote);
	            }
	            else if (!selected) {
	                var cursor = editor.getCursorPosition();
	                var line = session.doc.getLine(cursor.row);
	                var leftChar = line.substring(cursor.column - 1, cursor.column);
	                var rightChar = line.substring(cursor.column, cursor.column + 1);
	                var token = session.getTokenAt(cursor.row, cursor.column);
	                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
	                if (leftChar == "\\" && token && /escape/.test(token.type))
	                    return null;
	                var stringBefore = token && /string|escape/.test(token.type);
	                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
	                var pair;
	                if (rightChar == quote) {
	                    pair = stringBefore !== stringAfter;
	                    if (pair && /string\.end/.test(rightToken.type))
	                        pair = false;
	                }
	                else {
	                    if (stringBefore && !stringAfter)
	                        return null; // wrap string with different quote
	                    if (stringBefore && stringAfter)
	                        return null; // do not pair quotes inside strings
	                    var wordRe = session.$mode.tokenRe;
	                    wordRe.lastIndex = 0;
	                    var isWordBefore = wordRe.test(leftChar);
	                    wordRe.lastIndex = 0;
	                    var isWordAfter = wordRe.test(rightChar);
	                    var pairQuotesAfter = session.$mode.$pairQuotesAfter;
	                    var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);
	                    if ((!shouldPairQuotes && isWordBefore) || isWordAfter)
	                        return null; // before or after alphanumeric
	                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
	                        return null; // there is rightChar and it isn't closing
	                    var charBefore = line[cursor.column - 2];
	                    if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))
	                        return null;
	                    pair = true;
	                }
	                return {
	                    text: pair ? quote + quote : "",
	                    selection: [1, 1]
	                };
	            }
	        }
	    });
	    this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
	        var quotes = session.$mode.$quotes || defaultQuotes;
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == selected) {
	                range.end.column++;
	                return range;
	            }
	        }
	    });
	    if (options.closeDocComment !== false) {
	        this.add("doc comment end", "insertion", function (state, action, editor, session, text) {
	            if (state === "doc-start" && (text === "\n" || text === "\r\n") && editor.selection.isEmpty()) {
	                var cursor = editor.getCursorPosition();
	                if (cursor.column === 0) {
	                    return;
	                }
	                var line = session.doc.getLine(cursor.row);
	                var nextLine = session.doc.getLine(cursor.row + 1);
	                var tokens = session.getTokens(cursor.row);
	                var index = 0;
	                for (var i = 0; i < tokens.length; i++) {
	                    index += tokens[i].value.length;
	                    var currentToken = tokens[i];
	                    if (index >= cursor.column) {
	                        if (index === cursor.column) {
	                            if (!/\.doc/.test(currentToken.type)) {
	                                return;
	                            }
	                            if (/\*\//.test(currentToken.value)) {
	                                var nextToken = tokens[i + 1];
	                                if (!nextToken || !/\.doc/.test(nextToken.type)) {
	                                    return;
	                                }
	                            }
	                        }
	                        var cursorPosInToken = cursor.column - (index - currentToken.value.length);
	                        var closeDocPos = currentToken.value.indexOf("*/");
	                        var openDocPos = currentToken.value.indexOf("/**", closeDocPos > -1 ? closeDocPos + 2 : 0);
	                        if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) {
	                            return;
	                        }
	                        if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos
	                            && cursorPosInToken <= openDocPos || !/\.doc/.test(currentToken.type)) {
	                            return;
	                        }
	                        break;
	                    }
	                }
	                var indent = this.$getIndent(line);
	                if (/\s*\*/.test(nextLine)) {
	                    if (/^\s*\*/.test(line)) {
	                        return {
	                            text: text + indent + "* ",
	                            selection: [1, 2 + indent.length, 1, 2 + indent.length]
	                        };
	                    }
	                    else {
	                        return {
	                            text: text + indent + " * ",
	                            selection: [1, 3 + indent.length, 1, 3 + indent.length]
	                        };
	                    }
	                }
	                if (/\/\*\*/.test(line.substring(0, cursor.column))) {
	                    return {
	                        text: text + indent + " * " + text + " " + indent + "*/",
	                        selection: [1, 4 + indent.length, 1, 4 + indent.length]
	                    };
	                }
	            }
	        });
	    }
	};
	CstyleBehaviour.isSaneInsertion = function (editor, session) {
	    var cursor = editor.getCursorPosition();
	    var iterator = new TokenIterator(session, cursor.row, cursor.column);
	    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
	        if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
	            return true;
	        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
	        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
	            return false;
	    }
	    iterator.stepForward();
	    return iterator.getCurrentTokenRow() !== cursor.row ||
	        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
	};
	CstyleBehaviour["$matchTokenType"] = function (token, types) {
	    return types.indexOf(token.type || token) > -1;
	};
	CstyleBehaviour["recordAutoInsert"] = function (editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this["isAutoInsertedClosing"](cursor, line, context.autoInsertedLineEnd[0]))
	        context.autoInsertedBrackets = 0;
	    context.autoInsertedRow = cursor.row;
	    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
	    context.autoInsertedBrackets++;
	};
	CstyleBehaviour["recordMaybeInsert"] = function (editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this["isMaybeInsertedClosing"](cursor, line))
	        context.maybeInsertedBrackets = 0;
	    context.maybeInsertedRow = cursor.row;
	    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
	    context.maybeInsertedLineEnd = line.substr(cursor.column);
	    context.maybeInsertedBrackets++;
	};
	CstyleBehaviour["isAutoInsertedClosing"] = function (cursor, line, bracket) {
	    return context.autoInsertedBrackets > 0 &&
	        cursor.row === context.autoInsertedRow &&
	        bracket === context.autoInsertedLineEnd[0] &&
	        line.substr(cursor.column) === context.autoInsertedLineEnd;
	};
	CstyleBehaviour["isMaybeInsertedClosing"] = function (cursor, line) {
	    return context.maybeInsertedBrackets > 0 &&
	        cursor.row === context.maybeInsertedRow &&
	        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
	        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
	};
	CstyleBehaviour["popAutoInsertedClosing"] = function () {
	    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
	    context.autoInsertedBrackets--;
	};
	CstyleBehaviour["clearMaybeInsertedClosing"] = function () {
	    if (context) {
	        context.maybeInsertedBrackets = 0;
	        context.maybeInsertedRow = -1;
	    }
	};
	oop.inherits(CstyleBehaviour, Behaviour);
	exports.CstyleBehaviour = CstyleBehaviour;

	});

	ace.define("ace/unicode",["require","exports","module"], function(require, exports, module){	var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
	var code = 0;
	var str = [];
	for (var i = 0; i < wordChars.length; i += 2) {
	    str.push(code += wordChars[i]);
	    if (wordChars[i + 1])
	        str.push(45, code += wordChars[i + 1]);
	}
	exports.wordChars = String.fromCharCode.apply(null, str);

	});

	ace.define("ace/mode/text",["require","exports","module","ace/config","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour/cstyle","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(require, exports, module){	var config = require("../config");
	var Tokenizer = require("../tokenizer").Tokenizer;
	var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
	var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
	var unicode = require("../unicode");
	var lang = require("../lib/lang");
	var TokenIterator = require("../token_iterator").TokenIterator;
	var Range = require("../range").Range;
	var Mode;
	Mode = function () {
	    this.HighlightRules = TextHighlightRules;
	};
	(function () {
	    this.$defaultBehaviour = new CstyleBehaviour();
	    this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
	    this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
	    this.getTokenizer = function () {
	        if (!this.$tokenizer) {
	            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
	            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
	        }
	        return this.$tokenizer;
	    };
	    this.lineCommentStart = "";
	    this.blockComment = "";
	    this.toggleCommentLines = function (state, session, startRow, endRow) {
	        var doc = session.doc;
	        var ignoreBlankLines = true;
	        var shouldRemove = true;
	        var minIndent = Infinity;
	        var tabSize = session.getTabSize();
	        var insertAtTabStop = false;
	        if (!this.lineCommentStart) {
	            if (!this.blockComment)
	                return false;
	            var lineCommentStart = this.blockComment.start;
	            var lineCommentEnd = this.blockComment.end;
	            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
	            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
	            var comment = function (line, i) {
	                if (testRemove(line, i))
	                    return;
	                if (!ignoreBlankLines || /\S/.test(line)) {
	                    doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
	                    doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
	                }
	            };
	            var uncomment = function (line, i) {
	                var m;
	                if (m = line.match(regexpEnd))
	                    doc.removeInLine(i, line.length - m[0].length, line.length);
	                if (m = line.match(regexpStart))
	                    doc.removeInLine(i, m[1].length, m[0].length);
	            };
	            var testRemove = function (line, row) {
	                if (regexpStart.test(line))
	                    return true;
	                var tokens = session.getTokens(row);
	                for (var i = 0; i < tokens.length; i++) {
	                    if (tokens[i].type === "comment")
	                        return true;
	                }
	            };
	        }
	        else {
	            if (Array.isArray(this.lineCommentStart)) {
	                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
	                var lineCommentStart = this.lineCommentStart[0];
	            }
	            else {
	                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
	                var lineCommentStart = this.lineCommentStart;
	            }
	            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
	            insertAtTabStop = session.getUseSoftTabs();
	            var uncomment = function (line, i) {
	                var m = line.match(regexpStart);
	                if (!m)
	                    return;
	                var start = m[1].length, end = m[0].length;
	                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
	                    end--;
	                doc.removeInLine(i, start, end);
	            };
	            var commentWithSpace = lineCommentStart + " ";
	            var comment = function (line, i) {
	                if (!ignoreBlankLines || /\S/.test(line)) {
	                    if (shouldInsertSpace(line, minIndent, minIndent))
	                        doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);
	                    else
	                        doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
	                }
	            };
	            var testRemove = function (line, i) {
	                return regexpStart.test(line);
	            };
	            var shouldInsertSpace = function (line, before, after) {
	                var spaces = 0;
	                while (before-- && line.charAt(before) == " ")
	                    spaces++;
	                if (spaces % tabSize != 0)
	                    return false;
	                var spaces = 0;
	                while (line.charAt(after++) == " ")
	                    spaces++;
	                if (tabSize > 2)
	                    return spaces % tabSize != tabSize - 1;
	                else
	                    return spaces % tabSize == 0;
	            };
	        }
	        function iter(fun) {
	            for (var i = startRow; i <= endRow; i++)
	                fun(doc.getLine(i), i);
	        }
	        var minEmptyLength = Infinity;
	        iter(function (line, i) {
	            var indent = line.search(/\S/);
	            if (indent !== -1) {
	                if (indent < minIndent)
	                    minIndent = indent;
	                if (shouldRemove && !testRemove(line, i))
	                    shouldRemove = false;
	            }
	            else if (minEmptyLength > line.length) {
	                minEmptyLength = line.length;
	            }
	        });
	        if (minIndent == Infinity) {
	            minIndent = minEmptyLength;
	            ignoreBlankLines = false;
	            shouldRemove = false;
	        }
	        if (insertAtTabStop && minIndent % tabSize != 0)
	            minIndent = Math.floor(minIndent / tabSize) * tabSize;
	        iter(shouldRemove ? uncomment : comment);
	    };
	    this.toggleBlockComment = function (state, session, range, cursor) {
	        var comment = this.blockComment;
	        if (!comment)
	            return;
	        if (!comment.start && comment[0])
	            comment = comment[0];
	        var iterator = new TokenIterator(session, cursor.row, cursor.column);
	        var token = iterator.getCurrentToken();
	        session.selection;
	        var initialRange = session.selection.toOrientedRange();
	        var startRow, colDiff;
	        if (token && /comment/.test(token.type)) {
	            var startRange, endRange;
	            while (token && /comment/.test(token.type)) {
	                var i = token.value.indexOf(comment.start);
	                if (i != -1) {
	                    var row = iterator.getCurrentTokenRow();
	                    var column = iterator.getCurrentTokenColumn() + i;
	                    startRange = new Range(row, column, row, column + comment.start.length);
	                    break;
	                }
	                token = iterator.stepBackward();
	            }
	            var iterator = new TokenIterator(session, cursor.row, cursor.column);
	            var token = iterator.getCurrentToken();
	            while (token && /comment/.test(token.type)) {
	                var i = token.value.indexOf(comment.end);
	                if (i != -1) {
	                    var row = iterator.getCurrentTokenRow();
	                    var column = iterator.getCurrentTokenColumn() + i;
	                    endRange = new Range(row, column, row, column + comment.end.length);
	                    break;
	                }
	                token = iterator.stepForward();
	            }
	            if (endRange)
	                session.remove(endRange);
	            if (startRange) {
	                session.remove(startRange);
	                startRow = startRange.start.row;
	                colDiff = -comment.start.length;
	            }
	        }
	        else {
	            colDiff = comment.start.length;
	            startRow = range.start.row;
	            session.insert(range.end, comment.end);
	            session.insert(range.start, comment.start);
	        }
	        if (initialRange.start.row == startRow)
	            initialRange.start.column += colDiff;
	        if (initialRange.end.row == startRow)
	            initialRange.end.column += colDiff;
	        session.selection.fromOrientedRange(initialRange);
	    };
	    this.getNextLineIndent = function (state, line, tab) {
	        return this.$getIndent(line);
	    };
	    this.checkOutdent = function (state, line, input) {
	        return false;
	    };
	    this.autoOutdent = function (state, doc, row) {
	    };
	    this.$getIndent = function (line) {
	        return line.match(/^\s*/)[0];
	    };
	    this.createWorker = function (session) {
	        return null;
	    };
	    this.createModeDelegates = function (mapping) {
	        this.$embeds = [];
	        this.$modes = {};
	        for (var i in mapping) {
	            if (mapping[i]) {
	                var Mode = mapping[i];
	                var id = Mode.prototype.$id;
	                var mode = config.$modes[id];
	                if (!mode)
	                    config.$modes[id] = mode = new Mode();
	                if (!config.$modes[i])
	                    config.$modes[i] = mode;
	                this.$embeds.push(i);
	                this.$modes[i] = mode;
	            }
	        }
	        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent",
	            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];
	        var _loop_1 = function (i) {
	            (function (scope) {
	                var functionName = delegations[i];
	                var defaultHandler = scope[functionName];
	                scope[delegations[i]] =
	                    function () {
	                        return this.$delegator(functionName, arguments, defaultHandler);
	                    };
	            }(this_1));
	        };
	        var this_1 = this;
	        for (var i = 0; i < delegations.length; i++) {
	            _loop_1(i);
	        }
	    };
	    this.$delegator = function (method, args, defaultHandler) {
	        var state = args[0] || "start";
	        if (typeof state != "string") {
	            if (Array.isArray(state[2])) {
	                var language = state[2][state[2].length - 1];
	                var mode = this.$modes[language];
	                if (mode)
	                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
	            }
	            state = state[0] || "start";
	        }
	        for (var i = 0; i < this.$embeds.length; i++) {
	            if (!this.$modes[this.$embeds[i]])
	                continue;
	            var split = state.split(this.$embeds[i]);
	            if (!split[0] && split[1]) {
	                args[0] = split[1];
	                var mode = this.$modes[this.$embeds[i]];
	                return mode[method].apply(mode, args);
	            }
	        }
	        var ret = defaultHandler.apply(this, args);
	        return defaultHandler ? ret : undefined;
	    };
	    this.transformAction = function (state, action, editor, session, param) {
	        if (this.$behaviour) {
	            var behaviours = this.$behaviour.getBehaviours();
	            for (var key in behaviours) {
	                if (behaviours[key][action]) {
	                    var ret = behaviours[key][action].apply(this, arguments);
	                    if (ret) {
	                        return ret;
	                    }
	                }
	            }
	        }
	    };
	    this.getKeywords = function (append) {
	        if (!this.completionKeywords) {
	            var rules = this.$tokenizer["rules"];
	            var completionKeywords = [];
	            for (var rule in rules) {
	                var ruleItr = rules[rule];
	                for (var r = 0, l = ruleItr.length; r < l; r++) {
	                    if (typeof ruleItr[r].token === "string") {
	                        if (/keyword|support|storage/.test(ruleItr[r].token))
	                            completionKeywords.push(ruleItr[r].regex);
	                    }
	                    else if (typeof ruleItr[r].token === "object") {
	                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
	                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
	                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
	                                completionKeywords.push(rule.substr(1, rule.length - 2));
	                            }
	                        }
	                    }
	                }
	            }
	            this.completionKeywords = completionKeywords;
	        }
	        if (!append)
	            return this.$keywordList;
	        return completionKeywords.concat(this.$keywordList || []);
	    };
	    this.$createKeywordList = function () {
	        if (!this.$highlightRules)
	            this.getTokenizer();
	        return this.$keywordList = this.$highlightRules.$keywordList || [];
	    };
	    this.getCompletions = function (state, session, pos, prefix) {
	        var keywords = this.$keywordList || this.$createKeywordList();
	        return keywords.map(function (word) {
	            return {
	                name: word,
	                value: word,
	                score: 0,
	                meta: "keyword"
	            };
	        });
	    };
	    this.$id = "ace/mode/text";
	}).call(Mode.prototype);
	exports.Mode = Mode;

	});

	ace.define("ace/line_widgets",["require","exports","module","ace/lib/dom"], function(require, exports, module){	var dom = require("./lib/dom");
	var LineWidgets = /** @class */ (function () {
	    function LineWidgets(session) {
	        this.session = session;
	        this.session.widgetManager = this;
	        this.session.getRowLength = this.getRowLength;
	        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
	        this.updateOnChange = this.updateOnChange.bind(this);
	        this.renderWidgets = this.renderWidgets.bind(this);
	        this.measureWidgets = this.measureWidgets.bind(this);
	        this.session._changedWidgets = [];
	        this.$onChangeEditor = this.$onChangeEditor.bind(this);
	        this.session.on("change", this.updateOnChange);
	        this.session.on("changeFold", this.updateOnFold);
	        this.session.on("changeEditor", this.$onChangeEditor);
	    }
	    LineWidgets.prototype.getRowLength = function (row) {
	        var h;
	        if (this.lineWidgets)
	            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
	        else
	            h = 0;
	        if (!this["$useWrapMode"] || !this["$wrapData"][row]) {
	            return 1 + h;
	        }
	        else {
	            return this["$wrapData"][row].length + 1 + h;
	        }
	    };
	    LineWidgets.prototype.$getWidgetScreenLength = function () {
	        var screenRows = 0;
	        this.lineWidgets.forEach(function (w) {
	            if (w && w.rowCount && !w.hidden)
	                screenRows += w.rowCount;
	        });
	        return screenRows;
	    };
	    LineWidgets.prototype.$onChangeEditor = function (e) {
	        this.attach(e.editor);
	    };
	    LineWidgets.prototype.attach = function (editor) {
	        if (editor && editor.widgetManager && editor.widgetManager != this)
	            editor.widgetManager.detach();
	        if (this.editor == editor)
	            return;
	        this.detach();
	        this.editor = editor;
	        if (editor) {
	            editor.widgetManager = this;
	            editor.renderer.on("beforeRender", this.measureWidgets);
	            editor.renderer.on("afterRender", this.renderWidgets);
	        }
	    };
	    LineWidgets.prototype.detach = function (e) {
	        var editor = this.editor;
	        if (!editor)
	            return;
	        this.editor = null;
	        editor.widgetManager = null;
	        editor.renderer.off("beforeRender", this.measureWidgets);
	        editor.renderer.off("afterRender", this.renderWidgets);
	        var lineWidgets = this.session.lineWidgets;
	        lineWidgets && lineWidgets.forEach(function (w) {
	            if (w && w.el && w.el.parentNode) {
	                w._inDocument = false;
	                w.el.parentNode.removeChild(w.el);
	            }
	        });
	    };
	    LineWidgets.prototype.updateOnFold = function (e, session) {
	        var lineWidgets = session.lineWidgets;
	        if (!lineWidgets || !e.action)
	            return;
	        var fold = e.data;
	        var start = fold.start.row;
	        var end = fold.end.row;
	        var hide = e.action == "add";
	        for (var i = start + 1; i < end; i++) {
	            if (lineWidgets[i])
	                lineWidgets[i].hidden = hide;
	        }
	        if (lineWidgets[end]) {
	            if (hide) {
	                if (!lineWidgets[start])
	                    lineWidgets[start] = lineWidgets[end];
	                else
	                    lineWidgets[end].hidden = hide;
	            }
	            else {
	                if (lineWidgets[start] == lineWidgets[end])
	                    lineWidgets[start] = undefined;
	                lineWidgets[end].hidden = hide;
	            }
	        }
	    };
	    LineWidgets.prototype.updateOnChange = function (delta) {
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets)
	            return;
	        var startRow = delta.start.row;
	        var len = delta.end.row - startRow;
	        if (len === 0) ;
	        else if (delta.action == "remove") {
	            var removed = lineWidgets.splice(startRow + 1, len);
	            if (!lineWidgets[startRow] && removed[removed.length - 1]) {
	                lineWidgets[startRow] = removed.pop();
	            }
	            removed.forEach(function (w) {
	                w && this.removeLineWidget(w);
	            }, this);
	            this.$updateRows();
	        }
	        else {
	            var args = new Array(len);
	            if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
	                if (delta.start.column > lineWidgets[startRow].column)
	                    startRow++;
	            }
	            args.unshift(startRow, 0);
	            lineWidgets.splice.apply(lineWidgets, args);
	            this.$updateRows();
	        }
	    };
	    LineWidgets.prototype.$updateRows = function () {
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets)
	            return;
	        var noWidgets = true;
	        lineWidgets.forEach(function (w, i) {
	            if (w) {
	                noWidgets = false;
	                w.row = i;
	                while (w.$oldWidget) {
	                    w.$oldWidget.row = i;
	                    w = w.$oldWidget;
	                }
	            }
	        });
	        if (noWidgets)
	            this.session.lineWidgets = null;
	    };
	    LineWidgets.prototype.$registerLineWidget = function (w) {
	        if (!this.session.lineWidgets)
	            this.session.lineWidgets = new Array(this.session.getLength());
	        var old = this.session.lineWidgets[w.row];
	        if (old) {
	            w.$oldWidget = old;
	            if (old.el && old.el.parentNode) {
	                old.el.parentNode.removeChild(old.el);
	                old._inDocument = false;
	            }
	        }
	        this.session.lineWidgets[w.row] = w;
	        return w;
	    };
	    LineWidgets.prototype.addLineWidget = function (w) {
	        this.$registerLineWidget(w);
	        w.session = this.session;
	        if (!this.editor)
	            return w;
	        var renderer = this.editor.renderer;
	        if (w.html && !w.el) {
	            w.el = dom.createElement("div");
	            w.el.innerHTML = w.html;
	        }
	        if (w.text && !w.el) {
	            w.el = dom.createElement("div");
	            w.el.textContent = w.text;
	        }
	        if (w.el) {
	            dom.addCssClass(w.el, "ace_lineWidgetContainer");
	            if (w.className) {
	                dom.addCssClass(w.el, w.className);
	            }
	            w.el.style.position = "absolute";
	            w.el.style.zIndex = "5";
	            renderer.container.appendChild(w.el);
	            w._inDocument = true;
	            if (!w.coverGutter) {
	                w.el.style.zIndex = "3";
	            }
	            if (w.pixelHeight == null) {
	                w.pixelHeight = w.el.offsetHeight;
	            }
	        }
	        if (w.rowCount == null) {
	            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
	        }
	        var fold = this.session.getFoldAt(w.row, 0);
	        w.$fold = fold;
	        if (fold) {
	            var lineWidgets = this.session.lineWidgets;
	            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
	                lineWidgets[fold.start.row] = w;
	            else
	                w.hidden = true;
	        }
	        this.session._emit("changeFold", { data: { start: { row: w.row } } });
	        this.$updateRows();
	        this.renderWidgets(null, renderer);
	        this.onWidgetChanged(w);
	        return w;
	    };
	    LineWidgets.prototype.removeLineWidget = function (w) {
	        w._inDocument = false;
	        w.session = null;
	        if (w.el && w.el.parentNode)
	            w.el.parentNode.removeChild(w.el);
	        if (w.editor && w.editor.destroy)
	            try {
	                w.editor.destroy();
	            }
	            catch (e) { }
	        if (this.session.lineWidgets) {
	            var w1 = this.session.lineWidgets[w.row];
	            if (w1 == w) {
	                this.session.lineWidgets[w.row] = w.$oldWidget;
	                if (w.$oldWidget)
	                    this.onWidgetChanged(w.$oldWidget);
	            }
	            else {
	                while (w1) {
	                    if (w1.$oldWidget == w) {
	                        w1.$oldWidget = w.$oldWidget;
	                        break;
	                    }
	                    w1 = w1.$oldWidget;
	                }
	            }
	        }
	        this.session._emit("changeFold", { data: { start: { row: w.row } } });
	        this.$updateRows();
	    };
	    LineWidgets.prototype.getWidgetsAtRow = function (row) {
	        var lineWidgets = this.session.lineWidgets;
	        var w = lineWidgets && lineWidgets[row];
	        var list = [];
	        while (w) {
	            list.push(w);
	            w = w.$oldWidget;
	        }
	        return list;
	    };
	    LineWidgets.prototype.onWidgetChanged = function (w) {
	        this.session._changedWidgets.push(w);
	        this.editor && this.editor.renderer.updateFull();
	    };
	    LineWidgets.prototype.measureWidgets = function (e, renderer) {
	        var changedWidgets = this.session._changedWidgets;
	        var config = renderer.layerConfig;
	        if (!changedWidgets || !changedWidgets.length)
	            return;
	        var min = Infinity;
	        for (var i = 0; i < changedWidgets.length; i++) {
	            var w = changedWidgets[i];
	            if (!w || !w.el)
	                continue;
	            if (w.session != this.session)
	                continue;
	            if (!w._inDocument) {
	                if (this.session.lineWidgets[w.row] != w)
	                    continue;
	                w._inDocument = true;
	                renderer.container.appendChild(w.el);
	            }
	            w.h = w.el.offsetHeight;
	            if (!w.fixedWidth) {
	                w.w = w.el.offsetWidth;
	                w.screenWidth = Math.ceil(w.w / config.characterWidth);
	            }
	            var rowCount = w.h / config.lineHeight;
	            if (w.coverLine) {
	                rowCount -= this.session.getRowLineCount(w.row);
	                if (rowCount < 0)
	                    rowCount = 0;
	            }
	            if (w.rowCount != rowCount) {
	                w.rowCount = rowCount;
	                if (w.row < min)
	                    min = w.row;
	            }
	        }
	        if (min != Infinity) {
	            this.session._emit("changeFold", { data: { start: { row: min } } });
	            this.session.lineWidgetWidth = null;
	        }
	        this.session._changedWidgets = [];
	    };
	    LineWidgets.prototype.renderWidgets = function (e, renderer) {
	        var config = renderer.layerConfig;
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets)
	            return;
	        var first = Math.min(this.firstRow, config.firstRow);
	        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
	        while (first > 0 && !lineWidgets[first])
	            first--;
	        this.firstRow = config.firstRow;
	        this.lastRow = config.lastRow;
	        renderer.$cursorLayer.config = config;
	        for (var i = first; i <= last; i++) {
	            var w = lineWidgets[i];
	            if (!w || !w.el)
	                continue;
	            if (w.hidden) {
	                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
	                continue;
	            }
	            if (!w._inDocument) {
	                w._inDocument = true;
	                renderer.container.appendChild(w.el);
	            }
	            var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
	            if (!w.coverLine)
	                top += config.lineHeight * this.session.getRowLineCount(w.row);
	            w.el.style.top = top - config.offset + "px";
	            var left = w.coverGutter ? 0 : renderer.gutterWidth;
	            if (!w.fixedWidth)
	                left -= renderer.scrollLeft;
	            w.el.style.left = left + "px";
	            if (w.fullWidth && w.screenWidth) {
	                w.el.style.minWidth = config.width + 2 * config.padding + "px";
	            }
	            if (w.fixedWidth) {
	                w.el.style.right = renderer.scrollBar.getWidth() + "px";
	            }
	            else {
	                w.el.style.right = "";
	            }
	        }
	    };
	    return LineWidgets;
	}());
	exports.LineWidgets = LineWidgets;

	});

	ace.define("ace/apply_delta",["require","exports","module"], function(require, exports, module){	exports.applyDelta = function (docLines, delta, doNotValidate) {
	    var row = delta.start.row;
	    var startColumn = delta.start.column;
	    var line = docLines[row] || "";
	    switch (delta.action) {
	        case "insert":
	            var lines = delta.lines;
	            if (lines.length === 1) {
	                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
	            }
	            else {
	                var args = [row, 1].concat(delta.lines);
	                docLines.splice.apply(docLines, args);
	                docLines[row] = line.substring(0, startColumn) + docLines[row];
	                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
	            }
	            break;
	        case "remove":
	            var endColumn = delta.end.column;
	            var endRow = delta.end.row;
	            if (row === endRow) {
	                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
	            }
	            else {
	                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
	            }
	            break;
	    }
	};

	});

	ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module){	var oop = require("./lib/oop");
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var Anchor = /** @class */ (function () {
	    function Anchor(doc, row, column) {
	        this.$onChange = this.onChange.bind(this);
	        this.attach(doc);
	        if (typeof row != "number")
	            this.setPosition(row.row, row.column);
	        else
	            this.setPosition(row, column);
	    }
	    Anchor.prototype.getPosition = function () {
	        return this.$clipPositionToDocument(this.row, this.column);
	    };
	    Anchor.prototype.getDocument = function () {
	        return this.document;
	    };
	    Anchor.prototype.onChange = function (delta) {
	        if (delta.start.row == delta.end.row && delta.start.row != this.row)
	            return;
	        if (delta.start.row > this.row)
	            return;
	        var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
	        this.setPosition(point.row, point.column, true);
	    };
	    Anchor.prototype.setPosition = function (row, column, noClip) {
	        var pos;
	        if (noClip) {
	            pos = {
	                row: row,
	                column: column
	            };
	        }
	        else {
	            pos = this.$clipPositionToDocument(row, column);
	        }
	        if (this.row == pos.row && this.column == pos.column)
	            return;
	        var old = {
	            row: this.row,
	            column: this.column
	        };
	        this.row = pos.row;
	        this.column = pos.column;
	        this._signal("change", {
	            old: old,
	            value: pos
	        });
	    };
	    Anchor.prototype.detach = function () {
	        this.document.off("change", this.$onChange);
	    };
	    Anchor.prototype.attach = function (doc) {
	        this.document = doc || this.document;
	        this.document.on("change", this.$onChange);
	    };
	    Anchor.prototype.$clipPositionToDocument = function (row, column) {
	        var pos = {};
	        if (row >= this.document.getLength()) {
	            pos.row = Math.max(0, this.document.getLength() - 1);
	            pos.column = this.document.getLine(pos.row).length;
	        }
	        else if (row < 0) {
	            pos.row = 0;
	            pos.column = 0;
	        }
	        else {
	            pos.row = row;
	            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
	        }
	        if (column < 0)
	            pos.column = 0;
	        return pos;
	    };
	    return Anchor;
	}());
	Anchor.prototype.$insertRight = false;
	oop.implement(Anchor.prototype, EventEmitter);
	function $pointsInOrder(point1, point2, equalPointsInOrder) {
	    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
	    return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
	}
	function $getTransformedPoint(delta, point, moveIfEqual) {
	    var deltaIsInsert = delta.action == "insert";
	    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
	    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
	    var deltaStart = delta.start;
	    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
	    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
	        return {
	            row: point.row,
	            column: point.column
	        };
	    }
	    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
	        return {
	            row: point.row + deltaRowShift,
	            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
	        };
	    }
	    return {
	        row: deltaStart.row,
	        column: deltaStart.column
	    };
	}
	exports.Anchor = Anchor;

	});

	ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(require, exports, module){	var oop = require("./lib/oop");
	var applyDelta = require("./apply_delta").applyDelta;
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var Range = require("./range").Range;
	var Anchor = require("./anchor").Anchor;
	var Document = /** @class */ (function () {
	    function Document(textOrLines) {
	        this.$lines = [""];
	        if (textOrLines.length === 0) {
	            this.$lines = [""];
	        }
	        else if (Array.isArray(textOrLines)) {
	            this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
	        }
	        else {
	            this.insert({ row: 0, column: 0 }, textOrLines);
	        }
	    }
	    Document.prototype.setValue = function (text) {
	        var len = this.getLength() - 1;
	        this.remove(new Range(0, 0, len, this.getLine(len).length));
	        this.insert({ row: 0, column: 0 }, text || "");
	    };
	    Document.prototype.getValue = function () {
	        return this.getAllLines().join(this.getNewLineCharacter());
	    };
	    Document.prototype.createAnchor = function (row, column) {
	        return new Anchor(this, row, column);
	    };
	    Document.prototype.$detectNewLine = function (text) {
	        var match = text.match(/^.*?(\r\n|\r|\n)/m);
	        this.$autoNewLine = match ? match[1] : "\n";
	        this._signal("changeNewLineMode");
	    };
	    Document.prototype.getNewLineCharacter = function () {
	        switch (this.$newLineMode) {
	            case "windows":
	                return "\r\n";
	            case "unix":
	                return "\n";
	            default:
	                return this.$autoNewLine || "\n";
	        }
	    };
	    Document.prototype.setNewLineMode = function (newLineMode) {
	        if (this.$newLineMode === newLineMode)
	            return;
	        this.$newLineMode = newLineMode;
	        this._signal("changeNewLineMode");
	    };
	    Document.prototype.getNewLineMode = function () {
	        return this.$newLineMode;
	    };
	    Document.prototype.isNewLine = function (text) {
	        return (text == "\r\n" || text == "\r" || text == "\n");
	    };
	    Document.prototype.getLine = function (row) {
	        return this.$lines[row] || "";
	    };
	    Document.prototype.getLines = function (firstRow, lastRow) {
	        return this.$lines.slice(firstRow, lastRow + 1);
	    };
	    Document.prototype.getAllLines = function () {
	        return this.getLines(0, this.getLength());
	    };
	    Document.prototype.getLength = function () {
	        return this.$lines.length;
	    };
	    Document.prototype.getTextRange = function (range) {
	        return this.getLinesForRange(range).join(this.getNewLineCharacter());
	    };
	    Document.prototype.getLinesForRange = function (range) {
	        var lines;
	        if (range.start.row === range.end.row) {
	            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
	        }
	        else {
	            lines = this.getLines(range.start.row, range.end.row);
	            lines[0] = (lines[0] || "").substring(range.start.column);
	            var l = lines.length - 1;
	            if (range.end.row - range.start.row == l)
	                lines[l] = lines[l].substring(0, range.end.column);
	        }
	        return lines;
	    };
	    Document.prototype.insertLines = function (row, lines) {
	        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
	        return this.insertFullLines(row, lines);
	    };
	    Document.prototype.removeLines = function (firstRow, lastRow) {
	        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
	        return this.removeFullLines(firstRow, lastRow);
	    };
	    Document.prototype.insertNewLine = function (position) {
	        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
	        return this.insertMergedLines(position, ["", ""]);
	    };
	    Document.prototype.insert = function (position, text) {
	        if (this.getLength() <= 1)
	            this.$detectNewLine(text);
	        return this.insertMergedLines(position, this.$split(text));
	    };
	    Document.prototype.insertInLine = function (position, text) {
	        var start = this.clippedPos(position.row, position.column);
	        var end = this.pos(position.row, position.column + text.length);
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "insert",
	            lines: [text]
	        }, true);
	        return this.clonePos(end);
	    };
	    Document.prototype.clippedPos = function (row, column) {
	        var length = this.getLength();
	        if (row === undefined) {
	            row = length;
	        }
	        else if (row < 0) {
	            row = 0;
	        }
	        else if (row >= length) {
	            row = length - 1;
	            column = undefined;
	        }
	        var line = this.getLine(row);
	        if (column == undefined)
	            column = line.length;
	        column = Math.min(Math.max(column, 0), line.length);
	        return { row: row, column: column };
	    };
	    Document.prototype.clonePos = function (pos) {
	        return { row: pos.row, column: pos.column };
	    };
	    Document.prototype.pos = function (row, column) {
	        return { row: row, column: column };
	    };
	    Document.prototype.$clipPosition = function (position) {
	        var length = this.getLength();
	        if (position.row >= length) {
	            position.row = Math.max(0, length - 1);
	            position.column = this.getLine(length - 1).length;
	        }
	        else {
	            position.row = Math.max(0, position.row);
	            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
	        }
	        return position;
	    };
	    Document.prototype.insertFullLines = function (row, lines) {
	        row = Math.min(Math.max(row, 0), this.getLength());
	        var column = 0;
	        if (row < this.getLength()) {
	            lines = lines.concat([""]);
	            column = 0;
	        }
	        else {
	            lines = [""].concat(lines);
	            row--;
	            column = this.$lines[row].length;
	        }
	        this.insertMergedLines({ row: row, column: column }, lines);
	    };
	    Document.prototype.insertMergedLines = function (position, lines) {
	        var start = this.clippedPos(position.row, position.column);
	        var end = {
	            row: start.row + lines.length - 1,
	            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
	        };
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "insert",
	            lines: lines
	        });
	        return this.clonePos(end);
	    };
	    Document.prototype.remove = function (range) {
	        var start = this.clippedPos(range.start.row, range.start.column);
	        var end = this.clippedPos(range.end.row, range.end.column);
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "remove",
	            lines: this.getLinesForRange({ start: start, end: end })
	        });
	        return this.clonePos(start);
	    };
	    Document.prototype.removeInLine = function (row, startColumn, endColumn) {
	        var start = this.clippedPos(row, startColumn);
	        var end = this.clippedPos(row, endColumn);
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "remove",
	            lines: this.getLinesForRange({ start: start, end: end })
	        }, true);
	        return this.clonePos(start);
	    };
	    Document.prototype.removeFullLines = function (firstRow, lastRow) {
	        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
	        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
	        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
	        var deleteLastNewLine = lastRow < this.getLength() - 1;
	        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);
	        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);
	        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);
	        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);
	        var range = new Range(startRow, startCol, endRow, endCol);
	        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
	        this.applyDelta({
	            start: range.start,
	            end: range.end,
	            action: "remove",
	            lines: this.getLinesForRange(range)
	        });
	        return deletedLines;
	    };
	    Document.prototype.removeNewLine = function (row) {
	        if (row < this.getLength() - 1 && row >= 0) {
	            this.applyDelta({
	                start: this.pos(row, this.getLine(row).length),
	                end: this.pos(row + 1, 0),
	                action: "remove",
	                lines: ["", ""]
	            });
	        }
	    };
	    Document.prototype.replace = function (range, text) {
	        if (!(range instanceof Range))
	            range = Range.fromPoints(range.start, range.end);
	        if (text.length === 0 && range.isEmpty())
	            return range.start;
	        if (text == this.getTextRange(range))
	            return range.end;
	        this.remove(range);
	        var end;
	        if (text) {
	            end = this.insert(range.start, text);
	        }
	        else {
	            end = range.start;
	        }
	        return end;
	    };
	    Document.prototype.applyDeltas = function (deltas) {
	        for (var i = 0; i < deltas.length; i++) {
	            this.applyDelta(deltas[i]);
	        }
	    };
	    Document.prototype.revertDeltas = function (deltas) {
	        for (var i = deltas.length - 1; i >= 0; i--) {
	            this.revertDelta(deltas[i]);
	        }
	    };
	    Document.prototype.applyDelta = function (delta, doNotValidate) {
	        var isInsert = delta.action == "insert";
	        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
	            : !Range.comparePoints(delta.start, delta.end)) {
	            return;
	        }
	        if (isInsert && delta.lines.length > 20000) {
	            this.$splitAndapplyLargeDelta(delta, 20000);
	        }
	        else {
	            applyDelta(this.$lines, delta, doNotValidate);
	            this._signal("change", delta);
	        }
	    };
	    Document.prototype.$safeApplyDelta = function (delta) {
	        var docLength = this.$lines.length;
	        if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength
	            || delta.action == "insert" && delta.start.row <= docLength) {
	            this.applyDelta(delta);
	        }
	    };
	    Document.prototype.$splitAndapplyLargeDelta = function (delta, MAX) {
	        var lines = delta.lines;
	        var l = lines.length - MAX + 1;
	        var row = delta.start.row;
	        var column = delta.start.column;
	        for (var from = 0, to = 0; from < l; from = to) {
	            to += MAX - 1;
	            var chunk = lines.slice(from, to);
	            chunk.push("");
	            this.applyDelta({
	                start: this.pos(row + from, column),
	                end: this.pos(row + to, column = 0),
	                action: delta.action,
	                lines: chunk
	            }, true);
	        }
	        delta.lines = lines.slice(from);
	        delta.start.row = row + from;
	        delta.start.column = column;
	        this.applyDelta(delta, true);
	    };
	    Document.prototype.revertDelta = function (delta) {
	        this.$safeApplyDelta({
	            start: this.clonePos(delta.start),
	            end: this.clonePos(delta.end),
	            action: (delta.action == "insert" ? "remove" : "insert"),
	            lines: delta.lines.slice()
	        });
	    };
	    Document.prototype.indexToPosition = function (index, startRow) {
	        var lines = this.$lines || this.getAllLines();
	        var newlineLength = this.getNewLineCharacter().length;
	        for (var i = startRow || 0, l = lines.length; i < l; i++) {
	            index -= lines[i].length + newlineLength;
	            if (index < 0)
	                return { row: i, column: index + lines[i].length + newlineLength };
	        }
	        return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
	    };
	    Document.prototype.positionToIndex = function (pos, startRow) {
	        var lines = this.$lines || this.getAllLines();
	        var newlineLength = this.getNewLineCharacter().length;
	        var index = 0;
	        var row = Math.min(pos.row, lines.length);
	        for (var i = startRow || 0; i < row; ++i)
	            index += lines[i].length + newlineLength;
	        return index + pos.column;
	    };
	    Document.prototype.$split = function (text) {
	        return text.split(/\r\n|\r|\n/);
	    };
	    return Document;
	}());
	Document.prototype.$autoNewLine = "";
	Document.prototype.$newLineMode = "auto";
	oop.implement(Document.prototype, EventEmitter);
	exports.Document = Document;

	});

	ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module){	var oop = require("./lib/oop");
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var BackgroundTokenizer = /** @class */ (function () {
	    function BackgroundTokenizer(tokenizer, session) {
	        this.running = false;
	        this.lines = [];
	        this.states = [];
	        this.currentLine = 0;
	        this.tokenizer = tokenizer;
	        var self = this;
	        this.$worker = function () {
	            if (!self.running) {
	                return;
	            }
	            var workerStart = new Date();
	            var currentLine = self.currentLine;
	            var endLine = -1;
	            var doc = self.doc;
	            var startLine = currentLine;
	            while (self.lines[currentLine])
	                currentLine++;
	            var len = doc.getLength();
	            var processedLines = 0;
	            self.running = false;
	            while (currentLine < len) {
	                self.$tokenizeRow(currentLine);
	                endLine = currentLine;
	                do {
	                    currentLine++;
	                } while (self.lines[currentLine]);
	                processedLines++;
	                if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
	                    self.running = setTimeout(self.$worker, 20);
	                    break;
	                }
	            }
	            self.currentLine = currentLine;
	            if (endLine == -1)
	                endLine = currentLine;
	            if (startLine <= endLine)
	                self.fireUpdateEvent(startLine, endLine);
	        };
	    }
	    BackgroundTokenizer.prototype.setTokenizer = function (tokenizer) {
	        this.tokenizer = tokenizer;
	        this.lines = [];
	        this.states = [];
	        this.start(0);
	    };
	    BackgroundTokenizer.prototype.setDocument = function (doc) {
	        this.doc = doc;
	        this.lines = [];
	        this.states = [];
	        this.stop();
	    };
	    BackgroundTokenizer.prototype.fireUpdateEvent = function (firstRow, lastRow) {
	        var data = {
	            first: firstRow,
	            last: lastRow
	        };
	        this._signal("update", { data: data });
	    };
	    BackgroundTokenizer.prototype.start = function (startRow) {
	        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
	        this.lines.splice(this.currentLine, this.lines.length);
	        this.states.splice(this.currentLine, this.states.length);
	        this.stop();
	        this.running = setTimeout(this.$worker, 700);
	    };
	    BackgroundTokenizer.prototype.scheduleStart = function () {
	        if (!this.running)
	            this.running = setTimeout(this.$worker, 700);
	    };
	    BackgroundTokenizer.prototype.$updateOnChange = function (delta) {
	        var startRow = delta.start.row;
	        var len = delta.end.row - startRow;
	        if (len === 0) {
	            this.lines[startRow] = null;
	        }
	        else if (delta.action == "remove") {
	            this.lines.splice(startRow, len + 1, null);
	            this.states.splice(startRow, len + 1, null);
	        }
	        else {
	            var args = Array(len + 1);
	            args.unshift(startRow, 1);
	            this.lines.splice.apply(this.lines, args);
	            this.states.splice.apply(this.states, args);
	        }
	        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
	        this.stop();
	    };
	    BackgroundTokenizer.prototype.stop = function () {
	        if (this.running)
	            clearTimeout(this.running);
	        this.running = false;
	    };
	    BackgroundTokenizer.prototype.getTokens = function (row) {
	        return this.lines[row] || this.$tokenizeRow(row);
	    };
	    BackgroundTokenizer.prototype.getState = function (row) {
	        if (this.currentLine == row)
	            this.$tokenizeRow(row);
	        return this.states[row] || "start";
	    };
	    BackgroundTokenizer.prototype.$tokenizeRow = function (row) {
	        var line = this.doc.getLine(row);
	        var state = this.states[row - 1];
	        var data = this.tokenizer.getLineTokens(line, state, row);
	        if (this.states[row] + "" !== data.state + "") {
	            this.states[row] = data.state;
	            this.lines[row + 1] = null;
	            if (this.currentLine > row + 1)
	                this.currentLine = row + 1;
	        }
	        else if (this.currentLine == row) {
	            this.currentLine = row + 1;
	        }
	        return this.lines[row] = data.tokens;
	    };
	    BackgroundTokenizer.prototype.cleanup = function () {
	        this.running = false;
	        this.lines = [];
	        this.states = [];
	        this.currentLine = 0;
	        this.removeAllListeners();
	    };
	    return BackgroundTokenizer;
	}());
	oop.implement(BackgroundTokenizer.prototype, EventEmitter);
	exports.BackgroundTokenizer = BackgroundTokenizer;

	});

	ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/range"], function(require, exports, module){	var lang = require("./lib/lang");
	var Range = require("./range").Range;
	var SearchHighlight = /** @class */ (function () {
	    function SearchHighlight(regExp, clazz, type) {
	        if (type === void 0) { type = "text"; }
	        this.setRegexp(regExp);
	        this.clazz = clazz;
	        this.type = type;
	        this.docLen = 0;
	    }
	    SearchHighlight.prototype.setRegexp = function (regExp) {
	        if (this.regExp + "" == regExp + "")
	            return;
	        this.regExp = regExp;
	        this.cache = [];
	    };
	    SearchHighlight.prototype.update = function (html, markerLayer, session, config) {
	        if (!this.regExp)
	            return;
	        var start = config.firstRow;
	        var end = config.lastRow;
	        var renderedMarkerRanges = {};
	        var _search = session.$editor && session.$editor.$search;
	        var mtSearch = _search && _search.$isMultilineSearch(session.$editor.getLastSearchOptions());
	        for (var i = start; i <= end; i++) {
	            var ranges = this.cache[i];
	            if (ranges == null || session.getValue().length != this.docLen) {
	                if (mtSearch) {
	                    ranges = [];
	                    var match = _search.$multiLineForward(session, this.regExp, i, end);
	                    if (match) {
	                        var end_row = match.endRow <= end ? match.endRow - 1 : end;
	                        if (end_row > i)
	                            i = end_row;
	                        ranges.push(new Range(match.startRow, match.startCol, match.endRow, match.endCol));
	                    }
	                    if (ranges.length > this.MAX_RANGES)
	                        ranges = ranges.slice(0, this.MAX_RANGES);
	                }
	                else {
	                    ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
	                    if (ranges.length > this.MAX_RANGES)
	                        ranges = ranges.slice(0, this.MAX_RANGES);
	                    ranges = ranges.map(function (match) {
	                        return new Range(i, match.offset, i, match.offset + match.length);
	                    });
	                }
	                this.cache[i] = ranges.length ? ranges : "";
	            }
	            if (ranges.length === 0)
	                continue;
	            for (var j = ranges.length; j--;) {
	                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
	                var rangeAsString = rangeToAddMarkerTo.toString();
	                if (renderedMarkerRanges[rangeAsString])
	                    continue;
	                renderedMarkerRanges[rangeAsString] = true;
	                markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);
	            }
	        }
	        this.docLen = session.getValue().length;
	    };
	    return SearchHighlight;
	}());
	SearchHighlight.prototype.MAX_RANGES = 500;
	exports.SearchHighlight = SearchHighlight;

	});

	ace.define("ace/undomanager",["require","exports","module","ace/range"], function(require, exports, module){	var UndoManager = /** @class */ (function () {
	    function UndoManager() {
	        this.$keepRedoStack;
	        this.$maxRev = 0;
	        this.$fromUndo = false;
	        this.$undoDepth = Infinity;
	        this.reset();
	    }
	    UndoManager.prototype.addSession = function (session) {
	        this.$session = session;
	    };
	    UndoManager.prototype.add = function (delta, allowMerge, session) {
	        if (this.$fromUndo)
	            return;
	        if (delta == this.$lastDelta)
	            return;
	        if (!this.$keepRedoStack)
	            this.$redoStack.length = 0;
	        if (allowMerge === false || !this.lastDeltas) {
	            this.lastDeltas = [];
	            var undoStackLength = this.$undoStack.length;
	            if (undoStackLength > this.$undoDepth - 1) {
	                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
	            }
	            this.$undoStack.push(this.lastDeltas);
	            delta.id = this.$rev = ++this.$maxRev;
	        }
	        if (delta.action == "remove" || delta.action == "insert")
	            this.$lastDelta = delta;
	        this.lastDeltas.push(delta);
	    };
	    UndoManager.prototype.addSelection = function (selection, rev) {
	        this.selections.push({
	            value: selection,
	            rev: rev || this.$rev
	        });
	    };
	    UndoManager.prototype.startNewGroup = function () {
	        this.lastDeltas = null;
	        return this.$rev;
	    };
	    UndoManager.prototype.markIgnored = function (from, to) {
	        if (to == null)
	            to = this.$rev + 1;
	        var stack = this.$undoStack;
	        for (var i = stack.length; i--;) {
	            var delta = stack[i][0];
	            if (delta.id <= from)
	                break;
	            if (delta.id < to)
	                delta.ignore = true;
	        }
	        this.lastDeltas = null;
	    };
	    UndoManager.prototype.getSelection = function (rev, after) {
	        var stack = this.selections;
	        for (var i = stack.length; i--;) {
	            var selection = stack[i];
	            if (selection.rev < rev) {
	                if (after)
	                    selection = stack[i + 1];
	                return selection;
	            }
	        }
	    };
	    UndoManager.prototype.getRevision = function () {
	        return this.$rev;
	    };
	    UndoManager.prototype.getDeltas = function (from, to) {
	        if (to == null)
	            to = this.$rev + 1;
	        var stack = this.$undoStack;
	        var end = null, start = 0;
	        for (var i = stack.length; i--;) {
	            var delta = stack[i][0];
	            if (delta.id < to && !end)
	                end = i + 1;
	            if (delta.id <= from) {
	                start = i + 1;
	                break;
	            }
	        }
	        return stack.slice(start, end);
	    };
	    UndoManager.prototype.getChangedRanges = function (from, to) {
	        if (to == null)
	            to = this.$rev + 1;
	    };
	    UndoManager.prototype.getChangedLines = function (from, to) {
	        if (to == null)
	            to = this.$rev + 1;
	    };
	    UndoManager.prototype.undo = function (session, dontSelect) {
	        this.lastDeltas = null;
	        var stack = this.$undoStack;
	        if (!rearrangeUndoStack(stack, stack.length))
	            return;
	        if (!session)
	            session = this.$session;
	        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
	            this.$redoStack = [];
	        this.$fromUndo = true;
	        var deltaSet = stack.pop();
	        var undoSelectionRange = null;
	        if (deltaSet) {
	            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
	            this.$redoStack.push(deltaSet);
	            this.$syncRev();
	        }
	        this.$fromUndo = false;
	        return undoSelectionRange;
	    };
	    UndoManager.prototype.redo = function (session, dontSelect) {
	        this.lastDeltas = null;
	        if (!session)
	            session = this.$session;
	        this.$fromUndo = true;
	        if (this.$redoStackBaseRev != this.$rev) {
	            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
	            rebaseRedoStack(this.$redoStack, diff);
	            this.$redoStackBaseRev = this.$rev;
	            this.$redoStack.forEach(function (x) {
	                x[0].id = ++this.$maxRev;
	            }, this);
	        }
	        var deltaSet = this.$redoStack.pop();
	        var redoSelectionRange = null;
	        if (deltaSet) {
	            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
	            this.$undoStack.push(deltaSet);
	            this.$syncRev();
	        }
	        this.$fromUndo = false;
	        return redoSelectionRange;
	    };
	    UndoManager.prototype.$syncRev = function () {
	        var stack = this.$undoStack;
	        var nextDelta = stack[stack.length - 1];
	        var id = nextDelta && nextDelta[0].id || 0;
	        this.$redoStackBaseRev = id;
	        this.$rev = id;
	    };
	    UndoManager.prototype.reset = function () {
	        this.lastDeltas = null;
	        this.$lastDelta = null;
	        this.$undoStack = [];
	        this.$redoStack = [];
	        this.$rev = 0;
	        this.mark = 0;
	        this.$redoStackBaseRev = this.$rev;
	        this.selections = [];
	    };
	    UndoManager.prototype.canUndo = function () {
	        return this.$undoStack.length > 0;
	    };
	    UndoManager.prototype.canRedo = function () {
	        return this.$redoStack.length > 0;
	    };
	    UndoManager.prototype.bookmark = function (rev) {
	        if (rev == undefined)
	            rev = this.$rev;
	        this.mark = rev;
	    };
	    UndoManager.prototype.isAtBookmark = function () {
	        return this.$rev === this.mark;
	    };
	    UndoManager.prototype.toJSON = function () {
	        return {
	            $redoStack: this.$redoStack,
	            $undoStack: this.$undoStack
	        };
	    };
	    UndoManager.prototype.fromJSON = function (json) {
	        this.reset();
	        this.$undoStack = json.$undoStack;
	        this.$redoStack = json.$redoStack;
	    };
	    UndoManager.prototype.$prettyPrint = function (delta) {
	        if (delta)
	            return stringifyDelta(delta);
	        return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
	    };
	    return UndoManager;
	}());
	UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
	UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
	UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
	UndoManager.prototype.markClean = UndoManager.prototype.bookmark;
	function rearrangeUndoStack(stack, pos) {
	    for (var i = pos; i--;) {
	        var deltaSet = stack[i];
	        if (deltaSet && !deltaSet[0].ignore) {
	            while (i < pos - 1) {
	                var swapped = swapGroups(stack[i], stack[i + 1]);
	                stack[i] = swapped[0];
	                stack[i + 1] = swapped[1];
	                i++;
	            }
	            return true;
	        }
	    }
	}
	var Range = require("./range").Range;
	var cmp = Range.comparePoints;
	Range.comparePoints;
	function clonePos(pos) {
	    return { row: pos.row, column: pos.column };
	}
	function cloneDelta(d) {
	    return {
	        start: clonePos(d.start),
	        end: clonePos(d.end),
	        action: d.action,
	        lines: d.lines.slice()
	    };
	}
	function stringifyDelta(d) {
	    d = d || this;
	    if (Array.isArray(d)) {
	        return d.map(stringifyDelta).join("\n");
	    }
	    var type = "";
	    if (d.action) {
	        type = d.action == "insert" ? "+" : "-";
	        type += "[" + d.lines + "]";
	    }
	    else if (d.value) {
	        if (Array.isArray(d.value)) {
	            type = d.value.map(stringifyRange).join("\n");
	        }
	        else {
	            type = stringifyRange(d.value);
	        }
	    }
	    if (d.start) {
	        type += stringifyRange(d);
	    }
	    if (d.id || d.rev) {
	        type += "\t(" + (d.id || d.rev) + ")";
	    }
	    return type;
	}
	function stringifyRange(r) {
	    return r.start.row + ":" + r.start.column
	        + "=>" + r.end.row + ":" + r.end.column;
	}
	function swap(d1, d2) {
	    var i1 = d1.action == "insert";
	    var i2 = d2.action == "insert";
	    if (i1 && i2) {
	        if (cmp(d2.start, d1.end) >= 0) {
	            shift(d2, d1, -1);
	        }
	        else if (cmp(d2.start, d1.start) <= 0) {
	            shift(d1, d2, 1);
	        }
	        else {
	            return null;
	        }
	    }
	    else if (i1 && !i2) {
	        if (cmp(d2.start, d1.end) >= 0) {
	            shift(d2, d1, -1);
	        }
	        else if (cmp(d2.end, d1.start) <= 0) {
	            shift(d1, d2, -1);
	        }
	        else {
	            return null;
	        }
	    }
	    else if (!i1 && i2) {
	        if (cmp(d2.start, d1.start) >= 0) {
	            shift(d2, d1, 1);
	        }
	        else if (cmp(d2.start, d1.start) <= 0) {
	            shift(d1, d2, 1);
	        }
	        else {
	            return null;
	        }
	    }
	    else if (!i1 && !i2) {
	        if (cmp(d2.start, d1.start) >= 0) {
	            shift(d2, d1, 1);
	        }
	        else if (cmp(d2.end, d1.start) <= 0) {
	            shift(d1, d2, -1);
	        }
	        else {
	            return null;
	        }
	    }
	    return [d2, d1];
	}
	function swapGroups(ds1, ds2) {
	    for (var i = ds1.length; i--;) {
	        for (var j = 0; j < ds2.length; j++) {
	            if (!swap(ds1[i], ds2[j])) {
	                while (i < ds1.length) {
	                    while (j--) {
	                        swap(ds2[j], ds1[i]);
	                    }
	                    j = ds2.length;
	                    i++;
	                }
	                return [ds1, ds2];
	            }
	        }
	    }
	    ds1.selectionBefore = ds2.selectionBefore =
	        ds1.selectionAfter = ds2.selectionAfter = null;
	    return [ds2, ds1];
	}
	function xform(d1, c1) {
	    var i1 = d1.action == "insert";
	    var i2 = c1.action == "insert";
	    if (i1 && i2) {
	        if (cmp(d1.start, c1.start) < 0) {
	            shift(c1, d1, 1);
	        }
	        else {
	            shift(d1, c1, 1);
	        }
	    }
	    else if (i1 && !i2) {
	        if (cmp(d1.start, c1.end) >= 0) {
	            shift(d1, c1, -1);
	        }
	        else if (cmp(d1.start, c1.start) <= 0) {
	            shift(c1, d1, 1);
	        }
	        else {
	            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
	            shift(c1, d1, 1);
	        }
	    }
	    else if (!i1 && i2) {
	        if (cmp(c1.start, d1.end) >= 0) {
	            shift(c1, d1, -1);
	        }
	        else if (cmp(c1.start, d1.start) <= 0) {
	            shift(d1, c1, 1);
	        }
	        else {
	            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
	            shift(d1, c1, 1);
	        }
	    }
	    else if (!i1 && !i2) {
	        if (cmp(c1.start, d1.end) >= 0) {
	            shift(c1, d1, -1);
	        }
	        else if (cmp(c1.end, d1.start) <= 0) {
	            shift(d1, c1, -1);
	        }
	        else {
	            var before, after;
	            if (cmp(d1.start, c1.start) < 0) {
	                before = d1;
	                d1 = splitDelta(d1, c1.start);
	            }
	            if (cmp(d1.end, c1.end) > 0) {
	                after = splitDelta(d1, c1.end);
	            }
	            shiftPos(c1.end, d1.start, d1.end, -1);
	            if (after && !before) {
	                d1.lines = after.lines;
	                d1.start = after.start;
	                d1.end = after.end;
	                after = d1;
	            }
	            return [c1, before, after].filter(Boolean);
	        }
	    }
	    return [c1, d1];
	}
	function shift(d1, d2, dir) {
	    shiftPos(d1.start, d2.start, d2.end, dir);
	    shiftPos(d1.end, d2.start, d2.end, dir);
	}
	function shiftPos(pos, start, end, dir) {
	    if (pos.row == (dir == 1 ? start : end).row) {
	        pos.column += dir * (end.column - start.column);
	    }
	    pos.row += dir * (end.row - start.row);
	}
	function splitDelta(c, pos) {
	    var lines = c.lines;
	    var end = c.end;
	    c.end = clonePos(pos);
	    var rowsBefore = c.end.row - c.start.row;
	    var otherLines = lines.splice(rowsBefore, lines.length);
	    var col = rowsBefore ? pos.column : pos.column - c.start.column;
	    lines.push(otherLines[0].substring(0, col));
	    otherLines[0] = otherLines[0].substr(col);
	    var rest = {
	        start: clonePos(pos),
	        end: end,
	        lines: otherLines,
	        action: c.action
	    };
	    return rest;
	}
	function moveDeltasByOne(redoStack, d) {
	    d = cloneDelta(d);
	    for (var j = redoStack.length; j--;) {
	        var deltaSet = redoStack[j];
	        for (var i = 0; i < deltaSet.length; i++) {
	            var x = deltaSet[i];
	            var xformed = xform(x, d);
	            d = xformed[0];
	            if (xformed.length != 2) {
	                if (xformed[2]) {
	                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
	                    i++;
	                }
	                else if (!xformed[1]) {
	                    deltaSet.splice(i, 1);
	                    i--;
	                }
	            }
	        }
	        if (!deltaSet.length) {
	            redoStack.splice(j, 1);
	        }
	    }
	    return redoStack;
	}
	function rebaseRedoStack(redoStack, deltaSets) {
	    for (var i = 0; i < deltaSets.length; i++) {
	        var deltas = deltaSets[i];
	        for (var j = 0; j < deltas.length; j++) {
	            moveDeltasByOne(redoStack, deltas[j]);
	        }
	    }
	}
	exports.UndoManager = UndoManager;

	});

	ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(require, exports, module){	var Range = require("../range").Range;
	var FoldLine = /** @class */ (function () {
	    function FoldLine(foldData, folds) {
	        this.foldData = foldData;
	        if (Array.isArray(folds)) {
	            this.folds = folds;
	        }
	        else {
	            folds = this.folds = [folds];
	        }
	        var last = folds[folds.length - 1];
	        this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
	        this.start = this.range.start;
	        this.end = this.range.end;
	        this.folds.forEach(function (fold) {
	            fold.setFoldLine(this);
	        }, this);
	    }
	    FoldLine.prototype.shiftRow = function (shift) {
	        this.start.row += shift;
	        this.end.row += shift;
	        this.folds.forEach(function (fold) {
	            fold.start.row += shift;
	            fold.end.row += shift;
	        });
	    };
	    FoldLine.prototype.addFold = function (fold) {
	        if (fold.sameRow) {
	            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
	                throw new Error("Can't add a fold to this FoldLine as it has no connection");
	            }
	            this.folds.push(fold);
	            this.folds.sort(function (a, b) {
	                return -a.range.compareEnd(b.start.row, b.start.column);
	            });
	            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
	                this.end.row = fold.end.row;
	                this.end.column = fold.end.column;
	            }
	            else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
	                this.start.row = fold.start.row;
	                this.start.column = fold.start.column;
	            }
	        }
	        else if (fold.start.row == this.end.row) {
	            this.folds.push(fold);
	            this.end.row = fold.end.row;
	            this.end.column = fold.end.column;
	        }
	        else if (fold.end.row == this.start.row) {
	            this.folds.unshift(fold);
	            this.start.row = fold.start.row;
	            this.start.column = fold.start.column;
	        }
	        else {
	            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
	        }
	        fold.foldLine = this;
	    };
	    FoldLine.prototype.containsRow = function (row) {
	        return row >= this.start.row && row <= this.end.row;
	    };
	    FoldLine.prototype.walk = function (callback, endRow, endColumn) {
	        var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
	        if (endRow == null) {
	            endRow = this.end.row;
	            endColumn = this.end.column;
	        }
	        for (var i = 0; i < folds.length; i++) {
	            fold = folds[i];
	            cmp = fold.range.compareStart(endRow, endColumn);
	            if (cmp == -1) {
	                callback(null, endRow, endColumn, lastEnd, isNewRow);
	                return;
	            }
	            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
	            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
	            if (stop || cmp === 0) {
	                return;
	            }
	            isNewRow = !fold.sameRow;
	            lastEnd = fold.end.column;
	        }
	        callback(null, endRow, endColumn, lastEnd, isNewRow);
	    };
	    FoldLine.prototype.getNextFoldTo = function (row, column) {
	        var fold, cmp;
	        for (var i = 0; i < this.folds.length; i++) {
	            fold = this.folds[i];
	            cmp = fold.range.compareEnd(row, column);
	            if (cmp == -1) {
	                return {
	                    fold: fold,
	                    kind: "after"
	                };
	            }
	            else if (cmp === 0) {
	                return {
	                    fold: fold,
	                    kind: "inside"
	                };
	            }
	        }
	        return null;
	    };
	    FoldLine.prototype.addRemoveChars = function (row, column, len) {
	        var ret = this.getNextFoldTo(row, column), fold, folds;
	        if (ret) {
	            fold = ret.fold;
	            if (ret.kind == "inside"
	                && fold.start.column != column
	                && fold.start.row != row) {
	                window.console && window.console.log(row, column, fold);
	            }
	            else if (fold.start.row == row) {
	                folds = this.folds;
	                var i = folds.indexOf(fold);
	                if (i === 0) {
	                    this.start.column += len;
	                }
	                for (i; i < folds.length; i++) {
	                    fold = folds[i];
	                    fold.start.column += len;
	                    if (!fold.sameRow) {
	                        return;
	                    }
	                    fold.end.column += len;
	                }
	                this.end.column += len;
	            }
	        }
	    };
	    FoldLine.prototype.split = function (row, column) {
	        var pos = this.getNextFoldTo(row, column);
	        if (!pos || pos.kind == "inside")
	            return null;
	        var fold = pos.fold;
	        var folds = this.folds;
	        var foldData = this.foldData;
	        var i = folds.indexOf(fold);
	        var foldBefore = folds[i - 1];
	        this.end.row = foldBefore.end.row;
	        this.end.column = foldBefore.end.column;
	        folds = folds.splice(i, folds.length - i);
	        var newFoldLine = new FoldLine(foldData, folds);
	        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
	        return newFoldLine;
	    };
	    FoldLine.prototype.merge = function (foldLineNext) {
	        var folds = foldLineNext.folds;
	        for (var i = 0; i < folds.length; i++) {
	            this.addFold(folds[i]);
	        }
	        var foldData = this.foldData;
	        foldData.splice(foldData.indexOf(foldLineNext), 1);
	    };
	    FoldLine.prototype.toString = function () {
	        var ret = [this.range.toString() + ": ["];
	        this.folds.forEach(function (fold) {
	            ret.push("  " + fold.toString());
	        });
	        ret.push("]");
	        return ret.join("\n");
	    };
	    FoldLine.prototype.idxToPosition = function (idx) {
	        var lastFoldEndColumn = 0;
	        for (var i = 0; i < this.folds.length; i++) {
	            var fold = this.folds[i];
	            idx -= fold.start.column - lastFoldEndColumn;
	            if (idx < 0) {
	                return {
	                    row: fold.start.row,
	                    column: fold.start.column + idx
	                };
	            }
	            idx -= fold.placeholder.length;
	            if (idx < 0) {
	                return fold.start;
	            }
	            lastFoldEndColumn = fold.end.column;
	        }
	        return {
	            row: this.end.row,
	            column: this.end.column + idx
	        };
	    };
	    return FoldLine;
	}());
	exports.FoldLine = FoldLine;

	});

	ace.define("ace/range_list",["require","exports","module","ace/range"], function(require, exports, module){	var Range = require("./range").Range;
	var comparePoints = Range.comparePoints;
	var RangeList = /** @class */ (function () {
	    function RangeList() {
	        this.ranges = [];
	        this.$bias = 1;
	    }
	    RangeList.prototype.pointIndex = function (pos, excludeEdges, startIndex) {
	        var list = this.ranges;
	        for (var i = startIndex || 0; i < list.length; i++) {
	            var range = list[i];
	            var cmpEnd = comparePoints(pos, range.end);
	            if (cmpEnd > 0)
	                continue;
	            var cmpStart = comparePoints(pos, range.start);
	            if (cmpEnd === 0)
	                return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
	            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
	                return i;
	            return -i - 1;
	        }
	        return -i - 1;
	    };
	    RangeList.prototype.add = function (range) {
	        var excludeEdges = !range.isEmpty();
	        var startIndex = this.pointIndex(range.start, excludeEdges);
	        if (startIndex < 0)
	            startIndex = -startIndex - 1;
	        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
	        if (endIndex < 0)
	            endIndex = -endIndex - 1;
	        else
	            endIndex++;
	        return this.ranges.splice(startIndex, endIndex - startIndex, range);
	    };
	    RangeList.prototype.addList = function (list) {
	        var removed = [];
	        for (var i = list.length; i--;) {
	            removed.push.apply(removed, this.add(list[i]));
	        }
	        return removed;
	    };
	    RangeList.prototype.substractPoint = function (pos) {
	        var i = this.pointIndex(pos);
	        if (i >= 0)
	            return this.ranges.splice(i, 1);
	    };
	    RangeList.prototype.merge = function () {
	        var removed = [];
	        var list = this.ranges;
	        list = list.sort(function (a, b) {
	            return comparePoints(a.start, b.start);
	        });
	        var next = list[0], range;
	        for (var i = 1; i < list.length; i++) {
	            range = next;
	            next = list[i];
	            var cmp = comparePoints(range.end, next.start);
	            if (cmp < 0)
	                continue;
	            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
	                continue;
	            if (comparePoints(range.end, next.end) < 0) {
	                range.end.row = next.end.row;
	                range.end.column = next.end.column;
	            }
	            list.splice(i, 1);
	            removed.push(next);
	            next = range;
	            i--;
	        }
	        this.ranges = list;
	        return removed;
	    };
	    RangeList.prototype.contains = function (row, column) {
	        return this.pointIndex({ row: row, column: column }) >= 0;
	    };
	    RangeList.prototype.containsPoint = function (pos) {
	        return this.pointIndex(pos) >= 0;
	    };
	    RangeList.prototype.rangeAtPoint = function (pos) {
	        var i = this.pointIndex(pos);
	        if (i >= 0)
	            return this.ranges[i];
	    };
	    RangeList.prototype.clipRows = function (startRow, endRow) {
	        var list = this.ranges;
	        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
	            return [];
	        var startIndex = this.pointIndex({ row: startRow, column: 0 });
	        if (startIndex < 0)
	            startIndex = -startIndex - 1;
	        var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
	        if (endIndex < 0)
	            endIndex = -endIndex - 1;
	        var clipped = [];
	        for (var i = startIndex; i < endIndex; i++) {
	            clipped.push(list[i]);
	        }
	        return clipped;
	    };
	    RangeList.prototype.removeAll = function () {
	        return this.ranges.splice(0, this.ranges.length);
	    };
	    RangeList.prototype.attach = function (session) {
	        if (this.session)
	            this.detach();
	        this.session = session;
	        this.onChange = this.$onChange.bind(this);
	        this.session.on('change', this.onChange);
	    };
	    RangeList.prototype.detach = function () {
	        if (!this.session)
	            return;
	        this.session.removeListener('change', this.onChange);
	        this.session = null;
	    };
	    RangeList.prototype.$onChange = function (delta) {
	        var start = delta.start;
	        var end = delta.end;
	        var startRow = start.row;
	        var endRow = end.row;
	        var ranges = this.ranges;
	        for (var i = 0, n = ranges.length; i < n; i++) {
	            var r = ranges[i];
	            if (r.end.row >= startRow)
	                break;
	        }
	        if (delta.action == "insert") {
	            var lineDif = endRow - startRow;
	            var colDiff = -start.column + end.column;
	            for (; i < n; i++) {
	                var r = ranges[i];
	                if (r.start.row > startRow)
	                    break;
	                if (r.start.row == startRow && r.start.column >= start.column) {
	                    if (r.start.column == start.column && this.$bias <= 0) ;
	                    else {
	                        r.start.column += colDiff;
	                        r.start.row += lineDif;
	                    }
	                }
	                if (r.end.row == startRow && r.end.column >= start.column) {
	                    if (r.end.column == start.column && this.$bias < 0) {
	                        continue;
	                    }
	                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
	                        if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
	                            r.end.column -= colDiff;
	                    }
	                    r.end.column += colDiff;
	                    r.end.row += lineDif;
	                }
	            }
	        }
	        else {
	            var lineDif = startRow - endRow;
	            var colDiff = start.column - end.column;
	            for (; i < n; i++) {
	                var r = ranges[i];
	                if (r.start.row > endRow)
	                    break;
	                if (r.end.row < endRow
	                    && (startRow < r.end.row
	                        || startRow == r.end.row && start.column < r.end.column)) {
	                    r.end.row = startRow;
	                    r.end.column = start.column;
	                }
	                else if (r.end.row == endRow) {
	                    if (r.end.column <= end.column) {
	                        if (lineDif || r.end.column > start.column) {
	                            r.end.column = start.column;
	                            r.end.row = start.row;
	                        }
	                    }
	                    else {
	                        r.end.column += colDiff;
	                        r.end.row += lineDif;
	                    }
	                }
	                else if (r.end.row > endRow) {
	                    r.end.row += lineDif;
	                }
	                if (r.start.row < endRow
	                    && (startRow < r.start.row
	                        || startRow == r.start.row && start.column < r.start.column)) {
	                    r.start.row = startRow;
	                    r.start.column = start.column;
	                }
	                else if (r.start.row == endRow) {
	                    if (r.start.column <= end.column) {
	                        if (lineDif || r.start.column > start.column) {
	                            r.start.column = start.column;
	                            r.start.row = start.row;
	                        }
	                    }
	                    else {
	                        r.start.column += colDiff;
	                        r.start.row += lineDif;
	                    }
	                }
	                else if (r.start.row > endRow) {
	                    r.start.row += lineDif;
	                }
	            }
	        }
	        if (lineDif != 0 && i < n) {
	            for (; i < n; i++) {
	                var r = ranges[i];
	                r.start.row += lineDif;
	                r.end.row += lineDif;
	            }
	        }
	    };
	    return RangeList;
	}());
	RangeList.prototype.comparePoints = comparePoints;
	exports.RangeList = RangeList;

	});

	ace.define("ace/edit_session/fold",["require","exports","module","ace/range_list"], function(require, exports, module){	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var RangeList = require("../range_list").RangeList;
	var Fold = /** @class */ (function (_super) {
	    __extends(Fold, _super);
	    function Fold(range, placeholder) {
	        var _this = _super.call(this) || this;
	        _this.foldLine = null;
	        _this.placeholder = placeholder;
	        _this.range = range;
	        _this.start = range.start;
	        _this.end = range.end;
	        _this.sameRow = range.start.row == range.end.row;
	        _this.subFolds = _this.ranges = [];
	        return _this;
	    }
	    Fold.prototype.toString = function () {
	        return '"' + this.placeholder + '" ' + this.range.toString();
	    };
	    Fold.prototype.setFoldLine = function (foldLine) {
	        this.foldLine = foldLine;
	        this.subFolds.forEach(function (fold) {
	            fold.setFoldLine(foldLine);
	        });
	    };
	    Fold.prototype.clone = function () {
	        var range = this.range.clone();
	        var fold = new Fold(range, this.placeholder);
	        this.subFolds.forEach(function (subFold) {
	            fold.subFolds.push(subFold.clone());
	        });
	        fold.collapseChildren = this.collapseChildren;
	        return fold;
	    };
	    Fold.prototype.addSubFold = function (fold) {
	        if (this.range.isEqual(fold))
	            return;
	        consumeRange(fold, this.start);
	        var row = fold.start.row, column = fold.start.column;
	        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
	            cmp = this.subFolds[i].range.compare(row, column);
	            if (cmp != 1)
	                break;
	        }
	        var afterStart = this.subFolds[i];
	        var firstConsumed = 0;
	        if (cmp == 0) {
	            if (afterStart.range.containsRange(fold))
	                return afterStart.addSubFold(fold);
	            else
	                firstConsumed = 1;
	        }
	        var row = fold.range.end.row, column = fold.range.end.column;
	        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
	            cmp = this.subFolds[j].range.compare(row, column);
	            if (cmp != 1)
	                break;
	        }
	        if (cmp == 0)
	            j++;
	        var consumedFolds = this.subFolds.splice(i, j - i, fold);
	        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
	        for (var k = firstConsumed; k < last; k++) {
	            fold.addSubFold(consumedFolds[k]);
	        }
	        fold.setFoldLine(this.foldLine);
	        return fold;
	    };
	    Fold.prototype.restoreRange = function (range) {
	        return restoreRange(range, this.start);
	    };
	    return Fold;
	}(RangeList));
	function consumePoint(point, anchor) {
	    point.row -= anchor.row;
	    if (point.row == 0)
	        point.column -= anchor.column;
	}
	function consumeRange(range, anchor) {
	    consumePoint(range.start, anchor);
	    consumePoint(range.end, anchor);
	}
	function restorePoint(point, anchor) {
	    if (point.row == 0)
	        point.column += anchor.column;
	    point.row += anchor.row;
	}
	function restoreRange(range, anchor) {
	    restorePoint(range.start, anchor);
	    restorePoint(range.end, anchor);
	}
	exports.Fold = Fold;

	});

	ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator","ace/mouse/mouse_event"], function(require, exports, module){// @ts-nocheck
	var Range = require("../range").Range;
	var FoldLine = require("./fold_line").FoldLine;
	var Fold = require("./fold").Fold;
	var TokenIterator = require("../token_iterator").TokenIterator;
	var MouseEvent = require("../mouse/mouse_event").MouseEvent;
	function Folding() {
	    this.getFoldAt = function (row, column, side) {
	        var foldLine = this.getFoldLine(row);
	        if (!foldLine)
	            return null;
	        var folds = foldLine.folds;
	        for (var i = 0; i < folds.length; i++) {
	            var range = folds[i].range;
	            if (range.contains(row, column)) {
	                if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
	                    continue;
	                }
	                else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
	                    continue;
	                }
	                return folds[i];
	            }
	        }
	    };
	    this.getFoldsInRange = function (range) {
	        var start = range.start;
	        var end = range.end;
	        var foldLines = this.$foldData;
	        var foundFolds = [];
	        start.column += 1;
	        end.column -= 1;
	        for (var i = 0; i < foldLines.length; i++) {
	            var cmp = foldLines[i].range.compareRange(range);
	            if (cmp == 2) {
	                continue;
	            }
	            else if (cmp == -2) {
	                break;
	            }
	            var folds = foldLines[i].folds;
	            for (var j = 0; j < folds.length; j++) {
	                var fold = folds[j];
	                cmp = fold.range.compareRange(range);
	                if (cmp == -2) {
	                    break;
	                }
	                else if (cmp == 2) {
	                    continue;
	                }
	                else 
	                if (cmp == 42) {
	                    break;
	                }
	                foundFolds.push(fold);
	            }
	        }
	        start.column -= 1;
	        end.column += 1;
	        return foundFolds;
	    };
	    this.getFoldsInRangeList = function (ranges) {
	        if (Array.isArray(ranges)) {
	            var folds = [];
	            ranges.forEach(function (range) {
	                folds = folds.concat(this.getFoldsInRange(range));
	            }, this);
	        }
	        else {
	            var folds = this.getFoldsInRange(ranges);
	        }
	        return folds;
	    };
	    this.getAllFolds = function () {
	        var folds = [];
	        var foldLines = this.$foldData;
	        for (var i = 0; i < foldLines.length; i++)
	            for (var j = 0; j < foldLines[i].folds.length; j++)
	                folds.push(foldLines[i].folds[j]);
	        return folds;
	    };
	    this.getFoldStringAt = function (row, column, trim, foldLine) {
	        foldLine = foldLine || this.getFoldLine(row);
	        if (!foldLine)
	            return null;
	        var lastFold = {
	            end: { column: 0 }
	        };
	        var str, fold;
	        for (var i = 0; i < foldLine.folds.length; i++) {
	            fold = foldLine.folds[i];
	            var cmp = fold.range.compareEnd(row, column);
	            if (cmp == -1) {
	                str = this
	                    .getLine(fold.start.row)
	                    .substring(lastFold.end.column, fold.start.column);
	                break;
	            }
	            else if (cmp === 0) {
	                return null;
	            }
	            lastFold = fold;
	        }
	        if (!str)
	            str = this.getLine(fold.start.row).substring(lastFold.end.column);
	        if (trim == -1)
	            return str.substring(0, column - lastFold.end.column);
	        else if (trim == 1)
	            return str.substring(column - lastFold.end.column);
	        else
	            return str;
	    };
	    this.getFoldLine = function (docRow, startFoldLine) {
	        var foldData = this.$foldData;
	        var i = 0;
	        if (startFoldLine)
	            i = foldData.indexOf(startFoldLine);
	        if (i == -1)
	            i = 0;
	        for (i; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
	                return foldLine;
	            }
	            else if (foldLine.end.row > docRow) {
	                return null;
	            }
	        }
	        return null;
	    };
	    this.getNextFoldLine = function (docRow, startFoldLine) {
	        var foldData = this.$foldData;
	        var i = 0;
	        if (startFoldLine)
	            i = foldData.indexOf(startFoldLine);
	        if (i == -1)
	            i = 0;
	        for (i; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (foldLine.end.row >= docRow) {
	                return foldLine;
	            }
	        }
	        return null;
	    };
	    this.getFoldedRowCount = function (first, last) {
	        var foldData = this.$foldData, rowCount = last - first + 1;
	        for (var i = 0; i < foldData.length; i++) {
	            var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
	            if (end >= last) {
	                if (start < last) {
	                    if (start >= first)
	                        rowCount -= last - start;
	                    else
	                        rowCount = 0; // in one fold
	                }
	                break;
	            }
	            else if (end >= first) {
	                if (start >= first) // fold inside range
	                    rowCount -= end - start;
	                else
	                    rowCount -= end - first + 1;
	            }
	        }
	        return rowCount;
	    };
	    this.$addFoldLine = function (foldLine) {
	        this.$foldData.push(foldLine);
	        this.$foldData.sort(function (a, b) {
	            return a.start.row - b.start.row;
	        });
	        return foldLine;
	    };
	    this.addFold = function (placeholder, range) {
	        var foldData = this.$foldData;
	        var added = false;
	        var fold;
	        if (placeholder instanceof Fold)
	            fold = placeholder;
	        else {
	            fold = new Fold(range, placeholder);
	            fold.collapseChildren = range.collapseChildren;
	        }
	        this.$clipRangeToDocument(fold.range);
	        var startRow = fold.start.row;
	        var startColumn = fold.start.column;
	        var endRow = fold.end.row;
	        var endColumn = fold.end.column;
	        var startFold = this.getFoldAt(startRow, startColumn, 1);
	        var endFold = this.getFoldAt(endRow, endColumn, -1);
	        if (startFold && endFold == startFold)
	            return startFold.addSubFold(fold);
	        if (startFold && !startFold.range.isStart(startRow, startColumn))
	            this.removeFold(startFold);
	        if (endFold && !endFold.range.isEnd(endRow, endColumn))
	            this.removeFold(endFold);
	        var folds = this.getFoldsInRange(fold.range);
	        if (folds.length > 0) {
	            this.removeFolds(folds);
	            if (!fold.collapseChildren) {
	                folds.forEach(function (subFold) {
	                    fold.addSubFold(subFold);
	                });
	            }
	        }
	        for (var i = 0; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (endRow == foldLine.start.row) {
	                foldLine.addFold(fold);
	                added = true;
	                break;
	            }
	            else if (startRow == foldLine.end.row) {
	                foldLine.addFold(fold);
	                added = true;
	                if (!fold.sameRow) {
	                    var foldLineNext = foldData[i + 1];
	                    if (foldLineNext && foldLineNext.start.row == endRow) {
	                        foldLine.merge(foldLineNext);
	                        break;
	                    }
	                }
	                break;
	            }
	            else if (endRow <= foldLine.start.row) {
	                break;
	            }
	        }
	        if (!added)
	            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
	        if (this.$useWrapMode)
	            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
	        else
	            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
	        this.$modified = true;
	        this._signal("changeFold", { data: fold, action: "add" });
	        return fold;
	    };
	    this.addFolds = function (folds) {
	        folds.forEach(function (fold) {
	            this.addFold(fold);
	        }, this);
	    };
	    this.removeFold = function (fold) {
	        var foldLine = fold.foldLine;
	        var startRow = foldLine.start.row;
	        var endRow = foldLine.end.row;
	        var foldLines = this.$foldData;
	        var folds = foldLine.folds;
	        if (folds.length == 1) {
	            foldLines.splice(foldLines.indexOf(foldLine), 1);
	        }
	        else 
	        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
	            folds.pop();
	            foldLine.end.row = folds[folds.length - 1].end.row;
	            foldLine.end.column = folds[folds.length - 1].end.column;
	        }
	        else 
	        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
	            folds.shift();
	            foldLine.start.row = folds[0].start.row;
	            foldLine.start.column = folds[0].start.column;
	        }
	        else 
	        if (fold.sameRow) {
	            folds.splice(folds.indexOf(fold), 1);
	        }
	        else 
	        {
	            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
	            folds = newFoldLine.folds;
	            folds.shift();
	            newFoldLine.start.row = folds[0].start.row;
	            newFoldLine.start.column = folds[0].start.column;
	        }
	        if (!this.$updating) {
	            if (this.$useWrapMode)
	                this.$updateWrapData(startRow, endRow);
	            else
	                this.$updateRowLengthCache(startRow, endRow);
	        }
	        this.$modified = true;
	        this._signal("changeFold", { data: fold, action: "remove" });
	    };
	    this.removeFolds = function (folds) {
	        var cloneFolds = [];
	        for (var i = 0; i < folds.length; i++) {
	            cloneFolds.push(folds[i]);
	        }
	        cloneFolds.forEach(function (fold) {
	            this.removeFold(fold);
	        }, this);
	        this.$modified = true;
	    };
	    this.expandFold = function (fold) {
	        this.removeFold(fold);
	        fold.subFolds.forEach(function (subFold) {
	            fold.restoreRange(subFold);
	            this.addFold(subFold);
	        }, this);
	        if (fold.collapseChildren > 0) {
	            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
	        }
	        fold.subFolds = [];
	    };
	    this.expandFolds = function (folds) {
	        folds.forEach(function (fold) {
	            this.expandFold(fold);
	        }, this);
	    };
	    this.unfold = function (location, expandInner) {
	        var range, folds;
	        if (location == null) {
	            range = new Range(0, 0, this.getLength(), 0);
	            if (expandInner == null)
	                expandInner = true;
	        }
	        else if (typeof location == "number") {
	            range = new Range(location, 0, location, this.getLine(location).length);
	        }
	        else if ("row" in location) {
	            range = Range.fromPoints(location, location);
	        }
	        else if (Array.isArray(location)) {
	            folds = [];
	            location.forEach(function (range) {
	                folds = folds.concat(this.unfold(range));
	            }, this);
	            return folds;
	        }
	        else {
	            range = location;
	        }
	        folds = this.getFoldsInRangeList(range);
	        var outermostFolds = folds;
	        while (folds.length == 1
	            && Range.comparePoints(folds[0].start, range.start) < 0
	            && Range.comparePoints(folds[0].end, range.end) > 0) {
	            this.expandFolds(folds);
	            folds = this.getFoldsInRangeList(range);
	        }
	        if (expandInner != false) {
	            this.removeFolds(folds);
	        }
	        else {
	            this.expandFolds(folds);
	        }
	        if (outermostFolds.length)
	            return outermostFolds;
	    };
	    this.isRowFolded = function (docRow, startFoldRow) {
	        return !!this.getFoldLine(docRow, startFoldRow);
	    };
	    this.getRowFoldEnd = function (docRow, startFoldRow) {
	        var foldLine = this.getFoldLine(docRow, startFoldRow);
	        return foldLine ? foldLine.end.row : docRow;
	    };
	    this.getRowFoldStart = function (docRow, startFoldRow) {
	        var foldLine = this.getFoldLine(docRow, startFoldRow);
	        return foldLine ? foldLine.start.row : docRow;
	    };
	    this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {
	        if (startRow == null)
	            startRow = foldLine.start.row;
	        if (startColumn == null)
	            startColumn = 0;
	        if (endRow == null)
	            endRow = foldLine.end.row;
	        if (endColumn == null)
	            endColumn = this.getLine(endRow).length;
	        var doc = this.doc;
	        var textLine = "";
	        foldLine.walk(function (placeholder, row, column, lastColumn) {
	            if (row < startRow)
	                return;
	            if (row == startRow) {
	                if (column < startColumn)
	                    return;
	                lastColumn = Math.max(startColumn, lastColumn);
	            }
	            if (placeholder != null) {
	                textLine += placeholder;
	            }
	            else {
	                textLine += doc.getLine(row).substring(lastColumn, column);
	            }
	        }, endRow, endColumn);
	        return textLine;
	    };
	    this.getDisplayLine = function (row, endColumn, startRow, startColumn) {
	        var foldLine = this.getFoldLine(row);
	        if (!foldLine) {
	            var line;
	            line = this.doc.getLine(row);
	            return line.substring(startColumn || 0, endColumn || line.length);
	        }
	        else {
	            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
	        }
	    };
	    this.$cloneFoldData = function () {
	        var fd = [];
	        fd = this.$foldData.map(function (foldLine) {
	            var folds = foldLine.folds.map(function (fold) {
	                return fold.clone();
	            });
	            return new FoldLine(fd, folds);
	        });
	        return fd;
	    };
	    this.toggleFold = function (tryToUnfold) {
	        var selection = this.selection;
	        var range = selection.getRange();
	        var fold;
	        var bracketPos;
	        if (range.isEmpty()) {
	            var cursor = range.start;
	            fold = this.getFoldAt(cursor.row, cursor.column);
	            if (fold) {
	                this.expandFold(fold);
	                return;
	            }
	            else if (tryToUnfold) {
	                var foldLine = this.getFoldLine(cursor.row);
	                if (foldLine)
	                    this.expandFolds(foldLine.folds);
	                return;
	            }
	            else if (bracketPos = this.findMatchingBracket(cursor)) {
	                if (range.comparePoint(bracketPos) == 1) {
	                    range.end = bracketPos;
	                }
	                else {
	                    range.start = bracketPos;
	                    range.start.column++;
	                    range.end.column--;
	                }
	            }
	            else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
	                if (range.comparePoint(bracketPos) == 1)
	                    range.end = bracketPos;
	                else
	                    range.start = bracketPos;
	                range.start.column++;
	            }
	            else {
	                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
	            }
	        }
	        else {
	            var folds = this.getFoldsInRange(range);
	            if (tryToUnfold && folds.length) {
	                this.expandFolds(folds);
	                return;
	            }
	            else if (folds.length == 1) {
	                fold = folds[0];
	            }
	        }
	        if (!fold)
	            fold = this.getFoldAt(range.start.row, range.start.column);
	        if (fold && fold.range.toString() == range.toString()) {
	            this.expandFold(fold);
	            return;
	        }
	        var placeholder = "...";
	        if (!range.isMultiLine()) {
	            placeholder = this.getTextRange(range);
	            if (placeholder.length < 4)
	                return;
	            placeholder = placeholder.trim().substring(0, 2) + "..";
	        }
	        this.addFold(placeholder, range);
	    };
	    this.getCommentFoldRange = function (row, column, dir) {
	        var iterator = new TokenIterator(this, row, column);
	        var token = iterator.getCurrentToken();
	        var type = token && token.type;
	        if (token && /^comment|string/.test(type)) {
	            type = type.match(/comment|string/)[0];
	            if (type == "comment")
	                type += "|doc-start|\\.doc";
	            var re = new RegExp(type);
	            var range = new Range();
	            if (dir != 1) {
	                do {
	                    token = iterator.stepBackward();
	                } while (token && re.test(token.type));
	                token = iterator.stepForward();
	            }
	            range.start.row = iterator.getCurrentTokenRow();
	            range.start.column = iterator.getCurrentTokenColumn() + token.value.length;
	            iterator = new TokenIterator(this, row, column);
	            var initState = this.getState(iterator.$row);
	            if (dir != -1) {
	                var lastRow = -1;
	                do {
	                    token = iterator.stepForward();
	                    if (lastRow == -1) {
	                        var state = this.getState(iterator.$row);
	                        if (initState.toString() !== state.toString())
	                            lastRow = iterator.$row;
	                    }
	                    else if (iterator.$row > lastRow) {
	                        break;
	                    }
	                } while (token && re.test(token.type));
	                token = iterator.stepBackward();
	            }
	            else
	                token = iterator.getCurrentToken();
	            range.end.row = iterator.getCurrentTokenRow();
	            range.end.column = iterator.getCurrentTokenColumn();
	            if (range.start.row == range.end.row && range.start.column > range.end.column)
	                return;
	            return range;
	        }
	    };
	    this.foldAll = function (startRow, endRow, depth, test) {
	        if (depth == undefined)
	            depth = 100000; // JSON.stringify doesn't hanle Infinity
	        var foldWidgets = this.foldWidgets;
	        if (!foldWidgets)
	            return; // mode doesn't support folding
	        endRow = endRow || this.getLength();
	        startRow = startRow || 0;
	        for (var row = startRow; row < endRow; row++) {
	            if (foldWidgets[row] == null)
	                foldWidgets[row] = this.getFoldWidget(row);
	            if (foldWidgets[row] != "start")
	                continue;
	            if (test && !test(row))
	                continue;
	            var range = this.getFoldWidgetRange(row);
	            if (range && range.isMultiLine()
	                && range.end.row <= endRow
	                && range.start.row >= startRow) {
	                row = range.end.row;
	                range.collapseChildren = depth;
	                this.addFold("...", range);
	            }
	        }
	    };
	    this.foldToLevel = function (level) {
	        this.foldAll();
	        while (level-- > 0)
	            this.unfold(null, false);
	    };
	    this.foldAllComments = function () {
	        var session = this;
	        this.foldAll(null, null, null, function (row) {
	            var tokens = session.getTokens(row);
	            for (var i = 0; i < tokens.length; i++) {
	                var token = tokens[i];
	                if (token.type == "text" && /^\s+$/.test(token.value))
	                    continue;
	                if (/comment/.test(token.type))
	                    return true;
	                return false;
	            }
	        });
	    };
	    this.$foldStyles = {
	        "manual": 1,
	        "markbegin": 1,
	        "markbeginend": 1
	    };
	    this.$foldStyle = "markbegin";
	    this.setFoldStyle = function (style) {
	        if (!this.$foldStyles[style])
	            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
	        if (this.$foldStyle == style)
	            return;
	        this.$foldStyle = style;
	        if (style == "manual")
	            this.unfold();
	        var mode = this.$foldMode;
	        this.$setFolding(null);
	        this.$setFolding(mode);
	    };
	    this.$setFolding = function (foldMode) {
	        if (this.$foldMode == foldMode)
	            return;
	        this.$foldMode = foldMode;
	        this.off('change', this.$updateFoldWidgets);
	        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
	        this._signal("changeAnnotation");
	        if (!foldMode || this.$foldStyle == "manual") {
	            this.foldWidgets = null;
	            return;
	        }
	        this.foldWidgets = [];
	        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
	        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
	        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
	        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
	        this.on('change', this.$updateFoldWidgets);
	        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
	    };
	    this.getParentFoldRangeData = function (row, ignoreCurrent) {
	        var fw = this.foldWidgets;
	        if (!fw || (ignoreCurrent && fw[row]))
	            return {};
	        var i = row - 1, firstRange;
	        while (i >= 0) {
	            var c = fw[i];
	            if (c == null)
	                c = fw[i] = this.getFoldWidget(i);
	            if (c == "start") {
	                var range = this.getFoldWidgetRange(i);
	                if (!firstRange)
	                    firstRange = range;
	                if (range && range.end.row >= row)
	                    break;
	            }
	            i--;
	        }
	        return {
	            range: i !== -1 && range,
	            firstRange: firstRange
	        };
	    };
	    this.onFoldWidgetClick = function (row, e) {
	        if (e instanceof MouseEvent)
	            e = e.domEvent;
	        var options = {
	            children: e.shiftKey,
	            all: e.ctrlKey || e.metaKey,
	            siblings: e.altKey
	        };
	        var range = this.$toggleFoldWidget(row, options);
	        if (!range) {
	            var el = (e.target || e.srcElement);
	            if (el && /ace_fold-widget/.test(el.className))
	                el.className += " ace_invalid";
	        }
	    };
	    this.$toggleFoldWidget = function (row, options) {
	        if (!this.getFoldWidget)
	            return;
	        var type = this.getFoldWidget(row);
	        var line = this.getLine(row);
	        var dir = type === "end" ? -1 : 1;
	        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
	        if (fold) {
	            if (options.children || options.all)
	                this.removeFold(fold);
	            else
	                this.expandFold(fold);
	            return fold;
	        }
	        var range = this.getFoldWidgetRange(row, true);
	        if (range && !range.isMultiLine()) {
	            fold = this.getFoldAt(range.start.row, range.start.column, 1);
	            if (fold && range.isEqual(fold.range)) {
	                this.removeFold(fold);
	                return fold;
	            }
	        }
	        if (options.siblings) {
	            var data = this.getParentFoldRangeData(row);
	            if (data.range) {
	                var startRow = data.range.start.row + 1;
	                var endRow = data.range.end.row;
	            }
	            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
	        }
	        else if (options.children) {
	            endRow = range ? range.end.row : this.getLength();
	            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
	        }
	        else if (range) {
	            if (options.all)
	                range.collapseChildren = 10000;
	            this.addFold("...", range);
	        }
	        return range;
	    };
	    this.toggleFoldWidget = function (toggleParent) {
	        var row = this.selection.getCursor().row;
	        row = this.getRowFoldStart(row);
	        var range = this.$toggleFoldWidget(row, {});
	        if (range)
	            return;
	        var data = this.getParentFoldRangeData(row, true);
	        range = data.range || data.firstRange;
	        if (range) {
	            row = range.start.row;
	            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
	            if (fold) {
	                this.removeFold(fold);
	            }
	            else {
	                this.addFold("...", range);
	            }
	        }
	    };
	    this.updateFoldWidgets = function (delta) {
	        var firstRow = delta.start.row;
	        var len = delta.end.row - firstRow;
	        if (len === 0) {
	            this.foldWidgets[firstRow] = null;
	        }
	        else if (delta.action == 'remove') {
	            this.foldWidgets.splice(firstRow, len + 1, null);
	        }
	        else {
	            var args = Array(len + 1);
	            args.unshift(firstRow, 1);
	            this.foldWidgets.splice.apply(this.foldWidgets, args);
	        }
	    };
	    this.tokenizerUpdateFoldWidgets = function (e) {
	        var rows = e.data;
	        if (rows.first != rows.last) {
	            if (this.foldWidgets.length > rows.first)
	                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
	        }
	    };
	}
	exports.Folding = Folding;

	});

	ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(require, exports, module){	var TokenIterator = require("../token_iterator").TokenIterator;
	var Range = require("../range").Range;
	function BracketMatch() {
	    this.findMatchingBracket = function (position, chr) {
	        if (position.column == 0)
	            return null;
	        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
	        if (charBeforeCursor == "")
	            return null;
	        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
	        if (!match)
	            return null;
	        if (match[1])
	            return this.$findClosingBracket(match[1], position);
	        else
	            return this.$findOpeningBracket(match[2], position);
	    };
	    this.getBracketRange = function (pos) {
	        var line = this.getLine(pos.row);
	        var before = true, range;
	        var chr = line.charAt(pos.column - 1);
	        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
	        if (!match) {
	            chr = line.charAt(pos.column);
	            pos = { row: pos.row, column: pos.column + 1 };
	            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
	            before = false;
	        }
	        if (!match)
	            return null;
	        if (match[1]) {
	            var bracketPos = this.$findClosingBracket(match[1], pos);
	            if (!bracketPos)
	                return null;
	            range = Range.fromPoints(pos, bracketPos);
	            if (!before) {
	                range.end.column++;
	                range.start.column--;
	            }
	            range.cursor = range.end;
	        }
	        else {
	            var bracketPos = this.$findOpeningBracket(match[2], pos);
	            if (!bracketPos)
	                return null;
	            range = Range.fromPoints(bracketPos, pos);
	            if (!before) {
	                range.start.column++;
	                range.end.column--;
	            }
	            range.cursor = range.start;
	        }
	        return range;
	    };
	    this.getMatchingBracketRanges = function (pos, isBackwards) {
	        var line = this.getLine(pos.row);
	        var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
	        var chr = !isBackwards && line.charAt(pos.column - 1);
	        var match = chr && chr.match(bracketsRegExp);
	        if (!match) {
	            chr = (isBackwards === undefined || isBackwards) && line.charAt(pos.column);
	            pos = {
	                row: pos.row,
	                column: pos.column + 1
	            };
	            match = chr && chr.match(bracketsRegExp);
	        }
	        if (!match)
	            return null;
	        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
	        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)
	            : this.$findOpeningBracket(match[2], pos);
	        if (!bracketPos)
	            return [startRange];
	        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
	        return [startRange, endRange];
	    };
	    this.$brackets = {
	        ")": "(",
	        "(": ")",
	        "]": "[",
	        "[": "]",
	        "{": "}",
	        "}": "{",
	        "<": ">",
	        ">": "<"
	    };
	    this.$findOpeningBracket = function (bracket, position, typeRe) {
	        var openBracket = this.$brackets[bracket];
	        var depth = 1;
	        var iterator = new TokenIterator(this, position.row, position.column);
	        var token = iterator.getCurrentToken();
	        if (!token)
	            token = iterator.stepForward();
	        if (!token)
	            return;
	        if (!typeRe) {
	            typeRe = new RegExp("(\\.?" +
	                token.type.replace(".", "\\.").replace("rparen", ".paren")
	                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
	                    .replace(/-close\b/, "-(close|open)")
	                + ")+");
	        }
	        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
	        var value = token.value;
	        while (true) {
	            while (valueIndex >= 0) {
	                var chr = value.charAt(valueIndex);
	                if (chr == openBracket) {
	                    depth -= 1;
	                    if (depth == 0) {
	                        return { row: iterator.getCurrentTokenRow(),
	                            column: valueIndex + iterator.getCurrentTokenColumn() };
	                    }
	                }
	                else if (chr == bracket) {
	                    depth += 1;
	                }
	                valueIndex -= 1;
	            }
	            do {
	                token = iterator.stepBackward();
	            } while (token && !typeRe.test(token.type));
	            if (token == null)
	                break;
	            value = token.value;
	            valueIndex = value.length - 1;
	        }
	        return null;
	    };
	    this.$findClosingBracket = function (bracket, position, typeRe) {
	        var closingBracket = this.$brackets[bracket];
	        var depth = 1;
	        var iterator = new TokenIterator(this, position.row, position.column);
	        var token = iterator.getCurrentToken();
	        if (!token)
	            token = iterator.stepForward();
	        if (!token)
	            return;
	        if (!typeRe) {
	            typeRe = new RegExp("(\\.?" +
	                token.type.replace(".", "\\.").replace("lparen", ".paren")
	                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
	                    .replace(/-open\b/, "-(close|open)")
	                + ")+");
	        }
	        var valueIndex = position.column - iterator.getCurrentTokenColumn();
	        while (true) {
	            var value = token.value;
	            var valueLength = value.length;
	            while (valueIndex < valueLength) {
	                var chr = value.charAt(valueIndex);
	                if (chr == closingBracket) {
	                    depth -= 1;
	                    if (depth == 0) {
	                        return { row: iterator.getCurrentTokenRow(),
	                            column: valueIndex + iterator.getCurrentTokenColumn() };
	                    }
	                }
	                else if (chr == bracket) {
	                    depth += 1;
	                }
	                valueIndex += 1;
	            }
	            do {
	                token = iterator.stepForward();
	            } while (token && !typeRe.test(token.type));
	            if (token == null)
	                break;
	            valueIndex = 0;
	        }
	        return null;
	    };
	    this.getMatchingTags = function (pos) {
	        var iterator = new TokenIterator(this, pos.row, pos.column);
	        var token = this.$findTagName(iterator);
	        if (!token)
	            return;
	        var prevToken = iterator.stepBackward();
	        if (prevToken.value === '<') {
	            return this.$findClosingTag(iterator, token);
	        }
	        else {
	            return this.$findOpeningTag(iterator, token);
	        }
	    };
	    this.$findTagName = function (iterator) {
	        var token = iterator.getCurrentToken();
	        var found = false;
	        var backward = false;
	        if (token && token.type.indexOf('tag-name') === -1) {
	            do {
	                if (backward)
	                    token = iterator.stepBackward();
	                else
	                    token = iterator.stepForward();
	                if (token) {
	                    if (token.value === "/>") {
	                        backward = true;
	                    }
	                    else if (token.type.indexOf('tag-name') !== -1) {
	                        found = true;
	                    }
	                }
	            } while (token && !found);
	        }
	        return token;
	    };
	    this.$findClosingTag = function (iterator, token) {
	        var prevToken;
	        var currentTag = token.value;
	        var tag = token.value;
	        var depth = 0;
	        var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
	        token = iterator.stepForward();
	        var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
	        var foundOpenTagEnd = false;
	        do {
	            prevToken = token;
	            if (prevToken.type.indexOf('tag-close') !== -1 && !foundOpenTagEnd) {
	                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`
	                foundOpenTagEnd = true;
	            }
	            token = iterator.stepForward();
	            if (token) {
	                if (token.value === '>' && !foundOpenTagEnd) {
	                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`
	                    foundOpenTagEnd = true;
	                }
	                if (token.type.indexOf('tag-name') !== -1) {
	                    currentTag = token.value;
	                    if (tag === currentTag) {
	                        if (prevToken.value === '<') {
	                            depth++;
	                        }
	                        else if (prevToken.value === '</') {
	                            depth--;
	                            if (depth < 0) { //found closing tag
	                                iterator.stepBackward();
	                                var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2); //Range for </
	                                token = iterator.stepForward();
	                                var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
	                                if (token.type.indexOf('tag-close') === -1) {
	                                    token = iterator.stepForward();
	                                }
	                                if (token && token.value === '>') {
	                                    var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
	                                }
	                                else {
	                                    return;
	                                }
	                            }
	                        }
	                    }
	                }
	                else if (tag === currentTag && token.value === '/>') { // self-closing tag
	                    depth--;
	                    if (depth < 0) { //found self-closing tag end
	                        var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
	                        var closeTagName = closeTagStart;
	                        var closeTagEnd = closeTagName;
	                        var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
	                    }
	                }
	            }
	        } while (token && depth >= 0);
	        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
	            return {
	                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
	                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
	                openTagName: openTagName,
	                closeTagName: closeTagName
	            };
	        }
	    };
	    this.$findOpeningTag = function (iterator, token) {
	        var prevToken = iterator.getCurrentToken();
	        var tag = token.value;
	        var depth = 0;
	        var startRow = iterator.getCurrentTokenRow();
	        var startColumn = iterator.getCurrentTokenColumn();
	        var endColumn = startColumn + 2;
	        var closeTagStart = new Range(startRow, startColumn, startRow, endColumn); //Range for </
	        iterator.stepForward();
	        var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
	        if (token.type.indexOf('tag-close') === -1) {
	            token = iterator.stepForward();
	        }
	        if (!token || token.value !== ">")
	            return;
	        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
	        iterator.stepBackward();
	        iterator.stepBackward();
	        do {
	            token = prevToken;
	            startRow = iterator.getCurrentTokenRow();
	            startColumn = iterator.getCurrentTokenColumn();
	            endColumn = startColumn + token.value.length;
	            prevToken = iterator.stepBackward();
	            if (token) {
	                if (token.type.indexOf('tag-name') !== -1) {
	                    if (tag === token.value) {
	                        if (prevToken.value === '<') {
	                            depth++;
	                            if (depth > 0) { //found opening tag
	                                var openTagName = new Range(startRow, startColumn, startRow, endColumn);
	                                var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for <
	                                do {
	                                    token = iterator.stepForward();
	                                } while (token && token.value !== '>');
	                                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
	                            }
	                        }
	                        else if (prevToken.value === '</') {
	                            depth--;
	                        }
	                    }
	                }
	                else if (token.value === '/>') { // self-closing tag
	                    var stepCount = 0;
	                    var tmpToken = prevToken;
	                    while (tmpToken) {
	                        if (tmpToken.type.indexOf('tag-name') !== -1 && tmpToken.value === tag) {
	                            depth--;
	                            break;
	                        }
	                        else if (tmpToken.value === '<') {
	                            break;
	                        }
	                        tmpToken = iterator.stepBackward();
	                        stepCount++;
	                    }
	                    for (var i = 0; i < stepCount; i++) {
	                        iterator.stepForward();
	                    }
	                }
	            }
	        } while (prevToken && depth <= 0);
	        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
	            return {
	                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
	                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
	                openTagName: openTagName,
	                closeTagName: closeTagName
	            };
	        }
	    };
	}
	exports.BracketMatch = BracketMatch;

	});

	ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/bidihandler","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/line_widgets","ace/document","ace/background_tokenizer","ace/search_highlight","ace/undomanager","ace/edit_session/folding","ace/edit_session/bracket_match"], function(require, exports, module){	var oop = require("./lib/oop");
	var lang = require("./lib/lang");
	var BidiHandler = require("./bidihandler").BidiHandler;
	var config = require("./config");
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var Selection = require("./selection").Selection;
	var TextMode = require("./mode/text").Mode;
	var Range = require("./range").Range;
	var LineWidgets = require("./line_widgets").LineWidgets;
	var Document = require("./document").Document;
	var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
	var SearchHighlight = require("./search_highlight").SearchHighlight;
	var UndoManager = require("./undomanager").UndoManager;
	var EditSession = /** @class */ (function () {
	    function EditSession(text, mode) { this.doc;
	        this.$breakpoints = [];
	        this.$decorations = [];
	        this.$frontMarkers = {};
	        this.$backMarkers = {};
	        this.$markerId = 1;
	        this.$undoSelect = true;
	        this.$editor = null;
	        this.prevOp = {};
	        this.$foldData = [];
	        this.id = "session" + (++EditSession.$uid);
	        this.$foldData.toString = function () {
	            return this.join("\n");
	        };
	        this.$gutterCustomWidgets = {};
	        this.bgTokenizer = new BackgroundTokenizer((new TextMode()).getTokenizer(), this);
	        var _self = this;
	        this.bgTokenizer.on("update", function (e) {
	            _self._signal("tokenizerUpdate", e);
	        });
	        this.on("changeFold", this.onChangeFold.bind(this));
	        this.$onChange = this.onChange.bind(this);
	        if (typeof text != "object" || !text.getLine)
	            text = new Document(/**@type{string}*/ (text));
	        this.setDocument(text);
	        this.selection = new Selection(this);
	        this.$onSelectionChange = this.onSelectionChange.bind(this);
	        this.selection.on("changeSelection", this.$onSelectionChange);
	        this.selection.on("changeCursor", this.$onSelectionChange);
	        this.$bidiHandler = new BidiHandler(this);
	        config.resetOptions(this);
	        this.setMode(mode);
	        config._signal("session", this);
	        this.destroyed = false;
	        this.$initOperationListeners();
	    }
	    EditSession.prototype.$initOperationListeners = function () {
	        var _this = this;
	        this.curOp = null;
	        this.on("change", function () {
	            if (!_this.curOp) {
	                _this.startOperation();
	                _this.curOp.selectionBefore = _this.$lastSel;
	            }
	            _this.curOp.docChanged = true;
	        }, true);
	        this.on("changeSelection", function () {
	            if (!_this.curOp) {
	                _this.startOperation();
	                _this.curOp.selectionBefore = _this.$lastSel;
	            }
	            _this.curOp.selectionChanged = true;
	        }, true);
	        this.$operationResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
	    };
	    EditSession.prototype.startOperation = function (commandEvent) {
	        if (this.curOp) {
	            if (!commandEvent || this.curOp.command) {
	                return;
	            }
	            this.prevOp = this.curOp;
	        }
	        if (!commandEvent) {
	            commandEvent = {};
	        }
	        this.$operationResetTimer.schedule();
	        this.curOp = {
	            command: commandEvent.command || {},
	            args: commandEvent.args
	        };
	        this.curOp.selectionBefore = this.selection.toJSON();
	        this._signal("startOperation", commandEvent);
	    };
	    EditSession.prototype.endOperation = function (e) {
	        if (this.curOp) {
	            if (e && e.returnValue === false) {
	                this.curOp = null;
	                this._signal("endOperation", e);
	                return;
	            }
	            if (e == true && this.curOp.command && this.curOp.command.name == "mouse") {
	                return;
	            }
	            var currentSelection = this.selection.toJSON();
	            this.curOp.selectionAfter = currentSelection;
	            this.$lastSel = this.selection.toJSON();
	            this.getUndoManager().addSelection(currentSelection);
	            this._signal("beforeEndOperation");
	            this.prevOp = this.curOp;
	            this.curOp = null;
	            this._signal("endOperation", e);
	        }
	    };
	    EditSession.prototype.setDocument = function (doc) {
	        if (this.doc)
	            this.doc.off("change", this.$onChange);
	        this.doc = doc;
	        doc.on("change", this.$onChange, true);
	        this.bgTokenizer.setDocument(this.getDocument());
	        this.resetCaches();
	    };
	    EditSession.prototype.getDocument = function () {
	        return this.doc;
	    };
	    Object.defineProperty(EditSession.prototype, "widgetManager", {
	        get: function () {
	            var widgetManager = new LineWidgets(this);
	            this.widgetManager = widgetManager;
	            if (this.$editor)
	                widgetManager.attach(this.$editor);
	            return widgetManager;
	        },
	        set: function (value) {
	            Object.defineProperty(this, "widgetManager", {
	                writable: true,
	                enumerable: true,
	                configurable: true,
	                value: value,
	            });
	        },
	        enumerable: false,
	        configurable: true
	    });
	    EditSession.prototype.$resetRowCache = function (docRow) {
	        if (!docRow) {
	            this.$docRowCache = [];
	            this.$screenRowCache = [];
	            return;
	        }
	        var l = this.$docRowCache.length;
	        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
	        if (l > i) {
	            this.$docRowCache.splice(i, l);
	            this.$screenRowCache.splice(i, l);
	        }
	    };
	    EditSession.prototype.$getRowCacheIndex = function (cacheArray, val) {
	        var low = 0;
	        var hi = cacheArray.length - 1;
	        while (low <= hi) {
	            var mid = (low + hi) >> 1;
	            var c = cacheArray[mid];
	            if (val > c)
	                low = mid + 1;
	            else if (val < c)
	                hi = mid - 1;
	            else
	                return mid;
	        }
	        return low - 1;
	    };
	    EditSession.prototype.resetCaches = function () {
	        this.$modified = true;
	        this.$wrapData = [];
	        this.$rowLengthCache = [];
	        this.$resetRowCache(0);
	        if (!this.destroyed)
	            this.bgTokenizer.start(0);
	    };
	    EditSession.prototype.onChangeFold = function (e) {
	        var fold = e.data;
	        this.$resetRowCache(fold.start.row);
	    };
	    EditSession.prototype.onChange = function (delta) {
	        this.$modified = true;
	        this.$bidiHandler.onChange(delta);
	        this.$resetRowCache(delta.start.row);
	        var removedFolds = this.$updateInternalDataOnChange(delta);
	        if (!this.$fromUndo && this.$undoManager) {
	            if (removedFolds && removedFolds.length) {
	                this.$undoManager.add({
	                    action: "removeFolds",
	                    folds: removedFolds
	                }, this.mergeUndoDeltas);
	                this.mergeUndoDeltas = true;
	            }
	            this.$undoManager.add(delta, this.mergeUndoDeltas);
	            this.mergeUndoDeltas = true;
	            this.$informUndoManager.schedule();
	        }
	        this.bgTokenizer.$updateOnChange(delta);
	        this._signal("change", delta);
	    };
	    EditSession.prototype.onSelectionChange = function () {
	        this._signal("changeSelection");
	    };
	    EditSession.prototype.setValue = function (text) {
	        this.doc.setValue(text);
	        this.selection.moveTo(0, 0);
	        this.$resetRowCache(0);
	        this.setUndoManager(this.$undoManager);
	        this.getUndoManager().reset();
	    };
	    EditSession.fromJSON = function (session) {
	        if (typeof session == "string")
	            session = JSON.parse(session);
	        var undoManager = new UndoManager();
	        undoManager.$undoStack = session.history.undo;
	        undoManager.$redoStack = session.history.redo;
	        undoManager.mark = session.history.mark;
	        undoManager.$rev = session.history.rev;
	        var editSession = new EditSession(session.value);
	        session.folds.forEach(function (fold) {
	            editSession.addFold("...", Range.fromPoints(fold.start, fold.end));
	        });
	        editSession.setAnnotations(session.annotations);
	        editSession.setBreakpoints(session.breakpoints);
	        editSession.setMode(session.mode);
	        editSession.setScrollLeft(session.scrollLeft);
	        editSession.setScrollTop(session.scrollTop);
	        editSession.setUndoManager(undoManager);
	        editSession.selection.fromJSON(session.selection);
	        return editSession;
	    };
	    EditSession.prototype.toJSON = function () {
	        return {
	            annotations: this.$annotations,
	            breakpoints: this.$breakpoints,
	            folds: this.getAllFolds().map(function (fold) {
	                return fold.range;
	            }),
	            history: this.getUndoManager(),
	            mode: this.$mode.$id,
	            scrollLeft: this.$scrollLeft,
	            scrollTop: this.$scrollTop,
	            selection: this.selection.toJSON(),
	            value: this.doc.getValue()
	        };
	    };
	    EditSession.prototype.toString = function () {
	        return this.doc.getValue();
	    };
	    EditSession.prototype.getSelection = function () {
	        return this.selection;
	    };
	    EditSession.prototype.getState = function (row) {
	        return this.bgTokenizer.getState(row);
	    };
	    EditSession.prototype.getTokens = function (row) {
	        return this.bgTokenizer.getTokens(row);
	    };
	    EditSession.prototype.getTokenAt = function (row, column) {
	        var tokens = this.bgTokenizer.getTokens(row);
	        var token, c = 0;
	        if (column == null) {
	            var i = tokens.length - 1;
	            c = this.getLine(row).length;
	        }
	        else {
	            for (var i = 0; i < tokens.length; i++) {
	                c += tokens[i].value.length;
	                if (c >= column)
	                    break;
	            }
	        }
	        token = tokens[i];
	        if (!token)
	            return null;
	        token.index = i;
	        token.start = c - token.value.length;
	        return token;
	    };
	    EditSession.prototype.setUndoManager = function (undoManager) {
	        this.$undoManager = undoManager;
	        if (this.$informUndoManager)
	            this.$informUndoManager.cancel();
	        if (undoManager) {
	            var self = this;
	            undoManager.addSession(this);
	            this.$syncInformUndoManager = function () {
	                self.$informUndoManager.cancel();
	                self.mergeUndoDeltas = false;
	            };
	            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
	        }
	        else {
	            this.$syncInformUndoManager = function () { };
	        }
	    };
	    EditSession.prototype.markUndoGroup = function () {
	        if (this.$syncInformUndoManager)
	            this.$syncInformUndoManager();
	    };
	    EditSession.prototype.getUndoManager = function () {
	        return this.$undoManager || this.$defaultUndoManager;
	    };
	    EditSession.prototype.getTabString = function () {
	        if (this.getUseSoftTabs()) {
	            return lang.stringRepeat(" ", this.getTabSize());
	        }
	        else {
	            return "\t";
	        }
	    };
	    EditSession.prototype.setUseSoftTabs = function (val) {
	        this.setOption("useSoftTabs", val);
	    };
	    EditSession.prototype.getUseSoftTabs = function () {
	        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
	    };
	    EditSession.prototype.setTabSize = function (tabSize) {
	        this.setOption("tabSize", tabSize);
	    };
	    EditSession.prototype.getTabSize = function () {
	        return this.$tabSize;
	    };
	    EditSession.prototype.isTabStop = function (position) {
	        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
	    };
	    EditSession.prototype.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
	        this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
	    };
	    EditSession.prototype.getNavigateWithinSoftTabs = function () {
	        return this.$navigateWithinSoftTabs;
	    };
	    EditSession.prototype.setOverwrite = function (overwrite) {
	        this.setOption("overwrite", overwrite);
	    };
	    EditSession.prototype.getOverwrite = function () {
	        return this.$overwrite;
	    };
	    EditSession.prototype.toggleOverwrite = function () {
	        this.setOverwrite(!this.$overwrite);
	    };
	    EditSession.prototype.addGutterDecoration = function (row, className) {
	        if (!this.$decorations[row])
	            this.$decorations[row] = "";
	        this.$decorations[row] += " " + className;
	        this._signal("changeBreakpoint", {});
	    };
	    EditSession.prototype.removeGutterCustomWidget = function (row) {
	        if (this.$editor) {
	            this.$editor.renderer.$gutterLayer.$removeCustomWidget(row);
	        }
	    };
	    EditSession.prototype.addGutterCustomWidget = function (row, attributes) {
	        if (this.$editor) {
	            this.$editor.renderer.$gutterLayer.$addCustomWidget(row, attributes);
	        }
	    };
	    EditSession.prototype.removeGutterDecoration = function (row, className) {
	        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
	        this._signal("changeBreakpoint", {});
	    };
	    EditSession.prototype.getBreakpoints = function () {
	        return this.$breakpoints;
	    };
	    EditSession.prototype.setBreakpoints = function (rows) {
	        this.$breakpoints = [];
	        for (var i = 0; i < rows.length; i++) {
	            this.$breakpoints[rows[i]] = "ace_breakpoint";
	        }
	        this._signal("changeBreakpoint", {});
	    };
	    EditSession.prototype.clearBreakpoints = function () {
	        this.$breakpoints = [];
	        this._signal("changeBreakpoint", {});
	    };
	    EditSession.prototype.setBreakpoint = function (row, className) {
	        if (className === undefined)
	            className = "ace_breakpoint";
	        if (className)
	            this.$breakpoints[row] = className;
	        else
	            delete this.$breakpoints[row];
	        this._signal("changeBreakpoint", {});
	    };
	    EditSession.prototype.clearBreakpoint = function (row) {
	        delete this.$breakpoints[row];
	        this._signal("changeBreakpoint", {});
	    };
	    EditSession.prototype.addMarker = function (range, clazz, type, inFront) {
	        var id = this.$markerId++;
	        var marker = {
	            range: range,
	            type: type || "line",
	            renderer: typeof type == "function" ? type : null,
	            clazz: clazz,
	            inFront: !!inFront,
	            id: id
	        };
	        if (inFront) {
	            this.$frontMarkers[id] = marker;
	            this._signal("changeFrontMarker");
	        }
	        else {
	            this.$backMarkers[id] = marker;
	            this._signal("changeBackMarker");
	        }
	        return id;
	    };
	    EditSession.prototype.addDynamicMarker = function (marker, inFront) {
	        if (!marker.update)
	            return;
	        var id = this.$markerId++;
	        marker.id = id;
	        marker.inFront = !!inFront;
	        if (inFront) {
	            this.$frontMarkers[id] = marker;
	            this._signal("changeFrontMarker");
	        }
	        else {
	            this.$backMarkers[id] = marker;
	            this._signal("changeBackMarker");
	        }
	        return marker;
	    };
	    EditSession.prototype.removeMarker = function (markerId) {
	        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
	        if (!marker)
	            return;
	        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
	        delete (markers[markerId]);
	        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
	    };
	    EditSession.prototype.getMarkers = function (inFront) {
	        return inFront ? this.$frontMarkers : this.$backMarkers;
	    };
	    EditSession.prototype.highlight = function (re) {
	        if (!this.$searchHighlight) {
	            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
	            this.$searchHighlight = this.addDynamicMarker(highlight);
	        }
	        this.$searchHighlight.setRegexp(re);
	    };
	    EditSession.prototype.highlightLines = function (startRow, endRow, clazz, inFront) {
	        if (typeof endRow != "number") {
	            clazz = endRow;
	            endRow = startRow;
	        }
	        if (!clazz)
	            clazz = "ace_step";
	        var range = new Range(startRow, 0, endRow, Infinity);
	        range.id = this.addMarker(range, clazz, "fullLine", inFront);
	        return range;
	    };
	    EditSession.prototype.setAnnotations = function (annotations) {
	        this.$annotations = annotations;
	        this._signal("changeAnnotation", {});
	    };
	    EditSession.prototype.getAnnotations = function () {
	        return this.$annotations || [];
	    };
	    EditSession.prototype.clearAnnotations = function () {
	        this.setAnnotations([]);
	    };
	    EditSession.prototype.$detectNewLine = function (text) {
	        var match = text.match(/^.*?(\r?\n)/m);
	        if (match) {
	            this.$autoNewLine = match[1];
	        }
	        else {
	            this.$autoNewLine = "\n";
	        }
	    };
	    EditSession.prototype.getWordRange = function (row, column) {
	        var line = this.getLine(row);
	        var inToken = false;
	        if (column > 0)
	            inToken = !!line.charAt(column - 1).match(this.tokenRe);
	        if (!inToken)
	            inToken = !!line.charAt(column).match(this.tokenRe);
	        if (inToken)
	            var re = this.tokenRe;
	        else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
	            var re = /\s/;
	        else
	            var re = this.nonTokenRe;
	        var start = column;
	        if (start > 0) {
	            do {
	                start--;
	            } while (start >= 0 && line.charAt(start).match(re));
	            start++;
	        }
	        var end = column;
	        while (end < line.length && line.charAt(end).match(re)) {
	            end++;
	        }
	        return new Range(row, start, row, end);
	    };
	    EditSession.prototype.getAWordRange = function (row, column) {
	        var wordRange = this.getWordRange(row, column);
	        var line = this.getLine(wordRange.end.row);
	        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
	            wordRange.end.column += 1;
	        }
	        return wordRange;
	    };
	    EditSession.prototype.setNewLineMode = function (newLineMode) {
	        this.doc.setNewLineMode(newLineMode);
	    };
	    EditSession.prototype.getNewLineMode = function () {
	        return this.doc.getNewLineMode();
	    };
	    EditSession.prototype.setUseWorker = function (useWorker) { this.setOption("useWorker", useWorker); };
	    EditSession.prototype.getUseWorker = function () { return this.$useWorker; };
	    EditSession.prototype.onReloadTokenizer = function (e) {
	        var rows = e.data;
	        this.bgTokenizer.start(rows.first);
	        this._signal("tokenizerUpdate", e);
	    };
	    EditSession.prototype.setMode = function (mode, cb) {
	        if (mode && typeof mode === "object") {
	            if (mode.getTokenizer)
	                return this.$onChangeMode(mode);
	            var options = mode;
	            var path = options.path;
	        }
	        else {
	            path = /**@type{string}*/ (mode) || "ace/mode/text";
	        }
	        if (!this.$modes["ace/mode/text"])
	            this.$modes["ace/mode/text"] = new TextMode();
	        if (this.$modes[path] && !options) {
	            this.$onChangeMode(this.$modes[path]);
	            cb && cb();
	            return;
	        }
	        this.$modeId = path;
	        config.loadModule(["mode", path], function (m) {
	            if (this.destroyed) {
	                return;
	            }
	            if (this.$modeId !== path)
	                return cb && cb();
	            if (this.$modes[path] && !options) {
	                this.$onChangeMode(this.$modes[path]);
	            }
	            else if (m && m.Mode) {
	                m = new m.Mode(options);
	                if (!options) {
	                    this.$modes[path] = m;
	                    m.$id = path;
	                }
	                this.$onChangeMode(m);
	            }
	            cb && cb();
	        }.bind(this));
	        if (!this.$mode)
	            this.$onChangeMode(this.$modes["ace/mode/text"], true);
	    };
	    EditSession.prototype.$onChangeMode = function (mode, $isPlaceholder) {
	        if (!$isPlaceholder)
	            this.$modeId = mode.$id;
	        if (this.$mode === mode)
	            return;
	        var oldMode = this.$mode;
	        this.$mode = mode;
	        this.$stopWorker();
	        if (this.$useWorker)
	            this.$startWorker();
	        var tokenizer = mode.getTokenizer();
	        if (tokenizer.on !== undefined) {
	            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
	            tokenizer.on("update", onReloadTokenizer);
	        }
	        this.bgTokenizer.setTokenizer(tokenizer);
	        this.bgTokenizer.setDocument(this.getDocument());
	        this.tokenRe = mode.tokenRe;
	        this.nonTokenRe = mode.nonTokenRe;
	        if (!$isPlaceholder) {
	            if (mode.attachToSession)
	                mode.attachToSession(this);
	            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
	            this.$setFolding(mode.foldingRules);
	            this.bgTokenizer.start(0);
	            this._emit("changeMode", { oldMode: oldMode, mode: mode });
	        }
	    };
	    EditSession.prototype.$stopWorker = function () {
	        if (this.$worker) {
	            this.$worker.terminate();
	            this.$worker = null;
	        }
	    };
	    EditSession.prototype.$startWorker = function () {
	        try {
	            this.$worker = this.$mode.createWorker(this);
	        }
	        catch (e) {
	            config.warn("Could not load worker", e);
	            this.$worker = null;
	        }
	    };
	    EditSession.prototype.getMode = function () {
	        return this.$mode;
	    };
	    EditSession.prototype.setScrollTop = function (scrollTop) {
	        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
	            return;
	        this.$scrollTop = scrollTop;
	        this._signal("changeScrollTop", scrollTop);
	    };
	    EditSession.prototype.getScrollTop = function () {
	        return this.$scrollTop;
	    };
	    EditSession.prototype.setScrollLeft = function (scrollLeft) {
	        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
	            return;
	        this.$scrollLeft = scrollLeft;
	        this._signal("changeScrollLeft", scrollLeft);
	    };
	    EditSession.prototype.getScrollLeft = function () {
	        return this.$scrollLeft;
	    };
	    EditSession.prototype.getScreenWidth = function () {
	        this.$computeWidth();
	        if (this.lineWidgets)
	            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
	        return this.screenWidth;
	    };
	    EditSession.prototype.getLineWidgetMaxWidth = function () {
	        if (this.lineWidgetsWidth != null)
	            return this.lineWidgetsWidth;
	        var width = 0;
	        this.lineWidgets.forEach(function (w) {
	            if (w && w.screenWidth > width)
	                width = w.screenWidth;
	        });
	        return this.lineWidgetWidth = width;
	    };
	    EditSession.prototype.$computeWidth = function (force) {
	        if (this.$modified || force) {
	            this.$modified = false;
	            if (this.$useWrapMode)
	                return this.screenWidth = this.$wrapLimit;
	            var lines = this.doc.getAllLines();
	            var cache = this.$rowLengthCache;
	            var longestScreenLine = 0;
	            var foldIndex = 0;
	            var foldLine = this.$foldData[foldIndex];
	            var foldStart = foldLine ? foldLine.start.row : Infinity;
	            var len = lines.length;
	            for (var i = 0; i < len; i++) {
	                if (i > foldStart) {
	                    i = foldLine.end.row + 1;
	                    if (i >= len)
	                        break;
	                    foldLine = this.$foldData[foldIndex++];
	                    foldStart = foldLine ? foldLine.start.row : Infinity;
	                }
	                if (cache[i] == null)
	                    cache[i] = this.$getStringScreenWidth(lines[i])[0];
	                if (cache[i] > longestScreenLine)
	                    longestScreenLine = cache[i];
	            }
	            this.screenWidth = longestScreenLine;
	        }
	    };
	    EditSession.prototype.getLine = function (row) {
	        return this.doc.getLine(row);
	    };
	    EditSession.prototype.getLines = function (firstRow, lastRow) {
	        return this.doc.getLines(firstRow, lastRow);
	    };
	    EditSession.prototype.getLength = function () {
	        return this.doc.getLength();
	    };
	    EditSession.prototype.getTextRange = function (range) {
	        return this.doc.getTextRange(range || this.selection.getRange());
	    };
	    EditSession.prototype.insert = function (position, text) {
	        return this.doc.insert(position, text);
	    };
	    EditSession.prototype.remove = function (range) {
	        return this.doc.remove(range);
	    };
	    EditSession.prototype.removeFullLines = function (firstRow, lastRow) {
	        return this.doc.removeFullLines(firstRow, lastRow);
	    };
	    EditSession.prototype.undoChanges = function (deltas, dontSelect) {
	        if (!deltas.length)
	            return;
	        this.$fromUndo = true;
	        for (var i = deltas.length - 1; i != -1; i--) {
	            var delta = deltas[i];
	            if (delta.action == "insert" || delta.action == "remove") {
	                this.doc.revertDelta(delta);
	            }
	            else if (delta.folds) {
	                this.addFolds(delta.folds);
	            }
	        }
	        if (!dontSelect && this.$undoSelect) {
	            if (deltas.selectionBefore)
	                this.selection.fromJSON(deltas.selectionBefore);
	            else
	                this.selection.setRange(this.$getUndoSelection(deltas, true));
	        }
	        this.$fromUndo = false;
	    };
	    EditSession.prototype.redoChanges = function (deltas, dontSelect) {
	        if (!deltas.length)
	            return;
	        this.$fromUndo = true;
	        for (var i = 0; i < deltas.length; i++) {
	            var delta = deltas[i];
	            if (delta.action == "insert" || delta.action == "remove") {
	                this.doc.$safeApplyDelta(delta);
	            }
	        }
	        if (!dontSelect && this.$undoSelect) {
	            if (deltas.selectionAfter)
	                this.selection.fromJSON(deltas.selectionAfter);
	            else
	                this.selection.setRange(this.$getUndoSelection(deltas, false));
	        }
	        this.$fromUndo = false;
	    };
	    EditSession.prototype.setUndoSelect = function (enable) {
	        this.$undoSelect = enable;
	    };
	    EditSession.prototype.$getUndoSelection = function (deltas, isUndo) {
	        function isInsert(delta) {
	            return isUndo ? delta.action !== "insert" : delta.action === "insert";
	        }
	        var range, point;
	        for (var i = 0; i < deltas.length; i++) {
	            var delta = deltas[i];
	            if (!delta.start)
	                continue; // skip folds
	            if (!range) {
	                if (isInsert(delta)) {
	                    range = Range.fromPoints(delta.start, delta.end);
	                }
	                else {
	                    range = Range.fromPoints(delta.start, delta.start);
	                }
	                continue;
	            }
	            if (isInsert(delta)) {
	                point = delta.start;
	                if (range.compare(point.row, point.column) == -1) {
	                    range.setStart(point);
	                }
	                point = delta.end;
	                if (range.compare(point.row, point.column) == 1) {
	                    range.setEnd(point);
	                }
	            }
	            else {
	                point = delta.start;
	                if (range.compare(point.row, point.column) == -1) {
	                    range = Range.fromPoints(delta.start, delta.start);
	                }
	            }
	        }
	        return range;
	    };
	    EditSession.prototype.replace = function (range, text) {
	        return this.doc.replace(range, text);
	    };
	    EditSession.prototype.moveText = function (fromRange, toPosition, copy) {
	        var text = this.getTextRange(fromRange);
	        var folds = this.getFoldsInRange(fromRange);
	        var toRange = Range.fromPoints(toPosition, toPosition);
	        if (!copy) {
	            this.remove(fromRange);
	            var rowDiff = fromRange.start.row - fromRange.end.row;
	            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
	            if (collDiff) {
	                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
	                    toRange.start.column += collDiff;
	                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
	                    toRange.end.column += collDiff;
	            }
	            if (rowDiff && toRange.start.row >= fromRange.end.row) {
	                toRange.start.row += rowDiff;
	                toRange.end.row += rowDiff;
	            }
	        }
	        toRange.end = this.insert(toRange.start, text);
	        if (folds.length) {
	            var oldStart = fromRange.start;
	            var newStart = toRange.start;
	            var rowDiff = newStart.row - oldStart.row;
	            var collDiff = newStart.column - oldStart.column;
	            this.addFolds(folds.map(function (x) {
	                x = x.clone();
	                if (x.start.row == oldStart.row)
	                    x.start.column += collDiff;
	                if (x.end.row == oldStart.row)
	                    x.end.column += collDiff;
	                x.start.row += rowDiff;
	                x.end.row += rowDiff;
	                return x;
	            }));
	        }
	        return toRange;
	    };
	    EditSession.prototype.indentRows = function (startRow, endRow, indentString) {
	        indentString = indentString.replace(/\t/g, this.getTabString());
	        for (var row = startRow; row <= endRow; row++)
	            this.doc.insertInLine({ row: row, column: 0 }, indentString);
	    };
	    EditSession.prototype.outdentRows = function (range) {
	        var rowRange = range.collapseRows();
	        var deleteRange = new Range(0, 0, 0, 0);
	        var size = this.getTabSize();
	        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
	            var line = this.getLine(i);
	            deleteRange.start.row = i;
	            deleteRange.end.row = i;
	            for (var j = 0; j < size; ++j)
	                if (line.charAt(j) != ' ')
	                    break;
	            if (j < size && line.charAt(j) == '\t') {
	                deleteRange.start.column = j;
	                deleteRange.end.column = j + 1;
	            }
	            else {
	                deleteRange.start.column = 0;
	                deleteRange.end.column = j;
	            }
	            this.remove(deleteRange);
	        }
	    };
	    EditSession.prototype.$moveLines = function (firstRow, lastRow, dir) {
	        firstRow = this.getRowFoldStart(firstRow);
	        lastRow = this.getRowFoldEnd(lastRow);
	        if (dir < 0) {
	            var row = this.getRowFoldStart(firstRow + dir);
	            if (row < 0)
	                return 0;
	            var diff = row - firstRow;
	        }
	        else if (dir > 0) {
	            var row = this.getRowFoldEnd(lastRow + dir);
	            if (row > this.doc.getLength() - 1)
	                return 0;
	            var diff = row - lastRow;
	        }
	        else {
	            firstRow = this.$clipRowToDocument(firstRow);
	            lastRow = this.$clipRowToDocument(lastRow);
	            var diff = lastRow - firstRow + 1;
	        }
	        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
	        var folds = this.getFoldsInRange(range).map(function (x) {
	            x = x.clone();
	            x.start.row += diff;
	            x.end.row += diff;
	            return x;
	        });
	        var lines = dir == 0
	            ? this.doc.getLines(firstRow, lastRow)
	            : this.doc.removeFullLines(firstRow, lastRow);
	        this.doc.insertFullLines(firstRow + diff, lines);
	        folds.length && this.addFolds(folds);
	        return diff;
	    };
	    EditSession.prototype.moveLinesUp = function (firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, -1);
	    };
	    EditSession.prototype.moveLinesDown = function (firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, 1);
	    };
	    EditSession.prototype.duplicateLines = function (firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, 0);
	    };
	    EditSession.prototype.$clipRowToDocument = function (row) {
	        return Math.max(0, Math.min(row, this.doc.getLength() - 1));
	    };
	    EditSession.prototype.$clipColumnToRow = function (row, column) {
	        if (column < 0)
	            return 0;
	        return Math.min(this.doc.getLine(row).length, column);
	    };
	    EditSession.prototype.$clipPositionToDocument = function (row, column) {
	        column = Math.max(0, column);
	        if (row < 0) {
	            row = 0;
	            column = 0;
	        }
	        else {
	            var len = this.doc.getLength();
	            if (row >= len) {
	                row = len - 1;
	                column = this.doc.getLine(len - 1).length;
	            }
	            else {
	                column = Math.min(this.doc.getLine(row).length, column);
	            }
	        }
	        return {
	            row: row,
	            column: column
	        };
	    };
	    EditSession.prototype.$clipRangeToDocument = function (range) {
	        if (range.start.row < 0) {
	            range.start.row = 0;
	            range.start.column = 0;
	        }
	        else {
	            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
	        }
	        var len = this.doc.getLength() - 1;
	        if (range.end.row > len) {
	            range.end.row = len;
	            range.end.column = this.doc.getLine(len).length;
	        }
	        else {
	            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
	        }
	        return range;
	    };
	    EditSession.prototype.setUseWrapMode = function (useWrapMode) {
	        if (useWrapMode != this.$useWrapMode) {
	            this.$useWrapMode = useWrapMode;
	            this.$modified = true;
	            this.$resetRowCache(0);
	            if (useWrapMode) {
	                var len = this.getLength();
	                this.$wrapData = Array(len);
	                this.$updateWrapData(0, len - 1);
	            }
	            this._signal("changeWrapMode");
	        }
	    };
	    EditSession.prototype.getUseWrapMode = function () {
	        return this.$useWrapMode;
	    };
	    EditSession.prototype.setWrapLimitRange = function (min, max) {
	        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
	            this.$wrapLimitRange = { min: min, max: max };
	            this.$modified = true;
	            this.$bidiHandler.markAsDirty();
	            if (this.$useWrapMode)
	                this._signal("changeWrapMode");
	        }
	    };
	    EditSession.prototype.adjustWrapLimit = function (desiredLimit, $printMargin) {
	        var limits = this.$wrapLimitRange;
	        if (limits.max < 0)
	            limits = { min: $printMargin, max: $printMargin };
	        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
	        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
	            this.$wrapLimit = wrapLimit;
	            this.$modified = true;
	            if (this.$useWrapMode) {
	                this.$updateWrapData(0, this.getLength() - 1);
	                this.$resetRowCache(0);
	                this._signal("changeWrapLimit");
	            }
	            return true;
	        }
	        return false;
	    };
	    EditSession.prototype.$constrainWrapLimit = function (wrapLimit, min, max) {
	        if (min)
	            wrapLimit = Math.max(min, wrapLimit);
	        if (max)
	            wrapLimit = Math.min(max, wrapLimit);
	        return wrapLimit;
	    };
	    EditSession.prototype.getWrapLimit = function () {
	        return this.$wrapLimit;
	    };
	    EditSession.prototype.setWrapLimit = function (limit) {
	        this.setWrapLimitRange(limit, limit);
	    };
	    EditSession.prototype.getWrapLimitRange = function () {
	        return {
	            min: this.$wrapLimitRange.min,
	            max: this.$wrapLimitRange.max
	        };
	    };
	    EditSession.prototype.$updateInternalDataOnChange = function (delta) {
	        var useWrapMode = this.$useWrapMode;
	        var action = delta.action;
	        var start = delta.start;
	        var end = delta.end;
	        var firstRow = start.row;
	        var lastRow = end.row;
	        var len = lastRow - firstRow;
	        var removedFolds = null;
	        this.$updating = true;
	        if (len != 0) {
	            if (action === "remove") {
	                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
	                var foldLines = this.$foldData;
	                removedFolds = this.getFoldsInRange(delta);
	                this.removeFolds(removedFolds);
	                var foldLine = this.getFoldLine(end.row);
	                var idx = 0;
	                if (foldLine) {
	                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
	                    foldLine.shiftRow(-len);
	                    var foldLineBefore = this.getFoldLine(firstRow);
	                    if (foldLineBefore && foldLineBefore !== foldLine) {
	                        foldLineBefore.merge(foldLine);
	                        foldLine = foldLineBefore;
	                    }
	                    idx = foldLines.indexOf(foldLine) + 1;
	                }
	                for (idx; idx < foldLines.length; idx++) {
	                    var foldLine = foldLines[idx];
	                    if (foldLine.start.row >= end.row) {
	                        foldLine.shiftRow(-len);
	                    }
	                }
	                lastRow = firstRow;
	            }
	            else {
	                var args = Array(len);
	                args.unshift(firstRow, 0);
	                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
	                arr.splice.apply(arr, args);
	                var foldLines = this.$foldData;
	                var foldLine = this.getFoldLine(firstRow);
	                var idx = 0;
	                if (foldLine) {
	                    var cmp = foldLine.range.compareInside(start.row, start.column);
	                    if (cmp == 0) {
	                        foldLine = foldLine.split(start.row, start.column);
	                        if (foldLine) {
	                            foldLine.shiftRow(len);
	                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
	                        }
	                    }
	                    else 
	                    if (cmp == -1) {
	                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
	                        foldLine.shiftRow(len);
	                    }
	                    idx = foldLines.indexOf(foldLine) + 1;
	                }
	                for (idx; idx < foldLines.length; idx++) {
	                    var foldLine = foldLines[idx];
	                    if (foldLine.start.row >= firstRow) {
	                        foldLine.shiftRow(len);
	                    }
	                }
	            }
	        }
	        else {
	            len = Math.abs(delta.start.column - delta.end.column);
	            if (action === "remove") {
	                removedFolds = this.getFoldsInRange(delta);
	                this.removeFolds(removedFolds);
	                len = -len;
	            }
	            var foldLine = this.getFoldLine(firstRow);
	            if (foldLine) {
	                foldLine.addRemoveChars(firstRow, start.column, len);
	            }
	        }
	        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
	            console.error("doc.getLength() and $wrapData.length have to be the same!");
	        }
	        this.$updating = false;
	        if (useWrapMode)
	            this.$updateWrapData(firstRow, lastRow);
	        else
	            this.$updateRowLengthCache(firstRow, lastRow);
	        return removedFolds;
	    };
	    EditSession.prototype.$updateRowLengthCache = function (firstRow, lastRow) {
	        this.$rowLengthCache[firstRow] = null;
	        this.$rowLengthCache[lastRow] = null;
	    };
	    EditSession.prototype.$updateWrapData = function (firstRow, lastRow) {
	        var lines = this.doc.getAllLines();
	        var tabSize = this.getTabSize();
	        var wrapData = this.$wrapData;
	        var wrapLimit = this.$wrapLimit;
	        var tokens;
	        var foldLine;
	        var row = firstRow;
	        lastRow = Math.min(lastRow, lines.length - 1);
	        while (row <= lastRow) {
	            foldLine = this.getFoldLine(row, foldLine);
	            if (!foldLine) {
	                tokens = this.$getDisplayTokens(lines[row]);
	                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
	                row++;
	            }
	            else {
	                tokens = [];
	                foldLine.walk(function (placeholder, row, column, lastColumn) {
	                    var walkTokens;
	                    if (placeholder != null) {
	                        walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
	                        walkTokens[0] = PLACEHOLDER_START;
	                        for (var i = 1; i < walkTokens.length; i++) {
	                            walkTokens[i] = PLACEHOLDER_BODY;
	                        }
	                    }
	                    else {
	                        walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
	                    }
	                    tokens = tokens.concat(walkTokens);
	                }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
	                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
	                row = foldLine.end.row + 1;
	            }
	        }
	    };
	    EditSession.prototype.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {
	        if (tokens.length == 0) {
	            return [];
	        }
	        var splits = [];
	        var displayLength = tokens.length;
	        var lastSplit = 0, lastDocSplit = 0;
	        var isCode = this.$wrapAsCode;
	        var indentedSoftWrap = this.$indentedSoftWrap;
	        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
	            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
	        function getWrapIndent() {
	            var indentation = 0;
	            if (maxIndent === 0)
	                return indentation;
	            if (indentedSoftWrap) {
	                for (var i = 0; i < tokens.length; i++) {
	                    var token = tokens[i];
	                    if (token == SPACE)
	                        indentation += 1;
	                    else if (token == TAB)
	                        indentation += tabSize;
	                    else if (token == TAB_SPACE)
	                        continue;
	                    else
	                        break;
	                }
	            }
	            if (isCode && indentedSoftWrap !== false)
	                indentation += tabSize;
	            return Math.min(indentation, maxIndent);
	        }
	        function addSplit(screenPos) {
	            var len = screenPos - lastSplit;
	            for (var i = lastSplit; i < screenPos; i++) {
	                var ch = tokens[i];
	                if (ch === 12 || ch === 2)
	                    len -= 1;
	            }
	            if (!splits.length) {
	                indent = getWrapIndent();
	                splits.indent = indent;
	            }
	            lastDocSplit += len;
	            splits.push(lastDocSplit);
	            lastSplit = screenPos;
	        }
	        var indent = 0;
	        while (displayLength - lastSplit > wrapLimit - indent) {
	            var split = lastSplit + wrapLimit - indent;
	            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
	                addSplit(split);
	                continue;
	            }
	            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
	                for (split; split != lastSplit - 1; split--) {
	                    if (tokens[split] == PLACEHOLDER_START) {
	                        break;
	                    }
	                }
	                if (split > lastSplit) {
	                    addSplit(split);
	                    continue;
	                }
	                split = lastSplit + wrapLimit;
	                for (split; split < tokens.length; split++) {
	                    if (tokens[split] != PLACEHOLDER_BODY) {
	                        break;
	                    }
	                }
	                if (split == tokens.length) {
	                    break; // Breaks the while-loop.
	                }
	                addSplit(split);
	                continue;
	            }
	            var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
	            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
	                split--;
	            }
	            if (isCode) {
	                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
	                    split--;
	                }
	                while (split > minSplit && tokens[split] == PUNCTUATION) {
	                    split--;
	                }
	            }
	            else {
	                while (split > minSplit && tokens[split] < SPACE) {
	                    split--;
	                }
	            }
	            if (split > minSplit) {
	                addSplit(++split);
	                continue;
	            }
	            split = lastSplit + wrapLimit;
	            if (tokens[split] == CHAR_EXT)
	                split--;
	            addSplit(split - indent);
	        }
	        return splits;
	    };
	    EditSession.prototype.$getDisplayTokens = function (str, offset) {
	        var arr = [];
	        var tabSize;
	        offset = offset || 0;
	        for (var i = 0; i < str.length; i++) {
	            var c = str.charCodeAt(i);
	            if (c == 9) {
	                tabSize = this.getScreenTabSize(arr.length + offset);
	                arr.push(TAB);
	                for (var n = 1; n < tabSize; n++) {
	                    arr.push(TAB_SPACE);
	                }
	            }
	            else if (c == 32) {
	                arr.push(SPACE);
	            }
	            else if ((c > 39 && c < 48) || (c > 57 && c < 64)) {
	                arr.push(PUNCTUATION);
	            }
	            else if (c >= 0x1100 && isFullWidth(c)) {
	                arr.push(CHAR, CHAR_EXT);
	            }
	            else {
	                arr.push(CHAR);
	            }
	        }
	        return arr;
	    };
	    EditSession.prototype.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
	        if (maxScreenColumn == 0)
	            return [0, 0];
	        if (maxScreenColumn == null)
	            maxScreenColumn = Infinity;
	        screenColumn = screenColumn || 0;
	        var c, column;
	        for (column = 0; column < str.length; column++) {
	            c = str.charCodeAt(column);
	            if (c == 9) {
	                screenColumn += this.getScreenTabSize(screenColumn);
	            }
	            else if (c >= 0x1100 && isFullWidth(c)) {
	                screenColumn += 2;
	            }
	            else {
	                screenColumn += 1;
	            }
	            if (screenColumn > maxScreenColumn) {
	                break;
	            }
	        }
	        return [screenColumn, column];
	    };
	    EditSession.prototype.getRowLength = function (row) {
	        var h = 1;
	        if (this.lineWidgets)
	            h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
	        if (!this.$useWrapMode || !this.$wrapData[row])
	            return h;
	        else
	            return this.$wrapData[row].length + h;
	    };
	    EditSession.prototype.getRowLineCount = function (row) {
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1;
	        }
	        else {
	            return this.$wrapData[row].length + 1;
	        }
	    };
	    EditSession.prototype.getRowWrapIndent = function (screenRow) {
	        if (this.$useWrapMode) {
	            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
	            var splits = this.$wrapData[pos.row];
	            return splits.length && splits[0] < pos.column ? splits.indent : 0;
	        }
	        else {
	            return 0;
	        }
	    };
	    EditSession.prototype.getScreenLastRowColumn = function (screenRow) {
	        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
	        return this.documentToScreenColumn(pos.row, pos.column);
	    };
	    EditSession.prototype.getDocumentLastRowColumn = function (docRow, docColumn) {
	        var screenRow = this.documentToScreenRow(docRow, docColumn);
	        return this.getScreenLastRowColumn(screenRow);
	    };
	    EditSession.prototype.getDocumentLastRowColumnPosition = function (docRow, docColumn) {
	        var screenRow = this.documentToScreenRow(docRow, docColumn);
	        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
	    };
	    EditSession.prototype.getRowSplitData = function (row) {
	        if (!this.$useWrapMode) {
	            return undefined;
	        }
	        else {
	            return this.$wrapData[row];
	        }
	    };
	    EditSession.prototype.getScreenTabSize = function (screenColumn) {
	        return this.$tabSize - (screenColumn % this.$tabSize | 0);
	    };
	    EditSession.prototype.screenToDocumentRow = function (screenRow, screenColumn) {
	        return this.screenToDocumentPosition(screenRow, screenColumn).row;
	    };
	    EditSession.prototype.screenToDocumentColumn = function (screenRow, screenColumn) {
	        return this.screenToDocumentPosition(screenRow, screenColumn).column;
	    };
	    EditSession.prototype.screenToDocumentPosition = function (screenRow, screenColumn, offsetX) {
	        if (screenRow < 0)
	            return { row: 0, column: 0 };
	        var line;
	        var docRow = 0;
	        var docColumn = 0;
	        var column;
	        var row = 0;
	        var rowLength = 0;
	        var rowCache = this.$screenRowCache;
	        var i = this.$getRowCacheIndex(rowCache, screenRow);
	        var l = rowCache.length;
	        if (l && i >= 0) {
	            var row = rowCache[i];
	            var docRow = this.$docRowCache[i];
	            var doCache = screenRow > rowCache[l - 1];
	        }
	        else {
	            var doCache = !l;
	        }
	        var maxRow = this.getLength() - 1;
	        var foldLine = this.getNextFoldLine(docRow);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;
	        while (row <= screenRow) {
	            rowLength = this.getRowLength(docRow);
	            if (row + rowLength > screenRow || docRow >= maxRow) {
	                break;
	            }
	            else {
	                row += rowLength;
	                docRow++;
	                if (docRow > foldStart) {
	                    docRow = foldLine.end.row + 1;
	                    foldLine = this.getNextFoldLine(docRow, foldLine);
	                    foldStart = foldLine ? foldLine.start.row : Infinity;
	                }
	            }
	            if (doCache) {
	                this.$docRowCache.push(docRow);
	                this.$screenRowCache.push(row);
	            }
	        }
	        if (foldLine && foldLine.start.row <= docRow) {
	            line = this.getFoldDisplayLine(foldLine);
	            docRow = foldLine.start.row;
	        }
	        else if (row + rowLength <= screenRow || docRow > maxRow) {
	            return {
	                row: maxRow,
	                column: this.getLine(maxRow).length
	            };
	        }
	        else {
	            line = this.getLine(docRow);
	            foldLine = null;
	        }
	        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
	        if (this.$useWrapMode) {
	            var splits = this.$wrapData[docRow];
	            if (splits) {
	                column = splits[splitIndex];
	                if (splitIndex > 0 && splits.length) {
	                    wrapIndent = splits.indent;
	                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
	                    line = line.substring(docColumn);
	                }
	            }
	        }
	        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
	            screenColumn = this.$bidiHandler.offsetToCol(offsetX);
	        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
	        if (this.$useWrapMode && docColumn >= column)
	            docColumn = column - 1;
	        if (foldLine)
	            return foldLine.idxToPosition(docColumn);
	        return { row: docRow, column: docColumn };
	    };
	    EditSession.prototype.documentToScreenPosition = function (docRow, docColumn) {
	        if (typeof docColumn === "undefined")
	            var pos = this.$clipPositionToDocument(/**@type{Point}*/ (docRow).row, /**@type{Point}*/ (docRow).column);
	        else
	            pos = this.$clipPositionToDocument(/**@type{number}*/ (docRow), docColumn);
	        docRow = pos.row;
	        docColumn = pos.column;
	        var screenRow = 0;
	        var foldStartRow = null;
	        var fold = null;
	        fold = this.getFoldAt(docRow, docColumn, 1);
	        if (fold) {
	            docRow = fold.start.row;
	            docColumn = fold.start.column;
	        }
	        var rowEnd, row = 0;
	        var rowCache = this.$docRowCache;
	        var i = this.$getRowCacheIndex(rowCache, docRow);
	        var l = rowCache.length;
	        if (l && i >= 0) {
	            var row = rowCache[i];
	            var screenRow = this.$screenRowCache[i];
	            var doCache = docRow > rowCache[l - 1];
	        }
	        else {
	            var doCache = !l;
	        }
	        var foldLine = this.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;
	        while (row < docRow) {
	            if (row >= foldStart) {
	                rowEnd = foldLine.end.row + 1;
	                if (rowEnd > docRow)
	                    break;
	                foldLine = this.getNextFoldLine(rowEnd, foldLine);
	                foldStart = foldLine ? foldLine.start.row : Infinity;
	            }
	            else {
	                rowEnd = row + 1;
	            }
	            screenRow += this.getRowLength(row);
	            row = rowEnd;
	            if (doCache) {
	                this.$docRowCache.push(row);
	                this.$screenRowCache.push(screenRow);
	            }
	        }
	        var textLine = "";
	        if (foldLine && row >= foldStart) {
	            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
	            foldStartRow = foldLine.start.row;
	        }
	        else {
	            textLine = this.getLine(docRow).substring(0, docColumn);
	            foldStartRow = docRow;
	        }
	        var wrapIndent = 0;
	        if (this.$useWrapMode) {
	            var wrapRow = this.$wrapData[foldStartRow];
	            if (wrapRow) {
	                var screenRowOffset = 0;
	                while (textLine.length >= wrapRow[screenRowOffset]) {
	                    screenRow++;
	                    screenRowOffset++;
	                }
	                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
	                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
	            }
	        }
	        if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
	            screenRow += this.lineWidgets[row].rowsAbove;
	        return {
	            row: screenRow,
	            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
	        };
	    };
	    EditSession.prototype.documentToScreenColumn = function (row, docColumn) {
	        return this.documentToScreenPosition(row, docColumn).column;
	    };
	    EditSession.prototype.documentToScreenRow = function (docRow, docColumn) {
	        return this.documentToScreenPosition(docRow, docColumn).row;
	    };
	    EditSession.prototype.getScreenLength = function () {
	        var screenRows = 0;
	        var fold = null;
	        if (!this.$useWrapMode) {
	            screenRows = this.getLength();
	            var foldData = this.$foldData;
	            for (var i = 0; i < foldData.length; i++) {
	                fold = foldData[i];
	                screenRows -= fold.end.row - fold.start.row;
	            }
	        }
	        else {
	            var lastRow = this.$wrapData.length;
	            var row = 0, i = 0;
	            var fold = this.$foldData[i++];
	            var foldStart = fold ? fold.start.row : Infinity;
	            while (row < lastRow) {
	                var splits = this.$wrapData[row];
	                screenRows += splits ? splits.length + 1 : 1;
	                row++;
	                if (row > foldStart) {
	                    row = fold.end.row + 1;
	                    fold = this.$foldData[i++];
	                    foldStart = fold ? fold.start.row : Infinity;
	                }
	            }
	        }
	        if (this.lineWidgets)
	            screenRows += this.$getWidgetScreenLength();
	        return screenRows;
	    };
	    EditSession.prototype.$setFontMetrics = function (fm) {
	        if (!this.$enableVarChar)
	            return;
	        this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
	            if (maxScreenColumn === 0)
	                return [0, 0];
	            if (!maxScreenColumn)
	                maxScreenColumn = Infinity;
	            screenColumn = screenColumn || 0;
	            var c, column;
	            for (column = 0; column < str.length; column++) {
	                c = str.charAt(column);
	                if (c === "\t") {
	                    screenColumn += this.getScreenTabSize(screenColumn);
	                }
	                else {
	                    screenColumn += fm.getCharacterWidth(c);
	                }
	                if (screenColumn > maxScreenColumn) {
	                    break;
	                }
	            }
	            return [screenColumn, column];
	        };
	    };
	    EditSession.prototype.getPrecedingCharacter = function () {
	        var pos = this.selection.getCursor();
	        if (pos.column === 0) {
	            return pos.row === 0 ? "" : this.doc.getNewLineCharacter();
	        }
	        var currentLine = this.getLine(pos.row);
	        return currentLine[pos.column - 1];
	    };
	    EditSession.prototype.destroy = function () {
	        if (!this.destroyed) {
	            this.bgTokenizer.setDocument(null);
	            this.bgTokenizer.cleanup();
	            this.destroyed = true;
	        }
	        this.endOperation();
	        this.$stopWorker();
	        this.removeAllListeners();
	        if (this.doc) {
	            this.doc.off("change", this.$onChange);
	        }
	        if (this.selection) {
	            this.selection.off("changeCursor", this.$onSelectionChange);
	            this.selection.off("changeSelection", this.$onSelectionChange);
	        }
	        this.selection.detach();
	    };
	    return EditSession;
	}());
	EditSession.$uid = 0;
	EditSession.prototype.$modes = config.$modes;
	EditSession.prototype.getValue = EditSession.prototype.toString;
	EditSession.prototype.$defaultUndoManager = {
	    undo: function () { },
	    redo: function () { },
	    hasUndo: function () { },
	    hasRedo: function () { },
	    reset: function () { },
	    add: function () { },
	    addSelection: function () { },
	    startNewGroup: function () { },
	    addSession: function () { }
	};
	EditSession.prototype.$overwrite = false;
	EditSession.prototype.$mode = null;
	EditSession.prototype.$modeId = null;
	EditSession.prototype.$scrollTop = 0;
	EditSession.prototype.$scrollLeft = 0;
	EditSession.prototype.$wrapLimit = 80;
	EditSession.prototype.$useWrapMode = false;
	EditSession.prototype.$wrapLimitRange = {
	    min: null,
	    max: null
	};
	EditSession.prototype.lineWidgets = null;
	EditSession.prototype.isFullWidth = isFullWidth;
	oop.implement(EditSession.prototype, EventEmitter);
	var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
	function isFullWidth(c) {
	    if (c < 0x1100)
	        return false;
	    return c >= 0x1100 && c <= 0x115F ||
	        c >= 0x11A3 && c <= 0x11A7 ||
	        c >= 0x11FA && c <= 0x11FF ||
	        c >= 0x2329 && c <= 0x232A ||
	        c >= 0x2E80 && c <= 0x2E99 ||
	        c >= 0x2E9B && c <= 0x2EF3 ||
	        c >= 0x2F00 && c <= 0x2FD5 ||
	        c >= 0x2FF0 && c <= 0x2FFB ||
	        c >= 0x3000 && c <= 0x303E ||
	        c >= 0x3041 && c <= 0x3096 ||
	        c >= 0x3099 && c <= 0x30FF ||
	        c >= 0x3105 && c <= 0x312D ||
	        c >= 0x3131 && c <= 0x318E ||
	        c >= 0x3190 && c <= 0x31BA ||
	        c >= 0x31C0 && c <= 0x31E3 ||
	        c >= 0x31F0 && c <= 0x321E ||
	        c >= 0x3220 && c <= 0x3247 ||
	        c >= 0x3250 && c <= 0x32FE ||
	        c >= 0x3300 && c <= 0x4DBF ||
	        c >= 0x4E00 && c <= 0xA48C ||
	        c >= 0xA490 && c <= 0xA4C6 ||
	        c >= 0xA960 && c <= 0xA97C ||
	        c >= 0xAC00 && c <= 0xD7A3 ||
	        c >= 0xD7B0 && c <= 0xD7C6 ||
	        c >= 0xD7CB && c <= 0xD7FB ||
	        c >= 0xF900 && c <= 0xFAFF ||
	        c >= 0xFE10 && c <= 0xFE19 ||
	        c >= 0xFE30 && c <= 0xFE52 ||
	        c >= 0xFE54 && c <= 0xFE66 ||
	        c >= 0xFE68 && c <= 0xFE6B ||
	        c >= 0xFF01 && c <= 0xFF60 ||
	        c >= 0xFFE0 && c <= 0xFFE6;
	}
	require("./edit_session/folding").Folding.call(EditSession.prototype);
	require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
	config.defineOptions(EditSession.prototype, "session", {
	    wrap: {
	        set: function (value) {
	            if (!value || value == "off")
	                value = false;
	            else if (value == "free")
	                value = true;
	            else if (value == "printMargin")
	                value = -1;
	            else if (typeof value == "string")
	                value = parseInt(value, 10) || false;
	            if (this.$wrap == value)
	                return;
	            this.$wrap = value;
	            if (!value) {
	                this.setUseWrapMode(false);
	            }
	            else {
	                var col = typeof value == "number" ? value : null;
	                this.setWrapLimitRange(col, col);
	                this.setUseWrapMode(true);
	            }
	        },
	        get: function () {
	            if (this.getUseWrapMode()) {
	                if (this.$wrap == -1)
	                    return "printMargin";
	                if (!this.getWrapLimitRange().min)
	                    return "free";
	                return this.$wrap;
	            }
	            return "off";
	        },
	        handlesSet: true
	    },
	    wrapMethod: {
	        set: function (val) {
	            val = val == "auto"
	                ? this.$mode.type != "text"
	                : val != "text";
	            if (val != this.$wrapAsCode) {
	                this.$wrapAsCode = val;
	                if (this.$useWrapMode) {
	                    this.$useWrapMode = false;
	                    this.setUseWrapMode(true);
	                }
	            }
	        },
	        initialValue: "auto"
	    },
	    indentedSoftWrap: {
	        set: function () {
	            if (this.$useWrapMode) {
	                this.$useWrapMode = false;
	                this.setUseWrapMode(true);
	            }
	        },
	        initialValue: true
	    },
	    firstLineNumber: {
	        set: function () { this._signal("changeBreakpoint"); },
	        initialValue: 1
	    },
	    useWorker: {
	        set: function (useWorker) {
	            this.$useWorker = useWorker;
	            this.$stopWorker();
	            if (useWorker)
	                this.$startWorker();
	        },
	        initialValue: true
	    },
	    useSoftTabs: { initialValue: true },
	    tabSize: {
	        set: function (tabSize) {
	            tabSize = parseInt(tabSize);
	            if (tabSize > 0 && this.$tabSize !== tabSize) {
	                this.$modified = true;
	                this.$rowLengthCache = [];
	                this.$tabSize = tabSize;
	                this._signal("changeTabSize");
	            }
	        },
	        initialValue: 4,
	        handlesSet: true
	    },
	    navigateWithinSoftTabs: { initialValue: false },
	    foldStyle: {
	        set: function (val) { this.setFoldStyle(val); },
	        handlesSet: true
	    },
	    overwrite: {
	        set: function (val) { this._signal("changeOverwrite"); },
	        initialValue: false
	    },
	    newLineMode: {
	        set: function (val) { this.doc.setNewLineMode(val); },
	        get: function () { return this.doc.getNewLineMode(); },
	        handlesSet: true
	    },
	    mode: {
	        set: function (val) { this.setMode(val); },
	        get: function () { return this.$modeId; },
	        handlesSet: true
	    }
	});
	exports.EditSession = EditSession;

	});

	ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module){	var lang = require("./lib/lang");
	var oop = require("./lib/oop");
	var Range = require("./range").Range;
	var Search = /** @class */ (function () {
	    function Search() {
	        this.$options = {};
	    }
	    Search.prototype.set = function (options) {
	        oop.mixin(this.$options, options);
	        return this;
	    };
	    Search.prototype.getOptions = function () {
	        return lang.copyObject(this.$options);
	    };
	    Search.prototype.setOptions = function (options) {
	        this.$options = options;
	    };
	    Search.prototype.find = function (session) {
	        var options = this.$options;
	        var iterator = this.$matchIterator(session, options);
	        if (!iterator)
	            return false;
	        var firstRange = null;
	        iterator.forEach(function (sr, sc, er, ec) {
	            firstRange = new Range(sr, sc, er, ec);
	            if (sc == ec && options.start && /**@type{Range}*/ (options.start).start
	                && options.skipCurrent != false && firstRange.isEqual(/**@type{Range}*/ (options.start))) {
	                firstRange = null;
	                return false;
	            }
	            return true;
	        });
	        return firstRange;
	    };
	    Search.prototype.findAll = function (session) {
	        var options = this.$options;
	        if (!options.needle)
	            return [];
	        this.$assembleRegExp(options);
	        var range = options.range;
	        var lines = range
	            ? session.getLines(range.start.row, range.end.row)
	            : session.doc.getAllLines();
	        var ranges = [];
	        var re = options.re;
	        if (options.$isMultiLine) {
	            var len = re.length;
	            var maxRow = lines.length - len;
	            var prevRange;
	            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
	                for (var j = 0; j < len; j++)
	                    if (lines[row + j].search(re[j]) == -1)
	                        continue outer;
	                var startLine = lines[row];
	                var line = lines[row + len - 1];
	                var startIndex = startLine.length - startLine.match(re[0])[0].length;
	                var endIndex = line.match(re[len - 1])[0].length;
	                if (prevRange && prevRange.end.row === row &&
	                    prevRange.end.column > startIndex) {
	                    continue;
	                }
	                ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
	                if (len > 2)
	                    row = row + len - 2;
	            }
	        }
	        else {
	            for (var matches, i = 0; i < lines.length; i++) {
	                if (this.$isMultilineSearch(options)) {
	                    var lng = lines.length - 1;
	                    matches = this.$multiLineForward(session, re, i, lng);
	                    if (matches) {
	                        var end_row = matches.endRow <= lng ? matches.endRow - 1 : lng;
	                        if (end_row > i)
	                            i = end_row;
	                        ranges.push(new Range(matches.startRow, matches.startCol, matches.endRow, matches.endCol));
	                    }
	                }
	                else {
	                    matches = lang.getMatchOffsets(lines[i], re);
	                    for (var j = 0; j < matches.length; j++) {
	                        var match = matches[j];
	                        ranges.push(new Range(i, match.offset, i, match.offset + match.length));
	                    }
	                }
	            }
	        }
	        if (range) {
	            var startColumn = range.start.column;
	            var endColumn = range.end.column;
	            var i = 0, j = ranges.length - 1;
	            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)
	                i++;
	            var endRow = range.end.row - range.start.row;
	            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)
	                j--;
	            ranges = ranges.slice(i, j + 1);
	            for (i = 0, j = ranges.length; i < j; i++) {
	                ranges[i].start.row += range.start.row;
	                ranges[i].end.row += range.start.row;
	            }
	        }
	        return ranges;
	    };
	    Search.prototype.parseReplaceString = function (replaceString) {
	        var CharCode = {
	            DollarSign: 36,
	            Ampersand: 38,
	            Digit0: 48,
	            Digit1: 49,
	            Digit9: 57,
	            Backslash: 92,
	            n: 110,
	            t: 116
	        };
	        var replacement = '';
	        for (var i = 0, len = replaceString.length; i < len; i++) {
	            var chCode = replaceString.charCodeAt(i);
	            if (chCode === CharCode.Backslash) {
	                i++;
	                if (i >= len) {
	                    replacement += "\\";
	                    break;
	                }
	                var nextChCode = replaceString.charCodeAt(i);
	                switch (nextChCode) {
	                    case CharCode.Backslash:
	                        replacement += "\\";
	                        break;
	                    case CharCode.n:
	                        replacement += "\n";
	                        break;
	                    case CharCode.t:
	                        replacement += "\t";
	                        break;
	                }
	                continue;
	            }
	            if (chCode === CharCode.DollarSign) {
	                i++;
	                if (i >= len) {
	                    replacement += "$";
	                    break;
	                }
	                var nextChCode_1 = replaceString.charCodeAt(i);
	                if (nextChCode_1 === CharCode.DollarSign) {
	                    replacement += "$$";
	                    continue;
	                }
	                if (nextChCode_1 === CharCode.Digit0 || nextChCode_1 === CharCode.Ampersand) {
	                    replacement += "$&";
	                    continue;
	                }
	                if (CharCode.Digit1 <= nextChCode_1 && nextChCode_1 <= CharCode.Digit9) {
	                    replacement += "$" + replaceString[i];
	                    continue;
	                }
	            }
	            replacement += replaceString[i];
	        }
	        return replacement || replaceString;
	    };
	    Search.prototype.replace = function (input, replacement) {
	        var options = this.$options;
	        var re = this.$assembleRegExp(options);
	        if (options.$isMultiLine)
	            return replacement;
	        if (!re)
	            return;
	        var mtSearch = this.$isMultilineSearch(options);
	        if (mtSearch)
	            input = input.replace(/\r\n|\r|\n/g, "\n");
	        var match = re.exec(input);
	        if (!match || (!mtSearch && match[0].length != input.length))
	            return null;
	        replacement = options.regExp
	            ? this.parseReplaceString(replacement)
	            : replacement.replace(/\$/g, "$$$$");
	        replacement = input.replace(re, replacement);
	        if (options.preserveCase) {
	            replacement = replacement.split("");
	            for (var i = Math.min(input.length, input.length); i--;) {
	                var ch = input[i];
	                if (ch && ch.toLowerCase() != ch)
	                    replacement[i] = replacement[i].toUpperCase();
	                else
	                    replacement[i] = replacement[i].toLowerCase();
	            }
	            replacement = replacement.join("");
	        }
	        return replacement;
	    };
	    Search.prototype.$assembleRegExp = function (options, $disableFakeMultiline) {
	        if (options.needle instanceof RegExp)
	            return options.re = options.needle;
	        var needle = options.needle;
	        if (!options.needle)
	            return options.re = false;
	        if (!options.regExp)
	            needle = lang.escapeRegExp(needle);
	        var modifier = options.caseSensitive ? "gm" : "gmi";
	        try {
	            new RegExp(needle, "u");
	            options.$supportsUnicodeFlag = true;
	            modifier += "u";
	        }
	        catch (e) {
	            options.$supportsUnicodeFlag = false; //left for backward compatibility with previous versions for cases like /ab\{2}/gu
	        }
	        if (options.wholeWord)
	            needle = addWordBoundary(needle, options);
	        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
	        if (options.$isMultiLine)
	            return options.re = this.$assembleMultilineRegExp(needle, modifier);
	        try {
	            var re = new RegExp(needle, modifier);
	        }
	        catch (e) {
	            re = false;
	        }
	        return options.re = re;
	    };
	    Search.prototype.$assembleMultilineRegExp = function (needle, modifier) {
	        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
	        var re = [];
	        for (var i = 0; i < parts.length; i++)
	            try {
	                re.push(new RegExp(parts[i], modifier));
	            }
	            catch (e) {
	                return false;
	            }
	        return re;
	    };
	    Search.prototype.$isMultilineSearch = function (options) {
	        return options.re && /\\r\\n|\\r|\\n/.test(options.re.source) && options.regExp && !options.$isMultiLine;
	    };
	    Search.prototype.$multiLineForward = function (session, re, start, last) {
	        var line, chunk = chunkEnd(session, start);
	        for (var row = start; row <= last;) {
	            for (var i = 0; i < chunk; i++) {
	                if (row > last)
	                    break;
	                var next = session.getLine(row++);
	                line = line == null ? next : line + "\n" + next;
	            }
	            var match = re.exec(line);
	            re.lastIndex = 0;
	            if (match) {
	                var beforeMatch = line.slice(0, match.index).split("\n");
	                var matchedText = match[0].split("\n");
	                var startRow = start + beforeMatch.length - 1;
	                var startCol = beforeMatch[beforeMatch.length - 1].length;
	                var endRow = startRow + matchedText.length - 1;
	                var endCol = matchedText.length == 1
	                    ? startCol + matchedText[0].length
	                    : matchedText[matchedText.length - 1].length;
	                return {
	                    startRow: startRow,
	                    startCol: startCol,
	                    endRow: endRow,
	                    endCol: endCol
	                };
	            }
	        }
	        return null;
	    };
	    Search.prototype.$multiLineBackward = function (session, re, endIndex, start, first) {
	        var line, chunk = chunkEnd(session, start), endMargin = session.getLine(start).length - endIndex;
	        for (var row = start; row >= first;) {
	            for (var i = 0; i < chunk && row >= first; i++) {
	                var next = session.getLine(row--);
	                line = line == null ? next : next + "\n" + line;
	            }
	            var match = multiLineBackwardMatch(line, re, endMargin);
	            if (match) {
	                var beforeMatch = line.slice(0, match.index).split("\n");
	                var matchedText = match[0].split("\n");
	                var startRow = row + beforeMatch.length;
	                var startCol = beforeMatch[beforeMatch.length - 1].length;
	                var endRow = startRow + matchedText.length - 1;
	                var endCol = matchedText.length == 1
	                    ? startCol + matchedText[0].length
	                    : matchedText[matchedText.length - 1].length;
	                return {
	                    startRow: startRow,
	                    startCol: startCol,
	                    endRow: endRow,
	                    endCol: endCol
	                };
	            }
	        }
	        return null;
	    };
	    Search.prototype.$matchIterator = function (session, options) {
	        var re = this.$assembleRegExp(options);
	        if (!re)
	            return false;
	        var mtSearch = this.$isMultilineSearch(options);
	        var mtForward = this.$multiLineForward;
	        var mtBackward = this.$multiLineBackward;
	        var backwards = options.backwards == true;
	        var skipCurrent = options.skipCurrent != false;
	        var supportsUnicodeFlag = re.unicode;
	        var range = options.range;
	        var start = options.start;
	        if (!start)
	            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
	        if (start.start)
	            start = start[skipCurrent != backwards ? "end" : "start"];
	        var firstRow = range ? range.start.row : 0;
	        var lastRow = range ? range.end.row : session.getLength() - 1;
	        if (backwards) {
	            var forEach = function (callback) {
	                var row = start.row;
	                if (forEachInLine(row, start.column, callback))
	                    return;
	                for (row--; row >= firstRow; row--)
	                    if (forEachInLine(row, Number.MAX_VALUE, callback))
	                        return;
	                if (options.wrap == false)
	                    return;
	                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
	                    if (forEachInLine(row, Number.MAX_VALUE, callback))
	                        return;
	            };
	        }
	        else {
	            var forEach = function (callback) {
	                var row = start.row;
	                if (forEachInLine(row, start.column, callback))
	                    return;
	                for (row = row + 1; row <= lastRow; row++)
	                    if (forEachInLine(row, 0, callback))
	                        return;
	                if (options.wrap == false)
	                    return;
	                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
	                    if (forEachInLine(row, 0, callback))
	                        return;
	            };
	        }
	        if (options.$isMultiLine) {
	            var len = re.length;
	            var forEachInLine = function (row, offset, callback) {
	                var startRow = backwards ? row - len + 1 : row;
	                if (startRow < 0 || startRow + len > session.getLength())
	                    return;
	                var line = session.getLine(startRow);
	                var startIndex = line.search(re[0]);
	                if (!backwards && startIndex < offset || startIndex === -1)
	                    return;
	                for (var i = 1; i < len; i++) {
	                    line = session.getLine(startRow + i);
	                    if (line.search(re[i]) == -1)
	                        return;
	                }
	                var endIndex = line.match(re[len - 1])[0].length;
	                if (backwards && endIndex > offset)
	                    return;
	                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
	                    return true;
	            };
	        }
	        else if (backwards) {
	            var forEachInLine = function (row, endIndex, callback) {
	                if (mtSearch) {
	                    var pos = mtBackward(session, re, endIndex, row, firstRow);
	                    if (!pos)
	                        return false;
	                    if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
	                        return true;
	                }
	                else {
	                    var line = session.getLine(row);
	                    var matches = [];
	                    var m, last = 0;
	                    re.lastIndex = 0;
	                    while ((m = re.exec(line))) {
	                        var length = m[0].length;
	                        last = m.index;
	                        if (!length) {
	                            if (last >= line.length)
	                                break;
	                            re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
	                        }
	                        if (m.index + length > endIndex)
	                            break;
	                        matches.push(m.index, length);
	                    }
	                    for (var i = matches.length - 1; i >= 0; i -= 2) {
	                        var column = matches[i - 1];
	                        var length = matches[i];
	                        if (callback(row, column, row, column + length))
	                            return true;
	                    }
	                }
	            };
	        }
	        else {
	            var forEachInLine = function (row, startIndex, callback) {
	                re.lastIndex = startIndex;
	                if (mtSearch) {
	                    var pos = mtForward(session, re, row, lastRow);
	                    if (pos) {
	                        var end_row = pos.endRow <= lastRow ? pos.endRow - 1 : lastRow;
	                        if (end_row > row)
	                            row = end_row;
	                    }
	                    if (!pos)
	                        return false;
	                    if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
	                        return true;
	                }
	                else {
	                    var line = session.getLine(row);
	                    var last;
	                    var m;
	                    while ((m = re.exec(line))) {
	                        var length = m[0].length;
	                        last = m.index;
	                        if (callback(row, last, row, last + length))
	                            return true;
	                        if (!length) {
	                            re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
	                            if (last >= line.length)
	                                return false;
	                        }
	                    }
	                }
	            };
	        }
	        return { forEach: forEach };
	    };
	    return Search;
	}());
	function addWordBoundary(needle, options) {
	    var supportsLookbehind = lang.supportsLookbehind();
	    function wordBoundary(c, firstChar) {
	        if (firstChar === void 0) { firstChar = true; }
	        var wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]", "u") : new RegExp("\\w");
	        if (wordRegExp.test(c) || options.regExp) {
	            if (supportsLookbehind && options.$supportsUnicodeFlag) {
	                if (firstChar)
	                    return "(?<=^|[^\\p{L}\\p{N}_])";
	                return "(?=[^\\p{L}\\p{N}_]|$)";
	            }
	            return "\\b";
	        }
	        return "";
	    }
	    var needleArray = Array.from(needle);
	    var firstChar = needleArray[0];
	    var lastChar = needleArray[needleArray.length - 1];
	    return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);
	}
	function multiLineBackwardMatch(line, re, endMargin) {
	    var match = null;
	    var from = 0;
	    while (from <= line.length) {
	        re.lastIndex = from;
	        var newMatch = re.exec(line);
	        if (!newMatch)
	            break;
	        var end = newMatch.index + newMatch[0].length;
	        if (end > line.length - endMargin)
	            break;
	        if (!match || end > match.index + match[0].length)
	            match = newMatch;
	        from = newMatch.index + 1;
	    }
	    return match;
	}
	function chunkEnd(session, start) {
	    var base = 5000, startPosition = { row: start, column: 0 }, startIndex = session.doc.positionToIndex(startPosition), targetIndex = startIndex + base, targetPosition = session.doc.indexToPosition(targetIndex), targetLine = targetPosition.row;
	    return targetLine + 1;
	}
	exports.Search = Search;

	});

	ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module){	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})(); var keyUtil = require("../lib/keys");
	var useragent = require("../lib/useragent");
	var KEY_MODS = keyUtil.KEY_MODS;
	var MultiHashHandler = /** @class */ (function () {
	    function MultiHashHandler(config, platform) {
	        this.$init(config, platform, false);
	    }
	    MultiHashHandler.prototype.$init = function (config, platform, $singleCommand) {
	        this.platform = platform || (useragent.isMac ? "mac" : "win");
	        this.commands = {};
	        this.commandKeyBinding = {};
	        this.addCommands(config);
	        this.$singleCommand = $singleCommand;
	    };
	    MultiHashHandler.prototype.addCommand = function (command) {
	        if (this.commands[command.name])
	            this.removeCommand(command);
	        this.commands[command.name] = command;
	        if (command.bindKey)
	            this._buildKeyHash(command);
	    };
	    MultiHashHandler.prototype.removeCommand = function (command, keepCommand) {
	        var name = command && (typeof command === 'string' ? command : command.name);
	        command = this.commands[name];
	        if (!keepCommand)
	            delete this.commands[name];
	        var ckb = this.commandKeyBinding;
	        for (var keyId in ckb) {
	            var cmdGroup = ckb[keyId];
	            if (cmdGroup == command) {
	                delete ckb[keyId];
	            }
	            else if (Array.isArray(cmdGroup)) {
	                var i = cmdGroup.indexOf(command);
	                if (i != -1) {
	                    cmdGroup.splice(i, 1);
	                    if (cmdGroup.length == 1)
	                        ckb[keyId] = cmdGroup[0];
	                }
	            }
	        }
	    };
	    MultiHashHandler.prototype.bindKey = function (key, command, position) {
	        if (typeof key == "object" && key) {
	            if (position == undefined)
	                position = key.position;
	            key = key[this.platform];
	        }
	        if (!key)
	            return;
	        if (typeof command == "function")
	            return this.addCommand({ exec: command, bindKey: key, name: command.name || /**@type{string}*/ (key) }); (key).split("|").forEach(function (keyPart) {
	            var chain = "";
	            if (keyPart.indexOf(" ") != -1) {
	                var parts = keyPart.split(/\s+/);
	                keyPart = parts.pop();
	                parts.forEach(function (keyPart) {
	                    var binding = this.parseKeys(keyPart);
	                    var id = KEY_MODS[binding.hashId] + binding.key;
	                    chain += (chain ? " " : "") + id;
	                    this._addCommandToBinding(chain, "chainKeys");
	                }, this);
	                chain += " ";
	            }
	            var binding = this.parseKeys(keyPart);
	            var id = KEY_MODS[binding.hashId] + binding.key;
	            this._addCommandToBinding(chain + id, command, position);
	        }, this);
	    };
	    MultiHashHandler.prototype._addCommandToBinding = function (keyId, command, position) {
	        var ckb = this.commandKeyBinding, i;
	        if (!command) {
	            delete ckb[keyId];
	        }
	        else if (!ckb[keyId] || this.$singleCommand) {
	            ckb[keyId] = command;
	        }
	        else {
	            if (!Array.isArray(ckb[keyId])) {
	                ckb[keyId] = [ckb[keyId]];
	            }
	            else if ((i = ckb[keyId].indexOf(command)) != -1) {
	                ckb[keyId].splice(i, 1);
	            }
	            if (typeof position != "number") {
	                position = getPosition(command);
	            }
	            var commands = ckb[keyId];
	            for (i = 0; i < commands.length; i++) {
	                var other = commands[i];
	                var otherPos = getPosition(other);
	                if (otherPos > position)
	                    break;
	            }
	            commands.splice(i, 0, command);
	        }
	    };
	    MultiHashHandler.prototype.addCommands = function (commands) {
	        commands && Object.keys(commands).forEach(function (name) {
	            var command = commands[name];
	            if (!command)
	                return;
	            if (typeof command === "string")
	                return this.bindKey(command, name);
	            if (typeof command === "function")
	                command = { exec: command };
	            if (typeof command !== "object")
	                return;
	            if (!command.name)
	                command.name = name;
	            this.addCommand(command);
	        }, this);
	    };
	    MultiHashHandler.prototype.removeCommands = function (commands) {
	        Object.keys(commands).forEach(function (name) {
	            this.removeCommand(commands[name]);
	        }, this);
	    };
	    MultiHashHandler.prototype.bindKeys = function (keyList) {
	        Object.keys(keyList).forEach(function (key) {
	            this.bindKey(key, keyList[key]);
	        }, this);
	    };
	    MultiHashHandler.prototype._buildKeyHash = function (command) {
	        this.bindKey(command.bindKey, command);
	    };
	    MultiHashHandler.prototype.parseKeys = function (keys) {
	        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) { return x; });
	        var key = parts.pop();
	        var keyCode = keyUtil[key];
	        if (keyUtil.FUNCTION_KEYS[keyCode])
	            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
	        else if (!parts.length)
	            return { key: key, hashId: -1 };
	        else if (parts.length == 1 && parts[0] == "shift")
	            return { key: key.toUpperCase(), hashId: -1 };
	        var hashId = 0;
	        for (var i = parts.length; i--;) {
	            var modifier = keyUtil.KEY_MODS[parts[i]];
	            if (modifier == null) {
	                if (typeof console != "undefined")
	                    console.error("invalid modifier " + parts[i] + " in " + keys);
	                return false;
	            }
	            hashId |= modifier;
	        }
	        return { key: key, hashId: hashId };
	    };
	    MultiHashHandler.prototype.findKeyCommand = function (hashId, keyString) {
	        var key = KEY_MODS[hashId] + keyString;
	        return this.commandKeyBinding[key];
	    };
	    MultiHashHandler.prototype.handleKeyboard = function (data, hashId, keyString, keyCode) {
	        if (keyCode < 0)
	            return;
	        var key = KEY_MODS[hashId] + keyString;
	        var command = this.commandKeyBinding[key];
	        if (data.$keyChain) {
	            data.$keyChain += " " + key;
	            command = this.commandKeyBinding[data.$keyChain] || command;
	        }
	        if (command) {
	            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
	                data.$keyChain = data.$keyChain || key;
	                return { command: "null" };
	            }
	        }
	        if (data.$keyChain) {
	            if ((!hashId || hashId == 4) && keyString.length == 1)
	                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
	            else if (hashId == -1 || keyCode > 0)
	                data.$keyChain = ""; // reset keyChain
	        }
	        return { command: command };
	    };
	    MultiHashHandler.prototype.getStatusText = function (editor, data) {
	        return data.$keyChain || "";
	    };
	    return MultiHashHandler;
	}());
	function getPosition(command) {
	    return typeof command == "object" && command.bindKey
	        && command.bindKey.position
	        || (command.isDefault ? -100 : 0);
	}
	var HashHandler = /** @class */ (function (_super) {
	    __extends(HashHandler, _super);
	    function HashHandler(config, platform) {
	        var _this = _super.call(this, config, platform) || this;
	        _this.$singleCommand = true;
	        return _this;
	    }
	    return HashHandler;
	}(MultiHashHandler));
	HashHandler.call = function (thisArg, config, platform) {
	    MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);
	};
	MultiHashHandler.call = function (thisArg, config, platform) {
	    MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);
	};
	exports.HashHandler = HashHandler;
	exports.MultiHashHandler = MultiHashHandler;

	});

	ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(require, exports, module){	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var oop = require("../lib/oop");
	var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
	var EventEmitter = require("../lib/event_emitter").EventEmitter;
	var CommandManager = /** @class */ (function (_super) {
	    __extends(CommandManager, _super);
	    function CommandManager(platform, commands) {
	        var _this = _super.call(this, commands, platform) || this;
	        _this.byName = _this.commands;
	        _this.setDefaultHandler("exec", function (e) {
	            if (!e.args) {
	                return e.command.exec(e.editor, {}, e.event, true);
	            }
	            return e.command.exec(e.editor, e.args, e.event, false);
	        });
	        return _this;
	    }
	    CommandManager.prototype.exec = function (command, editor, args) {
	        if (Array.isArray(command)) {
	            for (var i = command.length; i--;) {
	                if (this.exec(command[i], editor, args))
	                    return true;
	            }
	            return false;
	        }
	        if (typeof command === "string")
	            command = this.commands[command];
	        var e = { editor: editor, command: command, args: args };
	        if (!this.canExecute(command, editor)) {
	            this._signal("commandUnavailable", e);
	            return false;
	        }
	        e.returnValue = this._emit("exec", e);
	        this._signal("afterExec", e);
	        return e.returnValue === false ? false : true;
	    };
	    CommandManager.prototype.canExecute = function (command, editor) {
	        if (typeof command === "string")
	            command = this.commands[command];
	        if (!command)
	            return false;
	        if (editor && editor.$readOnly && !command.readOnly)
	            return false;
	        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
	            return false;
	        return true;
	    };
	    CommandManager.prototype.toggleRecording = function (editor) {
	        if (this.$inReplay)
	            return;
	        editor && editor._emit("changeStatus");
	        if (this.recording) {
	            this.macro.pop();
	            this.off("exec", this.$addCommandToMacro);
	            if (!this.macro.length)
	                this.macro = this.oldMacro;
	            return this.recording = false;
	        }
	        if (!this.$addCommandToMacro) {
	            this.$addCommandToMacro = function (e) {
	                this.macro.push([e.command, e.args]);
	            }.bind(this);
	        }
	        this.oldMacro = this.macro;
	        this.macro = [];
	        this.on("exec", this.$addCommandToMacro);
	        return this.recording = true;
	    };
	    CommandManager.prototype.replay = function (editor) {
	        if (this.$inReplay || !this.macro)
	            return;
	        if (this.recording)
	            return this.toggleRecording(editor);
	        try {
	            this.$inReplay = true;
	            this.macro.forEach(function (x) {
	                if (typeof x == "string")
	                    this.exec(x, editor);
	                else
	                    this.exec(x[0], editor, x[1]);
	            }, this);
	        }
	        finally {
	            this.$inReplay = false;
	        }
	    };
	    CommandManager.prototype.trimMacro = function (m) {
	        return m.map(function (x) {
	            if (typeof x[0] != "string")
	                x[0] = x[0].name;
	            if (!x[1])
	                x = x[0];
	            return x;
	        });
	    };
	    return CommandManager;
	}(MultiHashHandler));
	oop.implement(CommandManager.prototype, EventEmitter);
	exports.CommandManager = CommandManager;

	});

	ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(require, exports, module){	var lang = require("../lib/lang");
	var config = require("../config");
	var Range = require("../range").Range;
	function bindKey(win, mac) {
	    return { win: win, mac: mac };
	}
	exports.commands = [{
	        name: "showSettingsMenu",
	        description: "Show settings menu",
	        bindKey: bindKey("Ctrl-,", "Command-,"),
	        exec: function (editor) {
	            config.loadModule("ace/ext/settings_menu", function (module) {
	                module.init(editor);
	                editor.showSettingsMenu();
	            });
	        },
	        readOnly: true
	    }, {
	        name: "goToNextError",
	        description: "Go to next error",
	        bindKey: bindKey("Alt-E", "F4"),
	        exec: function (editor) {
	            config.loadModule("ace/ext/error_marker", function (module) {
	                module.showErrorMarker(editor, 1);
	            });
	        },
	        scrollIntoView: "animate",
	        readOnly: true
	    }, {
	        name: "goToPreviousError",
	        description: "Go to previous error",
	        bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
	        exec: function (editor) {
	            config.loadModule("ace/ext/error_marker", function (module) {
	                module.showErrorMarker(editor, -1);
	            });
	        },
	        scrollIntoView: "animate",
	        readOnly: true
	    }, {
	        name: "selectall",
	        description: "Select all",
	        bindKey: bindKey("Ctrl-A", "Command-A"),
	        exec: function (editor) { editor.selectAll(); },
	        readOnly: true
	    }, {
	        name: "centerselection",
	        description: "Center selection",
	        bindKey: bindKey(null, "Ctrl-L"),
	        exec: function (editor) { editor.centerSelection(); },
	        readOnly: true
	    }, {
	        name: "gotoline",
	        description: "Go to line...",
	        bindKey: bindKey("Ctrl-L", "Command-L"),
	        exec: function (editor, line) {
	            if (typeof line === "number" && !isNaN(line))
	                editor.gotoLine(line);
	            editor.prompt({ $type: "gotoLine" });
	        },
	        readOnly: true
	    }, {
	        name: "fold",
	        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
	        exec: function (editor) { editor.session.toggleFold(false); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "unfold",
	        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
	        exec: function (editor) { editor.session.toggleFold(true); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "toggleFoldWidget",
	        description: "Toggle fold widget",
	        bindKey: bindKey("F2", "F2"),
	        exec: function (editor) { editor.session.toggleFoldWidget(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "toggleParentFoldWidget",
	        description: "Toggle parent fold widget",
	        bindKey: bindKey("Alt-F2", "Alt-F2"),
	        exec: function (editor) { editor.session.toggleFoldWidget(true); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "foldall",
	        description: "Fold all",
	        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
	        exec: function (editor) { editor.session.foldAll(); },
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "foldAllComments",
	        description: "Fold all comments",
	        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
	        exec: function (editor) { editor.session.foldAllComments(); },
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "foldOther",
	        description: "Fold other",
	        bindKey: bindKey("Alt-0", "Command-Option-0"),
	        exec: function (editor) {
	            editor.session.foldAll();
	            editor.session.unfold(editor.selection.getAllRanges());
	        },
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "unfoldall",
	        description: "Unfold all",
	        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
	        exec: function (editor) { editor.session.unfold(); },
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "findnext",
	        description: "Find next",
	        bindKey: bindKey("Ctrl-K", "Command-G"),
	        exec: function (editor) { editor.findNext(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "findprevious",
	        description: "Find previous",
	        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
	        exec: function (editor) { editor.findPrevious(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "center",
	        readOnly: true
	    }, {
	        name: "selectOrFindNext",
	        description: "Select or find next",
	        bindKey: bindKey("Alt-K", "Ctrl-G"),
	        exec: function (editor) {
	            if (editor.selection.isEmpty())
	                editor.selection.selectWord();
	            else
	                editor.findNext();
	        },
	        readOnly: true
	    }, {
	        name: "selectOrFindPrevious",
	        description: "Select or find previous",
	        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
	        exec: function (editor) {
	            if (editor.selection.isEmpty())
	                editor.selection.selectWord();
	            else
	                editor.findPrevious();
	        },
	        readOnly: true
	    }, {
	        name: "find",
	        description: "Find",
	        bindKey: bindKey("Ctrl-F", "Command-F"),
	        exec: function (editor) {
	            config.loadModule("ace/ext/searchbox", function (e) { e.Search(editor); });
	        },
	        readOnly: true
	    }, {
	        name: "overwrite",
	        description: "Overwrite",
	        bindKey: "Insert",
	        exec: function (editor) { editor.toggleOverwrite(); },
	        readOnly: true
	    }, {
	        name: "selecttostart",
	        description: "Select to start",
	        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
	        exec: function (editor) { editor.getSelection().selectFileStart(); },
	        multiSelectAction: "forEach",
	        readOnly: true,
	        scrollIntoView: "animate",
	        aceCommandGroup: "fileJump"
	    }, {
	        name: "gotostart",
	        description: "Go to start",
	        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
	        exec: function (editor) { editor.navigateFileStart(); },
	        multiSelectAction: "forEach",
	        readOnly: true,
	        scrollIntoView: "animate",
	        aceCommandGroup: "fileJump"
	    }, {
	        name: "selectup",
	        description: "Select up",
	        bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
	        exec: function (editor) { editor.getSelection().selectUp(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "golineup",
	        description: "Go line up",
	        bindKey: bindKey("Up", "Up|Ctrl-P"),
	        exec: function (editor, args) { editor.navigateUp(args.times); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selecttoend",
	        description: "Select to end",
	        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
	        exec: function (editor) { editor.getSelection().selectFileEnd(); },
	        multiSelectAction: "forEach",
	        readOnly: true,
	        scrollIntoView: "animate",
	        aceCommandGroup: "fileJump"
	    }, {
	        name: "gotoend",
	        description: "Go to end",
	        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
	        exec: function (editor) { editor.navigateFileEnd(); },
	        multiSelectAction: "forEach",
	        readOnly: true,
	        scrollIntoView: "animate",
	        aceCommandGroup: "fileJump"
	    }, {
	        name: "selectdown",
	        description: "Select down",
	        bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
	        exec: function (editor) { editor.getSelection().selectDown(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "golinedown",
	        description: "Go line down",
	        bindKey: bindKey("Down", "Down|Ctrl-N"),
	        exec: function (editor, args) { editor.navigateDown(args.times); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectwordleft",
	        description: "Select word left",
	        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
	        exec: function (editor) { editor.getSelection().selectWordLeft(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "gotowordleft",
	        description: "Go to word left",
	        bindKey: bindKey("Ctrl-Left", "Option-Left"),
	        exec: function (editor) { editor.navigateWordLeft(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selecttolinestart",
	        description: "Select to line start",
	        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
	        exec: function (editor) { editor.getSelection().selectLineStart(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "gotolinestart",
	        description: "Go to line start",
	        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
	        exec: function (editor) { editor.navigateLineStart(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectleft",
	        description: "Select left",
	        bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
	        exec: function (editor) { editor.getSelection().selectLeft(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "gotoleft",
	        description: "Go to left",
	        bindKey: bindKey("Left", "Left|Ctrl-B"),
	        exec: function (editor, args) { editor.navigateLeft(args.times); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectwordright",
	        description: "Select word right",
	        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
	        exec: function (editor) { editor.getSelection().selectWordRight(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "gotowordright",
	        description: "Go to word right",
	        bindKey: bindKey("Ctrl-Right", "Option-Right"),
	        exec: function (editor) { editor.navigateWordRight(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selecttolineend",
	        description: "Select to line end",
	        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
	        exec: function (editor) { editor.getSelection().selectLineEnd(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "gotolineend",
	        description: "Go to line end",
	        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
	        exec: function (editor) { editor.navigateLineEnd(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectright",
	        description: "Select right",
	        bindKey: bindKey("Shift-Right", "Shift-Right"),
	        exec: function (editor) { editor.getSelection().selectRight(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "gotoright",
	        description: "Go to right",
	        bindKey: bindKey("Right", "Right|Ctrl-F"),
	        exec: function (editor, args) { editor.navigateRight(args.times); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectpagedown",
	        description: "Select page down",
	        bindKey: "Shift-PageDown",
	        exec: function (editor) { editor.selectPageDown(); },
	        readOnly: true
	    }, {
	        name: "pagedown",
	        description: "Page down",
	        bindKey: bindKey(null, "Option-PageDown"),
	        exec: function (editor) { editor.scrollPageDown(); },
	        readOnly: true
	    }, {
	        name: "gotopagedown",
	        description: "Go to page down",
	        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
	        exec: function (editor) { editor.gotoPageDown(); },
	        readOnly: true
	    }, {
	        name: "selectpageup",
	        description: "Select page up",
	        bindKey: "Shift-PageUp",
	        exec: function (editor) { editor.selectPageUp(); },
	        readOnly: true
	    }, {
	        name: "pageup",
	        description: "Page up",
	        bindKey: bindKey(null, "Option-PageUp"),
	        exec: function (editor) { editor.scrollPageUp(); },
	        readOnly: true
	    }, {
	        name: "gotopageup",
	        description: "Go to page up",
	        bindKey: "PageUp",
	        exec: function (editor) { editor.gotoPageUp(); },
	        readOnly: true
	    }, {
	        name: "scrollup",
	        description: "Scroll up",
	        bindKey: bindKey("Ctrl-Up", null),
	        exec: function (e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
	        readOnly: true
	    }, {
	        name: "scrolldown",
	        description: "Scroll down",
	        bindKey: bindKey("Ctrl-Down", null),
	        exec: function (e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
	        readOnly: true
	    }, {
	        name: "selectlinestart",
	        description: "Select line start",
	        bindKey: "Shift-Home",
	        exec: function (editor) { editor.getSelection().selectLineStart(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectlineend",
	        description: "Select line end",
	        bindKey: "Shift-End",
	        exec: function (editor) { editor.getSelection().selectLineEnd(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "togglerecording",
	        description: "Toggle recording",
	        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
	        exec: function (editor) { editor.commands.toggleRecording(editor); },
	        readOnly: true
	    }, {
	        name: "replaymacro",
	        description: "Replay macro",
	        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
	        exec: function (editor) { editor.commands.replay(editor); },
	        readOnly: true
	    }, {
	        name: "jumptomatching",
	        description: "Jump to matching",
	        bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
	        exec: function (editor) { editor.jumpToMatching(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "animate",
	        readOnly: true
	    }, {
	        name: "selecttomatching",
	        description: "Select to matching",
	        bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
	        exec: function (editor) { editor.jumpToMatching(true); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "animate",
	        readOnly: true
	    }, {
	        name: "expandToMatching",
	        description: "Expand to matching",
	        bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
	        exec: function (editor) { editor.jumpToMatching(true, true); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "animate",
	        readOnly: true
	    }, {
	        name: "passKeysToBrowser",
	        description: "Pass keys to browser",
	        bindKey: bindKey(null, null),
	        exec: function () { },
	        passEvent: true,
	        readOnly: true
	    }, {
	        name: "copy",
	        description: "Copy",
	        exec: function (editor) {
	        },
	        readOnly: true
	    },
	    {
	        name: "cut",
	        description: "Cut",
	        exec: function (editor) {
	            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
	            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
	            editor._emit("cut", range);
	            if (!range.isEmpty())
	                editor.session.remove(range);
	            editor.clearSelection();
	        },
	        scrollIntoView: "cursor",
	        multiSelectAction: "forEach"
	    }, {
	        name: "paste",
	        description: "Paste",
	        exec: function (editor, args) {
	            editor.$handlePaste(args);
	        },
	        scrollIntoView: "cursor"
	    }, {
	        name: "removeline",
	        description: "Remove line",
	        bindKey: bindKey("Ctrl-D", "Command-D"),
	        exec: function (editor) { editor.removeLines(); },
	        scrollIntoView: "cursor",
	        multiSelectAction: "forEachLine"
	    }, {
	        name: "duplicateSelection",
	        description: "Duplicate selection",
	        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
	        exec: function (editor) { editor.duplicateSelection(); },
	        scrollIntoView: "cursor",
	        multiSelectAction: "forEach"
	    }, {
	        name: "sortlines",
	        description: "Sort lines",
	        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
	        exec: function (editor) { editor.sortLines(); },
	        scrollIntoView: "selection",
	        multiSelectAction: "forEachLine"
	    }, {
	        name: "togglecomment",
	        description: "Toggle comment",
	        bindKey: bindKey("Ctrl-/", "Command-/"),
	        exec: function (editor) { editor.toggleCommentLines(); },
	        multiSelectAction: "forEachLine",
	        scrollIntoView: "selectionPart"
	    }, {
	        name: "toggleBlockComment",
	        description: "Toggle block comment",
	        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
	        exec: function (editor) { editor.toggleBlockComment(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "selectionPart"
	    }, {
	        name: "modifyNumberUp",
	        description: "Modify number up",
	        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
	        exec: function (editor) { editor.modifyNumber(1); },
	        scrollIntoView: "cursor",
	        multiSelectAction: "forEach"
	    }, {
	        name: "modifyNumberDown",
	        description: "Modify number down",
	        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
	        exec: function (editor) { editor.modifyNumber(-1); },
	        scrollIntoView: "cursor",
	        multiSelectAction: "forEach"
	    }, {
	        name: "replace",
	        description: "Replace",
	        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
	        exec: function (editor) {
	            config.loadModule("ace/ext/searchbox", function (e) { e.Search(editor, true); });
	        }
	    }, {
	        name: "undo",
	        description: "Undo",
	        bindKey: bindKey("Ctrl-Z", "Command-Z"),
	        exec: function (editor) { editor.undo(); }
	    }, {
	        name: "redo",
	        description: "Redo",
	        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
	        exec: function (editor) { editor.redo(); }
	    }, {
	        name: "copylinesup",
	        description: "Copy lines up",
	        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
	        exec: function (editor) { editor.copyLinesUp(); },
	        scrollIntoView: "cursor"
	    }, {
	        name: "movelinesup",
	        description: "Move lines up",
	        bindKey: bindKey("Alt-Up", "Option-Up"),
	        exec: function (editor) { editor.moveLinesUp(); },
	        scrollIntoView: "cursor"
	    }, {
	        name: "copylinesdown",
	        description: "Copy lines down",
	        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
	        exec: function (editor) { editor.copyLinesDown(); },
	        scrollIntoView: "cursor"
	    }, {
	        name: "movelinesdown",
	        description: "Move lines down",
	        bindKey: bindKey("Alt-Down", "Option-Down"),
	        exec: function (editor) { editor.moveLinesDown(); },
	        scrollIntoView: "cursor"
	    }, {
	        name: "del",
	        description: "Delete",
	        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
	        exec: function (editor) { editor.remove("right"); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "backspace",
	        description: "Backspace",
	        bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
	        exec: function (editor) { editor.remove("left"); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "cut_or_delete",
	        description: "Cut or delete",
	        bindKey: bindKey("Shift-Delete", null),
	        exec: function (editor) {
	            if (editor.selection.isEmpty()) {
	                editor.remove("left");
	            }
	            else {
	                return false;
	            }
	        },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "removetolinestart",
	        description: "Remove to line start",
	        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
	        exec: function (editor) { editor.removeToLineStart(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "removetolineend",
	        description: "Remove to line end",
	        bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
	        exec: function (editor) { editor.removeToLineEnd(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "removetolinestarthard",
	        description: "Remove to line start hard",
	        bindKey: bindKey("Ctrl-Shift-Backspace", null),
	        exec: function (editor) {
	            var range = editor.selection.getRange();
	            range.start.column = 0;
	            editor.session.remove(range);
	        },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "removetolineendhard",
	        description: "Remove to line end hard",
	        bindKey: bindKey("Ctrl-Shift-Delete", null),
	        exec: function (editor) {
	            var range = editor.selection.getRange();
	            range.end.column = Number.MAX_VALUE;
	            editor.session.remove(range);
	        },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "removewordleft",
	        description: "Remove word left",
	        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
	        exec: function (editor) { editor.removeWordLeft(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "removewordright",
	        description: "Remove word right",
	        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
	        exec: function (editor) { editor.removeWordRight(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "outdent",
	        description: "Outdent",
	        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
	        exec: function (editor) { editor.blockOutdent(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "selectionPart"
	    }, {
	        name: "indent",
	        description: "Indent",
	        bindKey: bindKey("Tab", "Tab"),
	        exec: function (editor) { editor.indent(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "selectionPart"
	    }, {
	        name: "blockoutdent",
	        description: "Block outdent",
	        bindKey: bindKey("Ctrl-[", "Ctrl-["),
	        exec: function (editor) { editor.blockOutdent(); },
	        multiSelectAction: "forEachLine",
	        scrollIntoView: "selectionPart"
	    }, {
	        name: "blockindent",
	        description: "Block indent",
	        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
	        exec: function (editor) { editor.blockIndent(); },
	        multiSelectAction: "forEachLine",
	        scrollIntoView: "selectionPart"
	    }, {
	        name: "insertstring",
	        description: "Insert string",
	        exec: function (editor, str) { editor.insert(str); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "inserttext",
	        description: "Insert text",
	        exec: function (editor, args) {
	            editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
	        },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "splitline",
	        description: "Split line",
	        bindKey: bindKey(null, "Ctrl-O"),
	        exec: function (editor) { editor.splitLine(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "transposeletters",
	        description: "Transpose letters",
	        bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
	        exec: function (editor) { editor.transposeLetters(); },
	        multiSelectAction: function (editor) { editor.transposeSelections(1); },
	        scrollIntoView: "cursor"
	    }, {
	        name: "touppercase",
	        description: "To uppercase",
	        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
	        exec: function (editor) { editor.toUpperCase(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "tolowercase",
	        description: "To lowercase",
	        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
	        exec: function (editor) { editor.toLowerCase(); },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "autoindent",
	        description: "Auto Indent",
	        bindKey: bindKey(null, null),
	        exec: function (editor) { editor.autoIndent(); },
	        scrollIntoView: "animate"
	    }, {
	        name: "expandtoline",
	        description: "Expand to line",
	        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
	        exec: function (editor) {
	            var range = editor.selection.getRange();
	            range.start.column = range.end.column = 0;
	            range.end.row++;
	            editor.selection.setRange(range, false);
	        },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "openlink",
	        bindKey: bindKey("Ctrl+F3", "F3"),
	        exec: function (editor) { editor.openLink(); }
	    }, {
	        name: "joinlines",
	        description: "Join lines",
	        bindKey: bindKey(null, null),
	        exec: function (editor) {
	            var isBackwards = editor.selection.isBackwards();
	            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
	            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
	            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
	            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
	            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
	            var insertLine = editor.session.doc.getLine(selectionStart.row);
	            for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
	                var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
	                if (curLine.length !== 0) {
	                    curLine = " " + curLine;
	                }
	                insertLine += curLine;
	            }
	            if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
	                insertLine += editor.session.doc.getNewLineCharacter();
	            }
	            editor.clearSelection();
	            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
	            if (selectedCount > 0) {
	                editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
	                editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
	            }
	            else {
	                firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
	                editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
	            }
	        },
	        multiSelectAction: "forEach",
	        readOnly: true
	    }, {
	        name: "invertSelection",
	        description: "Invert selection",
	        bindKey: bindKey(null, null),
	        exec: function (editor) {
	            var endRow = editor.session.doc.getLength() - 1;
	            var endCol = editor.session.doc.getLine(endRow).length;
	            var ranges = editor.selection.rangeList.ranges;
	            var newRanges = [];
	            if (ranges.length < 1) {
	                ranges = [editor.selection.getRange()];
	            }
	            for (var i = 0; i < ranges.length; i++) {
	                if (i == (ranges.length - 1)) {
	                    if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
	                        newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
	                    }
	                }
	                if (i === 0) {
	                    if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
	                        newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
	                    }
	                }
	                else {
	                    newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
	                }
	            }
	            editor.exitMultiSelectMode();
	            editor.clearSelection();
	            for (var i = 0; i < newRanges.length; i++) {
	                editor.selection.addRange(newRanges[i], false);
	            }
	        },
	        readOnly: true,
	        scrollIntoView: "none"
	    }, {
	        name: "addLineAfter",
	        description: "Add new line after the current line",
	        exec: function (editor) {
	            editor.selection.clearSelection();
	            editor.navigateLineEnd();
	            editor.insert("\n");
	        },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "addLineBefore",
	        description: "Add new line before the current line",
	        exec: function (editor) {
	            editor.selection.clearSelection();
	            var cursor = editor.getCursorPosition();
	            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
	            editor.insert("\n");
	            if (cursor.row === 0)
	                editor.navigateUp();
	        },
	        multiSelectAction: "forEach",
	        scrollIntoView: "cursor"
	    }, {
	        name: "openCommandPallete",
	        exec: function (editor) {
	            console.warn("This is an obsolete command. Please use `openCommandPalette` instead.");
	            editor.prompt({ $type: "commands" });
	        },
	        readOnly: true
	    }, {
	        name: "openCommandPalette",
	        description: "Open command palette",
	        bindKey: bindKey("F1", "F1"),
	        exec: function (editor) {
	            editor.prompt({ $type: "commands" });
	        },
	        readOnly: true
	    }, {
	        name: "modeSelect",
	        description: "Change language mode...",
	        bindKey: bindKey(null, null),
	        exec: function (editor) {
	            editor.prompt({ $type: "modes" });
	        },
	        readOnly: true
	    }];
	for (var i = 1; i < 9; i++) {
	    exports.commands.push({
	        name: "foldToLevel" + i,
	        description: "Fold To Level " + i,
	        level: i,
	        exec: function (editor) { editor.session.foldToLevel(this.level); },
	        scrollIntoView: "center",
	        readOnly: true
	    });
	}

	});

	ace.define("ace/keyboard/gutter_handler",["require","exports","module","ace/lib/keys","ace/mouse/default_gutter_handler"], function(require, exports, module){	var keys = require('../lib/keys');
	var GutterTooltip = require("../mouse/default_gutter_handler").GutterTooltip;
	var GutterKeyboardHandler = /** @class */ (function () {
	    function GutterKeyboardHandler(editor) {
	        this.editor = editor;
	        this.gutterLayer = editor.renderer.$gutterLayer;
	        this.element = editor.renderer.$gutter;
	        this.lines = editor.renderer.$gutterLayer.$lines;
	        this.activeRowIndex = null;
	        this.activeLane = null;
	        this.annotationTooltip = new GutterTooltip(this.editor);
	    }
	    GutterKeyboardHandler.prototype.addListener = function () {
	        this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this));
	        this.element.addEventListener("focusout", this.$blurGutter.bind(this));
	        this.editor.on("mousewheel", this.$blurGutter.bind(this));
	    };
	    GutterKeyboardHandler.prototype.removeListener = function () {
	        this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this));
	        this.element.removeEventListener("focusout", this.$blurGutter.bind(this));
	        this.editor.off("mousewheel", this.$blurGutter.bind(this));
	    };
	    GutterKeyboardHandler.prototype.$onGutterKeyDown = function (e) {
	        if (this.annotationTooltip.isOpen) {
	            e.preventDefault();
	            if (e.keyCode === keys["escape"])
	                this.annotationTooltip.hideTooltip();
	            return;
	        }
	        if (e.target === this.element) {
	            if (e.keyCode != keys["enter"]) {
	                return;
	            }
	            e.preventDefault();
	            var row = this.editor.getCursorPosition().row;
	            if (!this.editor.isRowVisible(row))
	                this.editor.scrollToLine(row, true, true);
	            setTimeout(
	            function () {
	                var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);
	                var nearestFoldLaneWidgetIndex = this.$findNearestFoldLaneWidget(index);
	                var nearestAnnotationIndex = this.$findNearestAnnotation(index);
	                if (nearestFoldLaneWidgetIndex === null && nearestAnnotationIndex === null)
	                    return;
	                var futureActiveRowIndex = this.$findClosestNumber(nearestFoldLaneWidgetIndex, nearestAnnotationIndex, index);
	                if (futureActiveRowIndex === nearestFoldLaneWidgetIndex) {
	                    this.activeLane = "fold";
	                    this.activeRowIndex = nearestFoldLaneWidgetIndex;
	                    if (this.$isCustomWidgetVisible(nearestFoldLaneWidgetIndex)) {
	                        this.$focusCustomWidget(this.activeRowIndex);
	                        return;
	                    }
	                    else {
	                        this.$focusFoldWidget(this.activeRowIndex);
	                        return;
	                    }
	                }
	                else {
	                    this.activeRowIndex = nearestAnnotationIndex;
	                    this.activeLane = "annotation";
	                    this.$focusAnnotation(this.activeRowIndex);
	                    return;
	                }
	            }.bind(this), 10);
	            return;
	        }
	        this.$handleGutterKeyboardInteraction(e);
	        setTimeout(function () {
	            this.editor._signal("gutterkeydown", new GutterKeyboardEvent(e, this));
	        }.bind(this), 10);
	    };
	    GutterKeyboardHandler.prototype.$handleGutterKeyboardInteraction = function (e) {
	        if (e.keyCode === keys["tab"]) {
	            e.preventDefault();
	            return;
	        }
	        if (e.keyCode === keys["escape"]) {
	            e.preventDefault();
	            this.$blurGutter();
	            this.element.focus();
	            this.lane = null;
	            return;
	        }
	        if (e.keyCode === keys["up"]) {
	            e.preventDefault();
	            switch (this.activeLane) {
	                case "fold":
	                    this.$moveFoldWidgetUp();
	                    break;
	                case "annotation":
	                    this.$moveAnnotationUp();
	                    break;
	            }
	            return;
	        }
	        if (e.keyCode === keys["down"]) {
	            e.preventDefault();
	            switch (this.activeLane) {
	                case "fold":
	                    this.$moveFoldWidgetDown();
	                    break;
	                case "annotation":
	                    this.$moveAnnotationDown();
	                    break;
	            }
	            return;
	        }
	        if (e.keyCode === keys["left"]) {
	            e.preventDefault();
	            this.$switchLane("annotation");
	            return;
	        }
	        if (e.keyCode === keys["right"]) {
	            e.preventDefault();
	            this.$switchLane("fold");
	            return;
	        }
	        if (e.keyCode === keys["enter"] || e.keyCode === keys["space"]) {
	            e.preventDefault();
	            switch (this.activeLane) {
	                case "fold":
	                    var row = this.$rowIndexToRow(this.activeRowIndex);
	                    var customWidget = this.editor.session.$gutterCustomWidgets[row];
	                    if (customWidget) {
	                        if (customWidget.callbacks && customWidget.callbacks.onClick) {
	                            customWidget.callbacks.onClick(e, row);
	                        }
	                    }
	                    else if (this.gutterLayer.session.foldWidgets[row] === 'start') {
	                        this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e);
	                        setTimeout(
	                        function () {
	                            if (this.$rowIndexToRow(this.activeRowIndex) !== row) {
	                                this.$blurFoldWidget(this.activeRowIndex);
	                                this.activeRowIndex = this.$rowToRowIndex(row);
	                                this.$focusFoldWidget(this.activeRowIndex);
	                            }
	                        }.bind(this), 10);
	                        break;
	                    }
	                    else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === 'end') {
	                        break;
	                    }
	                    return;
	                case "annotation":
	                    var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];
	                    var rect = gutterElement.getBoundingClientRect();
	                    var style = this.annotationTooltip.getElement().style;
	                    style.left = rect.right + "px";
	                    style.top = rect.bottom + "px";
	                    this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
	                    break;
	            }
	            return;
	        }
	    };
	    GutterKeyboardHandler.prototype.$blurGutter = function () {
	        if (this.activeRowIndex !== null) {
	            switch (this.activeLane) {
	                case "fold":
	                    this.$blurFoldWidget(this.activeRowIndex);
	                    this.$blurCustomWidget(this.activeRowIndex);
	                    break;
	                case "annotation":
	                    this.$blurAnnotation(this.activeRowIndex);
	                    break;
	            }
	        }
	        if (this.annotationTooltip.isOpen)
	            this.annotationTooltip.hideTooltip();
	        return;
	    };
	    GutterKeyboardHandler.prototype.$isFoldWidgetVisible = function (index) {
	        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
	        var isIconVisible = this.$getFoldWidget(index).style.display !== "none";
	        return isRowFullyVisible && isIconVisible;
	    };
	    GutterKeyboardHandler.prototype.$isCustomWidgetVisible = function (index) {
	        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
	        var isIconVisible = !!this.$getCustomWidget(index);
	        return isRowFullyVisible && isIconVisible;
	    };
	    GutterKeyboardHandler.prototype.$isAnnotationVisible = function (index) {
	        var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
	        var isIconVisible = this.$getAnnotation(index).style.display !== "none";
	        return isRowFullyVisible && isIconVisible;
	    };
	    GutterKeyboardHandler.prototype.$getFoldWidget = function (index) {
	        var cell = this.lines.get(index);
	        var element = cell.element;
	        return element.childNodes[1];
	    };
	    GutterKeyboardHandler.prototype.$getCustomWidget = function (index) {
	        var cell = this.lines.get(index);
	        var element = cell.element;
	        return element.childNodes[3];
	    };
	    GutterKeyboardHandler.prototype.$getAnnotation = function (index) {
	        var cell = this.lines.get(index);
	        var element = cell.element;
	        return element.childNodes[2];
	    };
	    GutterKeyboardHandler.prototype.$findNearestFoldLaneWidget = function (index) {
	        if (this.$isCustomWidgetVisible(index))
	            return index;
	        if (this.$isFoldWidgetVisible(index))
	            return index;
	        var i = 0;
	        while (index - i > 0 || index + i < this.lines.getLength() - 1) {
	            i++;
	            if (index - i >= 0 && this.$isCustomWidgetVisible(index - i))
	                return index - i;
	            if (index + i <= this.lines.getLength() - 1 && this.$isCustomWidgetVisible(index + i))
	                return index + i;
	            if (index - i >= 0 && this.$isFoldWidgetVisible(index - i))
	                return index - i;
	            if (index + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i))
	                return index + i;
	        }
	        return null;
	    };
	    GutterKeyboardHandler.prototype.$findNearestAnnotation = function (index) {
	        if (this.$isAnnotationVisible(index))
	            return index;
	        var i = 0;
	        while (index - i > 0 || index + i < this.lines.getLength() - 1) {
	            i++;
	            if (index - i >= 0 && this.$isAnnotationVisible(index - i))
	                return index - i;
	            if (index + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i))
	                return index + i;
	        }
	        return null;
	    };
	    GutterKeyboardHandler.prototype.$focusFoldWidget = function (index) {
	        if (index == null)
	            return;
	        var foldWidget = this.$getFoldWidget(index);
	        foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
	        foldWidget.focus();
	    };
	    GutterKeyboardHandler.prototype.$focusCustomWidget = function (index) {
	        if (index == null)
	            return;
	        var customWidget = this.$getCustomWidget(index);
	        if (customWidget) {
	            customWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
	            customWidget.focus();
	        }
	    };
	    GutterKeyboardHandler.prototype.$focusAnnotation = function (index) {
	        if (index == null)
	            return;
	        var annotation = this.$getAnnotation(index);
	        annotation.classList.add(this.editor.renderer.keyboardFocusClassName);
	        annotation.focus();
	    };
	    GutterKeyboardHandler.prototype.$blurFoldWidget = function (index) {
	        var foldWidget = this.$getFoldWidget(index);
	        foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
	        foldWidget.blur();
	    };
	    GutterKeyboardHandler.prototype.$blurCustomWidget = function (index) {
	        var customWidget = this.$getCustomWidget(index);
	        if (customWidget) {
	            customWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
	            customWidget.blur();
	        }
	    };
	    GutterKeyboardHandler.prototype.$blurAnnotation = function (index) {
	        var annotation = this.$getAnnotation(index);
	        annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);
	        annotation.blur();
	    };
	    GutterKeyboardHandler.prototype.$moveFoldWidgetUp = function () {
	        var index = this.activeRowIndex;
	        while (index > 0) {
	            index--;
	            if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)) {
	                this.$blurFoldWidget(this.activeRowIndex);
	                this.$blurCustomWidget(this.activeRowIndex);
	                this.activeRowIndex = index;
	                if (this.$isFoldWidgetVisible(index)) {
	                    this.$focusFoldWidget(this.activeRowIndex);
	                }
	                else {
	                    this.$focusCustomWidget(this.activeRowIndex);
	                }
	                return;
	            }
	        }
	        return;
	    };
	    GutterKeyboardHandler.prototype.$moveFoldWidgetDown = function () {
	        var index = this.activeRowIndex;
	        while (index < this.lines.getLength() - 1) {
	            index++;
	            if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)) {
	                this.$blurFoldWidget(this.activeRowIndex);
	                this.$blurCustomWidget(this.activeRowIndex);
	                this.activeRowIndex = index;
	                if (this.$isFoldWidgetVisible(index)) {
	                    this.$focusFoldWidget(this.activeRowIndex);
	                }
	                else {
	                    this.$focusCustomWidget(this.activeRowIndex);
	                }
	                return;
	            }
	        }
	        return;
	    };
	    GutterKeyboardHandler.prototype.$moveAnnotationUp = function () {
	        var index = this.activeRowIndex;
	        while (index > 0) {
	            index--;
	            if (this.$isAnnotationVisible(index)) {
	                this.$blurAnnotation(this.activeRowIndex);
	                this.activeRowIndex = index;
	                this.$focusAnnotation(this.activeRowIndex);
	                return;
	            }
	        }
	        return;
	    };
	    GutterKeyboardHandler.prototype.$moveAnnotationDown = function () {
	        var index = this.activeRowIndex;
	        while (index < this.lines.getLength() - 1) {
	            index++;
	            if (this.$isAnnotationVisible(index)) {
	                this.$blurAnnotation(this.activeRowIndex);
	                this.activeRowIndex = index;
	                this.$focusAnnotation(this.activeRowIndex);
	                return;
	            }
	        }
	        return;
	    };
	    GutterKeyboardHandler.prototype.$findClosestNumber = function (num1, num2, target) {
	        if (num1 === null)
	            return num2;
	        if (num2 === null)
	            return num1;
	        return (Math.abs(target - num1) <= Math.abs(target - num2)) ? num1 : num2;
	    };
	    GutterKeyboardHandler.prototype.$switchLane = function (desinationLane) {
	        switch (desinationLane) {
	            case "annotation":
	                if (this.activeLane === "annotation") {
	                    break;
	                }
	                var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);
	                if (annotationIndex == null) {
	                    break;
	                }
	                this.activeLane = "annotation";
	                this.$blurFoldWidget(this.activeRowIndex);
	                this.$blurCustomWidget(this.activeRowIndex);
	                this.activeRowIndex = annotationIndex;
	                this.$focusAnnotation(this.activeRowIndex);
	                break;
	            case "fold":
	                if (this.activeLane === "fold") {
	                    break;
	                }
	                var foldLaneWidgetIndex = this.$findNearestFoldLaneWidget(this.activeRowIndex);
	                if (foldLaneWidgetIndex === null) {
	                    break;
	                }
	                this.activeLane = "fold";
	                this.$blurAnnotation(this.activeRowIndex);
	                this.activeRowIndex = foldLaneWidgetIndex;
	                if (this.$isCustomWidgetVisible(foldLaneWidgetIndex)) {
	                    this.$focusCustomWidget(this.activeRowIndex);
	                }
	                else {
	                    this.$focusFoldWidget(this.activeRowIndex);
	                }
	                break;
	        }
	        return;
	    };
	    GutterKeyboardHandler.prototype.$rowIndexToRow = function (index) {
	        var cell = this.lines.get(index);
	        if (cell)
	            return cell.row;
	        return null;
	    };
	    GutterKeyboardHandler.prototype.$rowToRowIndex = function (row) {
	        for (var i = 0; i < this.lines.getLength(); i++) {
	            var cell = this.lines.get(i);
	            if (cell.row == row)
	                return i;
	        }
	        return null;
	    };
	    return GutterKeyboardHandler;
	}());
	exports.GutterKeyboardHandler = GutterKeyboardHandler;
	var GutterKeyboardEvent = /** @class */ (function () {
	    function GutterKeyboardEvent(domEvent, gutterKeyboardHandler) {
	        this.gutterKeyboardHandler = gutterKeyboardHandler;
	        this.domEvent = domEvent;
	    }
	    GutterKeyboardEvent.prototype.getKey = function () {
	        return keys.keyCodeToString(this.domEvent.keyCode);
	    };
	    GutterKeyboardEvent.prototype.getRow = function () {
	        return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
	    };
	    GutterKeyboardEvent.prototype.isInAnnotationLane = function () {
	        return this.gutterKeyboardHandler.activeLane === "annotation";
	    };
	    GutterKeyboardEvent.prototype.isInFoldLane = function () {
	        return this.gutterKeyboardHandler.activeLane === "fold";
	    };
	    return GutterKeyboardEvent;
	}());
	exports.GutterKeyboardEvent = GutterKeyboardEvent;

	});

	ace.define("ace/editor",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator","ace/keyboard/gutter_handler","ace/config","ace/clipboard","ace/lib/keys","ace/lib/event","ace/tooltip"], function(require, exports, module){	var __values = (this && this.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var oop = require("./lib/oop");
	var dom = require("./lib/dom");
	var lang = require("./lib/lang");
	var useragent = require("./lib/useragent");
	var TextInput = require("./keyboard/textinput").TextInput;
	var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
	var FoldHandler = require("./mouse/fold_handler").FoldHandler;
	var KeyBinding = require("./keyboard/keybinding").KeyBinding;
	var EditSession = require("./edit_session").EditSession;
	var Search = require("./search").Search;
	var Range = require("./range").Range;
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var CommandManager = require("./commands/command_manager").CommandManager;
	var defaultCommands = require("./commands/default_commands").commands;
	var config = require("./config");
	var TokenIterator = require("./token_iterator").TokenIterator;
	var GutterKeyboardHandler = require("./keyboard/gutter_handler").GutterKeyboardHandler;
	var nls = require("./config").nls;
	var clipboard = require("./clipboard");
	var keys = require('./lib/keys');
	var event = require("./lib/event");
	var HoverTooltip = require("./tooltip").HoverTooltip;
	var Editor = /** @class */ (function () {
	    function Editor(renderer, session, options) {
	        this.id = "editor" + (++Editor.$uid); this.session;
	        this.$toDestroy = [];
	        var container = renderer.getContainerElement();
	        this.container = container;
	        this.renderer = renderer;
	        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
	        if (typeof document == "object") {
	            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
	            this.renderer.textarea = this.textInput.getElement();
	            this.$mouseHandler = new MouseHandler(this);
	            new FoldHandler(this);
	        }
	        this.keyBinding = new KeyBinding(this);
	        this.$search = new Search().set({
	            wrap: true
	        });
	        this.$historyTracker = this.$historyTracker.bind(this);
	        this.commands.on("exec", this.$historyTracker);
	        this.$initOperationListeners();
	        this._$emitInputEvent = lang.delayedCall(function () {
	            this._signal("input", {});
	            if (this.session && !this.session.destroyed)
	                this.session.bgTokenizer.scheduleStart();
	        }.bind(this));
	        this.on("change", function (_, _self) {
	            _self._$emitInputEvent.schedule(31);
	        });
	        this.setSession(session || options && options.session || new EditSession(""));
	        config.resetOptions(this);
	        if (options)
	            this.setOptions(options);
	        config._signal("editor", this);
	    }
	    Editor.prototype.$initOperationListeners = function () {
	        this.commands.on("exec", this.startOperation.bind(this), true);
	        this.commands.on("afterExec", this.endOperation.bind(this), true);
	    };
	    Editor.prototype.startOperation = function (commandEvent) {
	        this.session.startOperation(commandEvent);
	    };
	    Editor.prototype.endOperation = function (e) {
	        this.session.endOperation(e);
	    };
	    Editor.prototype.onStartOperation = function (commandEvent) {
	        this.curOp = this.session.curOp;
	        this.curOp.scrollTop = this.renderer.scrollTop;
	        this.prevOp = this.session.prevOp;
	        if (!commandEvent) {
	            this.previousCommand = null;
	        }
	    };
	    Editor.prototype.onEndOperation = function (e) {
	        if (this.curOp && this.session) {
	            if (e && e.returnValue === false) {
	                this.curOp = null;
	                return;
	            }
	            this._signal("beforeEndOperation");
	            if (!this.curOp)
	                return;
	            var command = this.curOp.command;
	            var scrollIntoView = command && command.scrollIntoView;
	            if (scrollIntoView) {
	                switch (scrollIntoView) {
	                    case "center-animate":
	                        scrollIntoView = "animate";
	                    case "center":
	                        this.renderer.scrollCursorIntoView(null, 0.5);
	                        break;
	                    case "animate":
	                    case "cursor":
	                        this.renderer.scrollCursorIntoView();
	                        break;
	                    case "selectionPart":
	                        var range = this.selection.getRange();
	                        var config = this.renderer.layerConfig;
	                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
	                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
	                        }
	                        break;
	                }
	                if (scrollIntoView == "animate")
	                    this.renderer.animateScrolling(this.curOp.scrollTop);
	            }
	            this.$lastSel = this.session.selection.toJSON();
	            this.prevOp = this.curOp;
	            this.curOp = null;
	        }
	    };
	    Editor.prototype.$historyTracker = function (e) {
	        if (!this.$mergeUndoDeltas)
	            return;
	        var prev = this.prevOp;
	        var mergeableCommands = this.$mergeableCommands;
	        var shouldMerge = prev.command && (e.command.name == prev.command.name);
	        if (e.command.name == "insertstring") {
	            var text = e.args;
	            if (this.mergeNextCommand === undefined)
	                this.mergeNextCommand = true;
	            shouldMerge = shouldMerge
	                && this.mergeNextCommand // previous command allows to coalesce with
	                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type
	            this.mergeNextCommand = true;
	        }
	        else {
	            shouldMerge = shouldMerge
	                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
	        }
	        if (this.$mergeUndoDeltas != "always"
	            && Date.now() - this.sequenceStartTime > 2000) {
	            shouldMerge = false; // the sequence is too long
	        }
	        if (shouldMerge)
	            this.session.mergeUndoDeltas = true;
	        else if (mergeableCommands.indexOf(e.command.name) !== -1)
	            this.sequenceStartTime = Date.now();
	    };
	    Editor.prototype.setKeyboardHandler = function (keyboardHandler, cb) {
	        if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
	            this.$keybindingId = keyboardHandler;
	            var _self = this;
	            config.loadModule(["keybinding", keyboardHandler], function (module) {
	                if (_self.$keybindingId == keyboardHandler)
	                    _self.keyBinding.setKeyboardHandler(module && module.handler);
	                cb && cb();
	            });
	        }
	        else {
	            this.$keybindingId = null;
	            this.keyBinding.setKeyboardHandler(keyboardHandler);
	            cb && cb();
	        }
	    };
	    Editor.prototype.getKeyboardHandler = function () {
	        return this.keyBinding.getKeyboardHandler();
	    };
	    Editor.prototype.setSession = function (session) {
	        if (this.session == session)
	            return;
	        if (this.curOp)
	            this.endOperation();
	        this.curOp = {};
	        var oldSession = this.session;
	        if (oldSession) {
	            this.session.off("change", this.$onDocumentChange);
	            this.session.off("changeMode", this.$onChangeMode);
	            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
	            this.session.off("changeTabSize", this.$onChangeTabSize);
	            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
	            this.session.off("changeWrapMode", this.$onChangeWrapMode);
	            this.session.off("changeFold", this.$onChangeFold);
	            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
	            this.session.off("changeBackMarker", this.$onChangeBackMarker);
	            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
	            this.session.off("changeAnnotation", this.$onChangeAnnotation);
	            this.session.off("changeOverwrite", this.$onCursorChange);
	            this.session.off("changeScrollTop", this.$onScrollTopChange);
	            this.session.off("changeScrollLeft", this.$onScrollLeftChange);
	            this.session.off("startOperation", this.$onStartOperation);
	            this.session.off("endOperation", this.$onEndOperation);
	            var selection = this.session.getSelection();
	            selection.off("changeCursor", this.$onCursorChange);
	            selection.off("changeSelection", this.$onSelectionChange);
	        }
	        this.session = session;
	        if (session) {
	            this.$onDocumentChange = this.onDocumentChange.bind(this);
	            session.on("change", this.$onDocumentChange);
	            this.renderer.setSession(session);
	            this.$onChangeMode = this.onChangeMode.bind(this);
	            session.on("changeMode", this.$onChangeMode);
	            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
	            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
	            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
	            session.on("changeTabSize", this.$onChangeTabSize);
	            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
	            session.on("changeWrapLimit", this.$onChangeWrapLimit);
	            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
	            session.on("changeWrapMode", this.$onChangeWrapMode);
	            this.$onChangeFold = this.onChangeFold.bind(this);
	            session.on("changeFold", this.$onChangeFold);
	            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
	            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
	            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
	            this.session.on("changeBackMarker", this.$onChangeBackMarker);
	            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
	            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
	            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
	            this.session.on("changeAnnotation", this.$onChangeAnnotation);
	            this.$onCursorChange = this.onCursorChange.bind(this);
	            this.session.on("changeOverwrite", this.$onCursorChange);
	            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
	            this.session.on("changeScrollTop", this.$onScrollTopChange);
	            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
	            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
	            this.selection = session.getSelection();
	            this.selection.on("changeCursor", this.$onCursorChange);
	            this.$onSelectionChange = this.onSelectionChange.bind(this);
	            this.selection.on("changeSelection", this.$onSelectionChange);
	            this.$onStartOperation = this.onStartOperation.bind(this);
	            this.session.on("startOperation", this.$onStartOperation);
	            this.$onEndOperation = this.onEndOperation.bind(this);
	            this.session.on("endOperation", this.$onEndOperation);
	            this.onChangeMode();
	            this.onCursorChange();
	            this.onScrollTopChange();
	            this.onScrollLeftChange();
	            this.onSelectionChange();
	            this.onChangeFrontMarker();
	            this.onChangeBackMarker();
	            this.onChangeBreakpoint();
	            this.onChangeAnnotation();
	            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
	            this.renderer.updateFull();
	        }
	        else {
	            this.selection = null;
	            this.renderer.setSession(session);
	        }
	        this._signal("changeSession", {
	            session: session,
	            oldSession: oldSession
	        });
	        this.curOp = null;
	        oldSession && oldSession._signal("changeEditor", { oldEditor: this });
	        if (oldSession)
	            oldSession.$editor = null;
	        session && session._signal("changeEditor", { editor: this });
	        if (session)
	            session.$editor = this;
	        if (session && !session.destroyed)
	            session.bgTokenizer.scheduleStart();
	    };
	    Editor.prototype.getSession = function () {
	        return this.session;
	    };
	    Editor.prototype.setValue = function (val, cursorPos) {
	        this.session.doc.setValue(val);
	        if (!cursorPos)
	            this.selectAll();
	        else if (cursorPos == 1)
	            this.navigateFileEnd();
	        else if (cursorPos == -1)
	            this.navigateFileStart();
	        return val;
	    };
	    Editor.prototype.getValue = function () {
	        return this.session.getValue();
	    };
	    Editor.prototype.getSelection = function () {
	        return this.selection;
	    };
	    Editor.prototype.resize = function (force) {
	        this.renderer.onResize(force);
	    };
	    Editor.prototype.setTheme = function (theme, cb) {
	        this.renderer.setTheme(theme, cb);
	    };
	    Editor.prototype.getTheme = function () {
	        return this.renderer.getTheme();
	    };
	    Editor.prototype.setStyle = function (style, incluude) {
	        this.renderer.setStyle(style, incluude);
	    };
	    Editor.prototype.unsetStyle = function (style) {
	        this.renderer.unsetStyle(style);
	    };
	    Editor.prototype.getFontSize = function () {
	        return this.getOption("fontSize") ||
	            dom.computedStyle(this.container).fontSize;
	    };
	    Editor.prototype.setFontSize = function (size) {
	        this.setOption("fontSize", size);
	    };
	    Editor.prototype.$highlightBrackets = function () {
	        if (this.$highlightPending) {
	            return;
	        }
	        var self = this;
	        this.$highlightPending = true;
	        setTimeout(function () {
	            self.$highlightPending = false;
	            var session = self.session;
	            if (!session || session.destroyed)
	                return;
	            if (session.$bracketHighlight) {
	                session.$bracketHighlight.markerIds.forEach(function (id) {
	                    session.removeMarker(id);
	                });
	                session.$bracketHighlight = null;
	            }
	            var pos = self.getCursorPosition();
	            var handler = self.getKeyboardHandler();
	            var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self);
	            var ranges = session.getMatchingBracketRanges(pos, isBackwards);
	            if (!ranges) {
	                var iterator = new TokenIterator(session, pos.row, pos.column);
	                var token = iterator.getCurrentToken();
	                if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
	                    var tagNamesRanges = session.getMatchingTags(pos);
	                    if (tagNamesRanges) {
	                        ranges = [
	                            tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,
	                            tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName
	                        ];
	                    }
	                }
	            }
	            if (!ranges && session.$mode.getMatching)
	                ranges = session.$mode.getMatching(self.session);
	            if (!ranges) {
	                if (self.getHighlightIndentGuides())
	                    self.renderer.$textLayer.$highlightIndentGuide();
	                return;
	            }
	            var markerType = "ace_bracket";
	            if (!Array.isArray(ranges)) {
	                ranges = [ranges];
	            }
	            else if (ranges.length == 1) {
	                markerType = "ace_error_bracket";
	            }
	            if (ranges.length == 2) {
	                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
	                    ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
	                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
	                    ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
	            }
	            session.$bracketHighlight = {
	                ranges: ranges,
	                markerIds: ranges.map(function (range) {
	                    return session.addMarker(range, markerType, "text");
	                })
	            };
	            if (self.getHighlightIndentGuides())
	                self.renderer.$textLayer.$highlightIndentGuide();
	        }, 50);
	    };
	    Editor.prototype.focus = function () {
	        this.textInput.focus();
	    };
	    Editor.prototype.isFocused = function () {
	        return this.textInput.isFocused();
	    };
	    Editor.prototype.blur = function () {
	        this.textInput.blur();
	    };
	    Editor.prototype.onFocus = function (e) {
	        if (this.$isFocused)
	            return;
	        this.$isFocused = true;
	        this.renderer.showCursor();
	        this.renderer.visualizeFocus();
	        this._emit("focus", e);
	    };
	    Editor.prototype.onBlur = function (e) {
	        if (!this.$isFocused)
	            return;
	        this.$isFocused = false;
	        this.renderer.hideCursor();
	        this.renderer.visualizeBlur();
	        this._emit("blur", e);
	    };
	    Editor.prototype.$cursorChange = function () {
	        this.renderer.updateCursor();
	        this.$highlightBrackets();
	        this.$updateHighlightActiveLine();
	    };
	    Editor.prototype.onDocumentChange = function (delta) {
	        var wrap = this.session.$useWrapMode;
	        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
	        this.renderer.updateLines(delta.start.row, lastRow, wrap);
	        this._signal("change", delta);
	        this.$cursorChange();
	    };
	    Editor.prototype.onTokenizerUpdate = function (e) {
	        var rows = e.data;
	        this.renderer.updateLines(rows.first, rows.last);
	    };
	    Editor.prototype.onScrollTopChange = function () {
	        this.renderer.scrollToY(this.session.getScrollTop());
	    };
	    Editor.prototype.onScrollLeftChange = function () {
	        this.renderer.scrollToX(this.session.getScrollLeft());
	    };
	    Editor.prototype.onCursorChange = function () {
	        this.$cursorChange();
	        this._signal("changeSelection");
	    };
	    Editor.prototype.$updateHighlightActiveLine = function () {
	        var session = this.getSession();
	        var highlight;
	        if (this.$highlightActiveLine) {
	            if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
	                highlight = this.getCursorPosition();
	            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
	                highlight = false;
	            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
	                highlight = false;
	        }
	        if (session.$highlightLineMarker && !highlight) {
	            session.removeMarker(session.$highlightLineMarker.id);
	            session.$highlightLineMarker = null;
	        }
	        else if (!session.$highlightLineMarker && highlight) {
	            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
	            range.id = session.addMarker(range, "ace_active-line", "screenLine");
	            session.$highlightLineMarker = range;
	        }
	        else if (highlight) {
	            session.$highlightLineMarker.start.row = highlight.row;
	            session.$highlightLineMarker.end.row = highlight.row;
	            session.$highlightLineMarker.start.column = highlight.column;
	            session._signal("changeBackMarker");
	        }
	    };
	    Editor.prototype.onSelectionChange = function (e) {
	        var session = this.session;
	        if (session.$selectionMarker) {
	            session.removeMarker(session.$selectionMarker);
	        }
	        session.$selectionMarker = null;
	        if (!this.selection.isEmpty()) {
	            var range = this.selection.getRange();
	            var style = this.getSelectionStyle();
	            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
	        }
	        else {
	            this.$updateHighlightActiveLine();
	        }
	        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
	        this.session.highlight(re);
	        this._signal("changeSelection");
	    };
	    Editor.prototype.$getSelectionHighLightRegexp = function () {
	        var session = this.session;
	        var selection = this.getSelectionRange();
	        if (selection.isEmpty() || selection.isMultiLine())
	            return;
	        var startColumn = selection.start.column;
	        var endColumn = selection.end.column;
	        var line = session.getLine(selection.start.row);
	        var needle = line.substring(startColumn, endColumn);
	        if (needle.length > 5000 || !/[\w\d]/.test(needle))
	            return;
	        var re = this.$search.$assembleRegExp({
	            wholeWord: true,
	            caseSensitive: true,
	            needle: needle
	        });
	        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
	        if (!re.test(wordWithBoundary))
	            return;
	        return re;
	    };
	    Editor.prototype.onChangeFrontMarker = function () {
	        this.renderer.updateFrontMarkers();
	    };
	    Editor.prototype.onChangeBackMarker = function () {
	        this.renderer.updateBackMarkers();
	    };
	    Editor.prototype.onChangeBreakpoint = function () {
	        this.renderer.updateBreakpoints();
	    };
	    Editor.prototype.onChangeAnnotation = function () {
	        this.renderer.setAnnotations(this.session.getAnnotations());
	    };
	    Editor.prototype.onChangeMode = function (e) {
	        this.renderer.updateText();
	        this._emit("changeMode", e);
	    };
	    Editor.prototype.onChangeWrapLimit = function () {
	        this.renderer.updateFull();
	    };
	    Editor.prototype.onChangeWrapMode = function () {
	        this.renderer.onResize(true);
	    };
	    Editor.prototype.onChangeFold = function () {
	        this.$updateHighlightActiveLine();
	        this.renderer.updateFull();
	    };
	    Editor.prototype.getSelectedText = function () {
	        return this.session.getTextRange(this.getSelectionRange());
	    };
	    Editor.prototype.getCopyText = function () {
	        var text = this.getSelectedText();
	        var nl = this.session.doc.getNewLineCharacter();
	        var copyLine = false;
	        if (!text && this.$copyWithEmptySelection) {
	            copyLine = true;
	            var ranges = this.selection.getAllRanges();
	            for (var i = 0; i < ranges.length; i++) {
	                var range = ranges[i];
	                if (i && ranges[i - 1].start.row == range.start.row)
	                    continue;
	                text += this.session.getLine(range.start.row) + nl;
	            }
	        }
	        var e = { text: text };
	        this._signal("copy", e);
	        clipboard.lineMode = copyLine ? e.text : false;
	        return e.text;
	    };
	    Editor.prototype.onCopy = function () {
	        this.commands.exec("copy", this);
	    };
	    Editor.prototype.onCut = function () {
	        this.commands.exec("cut", this);
	    };
	    Editor.prototype.onPaste = function (text, event) {
	        var e = { text: text, event: event };
	        this.commands.exec("paste", this, e);
	    };
	    Editor.prototype.$handlePaste = function (e) {
	        if (typeof e == "string")
	            e = { text: e };
	        this._signal("paste", e);
	        var text = e.text;
	        var lineMode = text === clipboard.lineMode;
	        var session = this.session;
	        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
	            if (lineMode)
	                session.insert({ row: this.selection.lead.row, column: 0 }, text);
	            else
	                this.insert(text);
	        }
	        else if (lineMode) {
	            this.selection.rangeList.ranges.forEach(function (range) {
	                session.insert({ row: range.start.row, column: 0 }, text);
	            });
	        }
	        else {
	            var lines = text.split(/\r\n|\r|\n/);
	            var ranges = this.selection.rangeList.ranges;
	            var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
	            if (lines.length != ranges.length || isFullLine)
	                return this.commands.exec("insertstring", this, text);
	            for (var i = ranges.length; i--;) {
	                var range = ranges[i];
	                if (!range.isEmpty())
	                    session.remove(range);
	                session.insert(range.start, lines[i]);
	            }
	        }
	    };
	    Editor.prototype.execCommand = function (command, args) {
	        return this.commands.exec(command, this, args);
	    };
	    Editor.prototype.insert = function (text, pasted) {
	        var session = this.session;
	        var mode = session.getMode();
	        var cursor = this.getCursorPosition();
	        if (this.getBehavioursEnabled() && !pasted) {
	            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
	            if (transform) {
	                if (text !== transform.text) {
	                    if (!this.inVirtualSelectionMode) {
	                        this.session.mergeUndoDeltas = false;
	                        this.mergeNextCommand = false;
	                    }
	                }
	                text = transform.text;
	            }
	        }
	        if (text == "\t")
	            text = this.session.getTabString();
	        if (!this.selection.isEmpty()) {
	            var range = this.getSelectionRange();
	            cursor = this.session.remove(range);
	            this.clearSelection();
	        }
	        else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
	            var range = Range.fromPoints(cursor, cursor);
	            range.end.column += text.length;
	            this.session.remove(range);
	        }
	        if (text == "\n" || text == "\r\n") {
	            var line = session.getLine(cursor.row);
	            if (cursor.column > line.search(/\S|$/)) {
	                var d = line.substr(cursor.column).search(/\S|$/);
	                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
	            }
	        }
	        this.clearSelection();
	        var start = cursor.column;
	        var lineState = session.getState(cursor.row);
	        var line = session.getLine(cursor.row);
	        var shouldOutdent = mode.checkOutdent(lineState, line, text);
	        session.insert(cursor, text);
	        if (transform && transform.selection) {
	            if (transform.selection.length == 2) { // Transform relative to the current column
	                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
	            }
	            else { // Transform relative to the current row.
	                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
	            }
	        }
	        if (this.$enableAutoIndent) {
	            if (session.getDocument().isNewLine(text)) {
	                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
	                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
	            }
	            if (shouldOutdent)
	                mode.autoOutdent(lineState, session, cursor.row);
	        }
	    };
	    Editor.prototype.autoIndent = function () {
	        var session = this.session;
	        var mode = session.getMode();
	        var ranges = this.selection.isEmpty()
	            ? [new Range(0, 0, session.doc.getLength() - 1, 0)]
	            : this.selection.getAllRanges();
	        var prevLineState = "";
	        var prevLine = "";
	        var lineIndent = "";
	        var tab = session.getTabString();
	        for (var i = 0; i < ranges.length; i++) {
	            var startRow = ranges[i].start.row;
	            var endRow = ranges[i].end.row;
	            for (var row = startRow; row <= endRow; row++) {
	                if (row > 0) {
	                    prevLineState = session.getState(row - 1);
	                    prevLine = session.getLine(row - 1);
	                    lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
	                }
	                var line = session.getLine(row);
	                var currIndent = mode.$getIndent(line);
	                if (lineIndent !== currIndent) {
	                    if (currIndent.length > 0) {
	                        var range = new Range(row, 0, row, currIndent.length);
	                        session.remove(range);
	                    }
	                    if (lineIndent.length > 0) {
	                        session.insert({ row: row, column: 0 }, lineIndent);
	                    }
	                }
	                mode.autoOutdent(prevLineState, session, row);
	            }
	        }
	    };
	    Editor.prototype.onTextInput = function (text, composition) {
	        if (!composition)
	            return this.keyBinding.onTextInput(text);
	        this.startOperation({ command: { name: "insertstring" } });
	        var applyComposition = this.applyComposition.bind(this, text, composition);
	        if (this.selection.rangeCount)
	            this.forEachSelection(applyComposition);
	        else
	            applyComposition();
	        this.endOperation();
	    };
	    Editor.prototype.applyComposition = function (text, composition) {
	        if (composition.extendLeft || composition.extendRight) {
	            var r = this.selection.getRange();
	            r.start.column -= composition.extendLeft;
	            r.end.column += composition.extendRight;
	            if (r.start.column < 0) {
	                r.start.row--;
	                r.start.column += this.session.getLine(r.start.row).length + 1;
	            }
	            this.selection.setRange(r);
	            if (!text && !r.isEmpty())
	                this.remove();
	        }
	        if (text || !this.selection.isEmpty())
	            this.insert(text, true);
	        if (composition.restoreStart || composition.restoreEnd) {
	            var r = this.selection.getRange();
	            r.start.column -= composition.restoreStart;
	            r.end.column -= composition.restoreEnd;
	            this.selection.setRange(r);
	        }
	    };
	    Editor.prototype.onCommandKey = function (e, hashId, keyCode) {
	        return this.keyBinding.onCommandKey(e, hashId, keyCode);
	    };
	    Editor.prototype.setOverwrite = function (overwrite) {
	        this.session.setOverwrite(overwrite);
	    };
	    Editor.prototype.getOverwrite = function () {
	        return this.session.getOverwrite();
	    };
	    Editor.prototype.toggleOverwrite = function () {
	        this.session.toggleOverwrite();
	    };
	    Editor.prototype.setScrollSpeed = function (speed) {
	        this.setOption("scrollSpeed", speed);
	    };
	    Editor.prototype.getScrollSpeed = function () {
	        return this.getOption("scrollSpeed");
	    };
	    Editor.prototype.setDragDelay = function (dragDelay) {
	        this.setOption("dragDelay", dragDelay);
	    };
	    Editor.prototype.getDragDelay = function () {
	        return this.getOption("dragDelay");
	    };
	    Editor.prototype.setSelectionStyle = function (val) {
	        this.setOption("selectionStyle", val);
	    };
	    Editor.prototype.getSelectionStyle = function () {
	        return this.getOption("selectionStyle");
	    };
	    Editor.prototype.setHighlightActiveLine = function (shouldHighlight) {
	        this.setOption("highlightActiveLine", shouldHighlight);
	    };
	    Editor.prototype.getHighlightActiveLine = function () {
	        return this.getOption("highlightActiveLine");
	    };
	    Editor.prototype.setHighlightGutterLine = function (shouldHighlight) {
	        this.setOption("highlightGutterLine", shouldHighlight);
	    };
	    Editor.prototype.getHighlightGutterLine = function () {
	        return this.getOption("highlightGutterLine");
	    };
	    Editor.prototype.setHighlightSelectedWord = function (shouldHighlight) {
	        this.setOption("highlightSelectedWord", shouldHighlight);
	    };
	    Editor.prototype.getHighlightSelectedWord = function () {
	        return this.$highlightSelectedWord;
	    };
	    Editor.prototype.setAnimatedScroll = function (shouldAnimate) {
	        this.renderer.setAnimatedScroll(shouldAnimate);
	    };
	    Editor.prototype.getAnimatedScroll = function () {
	        return this.renderer.getAnimatedScroll();
	    };
	    Editor.prototype.setShowInvisibles = function (showInvisibles) {
	        this.renderer.setShowInvisibles(showInvisibles);
	    };
	    Editor.prototype.getShowInvisibles = function () {
	        return this.renderer.getShowInvisibles();
	    };
	    Editor.prototype.setDisplayIndentGuides = function (display) {
	        this.renderer.setDisplayIndentGuides(display);
	    };
	    Editor.prototype.getDisplayIndentGuides = function () {
	        return this.renderer.getDisplayIndentGuides();
	    };
	    Editor.prototype.setHighlightIndentGuides = function (highlight) {
	        this.renderer.setHighlightIndentGuides(highlight);
	    };
	    Editor.prototype.getHighlightIndentGuides = function () {
	        return this.renderer.getHighlightIndentGuides();
	    };
	    Editor.prototype.setShowPrintMargin = function (showPrintMargin) {
	        this.renderer.setShowPrintMargin(showPrintMargin);
	    };
	    Editor.prototype.getShowPrintMargin = function () {
	        return this.renderer.getShowPrintMargin();
	    };
	    Editor.prototype.setPrintMarginColumn = function (showPrintMargin) {
	        this.renderer.setPrintMarginColumn(showPrintMargin);
	    };
	    Editor.prototype.getPrintMarginColumn = function () {
	        return this.renderer.getPrintMarginColumn();
	    };
	    Editor.prototype.setReadOnly = function (readOnly) {
	        this.setOption("readOnly", readOnly);
	    };
	    Editor.prototype.getReadOnly = function () {
	        return this.getOption("readOnly");
	    };
	    Editor.prototype.setBehavioursEnabled = function (enabled) {
	        this.setOption("behavioursEnabled", enabled);
	    };
	    Editor.prototype.getBehavioursEnabled = function () {
	        return this.getOption("behavioursEnabled");
	    };
	    Editor.prototype.setWrapBehavioursEnabled = function (enabled) {
	        this.setOption("wrapBehavioursEnabled", enabled);
	    };
	    Editor.prototype.getWrapBehavioursEnabled = function () {
	        return this.getOption("wrapBehavioursEnabled");
	    };
	    Editor.prototype.setShowFoldWidgets = function (show) {
	        this.setOption("showFoldWidgets", show);
	    };
	    Editor.prototype.getShowFoldWidgets = function () {
	        return this.getOption("showFoldWidgets");
	    };
	    Editor.prototype.setFadeFoldWidgets = function (fade) {
	        this.setOption("fadeFoldWidgets", fade);
	    };
	    Editor.prototype.getFadeFoldWidgets = function () {
	        return this.getOption("fadeFoldWidgets");
	    };
	    Editor.prototype.remove = function (dir) {
	        if (this.selection.isEmpty()) {
	            if (dir == "left")
	                this.selection.selectLeft();
	            else
	                this.selection.selectRight();
	        }
	        var range = this.getSelectionRange();
	        if (this.getBehavioursEnabled()) {
	            var session = this.session;
	            var state = session.getState(range.start.row);
	            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);
	            if (range.end.column === 0) {
	                var text = session.getTextRange(range);
	                if (text[text.length - 1] == "\n") {
	                    var line = session.getLine(range.end.row);
	                    if (/^\s+$/.test(line)) {
	                        range.end.column = line.length;
	                    }
	                }
	            }
	            if (new_range)
	                range = new_range;
	        }
	        this.session.remove(range);
	        this.clearSelection();
	    };
	    Editor.prototype.removeWordRight = function () {
	        if (this.selection.isEmpty())
	            this.selection.selectWordRight();
	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    Editor.prototype.removeWordLeft = function () {
	        if (this.selection.isEmpty())
	            this.selection.selectWordLeft();
	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    Editor.prototype.removeToLineStart = function () {
	        if (this.selection.isEmpty())
	            this.selection.selectLineStart();
	        if (this.selection.isEmpty())
	            this.selection.selectLeft();
	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    Editor.prototype.removeToLineEnd = function () {
	        if (this.selection.isEmpty())
	            this.selection.selectLineEnd();
	        var range = this.getSelectionRange();
	        if (range.start.column == range.end.column && range.start.row == range.end.row) {
	            range.end.column = 0;
	            range.end.row++;
	        }
	        this.session.remove(range);
	        this.clearSelection();
	    };
	    Editor.prototype.splitLine = function () {
	        if (!this.selection.isEmpty()) {
	            this.session.remove(this.getSelectionRange());
	            this.clearSelection();
	        }
	        var cursor = this.getCursorPosition();
	        this.insert("\n");
	        this.moveCursorToPosition(cursor);
	    };
	    Editor.prototype.setGhostText = function (text, position) {
	        this.renderer.setGhostText(text, position);
	    };
	    Editor.prototype.removeGhostText = function () {
	        this.renderer.removeGhostText();
	    };
	    Editor.prototype.transposeLetters = function () {
	        if (!this.selection.isEmpty()) {
	            return;
	        }
	        var cursor = this.getCursorPosition();
	        var column = cursor.column;
	        if (column === 0)
	            return;
	        var line = this.session.getLine(cursor.row);
	        var swap, range;
	        if (column < line.length) {
	            swap = line.charAt(column) + line.charAt(column - 1);
	            range = new Range(cursor.row, column - 1, cursor.row, column + 1);
	        }
	        else {
	            swap = line.charAt(column - 1) + line.charAt(column - 2);
	            range = new Range(cursor.row, column - 2, cursor.row, column);
	        }
	        this.session.replace(range, swap);
	        this.session.selection.moveToPosition(range.end);
	    };
	    Editor.prototype.toLowerCase = function () {
	        var originalRange = this.getSelectionRange();
	        if (this.selection.isEmpty()) {
	            this.selection.selectWord();
	        }
	        var range = this.getSelectionRange();
	        var text = this.session.getTextRange(range);
	        this.session.replace(range, text.toLowerCase());
	        this.selection.setSelectionRange(originalRange);
	    };
	    Editor.prototype.toUpperCase = function () {
	        var originalRange = this.getSelectionRange();
	        if (this.selection.isEmpty()) {
	            this.selection.selectWord();
	        }
	        var range = this.getSelectionRange();
	        var text = this.session.getTextRange(range);
	        this.session.replace(range, text.toUpperCase());
	        this.selection.setSelectionRange(originalRange);
	    };
	    Editor.prototype.indent = function () {
	        var session = this.session;
	        var range = this.getSelectionRange();
	        if (range.start.row < range.end.row) {
	            var rows = this.$getSelectedRows();
	            session.indentRows(rows.first, rows.last, "\t");
	            return;
	        }
	        else if (range.start.column < range.end.column) {
	            var text = session.getTextRange(range);
	            if (!/^\s+$/.test(text)) {
	                var rows = this.$getSelectedRows();
	                session.indentRows(rows.first, rows.last, "\t");
	                return;
	            }
	        }
	        var line = session.getLine(range.start.row);
	        var position = range.start;
	        var size = session.getTabSize();
	        var column = session.documentToScreenColumn(position.row, position.column);
	        if (this.session.getUseSoftTabs()) {
	            var count = (size - column % size);
	            var indentString = lang.stringRepeat(" ", count);
	        }
	        else {
	            var count = column % size;
	            while (line[range.start.column - 1] == " " && count) {
	                range.start.column--;
	                count--;
	            }
	            this.selection.setSelectionRange(range);
	            indentString = "\t";
	        }
	        return this.insert(indentString);
	    };
	    Editor.prototype.blockIndent = function () {
	        var rows = this.$getSelectedRows();
	        this.session.indentRows(rows.first, rows.last, "\t");
	    };
	    Editor.prototype.blockOutdent = function () {
	        var selection = this.session.getSelection();
	        this.session.outdentRows(selection.getRange());
	    };
	    Editor.prototype.sortLines = function () {
	        var rows = this.$getSelectedRows();
	        var session = this.session;
	        var lines = [];
	        for (var i = rows.first; i <= rows.last; i++)
	            lines.push(session.getLine(i));
	        lines.sort(function (a, b) {
	            if (a.toLowerCase() < b.toLowerCase())
	                return -1;
	            if (a.toLowerCase() > b.toLowerCase())
	                return 1;
	            return 0;
	        });
	        var deleteRange = new Range(0, 0, 0, 0);
	        for (var i = rows.first; i <= rows.last; i++) {
	            var line = session.getLine(i);
	            deleteRange.start.row = i;
	            deleteRange.end.row = i;
	            deleteRange.end.column = line.length;
	            session.replace(deleteRange, lines[i - rows.first]);
	        }
	    };
	    Editor.prototype.toggleCommentLines = function () {
	        var state = this.session.getState(this.getCursorPosition().row);
	        var rows = this.$getSelectedRows();
	        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
	    };
	    Editor.prototype.toggleBlockComment = function () {
	        var cursor = this.getCursorPosition();
	        var state = this.session.getState(cursor.row);
	        var range = this.getSelectionRange();
	        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
	    };
	    Editor.prototype.getNumberAt = function (row, column) {
	        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
	        _numberRx.lastIndex = 0;
	        var s = this.session.getLine(row);
	        while (_numberRx.lastIndex < column) {
	            var m = _numberRx.exec(s);
	            if (m.index <= column && m.index + m[0].length >= column) {
	                var number = {
	                    value: m[0],
	                    start: m.index,
	                    end: m.index + m[0].length
	                };
	                return number;
	            }
	        }
	        return null;
	    };
	    Editor.prototype.modifyNumber = function (amount) {
	        var row = this.selection.getCursor().row;
	        var column = this.selection.getCursor().column;
	        var charRange = new Range(row, column - 1, row, column);
	        var c = this.session.getTextRange(charRange);
	        if (!isNaN(parseFloat(c)) && isFinite(c)) {
	            var nr = this.getNumberAt(row, column);
	            if (nr) {
	                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
	                var decimals = nr.start + nr.value.length - fp;
	                var t = parseFloat(nr.value);
	                t *= Math.pow(10, decimals);
	                if (fp !== nr.end && column < fp) {
	                    amount *= Math.pow(10, nr.end - column - 1);
	                }
	                else {
	                    amount *= Math.pow(10, nr.end - column);
	                }
	                t += amount;
	                t /= Math.pow(10, decimals);
	                var nnr = t.toFixed(decimals);
	                var replaceRange = new Range(row, nr.start, row, nr.end);
	                this.session.replace(replaceRange, nnr);
	                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
	            }
	        }
	        else {
	            this.toggleWord();
	        }
	    };
	    Editor.prototype.toggleWord = function () {
	        var row = this.selection.getCursor().row;
	        var column = this.selection.getCursor().column;
	        this.selection.selectWord();
	        var currentState = this.getSelectedText();
	        var currWordStart = this.selection.getWordRange().start.column;
	        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\s/);
	        var delta = column - currWordStart - 1;
	        if (delta < 0)
	            delta = 0;
	        var curLength = 0, itLength = 0;
	        var that = this;
	        if (currentState.match(/[A-Za-z0-9_]+/)) {
	            wordParts.forEach(function (item, i) {
	                itLength = curLength + item.length;
	                if (delta >= curLength && delta <= itLength) {
	                    currentState = item;
	                    that.selection.clearSelection();
	                    that.moveCursorTo(row, curLength + currWordStart);
	                    that.selection.selectTo(row, itLength + currWordStart);
	                }
	                curLength = itLength;
	            });
	        }
	        var wordPairs = this.$toggleWordPairs;
	        var reg;
	        for (var i = 0; i < wordPairs.length; i++) {
	            var item = wordPairs[i];
	            for (var j = 0; j <= 1; j++) {
	                var negate = +!j;
	                var firstCondition = currentState.match(new RegExp('^\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\s?$', 'i'));
	                if (firstCondition) {
	                    var secondCondition = currentState.match(new RegExp('([_]|^|\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\s)', 'g'));
	                    if (secondCondition) {
	                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {
	                            var res = item[negate];
	                            if (result.toUpperCase() == result) {
	                                res = res.toUpperCase();
	                            }
	                            else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
	                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
	                            }
	                            return res;
	                        });
	                        this.insert(reg);
	                        reg = "";
	                    }
	                }
	            }
	        }
	    };
	    Editor.prototype.findLinkAt = function (row, column) {
	        var e_1, _a;
	        var line = this.session.getLine(row);
	        var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
	        var columnPosition = column;
	        if (columnPosition < 0)
	            columnPosition = 0;
	        var previousPosition = 0, currentPosition = 0, match;
	        try {
	            for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {
	                var item = wordParts_1_1.value;
	                currentPosition = previousPosition + item.length;
	                if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
	                    if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
	                        match = item.replace(/[\s:.,'";}\]]+$/, "");
	                        break;
	                    }
	                }
	                previousPosition = currentPosition;
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (wordParts_1_1 && !wordParts_1_1.done && (_a = wordParts_1.return)) _a.call(wordParts_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return match;
	    };
	    Editor.prototype.openLink = function () {
	        var cursor = this.selection.getCursor();
	        var url = this.findLinkAt(cursor.row, cursor.column);
	        if (url)
	            window.open(url, '_blank');
	        return url != null;
	    };
	    Editor.prototype.removeLines = function () {
	        var rows = this.$getSelectedRows();
	        this.session.removeFullLines(rows.first, rows.last);
	        this.clearSelection();
	    };
	    Editor.prototype.duplicateSelection = function () {
	        var sel = this.selection;
	        var doc = this.session;
	        var range = sel.getRange();
	        var reverse = sel.isBackwards();
	        if (range.isEmpty()) {
	            var row = range.start.row;
	            doc.duplicateLines(row, row);
	        }
	        else {
	            var point = reverse ? range.start : range.end;
	            var endPoint = doc.insert(point, doc.getTextRange(range));
	            range.start = point;
	            range.end = endPoint;
	            sel.setSelectionRange(range, reverse);
	        }
	    };
	    Editor.prototype.moveLinesDown = function () {
	        this.$moveLines(1, false);
	    };
	    Editor.prototype.moveLinesUp = function () {
	        this.$moveLines(-1, false);
	    };
	    Editor.prototype.moveText = function (range, toPosition, copy) {
	        return this.session.moveText(range, toPosition, copy);
	    };
	    Editor.prototype.copyLinesUp = function () {
	        this.$moveLines(-1, true);
	    };
	    Editor.prototype.copyLinesDown = function () {
	        this.$moveLines(1, true);
	    };
	    Editor.prototype.$moveLines = function (dir, copy) {
	        var rows, moved;
	        var selection = this.selection;
	        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
	            var range = selection.toOrientedRange();
	            rows = this.$getSelectedRows(range);
	            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
	            if (copy && dir == -1)
	                moved = 0;
	            range.moveBy(moved, 0);
	            selection.fromOrientedRange(range);
	        }
	        else {
	            var ranges = selection.rangeList.ranges;
	            selection.rangeList.detach(this.session);
	            this.inVirtualSelectionMode = true;
	            var diff = 0;
	            var totalDiff = 0;
	            var l = ranges.length;
	            for (var i = 0; i < l; i++) {
	                var rangeIndex = i;
	                ranges[i].moveBy(diff, 0);
	                rows = this.$getSelectedRows(ranges[i]);
	                var first = rows.first;
	                var last = rows.last;
	                while (++i < l) {
	                    if (totalDiff)
	                        ranges[i].moveBy(totalDiff, 0);
	                    var subRows = this.$getSelectedRows(ranges[i]);
	                    if (copy && subRows.first != last)
	                        break;
	                    else if (!copy && subRows.first > last + 1)
	                        break;
	                    last = subRows.last;
	                }
	                i--;
	                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
	                if (copy && dir == -1)
	                    rangeIndex = i + 1;
	                while (rangeIndex <= i) {
	                    ranges[rangeIndex].moveBy(diff, 0);
	                    rangeIndex++;
	                }
	                if (!copy)
	                    diff = 0;
	                totalDiff += diff;
	            }
	            selection.fromOrientedRange(selection.ranges[0]);
	            selection.rangeList.attach(this.session);
	            this.inVirtualSelectionMode = false;
	        }
	    };
	    Editor.prototype.$getSelectedRows = function (range) {
	        range = (range || this.getSelectionRange()).collapseRows();
	        return {
	            first: this.session.getRowFoldStart(range.start.row),
	            last: this.session.getRowFoldEnd(range.end.row)
	        };
	    };
	    Editor.prototype.onCompositionStart = function (compositionState) {
	        this.renderer.showComposition(compositionState);
	    };
	    Editor.prototype.onCompositionUpdate = function (text) {
	        this.renderer.setCompositionText(text);
	    };
	    Editor.prototype.onCompositionEnd = function () {
	        this.renderer.hideComposition();
	    };
	    Editor.prototype.getFirstVisibleRow = function () {
	        return this.renderer.getFirstVisibleRow();
	    };
	    Editor.prototype.getLastVisibleRow = function () {
	        return this.renderer.getLastVisibleRow();
	    };
	    Editor.prototype.isRowVisible = function (row) {
	        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
	    };
	    Editor.prototype.isRowFullyVisible = function (row) {
	        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
	    };
	    Editor.prototype.$getVisibleRowCount = function () {
	        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
	    };
	    Editor.prototype.$moveByPage = function (dir, select) {
	        var renderer = this.renderer;
	        var config = this.renderer.layerConfig;
	        var rows = dir * Math.floor(config.height / config.lineHeight);
	        if (select === true) {
	            this.selection.$moveSelection(function () {
	                this.moveCursorBy(rows, 0);
	            });
	        }
	        else if (select === false) {
	            this.selection.moveCursorBy(rows, 0);
	            this.selection.clearSelection();
	        }
	        var scrollTop = renderer.scrollTop;
	        renderer.scrollBy(0, rows * config.lineHeight);
	        if (select != null)
	            renderer.scrollCursorIntoView(null, 0.5);
	        renderer.animateScrolling(scrollTop);
	    };
	    Editor.prototype.selectPageDown = function () {
	        this.$moveByPage(1, true);
	    };
	    Editor.prototype.selectPageUp = function () {
	        this.$moveByPage(-1, true);
	    };
	    Editor.prototype.gotoPageDown = function () {
	        this.$moveByPage(1, false);
	    };
	    Editor.prototype.gotoPageUp = function () {
	        this.$moveByPage(-1, false);
	    };
	    Editor.prototype.scrollPageDown = function () {
	        this.$moveByPage(1);
	    };
	    Editor.prototype.scrollPageUp = function () {
	        this.$moveByPage(-1);
	    };
	    Editor.prototype.scrollToRow = function (row) {
	        this.renderer.scrollToRow(row);
	    };
	    Editor.prototype.scrollToLine = function (line, center, animate, callback) {
	        this.renderer.scrollToLine(line, center, animate, callback);
	    };
	    Editor.prototype.centerSelection = function () {
	        var range = this.getSelectionRange();
	        var pos = {
	            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
	            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
	        };
	        this.renderer.alignCursor(pos, 0.5);
	    };
	    Editor.prototype.getCursorPosition = function () {
	        return this.selection.getCursor();
	    };
	    Editor.prototype.getCursorPositionScreen = function () {
	        return this.session.documentToScreenPosition(this.getCursorPosition());
	    };
	    Editor.prototype.getSelectionRange = function () {
	        return this.selection.getRange();
	    };
	    Editor.prototype.selectAll = function () {
	        this.selection.selectAll();
	    };
	    Editor.prototype.clearSelection = function () {
	        this.selection.clearSelection();
	    };
	    Editor.prototype.moveCursorTo = function (row, column) {
	        this.selection.moveCursorTo(row, column);
	    };
	    Editor.prototype.moveCursorToPosition = function (pos) {
	        this.selection.moveCursorToPosition(pos);
	    };
	    Editor.prototype.jumpToMatching = function (select, expand) {
	        var cursor = this.getCursorPosition();
	        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
	        var prevToken = iterator.getCurrentToken();
	        var tokenCount = 0;
	        if (prevToken && prevToken.type.indexOf('tag-name') !== -1) {
	            prevToken = iterator.stepBackward();
	        }
	        var token = prevToken || iterator.stepForward();
	        if (!token)
	            return;
	        var matchType;
	        var found = false;
	        var depth = {};
	        var i = cursor.column - token.start;
	        var bracketType;
	        var brackets = {
	            ")": "(",
	            "(": "(",
	            "]": "[",
	            "[": "[",
	            "{": "{",
	            "}": "{"
	        };
	        do {
	            if (token.value.match(/[{}()\[\]]/g)) {
	                for (; i < token.value.length && !found; i++) {
	                    if (!brackets[token.value[i]]) {
	                        continue;
	                    }
	                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");
	                    if (isNaN(depth[bracketType])) {
	                        depth[bracketType] = 0;
	                    }
	                    switch (token.value[i]) {
	                        case '(':
	                        case '[':
	                        case '{':
	                            depth[bracketType]++;
	                            break;
	                        case ')':
	                        case ']':
	                        case '}':
	                            depth[bracketType]--;
	                            if (depth[bracketType] === -1) {
	                                matchType = 'bracket';
	                                found = true;
	                            }
	                            break;
	                    }
	                }
	            }
	            else if (token.type.indexOf('tag-name') !== -1) {
	                if (isNaN(depth[token.value])) {
	                    depth[token.value] = 0;
	                }
	                if (prevToken.value === '<' && tokenCount > 1) {
	                    depth[token.value]++;
	                }
	                else if (prevToken.value === '</') {
	                    depth[token.value]--;
	                }
	                if (depth[token.value] === -1) {
	                    matchType = 'tag';
	                    found = true;
	                }
	            }
	            if (!found) {
	                prevToken = token;
	                tokenCount++;
	                token = iterator.stepForward();
	                i = 0;
	            }
	        } while (token && !found);
	        if (!matchType)
	            return;
	        var range, pos;
	        if (matchType === 'bracket') {
	            range = this.session.getBracketRange(cursor);
	            if (!range) {
	                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
	                pos = range.start;
	                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column)
	                    < 2)
	                    range = this.session.getBracketRange(pos);
	            }
	        }
	        else if (matchType === 'tag') {
	            if (!token || token.type.indexOf('tag-name') === -1)
	                return;
	            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
	            if (range.compare(cursor.row, cursor.column) === 0) {
	                var tagsRanges = this.session.getMatchingTags(cursor);
	                if (tagsRanges) {
	                    if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
	                        range = tagsRanges.closeTag;
	                        pos = range.start;
	                    }
	                    else {
	                        range = tagsRanges.openTag;
	                        if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column
	                            === cursor.column)
	                            pos = range.end;
	                        else
	                            pos = range.start;
	                    }
	                }
	            }
	            pos = pos || range.start;
	        }
	        pos = range && range.cursor || pos;
	        if (pos) {
	            if (select) {
	                if (range && expand) {
	                    this.selection.setRange(range);
	                }
	                else if (range && range.isEqual(this.getSelectionRange())) {
	                    this.clearSelection();
	                }
	                else {
	                    this.selection.selectTo(pos.row, pos.column);
	                }
	            }
	            else {
	                this.selection.moveTo(pos.row, pos.column);
	            }
	        }
	    };
	    Editor.prototype.gotoLine = function (lineNumber, column, animate) {
	        this.selection.clearSelection();
	        this.session.unfold({ row: lineNumber - 1, column: column || 0 });
	        this.exitMultiSelectMode && this.exitMultiSelectMode();
	        this.moveCursorTo(lineNumber - 1, column || 0);
	        if (!this.isRowFullyVisible(lineNumber - 1))
	            this.scrollToLine(lineNumber - 1, true, animate);
	    };
	    Editor.prototype.navigateTo = function (row, column) {
	        this.selection.moveTo(row, column);
	    };
	    Editor.prototype.navigateUp = function (times) {
	        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
	            var selectionStart = this.selection.anchor.getPosition();
	            return this.moveCursorToPosition(selectionStart);
	        }
	        this.selection.clearSelection();
	        this.selection.moveCursorBy(-times || -1, 0);
	    };
	    Editor.prototype.navigateDown = function (times) {
	        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
	            var selectionEnd = this.selection.anchor.getPosition();
	            return this.moveCursorToPosition(selectionEnd);
	        }
	        this.selection.clearSelection();
	        this.selection.moveCursorBy(times || 1, 0);
	    };
	    Editor.prototype.navigateLeft = function (times) {
	        if (!this.selection.isEmpty()) {
	            var selectionStart = this.getSelectionRange().start;
	            this.moveCursorToPosition(selectionStart);
	        }
	        else {
	            times = times || 1;
	            while (times--) {
	                this.selection.moveCursorLeft();
	            }
	        }
	        this.clearSelection();
	    };
	    Editor.prototype.navigateRight = function (times) {
	        if (!this.selection.isEmpty()) {
	            var selectionEnd = this.getSelectionRange().end;
	            this.moveCursorToPosition(selectionEnd);
	        }
	        else {
	            times = times || 1;
	            while (times--) {
	                this.selection.moveCursorRight();
	            }
	        }
	        this.clearSelection();
	    };
	    Editor.prototype.navigateLineStart = function () {
	        this.selection.moveCursorLineStart();
	        this.clearSelection();
	    };
	    Editor.prototype.navigateLineEnd = function () {
	        this.selection.moveCursorLineEnd();
	        this.clearSelection();
	    };
	    Editor.prototype.navigateFileEnd = function () {
	        this.selection.moveCursorFileEnd();
	        this.clearSelection();
	    };
	    Editor.prototype.navigateFileStart = function () {
	        this.selection.moveCursorFileStart();
	        this.clearSelection();
	    };
	    Editor.prototype.navigateWordRight = function () {
	        this.selection.moveCursorWordRight();
	        this.clearSelection();
	    };
	    Editor.prototype.navigateWordLeft = function () {
	        this.selection.moveCursorWordLeft();
	        this.clearSelection();
	    };
	    Editor.prototype.replace = function (replacement, options) {
	        if (options)
	            this.$search.set(options);
	        var range = this.$search.find(this.session);
	        var replaced = 0;
	        if (!range)
	            return replaced;
	        if (this.$tryReplace(range, replacement)) {
	            replaced = 1;
	        }
	        this.selection.setSelectionRange(range);
	        this.renderer.scrollSelectionIntoView(range.start, range.end);
	        return replaced;
	    };
	    Editor.prototype.replaceAll = function (replacement, options) {
	        if (options) {
	            this.$search.set(options);
	        }
	        var ranges = this.$search.findAll(this.session);
	        var replaced = 0;
	        if (!ranges.length)
	            return replaced;
	        var selection = this.getSelectionRange();
	        this.selection.moveTo(0, 0);
	        for (var i = ranges.length - 1; i >= 0; --i) {
	            if (this.$tryReplace(ranges[i], replacement)) {
	                replaced++;
	            }
	        }
	        this.selection.setSelectionRange(selection);
	        return replaced;
	    };
	    Editor.prototype.$tryReplace = function (range, replacement) {
	        var input = this.session.getTextRange(range);
	        replacement = this.$search.replace(input, replacement);
	        if (replacement !== null) {
	            range.end = this.session.replace(range, replacement);
	            return range;
	        }
	        else {
	            return null;
	        }
	    };
	    Editor.prototype.getLastSearchOptions = function () {
	        return this.$search.getOptions();
	    };
	    Editor.prototype.find = function (needle, options, animate) {
	        if (!options)
	            options = {};
	        if (typeof needle == "string" || needle instanceof RegExp)
	            options.needle = needle;
	        else if (typeof needle == "object")
	            oop.mixin(options, needle);
	        var range = this.selection.getRange();
	        if (options.needle == null) {
	            needle = this.session.getTextRange(range)
	                || this.$search.$options.needle;
	            if (!needle) {
	                range = this.session.getWordRange(range.start.row, range.start.column);
	                needle = this.session.getTextRange(range);
	            }
	            this.$search.set({ needle: needle });
	        }
	        this.$search.set(options);
	        if (!options.start)
	            this.$search.set({ start: range });
	        var newRange = this.$search.find(this.session);
	        if (options.preventScroll)
	            return newRange;
	        if (newRange) {
	            this.revealRange(newRange, animate);
	            return newRange;
	        }
	        if (options.backwards)
	            range.start = range.end;
	        else
	            range.end = range.start;
	        this.selection.setRange(range);
	    };
	    Editor.prototype.findNext = function (options, animate) {
	        this.find({ skipCurrent: true, backwards: false }, options, animate);
	    };
	    Editor.prototype.findPrevious = function (options, animate) {
	        this.find(options, { skipCurrent: true, backwards: true }, animate);
	    };
	    Editor.prototype.revealRange = function (range, animate) {
	        this.session.unfold(range);
	        this.selection.setSelectionRange(range);
	        var scrollTop = this.renderer.scrollTop;
	        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
	        if (animate !== false)
	            this.renderer.animateScrolling(scrollTop);
	    };
	    Editor.prototype.undo = function () {
	        this.session.getUndoManager().undo(this.session);
	        this.renderer.scrollCursorIntoView(null, 0.5);
	    };
	    Editor.prototype.redo = function () {
	        this.session.getUndoManager().redo(this.session);
	        this.renderer.scrollCursorIntoView(null, 0.5);
	    };
	    Editor.prototype.destroy = function () {
	        this.destroyed = true;
	        if (this.$toDestroy) {
	            this.$toDestroy.forEach(function (el) {
	                el.destroy();
	            });
	            this.$toDestroy = [];
	        }
	        if (this.$mouseHandler)
	            this.$mouseHandler.destroy();
	        this.renderer.destroy();
	        this._signal("destroy", this);
	        if (this.session)
	            this.session.destroy();
	        if (this._$emitInputEvent)
	            this._$emitInputEvent.cancel();
	        this.removeAllListeners();
	    };
	    Editor.prototype.setAutoScrollEditorIntoView = function (enable) {
	        if (!enable)
	            return;
	        var rect;
	        var self = this;
	        var shouldScroll = false;
	        if (!this.$scrollAnchor)
	            this.$scrollAnchor = document.createElement("div");
	        var scrollAnchor = this.$scrollAnchor;
	        scrollAnchor.style.cssText = "position:absolute";
	        this.container.insertBefore(scrollAnchor, this.container.firstChild);
	        var onChangeSelection = this.on("changeSelection", function () {
	            shouldScroll = true;
	        });
	        var onBeforeRender = this.renderer.on("beforeRender", function () {
	            if (shouldScroll)
	                rect = self.renderer.container.getBoundingClientRect();
	        });
	        var onAfterRender = this.renderer.on("afterRender", function () {
	            if (shouldScroll && rect && (self.isFocused()
	                || self.searchBox && self.searchBox.isFocused())) {
	                var renderer = self.renderer;
	                var pos = renderer.$cursorLayer.$pixelPos;
	                var config = renderer.layerConfig;
	                var top = pos.top - config.offset;
	                if (pos.top >= 0 && top + rect.top < 0) {
	                    shouldScroll = true;
	                }
	                else if (pos.top < config.height &&
	                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
	                    shouldScroll = false;
	                }
	                else {
	                    shouldScroll = null;
	                }
	                if (shouldScroll != null) {
	                    scrollAnchor.style.top = top + "px";
	                    scrollAnchor.style.left = pos.left + "px";
	                    scrollAnchor.style.height = config.lineHeight + "px";
	                    scrollAnchor.scrollIntoView(shouldScroll);
	                }
	                shouldScroll = rect = null;
	            }
	        });
	        this.setAutoScrollEditorIntoView = function (enable) {
	            if (enable)
	                return;
	            delete this.setAutoScrollEditorIntoView;
	            this.off("changeSelection", onChangeSelection);
	            this.renderer.off("afterRender", onAfterRender);
	            this.renderer.off("beforeRender", onBeforeRender);
	        };
	    };
	    Editor.prototype.$resetCursorStyle = function () {
	        var style = this.$cursorStyle || "ace";
	        var cursorLayer = this.renderer.$cursorLayer;
	        if (!cursorLayer)
	            return;
	        cursorLayer.setSmoothBlinking(/smooth/.test(style));
	        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
	        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
	    };
	    Editor.prototype.prompt = function (message, options, callback) {
	        var editor = this;
	        config.loadModule("ace/ext/prompt", function (module) {
	            module.prompt(editor, message, options, callback);
	        });
	    };
	    return Editor;
	}());
	Editor.$uid = 0;
	Editor.prototype.curOp = null;
	Editor.prototype.prevOp = {};
	Editor.prototype.$mergeableCommands = ["backspace", "del", "insertstring"];
	Editor.prototype.$toggleWordPairs = [
	    ["first", "last"],
	    ["true", "false"],
	    ["yes", "no"],
	    ["width", "height"],
	    ["top", "bottom"],
	    ["right", "left"],
	    ["on", "off"],
	    ["x", "y"],
	    ["get", "set"],
	    ["max", "min"],
	    ["horizontal", "vertical"],
	    ["show", "hide"],
	    ["add", "remove"],
	    ["up", "down"],
	    ["before", "after"],
	    ["even", "odd"],
	    ["in", "out"],
	    ["inside", "outside"],
	    ["next", "previous"],
	    ["increase", "decrease"],
	    ["attach", "detach"],
	    ["&&", "||"],
	    ["==", "!="]
	];
	oop.implement(Editor.prototype, EventEmitter);
	config.defineOptions(Editor.prototype, "editor", {
	    selectionStyle: {
	        set: function (style) {
	            this.onSelectionChange();
	            this._signal("changeSelectionStyle", { data: style });
	        },
	        initialValue: "line"
	    },
	    highlightActiveLine: {
	        set: function () { this.$updateHighlightActiveLine(); },
	        initialValue: true
	    },
	    highlightSelectedWord: {
	        set: function (shouldHighlight) { this.$onSelectionChange(); },
	        initialValue: true
	    },
	    readOnly: {
	        set: function (/**@type{boolean}*/ readOnly) {
	            var _this = this;
	            this.textInput.setReadOnly(readOnly);
	            if (this.destroyed)
	                return;
	            this.$resetCursorStyle();
	            if (!this.$readOnlyCallback) {
	                this.$readOnlyCallback = function (e) {
	                    var shouldShow = false;
	                    if (e && e.type == "keydown") {
	                        if (e && e.key && !e.ctrlKey && !e.metaKey) {
	                            if (e.key == " ")
	                                e.preventDefault();
	                            shouldShow = e.key.length == 1;
	                        }
	                        if (!shouldShow)
	                            return;
	                    }
	                    else if (e && e.type !== "exec") {
	                        shouldShow = true;
	                    }
	                    if (shouldShow) {
	                        if (!_this.hoverTooltip) {
	                            _this.hoverTooltip = new HoverTooltip();
	                        }
	                        var domNode = dom.createElement("div");
	                        domNode.textContent = nls("editor.tooltip.disable-editing", "Editing is disabled");
	                        if (!_this.hoverTooltip.isOpen) {
	                            _this.hoverTooltip.showForRange(_this, _this.getSelectionRange(), domNode);
	                        }
	                    }
	                    else if (_this.hoverTooltip && _this.hoverTooltip.isOpen) {
	                        _this.hoverTooltip.hide();
	                    }
	                };
	            }
	            var textArea = this.textInput.getElement();
	            if (readOnly) {
	                event.addListener(textArea, "keydown", this.$readOnlyCallback, this);
	                this.commands.on("exec", this.$readOnlyCallback);
	                this.commands.on("commandUnavailable", this.$readOnlyCallback);
	            }
	            else {
	                event.removeListener(textArea, "keydown", this.$readOnlyCallback);
	                this.commands.off("exec", this.$readOnlyCallback);
	                this.commands.off("commandUnavailable", this.$readOnlyCallback);
	                if (this.hoverTooltip) {
	                    this.hoverTooltip.destroy();
	                    this.hoverTooltip = null;
	                }
	            }
	        },
	        initialValue: false
	    },
	    copyWithEmptySelection: {
	        set: function (value) {
	            this.textInput.setCopyWithEmptySelection(value);
	        },
	        initialValue: false
	    },
	    cursorStyle: {
	        set: function (val) { this.$resetCursorStyle(); },
	        values: ["ace", "slim", "smooth", "wide"],
	        initialValue: "ace"
	    },
	    mergeUndoDeltas: {
	        values: [false, true, "always"],
	        initialValue: true
	    },
	    behavioursEnabled: { initialValue: true },
	    wrapBehavioursEnabled: { initialValue: true },
	    enableAutoIndent: { initialValue: true },
	    autoScrollEditorIntoView: {
	        set: function (val) { this.setAutoScrollEditorIntoView(val); }
	    },
	    keyboardHandler: {
	        set: function (val) { this.setKeyboardHandler(val); },
	        get: function () { return this.$keybindingId; },
	        handlesSet: true
	    },
	    value: {
	        set: function (val) { this.session.setValue(val); },
	        get: function () { return this.getValue(); },
	        handlesSet: true,
	        hidden: true
	    },
	    session: {
	        set: function (val) { this.setSession(val); },
	        get: function () { return this.session; },
	        handlesSet: true,
	        hidden: true
	    },
	    showLineNumbers: {
	        set: function (show) {
	            this.renderer.$gutterLayer.setShowLineNumbers(show);
	            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
	            if (show && this.$relativeLineNumbers)
	                relativeNumberRenderer.attach(this);
	            else
	                relativeNumberRenderer.detach(this);
	        },
	        initialValue: true
	    },
	    relativeLineNumbers: {
	        set: function (value) {
	            if (this.$showLineNumbers && value)
	                relativeNumberRenderer.attach(this);
	            else
	                relativeNumberRenderer.detach(this);
	        }
	    },
	    placeholder: {
	        set: function (message) {
	            if (!this.$updatePlaceholder) {
	                this.$updatePlaceholder = function () {
	                    var hasValue = this.session && (this.renderer.$composition ||
	                        this.session.getLength() > 1 || this.session.getLine(0).length > 0);
	                    if (hasValue && this.renderer.placeholderNode) {
	                        this.renderer.off("afterRender", this.$updatePlaceholder);
	                        dom.removeCssClass(this.container, "ace_hasPlaceholder");
	                        this.renderer.placeholderNode.remove();
	                        this.renderer.placeholderNode = null;
	                    }
	                    else if (!hasValue && !this.renderer.placeholderNode) {
	                        this.renderer.on("afterRender", this.$updatePlaceholder);
	                        dom.addCssClass(this.container, "ace_hasPlaceholder");
	                        var el = dom.createElement("div");
	                        el.className = "ace_placeholder";
	                        el.textContent = this.$placeholder || "";
	                        this.renderer.placeholderNode = el;
	                        this.renderer.content.appendChild(this.renderer.placeholderNode);
	                    }
	                    else if (!hasValue && this.renderer.placeholderNode) {
	                        this.renderer.placeholderNode.textContent = this.$placeholder || "";
	                    }
	                }.bind(this);
	                this.on("input", this.$updatePlaceholder);
	            }
	            this.$updatePlaceholder();
	        }
	    },
	    enableKeyboardAccessibility: {
	        set: function (value) {
	            var blurCommand = {
	                name: "blurTextInput",
	                description: "Set focus to the editor content div to allow tabbing through the page",
	                bindKey: "Esc",
	                exec: function (editor) {
	                    editor.blur();
	                    editor.renderer.scroller.focus();
	                },
	                readOnly: true
	            };
	            var focusOnEnterKeyup = function (e) {
	                if (e.target == this.renderer.scroller && e.keyCode === keys['enter']) {
	                    e.preventDefault();
	                    var row = this.getCursorPosition().row;
	                    if (!this.isRowVisible(row))
	                        this.scrollToLine(row, true, true);
	                    this.focus();
	                }
	            };
	            var gutterKeyboardHandler;
	            if (value) {
	                this.renderer.enableKeyboardAccessibility = true;
	                this.renderer.keyboardFocusClassName = "ace_keyboard-focus";
	                this.textInput.getElement().setAttribute("tabindex", -1);
	                this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);
	                this.renderer.scroller.setAttribute("tabindex", 0);
	                this.renderer.scroller.setAttribute("role", "group");
	                this.renderer.scroller.setAttribute("aria-roledescription", nls("editor.scroller.aria-roledescription", "editor"));
	                this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);
	                this.renderer.scroller.setAttribute("aria-label", nls("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit"));
	                this.renderer.scroller.addEventListener("keyup", focusOnEnterKeyup.bind(this));
	                this.commands.addCommand(blurCommand);
	                this.renderer.$gutter.setAttribute("tabindex", 0);
	                this.renderer.$gutter.setAttribute("aria-hidden", false);
	                this.renderer.$gutter.setAttribute("role", "group");
	                this.renderer.$gutter.setAttribute("aria-roledescription", nls("editor.gutter.aria-roledescription", "editor gutter"));
	                this.renderer.$gutter.setAttribute("aria-label", nls("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit"));
	                this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);
	                this.renderer.content.setAttribute("aria-hidden", true);
	                if (!gutterKeyboardHandler)
	                    gutterKeyboardHandler = new GutterKeyboardHandler(this);
	                gutterKeyboardHandler.addListener();
	                this.textInput.setAriaOptions({
	                    setLabel: true
	                });
	            }
	            else {
	                this.renderer.enableKeyboardAccessibility = false;
	                this.textInput.getElement().setAttribute("tabindex", 0);
	                this.textInput.setNumberOfExtraLines(0);
	                this.renderer.scroller.setAttribute("tabindex", -1);
	                this.renderer.scroller.removeAttribute("role");
	                this.renderer.scroller.removeAttribute("aria-roledescription");
	                this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);
	                this.renderer.scroller.removeAttribute("aria-label");
	                this.renderer.scroller.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
	                this.commands.removeCommand(blurCommand);
	                this.renderer.content.removeAttribute("aria-hidden");
	                this.renderer.$gutter.setAttribute("tabindex", -1);
	                this.renderer.$gutter.setAttribute("aria-hidden", true);
	                this.renderer.$gutter.removeAttribute("role");
	                this.renderer.$gutter.removeAttribute("aria-roledescription");
	                this.renderer.$gutter.removeAttribute("aria-label");
	                this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);
	                if (gutterKeyboardHandler)
	                    gutterKeyboardHandler.removeListener();
	            }
	        },
	        initialValue: false
	    },
	    textInputAriaLabel: {
	        set: function (val) { this.$textInputAriaLabel = val; },
	        initialValue: ""
	    },
	    enableMobileMenu: {
	        set: function (val) { this.$enableMobileMenu = val; },
	        initialValue: true
	    },
	    customScrollbar: "renderer",
	    hScrollBarAlwaysVisible: "renderer",
	    vScrollBarAlwaysVisible: "renderer",
	    highlightGutterLine: "renderer",
	    animatedScroll: "renderer",
	    showInvisibles: "renderer",
	    showPrintMargin: "renderer",
	    printMarginColumn: "renderer",
	    printMargin: "renderer",
	    fadeFoldWidgets: "renderer",
	    showFoldWidgets: "renderer",
	    displayIndentGuides: "renderer",
	    highlightIndentGuides: "renderer",
	    showGutter: "renderer",
	    fontSize: "renderer",
	    fontFamily: "renderer",
	    maxLines: "renderer",
	    minLines: "renderer",
	    scrollPastEnd: "renderer",
	    fixedWidthGutter: "renderer",
	    theme: "renderer",
	    hasCssTransforms: "renderer",
	    maxPixelHeight: "renderer",
	    useTextareaForIME: "renderer",
	    useResizeObserver: "renderer",
	    useSvgGutterIcons: "renderer",
	    showFoldedAnnotations: "renderer",
	    scrollSpeed: "$mouseHandler",
	    dragDelay: "$mouseHandler",
	    dragEnabled: "$mouseHandler",
	    focusTimeout: "$mouseHandler",
	    tooltipFollowsMouse: "$mouseHandler",
	    firstLineNumber: "session",
	    overwrite: "session",
	    newLineMode: "session",
	    useWorker: "session",
	    useSoftTabs: "session",
	    navigateWithinSoftTabs: "session",
	    tabSize: "session",
	    wrap: "session",
	    indentedSoftWrap: "session",
	    foldStyle: "session",
	    mode: "session"
	});
	var relativeNumberRenderer = {
	    getText: function (/**@type{EditSession}*/ session, /**@type{number}*/ row) {
	        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? "\xb7" : ""))) + "";
	    },
	    getWidth: function (session, /**@type{number}*/ lastLineNumber, config) {
	        return Math.max(lastLineNumber.toString().length, (config.lastRow + 1).toString().length, 2) * config.characterWidth;
	    },
	    update: function (e, /**@type{Editor}*/ editor) {
	        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
	    },
	    attach: function (/**@type{Editor}*/ editor) {
	        editor.renderer.$gutterLayer.$renderer = this;
	        editor.on("changeSelection", this.update);
	        this.update(null, editor);
	    },
	    detach: function (/**@type{Editor}*/ editor) {
	        if (editor.renderer.$gutterLayer.$renderer == this)
	            editor.renderer.$gutterLayer.$renderer = null;
	        editor.off("changeSelection", this.update);
	        this.update(null, editor);
	    }
	};
	exports.Editor = Editor;

	});

	ace.define("ace/layer/lines",["require","exports","module","ace/lib/dom"], function(require, exports, module){	var dom = require("../lib/dom");
	var Lines = /** @class */ (function () {
	    function Lines(element, canvasHeight) {
	        this.element = element;
	        this.canvasHeight = canvasHeight || 500000;
	        this.element.style.height = (this.canvasHeight * 2) + "px";
	        this.cells = [];
	        this.cellCache = [];
	        this.$offsetCoefficient = 0;
	    }
	    Lines.prototype.moveContainer = function (config) {
	        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);
	    };
	    Lines.prototype.pageChanged = function (oldConfig, newConfig) {
	        return (Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==
	            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight));
	    };
	    Lines.prototype.computeLineTop = function (row, config, session) {
	        var screenTop = config.firstRowScreen * config.lineHeight;
	        var screenPage = Math.floor(screenTop / this.canvasHeight);
	        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
	        return lineTop - (screenPage * this.canvasHeight);
	    };
	    Lines.prototype.computeLineHeight = function (row, config, session) {
	        return config.lineHeight * session.getRowLineCount(row);
	    };
	    Lines.prototype.getLength = function () {
	        return this.cells.length;
	    };
	    Lines.prototype.get = function (index) {
	        return this.cells[index];
	    };
	    Lines.prototype.shift = function () {
	        this.$cacheCell(this.cells.shift());
	    };
	    Lines.prototype.pop = function () {
	        this.$cacheCell(this.cells.pop());
	    };
	    Lines.prototype.push = function (cell) {
	        if (Array.isArray(cell)) {
	            this.cells.push.apply(this.cells, cell);
	            var fragment = dom.createFragment(this.element);
	            for (var i = 0; i < cell.length; i++) {
	                fragment.appendChild(cell[i].element);
	            }
	            this.element.appendChild(fragment);
	        }
	        else {
	            this.cells.push(cell);
	            this.element.appendChild(cell.element);
	        }
	    };
	    Lines.prototype.unshift = function (cell) {
	        if (Array.isArray(cell)) {
	            this.cells.unshift.apply(this.cells, cell);
	            var fragment = dom.createFragment(this.element);
	            for (var i = 0; i < cell.length; i++) {
	                fragment.appendChild(cell[i].element);
	            }
	            if (this.element.firstChild)
	                this.element.insertBefore(fragment, this.element.firstChild);
	            else
	                this.element.appendChild(fragment);
	        }
	        else {
	            this.cells.unshift(cell);
	            this.element.insertAdjacentElement("afterbegin", cell.element);
	        }
	    };
	    Lines.prototype.last = function () {
	        if (this.cells.length)
	            return this.cells[this.cells.length - 1];
	        else
	            return null;
	    };
	    Lines.prototype.$cacheCell = function (cell) {
	        if (!cell)
	            return;
	        cell.element.remove();
	        this.cellCache.push(cell);
	    };
	    Lines.prototype.createCell = function (row, config, session, initElement) {
	        var cell = this.cellCache.pop();
	        if (!cell) {
	            var element = dom.createElement("div");
	            if (initElement)
	                initElement(element);
	            this.element.appendChild(element);
	            cell = {
	                element: element,
	                text: "",
	                row: row
	            };
	        }
	        cell.row = row;
	        return cell;
	    };
	    return Lines;
	}());
	exports.Lines = Lines;

	});

	ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/layer/lines","ace/config"], function(require, exports, module){	var dom = require("../lib/dom");
	var oop = require("../lib/oop");
	var lang = require("../lib/lang");
	var EventEmitter = require("../lib/event_emitter").EventEmitter;
	var Lines = require("./lines").Lines;
	var nls = require("../config").nls;
	var Gutter = /** @class */ (function () {
	    function Gutter(parentEl) {
	        this.element = dom.createElement("div");
	        this.element.className = "ace_layer ace_gutter-layer";
	        parentEl.appendChild(this.element);
	        this.setShowFoldWidgets(this.$showFoldWidgets);
	        this.gutterWidth = 0;
	        this.$annotations = [];
	        this.$updateAnnotations = this.$updateAnnotations.bind(this);
	        this.$lines = new Lines(this.element);
	        this.$lines.$offsetCoefficient = 1;
	    }
	    Gutter.prototype.setSession = function (session) {
	        if (this.session)
	            this.session.off("change", this.$updateAnnotations);
	        this.session = session;
	        if (session)
	            session.on("change", this.$updateAnnotations);
	    };
	    Gutter.prototype.addGutterDecoration = function (row, className) {
	        if (window.console)
	            console.warn && console.warn("deprecated use session.addGutterDecoration");
	        this.session.addGutterDecoration(row, className);
	    };
	    Gutter.prototype.removeGutterDecoration = function (row, className) {
	        if (window.console)
	            console.warn && console.warn("deprecated use session.removeGutterDecoration");
	        this.session.removeGutterDecoration(row, className);
	    };
	    Gutter.prototype.setAnnotations = function (annotations) {
	        this.$annotations = [];
	        for (var i = 0; i < annotations.length; i++) {
	            var annotation = annotations[i];
	            var row = annotation.row;
	            var rowInfo = this.$annotations[row];
	            if (!rowInfo)
	                rowInfo = this.$annotations[row] = { text: [], type: [], displayText: [] };
	            var annoText = annotation.text;
	            var displayAnnoText = annotation.text;
	            var annoType = annotation.type;
	            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
	            displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || "";
	            if (rowInfo.text.indexOf(annoText) === -1) {
	                rowInfo.text.push(annoText);
	                rowInfo.type.push(annoType);
	                rowInfo.displayText.push(displayAnnoText);
	            }
	            var className = annotation.className;
	            if (className) {
	                rowInfo.className = className;
	            }
	            else if (annoType === "error") {
	                rowInfo.className = " ace_error";
	            }
	            else if (annoType === "security" && !/\bace_error\b/.test(rowInfo.className)) {
	                rowInfo.className = " ace_security";
	            }
	            else if (annoType === "warning" && !/\bace_(error|security)\b/.test(rowInfo.className)) {
	                rowInfo.className = " ace_warning";
	            }
	            else if (annoType === "info" && !rowInfo.className) {
	                rowInfo.className = " ace_info";
	            }
	            else if (annoType === "hint" && !rowInfo.className) {
	                rowInfo.className = " ace_hint";
	            }
	        }
	    };
	    Gutter.prototype.$updateAnnotations = function (delta) {
	        if (!this.$annotations.length)
	            return;
	        var firstRow = delta.start.row;
	        var len = delta.end.row - firstRow;
	        if (len === 0) ;
	        else if (delta.action == 'remove') {
	            this.$annotations.splice(firstRow, len + 1, null);
	        }
	        else {
	            var args = new Array(len + 1);
	            args.unshift(firstRow, 1);
	            this.$annotations.splice.apply(this.$annotations, args);
	        }
	    };
	    Gutter.prototype.update = function (config) {
	        this.config = config;
	        var session = this.session;
	        var firstRow = config.firstRow;
	        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
	        session.getLength() - 1);
	        this.oldLastRow = lastRow;
	        this.config = config;
	        this.$lines.moveContainer(config);
	        this.$updateCursorRow();
	        var fold = session.getNextFoldLine(firstRow);
	        var foldStart = fold ? fold.start.row : Infinity;
	        var cell = null;
	        var index = -1;
	        var row = firstRow;
	        while (true) {
	            if (row > foldStart) {
	                row = fold.end.row + 1;
	                fold = session.getNextFoldLine(row, fold);
	                foldStart = fold ? fold.start.row : Infinity;
	            }
	            if (row > lastRow) {
	                while (this.$lines.getLength() > index + 1)
	                    this.$lines.pop();
	                break;
	            }
	            cell = this.$lines.get(++index);
	            if (cell) {
	                cell.row = row;
	            }
	            else {
	                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
	                this.$lines.push(cell);
	            }
	            this.$renderCell(cell, config, fold, row);
	            row++;
	        }
	        this._signal("afterRender");
	        this.$updateGutterWidth(config);
	    };
	    Gutter.prototype.$updateGutterWidth = function (config) {
	        var session = this.session;
	        var gutterRenderer = session.gutterRenderer || this.$renderer;
	        var firstLineNumber = session.$firstLineNumber;
	        var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
	        if (this.$fixedWidth || session.$useWrapMode)
	            lastLineText = session.getLength() + firstLineNumber - 1;
	        var gutterWidth = gutterRenderer
	            ? gutterRenderer.getWidth(session, lastLineText, config)
	            : lastLineText.toString().length * config.characterWidth;
	        var padding = this.$padding || this.$computePadding();
	        gutterWidth += padding.left + padding.right;
	        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
	            this.gutterWidth = gutterWidth; (this.element.parentNode).style.width =
	                this.element.style.width = Math.ceil(this.gutterWidth) + "px";
	            this._signal("changeGutterWidth", gutterWidth);
	        }
	    };
	    Gutter.prototype.$updateCursorRow = function () {
	        if (!this.$highlightGutterLine)
	            return;
	        var position = this.session.selection.getCursor();
	        if (this.$cursorRow === position.row)
	            return;
	        this.$cursorRow = position.row;
	    };
	    Gutter.prototype.updateLineHighlight = function () {
	        if (!this.$highlightGutterLine)
	            return;
	        var row = this.session.selection.cursor.row;
	        this.$cursorRow = row;
	        if (this.$cursorCell && this.$cursorCell.row == row)
	            return;
	        if (this.$cursorCell)
	            this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
	        var cells = this.$lines.cells;
	        this.$cursorCell = null;
	        for (var i = 0; i < cells.length; i++) {
	            var cell = cells[i];
	            if (cell.row >= this.$cursorRow) {
	                if (cell.row > this.$cursorRow) {
	                    var fold = this.session.getFoldLine(this.$cursorRow);
	                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)
	                        cell = cells[i - 1];
	                    else
	                        break;
	                }
	                cell.element.className = "ace_gutter-active-line " + cell.element.className;
	                this.$cursorCell = cell;
	                break;
	            }
	        }
	    };
	    Gutter.prototype.scrollLines = function (config) {
	        var oldConfig = this.config;
	        this.config = config;
	        this.$updateCursorRow();
	        if (this.$lines.pageChanged(oldConfig, config))
	            return this.update(config);
	        this.$lines.moveContainer(config);
	        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
	        this.session.getLength() - 1);
	        var oldLastRow = this.oldLastRow;
	        this.oldLastRow = lastRow;
	        if (!oldConfig || oldLastRow < config.firstRow)
	            return this.update(config);
	        if (lastRow < oldConfig.firstRow)
	            return this.update(config);
	        if (oldConfig.firstRow < config.firstRow)
	            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
	                this.$lines.shift();
	        if (oldLastRow > lastRow)
	            for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)
	                this.$lines.pop();
	        if (config.firstRow < oldConfig.firstRow) {
	            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
	        }
	        if (lastRow > oldLastRow) {
	            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
	        }
	        this.updateLineHighlight();
	        this._signal("afterRender");
	        this.$updateGutterWidth(config);
	    };
	    Gutter.prototype.$renderLines = function (config, firstRow, lastRow) {
	        var fragment = [];
	        var row = firstRow;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;
	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row + 1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row : Infinity;
	            }
	            if (row > lastRow)
	                break;
	            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
	            this.$renderCell(cell, config, foldLine, row);
	            fragment.push(cell);
	            row++;
	        }
	        return fragment;
	    };
	    Gutter.prototype.$renderCell = function (cell, config, fold, row) {
	        var element = cell.element;
	        var session = this.session;
	        var textNode = element.childNodes[0];
	        var foldWidget = element.childNodes[1];
	        var annotationNode = element.childNodes[2];
	        var customWidget = element.childNodes[3];
	        var annotationIconNode = annotationNode.firstChild;
	        var firstLineNumber = session.$firstLineNumber;
	        var breakpoints = session.$breakpoints;
	        var decorations = session.$decorations;
	        var gutterRenderer = session.gutterRenderer || this.$renderer;
	        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
	        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
	        var lineHeight = config.lineHeight + "px";
	        var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
	        var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
	        var rowText = (gutterRenderer
	            ? gutterRenderer.getText(session, row)
	            : row + firstLineNumber).toString();
	        if (this.$highlightGutterLine) {
	            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row)) {
	                className += "ace_gutter-active-line ";
	                if (this.$cursorCell != cell) {
	                    if (this.$cursorCell)
	                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
	                    this.$cursorCell = cell;
	                }
	            }
	        }
	        if (breakpoints[row])
	            className += breakpoints[row];
	        if (decorations[row])
	            className += decorations[row];
	        if (this.$annotations[row] && row !== foldStart)
	            className += this.$annotations[row].className;
	        if (foldWidgets) {
	            var c = foldWidgets[row];
	            if (c == null)
	                c = foldWidgets[row] = session.getFoldWidget(row);
	        }
	        if (c) {
	            var foldClass = "ace_fold-widget ace_" + c;
	            var isClosedFold = c == "start" && row == foldStart && row < fold.end.row;
	            if (isClosedFold) {
	                foldClass += " ace_closed";
	                var foldAnnotationClass = "";
	                var annotationInFold = false;
	                for (var i = row + 1; i <= fold.end.row; i++) {
	                    if (!this.$annotations[i])
	                        continue;
	                    if (this.$annotations[i].className === " ace_error") {
	                        annotationInFold = true;
	                        foldAnnotationClass = " ace_error_fold";
	                        break;
	                    }
	                    if (this.$annotations[i].className === " ace_security") {
	                        annotationInFold = true;
	                        foldAnnotationClass = " ace_security_fold";
	                    }
	                    else if (this.$annotations[i].className === " ace_warning" &&
	                        foldAnnotationClass !== " ace_security_fold") {
	                        annotationInFold = true;
	                        foldAnnotationClass = " ace_warning_fold";
	                    }
	                }
	                className += foldAnnotationClass;
	            }
	            else
	                foldClass += " ace_open";
	            if (foldWidget.className != foldClass)
	                foldWidget.className = foldClass;
	            dom.setStyle(foldWidget.style, "height", lineHeight);
	            dom.setStyle(foldWidget.style, "display", "inline-block");
	            foldWidget.setAttribute("role", "button");
	            foldWidget.setAttribute("tabindex", "-1");
	            var foldRange = session.getFoldWidgetRange(row);
	            if (foldRange)
	                foldWidget.setAttribute("aria-label", nls("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [
	                    foldRange.start.row + 1,
	                    foldRange.end.row + 1
	                ]));
	            else {
	                if (fold)
	                    foldWidget.setAttribute("aria-label", nls("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [
	                        fold.start.row + 1,
	                        fold.end.row + 1
	                    ]));
	                else
	                    foldWidget.setAttribute("aria-label", nls("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [row + 1]));
	            }
	            if (isClosedFold) {
	                foldWidget.setAttribute("aria-expanded", "false");
	                foldWidget.setAttribute("title", nls("gutter.code-folding.closed.title", "Unfold code"));
	            }
	            else {
	                foldWidget.setAttribute("aria-expanded", "true");
	                foldWidget.setAttribute("title", nls("gutter.code-folding.open.title", "Fold code"));
	            }
	        }
	        else {
	            if (foldWidget) {
	                dom.setStyle(foldWidget.style, "display", "none");
	                foldWidget.setAttribute("tabindex", "0");
	                foldWidget.removeAttribute("role");
	                foldWidget.removeAttribute("aria-label");
	            }
	        }
	        var customWidgetAttributes = this.session.$gutterCustomWidgets[row];
	        if (customWidgetAttributes) {
	            this.$addCustomWidget(row, customWidgetAttributes, cell);
	        }
	        else if (customWidget) {
	            this.$removeCustomWidget(row, cell);
	        }
	        if (annotationInFold && this.$showFoldedAnnotations) {
	            annotationNode.className = "ace_gutter_annotation";
	            annotationIconNode.className = iconClassName;
	            annotationIconNode.className += foldAnnotationClass;
	            dom.setStyle(annotationIconNode.style, "height", lineHeight);
	            dom.setStyle(annotationNode.style, "display", "block");
	            dom.setStyle(annotationNode.style, "height", lineHeight);
	            var ariaLabel;
	            switch (foldAnnotationClass) {
	                case " ace_error_fold":
	                    ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
	                    break;
	                case " ace_security_fold":
	                    ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
	                    break;
	                case " ace_warning_fold":
	                    ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
	                    break;
	            }
	            annotationNode.setAttribute("aria-label", ariaLabel);
	            annotationNode.setAttribute("tabindex", "-1");
	            annotationNode.setAttribute("role", "button");
	        }
	        else if (this.$annotations[row]) {
	            annotationNode.className = "ace_gutter_annotation";
	            annotationIconNode.className = iconClassName;
	            if (this.$useSvgGutterIcons)
	                annotationIconNode.className += this.$annotations[row].className;
	            else
	                element.classList.add(this.$annotations[row].className.replace(" ", ""));
	            dom.setStyle(annotationIconNode.style, "height", lineHeight);
	            dom.setStyle(annotationNode.style, "display", "block");
	            dom.setStyle(annotationNode.style, "height", lineHeight);
	            var ariaLabel;
	            switch (this.$annotations[row].className) {
	                case " ace_error":
	                    ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
	                    break;
	                case " ace_security":
	                    ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
	                    break;
	                case " ace_warning":
	                    ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
	                    break;
	                case " ace_info":
	                    ariaLabel = nls("gutter.annotation.aria-label.info", "Info, read annotations row $0", [rowText]);
	                    break;
	                case " ace_hint":
	                    ariaLabel = nls("gutter.annotation.aria-label.hint", "Suggestion, read annotations row $0", [rowText]);
	                    break;
	            }
	            annotationNode.setAttribute("aria-label", ariaLabel);
	            annotationNode.setAttribute("tabindex", "-1");
	            annotationNode.setAttribute("role", "button");
	        }
	        else {
	            dom.setStyle(annotationNode.style, "display", "none");
	            annotationNode.removeAttribute("aria-label");
	            annotationNode.removeAttribute("role");
	            annotationNode.setAttribute("tabindex", "0");
	        }
	        if (rowText !== textNode.data) {
	            textNode.data = rowText;
	        }
	        if (element.className != className)
	            element.className = className;
	        dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
	        dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
	        cell.text = rowText;
	        if (annotationNode.style.display === "none" && foldWidget.style.display === "none" && !customWidgetAttributes)
	            cell.element.setAttribute("aria-hidden", true);
	        else
	            cell.element.setAttribute("aria-hidden", false);
	        return cell;
	    };
	    Gutter.prototype.setHighlightGutterLine = function (highlightGutterLine) {
	        this.$highlightGutterLine = highlightGutterLine;
	    };
	    Gutter.prototype.setShowLineNumbers = function (show) {
	        this.$renderer = !show && {
	            getWidth: function () { return 0; },
	            getText: function () { return ""; }
	        };
	    };
	    Gutter.prototype.getShowLineNumbers = function () {
	        return this.$showLineNumbers;
	    };
	    Gutter.prototype.setShowFoldWidgets = function (show) {
	        if (show)
	            dom.addCssClass(this.element, "ace_folding-enabled");
	        else
	            dom.removeCssClass(this.element, "ace_folding-enabled");
	        this.$showFoldWidgets = show;
	        this.$padding = null;
	    };
	    Gutter.prototype.getShowFoldWidgets = function () {
	        return this.$showFoldWidgets;
	    };
	    Gutter.prototype.$hideFoldWidget = function (row, cell) {
	        var rowCell = cell || this.$getGutterCell(row);
	        if (rowCell && rowCell.element) {
	            var foldWidget = rowCell.element.childNodes[1];
	            if (foldWidget) {
	                dom.setStyle(foldWidget.style, "display", "none");
	            }
	        }
	    };
	    Gutter.prototype.$showFoldWidget = function (row, cell) {
	        var rowCell = cell || this.$getGutterCell(row);
	        if (rowCell && rowCell.element) {
	            var foldWidget = rowCell.element.childNodes[1];
	            if (foldWidget && this.session.foldWidgets && this.session.foldWidgets[rowCell.row]) {
	                dom.setStyle(foldWidget.style, "display", "inline-block");
	            }
	        }
	    };
	    Gutter.prototype.$getGutterCell = function (row) {
	        var cells = this.$lines.cells;
	        var visibileRow = this.session.documentToScreenRow(row, 0);
	        return cells[row - this.config.firstRowScreen - (row - visibileRow)];
	    };
	    Gutter.prototype.$addCustomWidget = function (row, _a, cell) {
	        var className = _a.className, label = _a.label, title = _a.title, callbacks = _a.callbacks;
	        this.session.$gutterCustomWidgets[row] = { className: className, label: label, title: title, callbacks: callbacks };
	        this.$hideFoldWidget(row, cell);
	        var rowCell = cell || this.$getGutterCell(row);
	        if (rowCell && rowCell.element) {
	            var customWidget = rowCell.element.querySelector(".ace_custom-widget");
	            if (customWidget) {
	                customWidget.remove();
	            }
	            customWidget = dom.createElement("span");
	            customWidget.className = "ace_custom-widget ".concat(className);
	            customWidget.setAttribute("tabindex", "-1");
	            customWidget.setAttribute("role", 'button');
	            customWidget.setAttribute("aria-label", label);
	            customWidget.setAttribute("title", title);
	            dom.setStyle(customWidget.style, "display", "inline-block");
	            dom.setStyle(customWidget.style, "height", "inherit");
	            if (callbacks && callbacks.onClick) {
	                customWidget.addEventListener("click", function (e) {
	                    callbacks.onClick(e, row);
	                    e.stopPropagation();
	                });
	            }
	            rowCell.element.appendChild(customWidget);
	        }
	    };
	    Gutter.prototype.$removeCustomWidget = function (row, cell) {
	        delete this.session.$gutterCustomWidgets[row];
	        this.$showFoldWidget(row, cell);
	        var rowCell = cell || this.$getGutterCell(row);
	        if (rowCell && rowCell.element) {
	            var customWidget = rowCell.element.querySelector(".ace_custom-widget");
	            if (customWidget) {
	                rowCell.element.removeChild(customWidget);
	            }
	        }
	    };
	    Gutter.prototype.$computePadding = function () {
	        if (!this.element.firstChild)
	            return { left: 0, right: 0 };
	        var style = dom.computedStyle(/**@type{Element}*/ (this.element.firstChild));
	        this.$padding = {};
	        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)
	            + (parseInt(style.paddingLeft) || 0) + 1;
	        this.$padding.right = (parseInt(style.borderRightWidth) || 0)
	            + (parseInt(style.paddingRight) || 0);
	        return this.$padding;
	    };
	    Gutter.prototype.getRegion = function (point) {
	        var padding = this.$padding || this.$computePadding();
	        var rect = this.element.getBoundingClientRect();
	        if (point.x < padding.left + rect.left)
	            return "markers";
	        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
	            return "foldWidgets";
	    };
	    return Gutter;
	}());
	Gutter.prototype.$fixedWidth = false;
	Gutter.prototype.$highlightGutterLine = true;
	Gutter.prototype.$renderer = "";
	Gutter.prototype.$showLineNumbers = true;
	Gutter.prototype.$showFoldWidgets = true;
	oop.implement(Gutter.prototype, EventEmitter);
	function onCreateCell(element) {
	    var textNode = document.createTextNode('');
	    element.appendChild(textNode);
	    var foldWidget = dom.createElement("span");
	    element.appendChild(foldWidget);
	    var annotationNode = dom.createElement("span");
	    element.appendChild(annotationNode);
	    var annotationIconNode = dom.createElement("span");
	    annotationNode.appendChild(annotationIconNode);
	    return element;
	}
	exports.Gutter = Gutter;

	});

	ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(require, exports, module){	var Range = require("../range").Range;
	var dom = require("../lib/dom");
	var Marker = /** @class */ (function () {
	    function Marker(parentEl) {
	        this.element = dom.createElement("div");
	        this.element.className = "ace_layer ace_marker-layer";
	        parentEl.appendChild(this.element);
	    }
	    Marker.prototype.setPadding = function (padding) {
	        this.$padding = padding;
	    };
	    Marker.prototype.setSession = function (session) {
	        this.session = session;
	    };
	    Marker.prototype.setMarkers = function (markers) {
	        this.markers = markers;
	    };
	    Marker.prototype.elt = function (className, css) {
	        var x = this.i != -1 && this.element.childNodes[this.i];
	        if (!x) {
	            x = document.createElement("div");
	            this.element.appendChild(x);
	            this.i = -1;
	        }
	        else {
	            this.i++;
	        }
	        x.style.cssText = css;
	        x.className = className;
	    };
	    Marker.prototype.update = function (config) {
	        if (!config)
	            return;
	        this.config = config;
	        this.i = 0;
	        var html;
	        for (var key in this.markers) {
	            var marker = this.markers[key];
	            if (!marker.range) {
	                marker.update(html, this, this.session, config);
	                continue;
	            }
	            var range = marker.range.clipRows(config.firstRow, config.lastRow);
	            if (range.isEmpty())
	                continue;
	            range = range.toScreenRange(this.session);
	            if (marker.renderer) {
	                var top = this.$getTop(range.start.row, config);
	                var left = this.$padding + range.start.column * config.characterWidth;
	                marker.renderer(html, range, left, top, config);
	            }
	            else if (marker.type == "fullLine") {
	                this.drawFullLineMarker(html, range, marker.clazz, config);
	            }
	            else if (marker.type == "screenLine") {
	                this.drawScreenLineMarker(html, range, marker.clazz, config);
	            }
	            else if (range.isMultiLine()) {
	                if (marker.type == "text")
	                    this.drawTextMarker(html, range, marker.clazz, config);
	                else
	                    this.drawMultiLineMarker(html, range, marker.clazz, config);
	            }
	            else {
	                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
	            }
	        }
	        if (this.i != -1) {
	            while (this.i < this.element.childElementCount)
	                this.element.removeChild(this.element.lastChild);
	        }
	    };
	    Marker.prototype.$getTop = function (row, layerConfig) {
	        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
	    };
	    Marker.prototype.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {
	        var session = this.session;
	        var start = range.start.row;
	        var end = range.end.row;
	        var row = start;
	        var prev = 0;
	        var curr = 0;
	        var next = session.getScreenLastRowColumn(row);
	        var lineRange = new Range(row, range.start.column, row, curr);
	        for (; row <= end; row++) {
	            lineRange.start.row = lineRange.end.row = row;
	            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
	            lineRange.end.column = next;
	            prev = curr;
	            curr = next;
	            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
	            this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br"
	                + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
	        }
	    };
	    Marker.prototype.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
	        var padding = this.$padding;
	        var height = config.lineHeight;
	        var top = this.$getTop(range.start.row, config);
	        var left = padding + range.start.column * config.characterWidth;
	        extraStyle = extraStyle || "";
	        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
	            var range1 = range.clone();
	            range1.end.row = range1.start.row;
	            range1.end.column = this.session.getLine(range1.start.row).length;
	            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
	        }
	        else {
	            this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;" + "right:" + padding + "px;" + "top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
	        }
	        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
	            var range1 = range.clone();
	            range1.start.row = range1.end.row;
	            range1.start.column = 0;
	            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
	        }
	        else {
	            top = this.$getTop(range.end.row, config);
	            var width = range.end.column * config.characterWidth;
	            this.elt(clazz + " ace_br12", "height:" + height + "px;" +
	                "width:" + width + "px;" +
	                "top:" + top + "px;" +
	                "left:" + padding + "px;" + (extraStyle || ""));
	        }
	        height = (range.end.row - range.start.row - 1) * config.lineHeight;
	        if (height <= 0)
	            return;
	        top = this.$getTop(range.start.row + 1, config);
	        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
	        this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;" +
	            "right:" + padding + "px;" +
	            "top:" + top + "px;" +
	            "left:" + padding + "px;" + (extraStyle || ""));
	    };
	    Marker.prototype.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
	        if (this.session.$bidiHandler.isBidiRow(range.start.row))
	            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
	        var height = config.lineHeight;
	        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
	        var top = this.$getTop(range.start.row, config);
	        var left = this.$padding + range.start.column * config.characterWidth;
	        this.elt(clazz, "height:" + height + "px;" +
	            "width:" + width + "px;" +
	            "top:" + top + "px;" +
	            "left:" + left + "px;" + (extraStyle || ""));
	    };
	    Marker.prototype.drawBidiSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
	        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
	        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
	        selections.forEach(function (selection) {
	            this.elt(clazz, "height:" + height + "px;" +
	                "width:" + (selection.width + (extraLength || 0)) + "px;" +
	                "top:" + top + "px;" +
	                "left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
	        }, this);
	    };
	    Marker.prototype.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
	        var top = this.$getTop(range.start.row, config);
	        var height = config.lineHeight;
	        if (range.start.row != range.end.row)
	            height += this.$getTop(range.end.row, config) - top;
	        this.elt(clazz, "height:" + height + "px;" +
	            "top:" + top + "px;" +
	            "left:0;right:0;" + (extraStyle || ""));
	    };
	    Marker.prototype.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
	        var top = this.$getTop(range.start.row, config);
	        var height = config.lineHeight;
	        this.elt(clazz, "height:" + height + "px;" +
	            "top:" + top + "px;" +
	            "left:0;right:0;" + (extraStyle || ""));
	    };
	    return Marker;
	}());
	Marker.prototype.$padding = 0;
	function getBorderClass(tl, tr, br, bl) {
	    return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
	}
	exports.Marker = Marker;

	});

	ace.define("ace/layer/text_util",["require","exports","module"], function(require, exports, module){// Tokens for which Ace just uses a simple TextNode and does not add any special className.
	var textTokens = new Set(["text", "rparen", "lparen"]);
	exports.isTextToken = function (tokenType) {
	    return textTokens.has(tokenType);
	};

	});

	ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/layer/lines","ace/lib/event_emitter","ace/config","ace/layer/text_util"], function(require, exports, module){	var oop = require("../lib/oop");
	var dom = require("../lib/dom");
	var lang = require("../lib/lang");
	var Lines = require("./lines").Lines;
	var EventEmitter = require("../lib/event_emitter").EventEmitter;
	var nls = require("../config").nls;
	var isTextToken = require("./text_util").isTextToken;
	var Text = /** @class */ (function () {
	    function Text(parentEl) {
	        this.dom = dom;
	        this.element = this.dom.createElement("div");
	        this.element.className = "ace_layer ace_text-layer";
	        parentEl.appendChild(this.element);
	        this.$updateEolChar = this.$updateEolChar.bind(this);
	        this.$lines = new Lines(this.element);
	    }
	    Text.prototype.$updateEolChar = function () {
	        var doc = this.session.doc;
	        var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
	        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
	        if (this.EOL_CHAR != EOL_CHAR) {
	            this.EOL_CHAR = EOL_CHAR;
	            return true;
	        }
	    };
	    Text.prototype.setPadding = function (padding) {
	        this.$padding = padding;
	        this.element.style.margin = "0 " + padding + "px";
	    };
	    Text.prototype.getLineHeight = function () {
	        return this.$fontMetrics.$characterSize.height || 0;
	    };
	    Text.prototype.getCharacterWidth = function () {
	        return this.$fontMetrics.$characterSize.width || 0;
	    };
	    Text.prototype.$setFontMetrics = function (measure) {
	        this.$fontMetrics = measure;
	        this.$fontMetrics.on("changeCharacterSize", 
	        function (e) {
	            this._signal("changeCharacterSize", e);
	        }.bind(this));
	        this.$pollSizeChanges();
	    };
	    Text.prototype.checkForSizeChanges = function () {
	        this.$fontMetrics.checkForSizeChanges();
	    };
	    Text.prototype.$pollSizeChanges = function () {
	        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
	    };
	    Text.prototype.setSession = function (session) {
	        this.session = session;
	        if (session)
	            this.$computeTabString();
	    };
	    Text.prototype.setShowInvisibles = function (showInvisibles) {
	        if (this.showInvisibles == showInvisibles)
	            return false;
	        this.showInvisibles = showInvisibles;
	        if (typeof showInvisibles == "string") {
	            this.showSpaces = /tab/i.test(showInvisibles);
	            this.showTabs = /space/i.test(showInvisibles);
	            this.showEOL = /eol/i.test(showInvisibles);
	        }
	        else {
	            this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
	        }
	        this.$computeTabString();
	        return true;
	    };
	    Text.prototype.setDisplayIndentGuides = function (display) {
	        if (this.displayIndentGuides == display)
	            return false;
	        this.displayIndentGuides = display;
	        this.$computeTabString();
	        return true;
	    };
	    Text.prototype.setHighlightIndentGuides = function (highlight) {
	        if (this.$highlightIndentGuides === highlight)
	            return false;
	        this.$highlightIndentGuides = highlight;
	        return highlight;
	    };
	    Text.prototype.$computeTabString = function () {
	        var tabSize = this.session.getTabSize();
	        this.tabSize = tabSize; var tabStr = this.$tabStrings = [0];
	        for (var i = 1; i < tabSize + 1; i++) {
	            if (this.showTabs) {
	                var span = this.dom.createElement("span");
	                span.className = "ace_invisible ace_invisible_tab";
	                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
	                tabStr.push(span);
	            }
	            else {
	                tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
	            }
	        }
	        if (this.displayIndentGuides) {
	            this.$indentGuideRe = /\s\S| \t|\t |\s$/;
	            var className = "ace_indent-guide";
	            var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
	            var spaceContent = this.showSpaces
	                ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize)
	                : lang.stringRepeat(" ", this.tabSize);
	            var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
	            var tabContent = this.showTabs
	                ? lang.stringRepeat(this.TAB_CHAR, this.tabSize)
	                : spaceContent;
	            var span = this.dom.createElement("span");
	            span.className = className + spaceClass;
	            span.textContent = spaceContent;
	            this.$tabStrings[" "] = span;
	            var span = this.dom.createElement("span");
	            span.className = className + tabClass;
	            span.textContent = tabContent;
	            this.$tabStrings["\t"] = span;
	        }
	    };
	    Text.prototype.updateLines = function (config, firstRow, lastRow) {
	        if (this.config.lastRow != config.lastRow ||
	            this.config.firstRow != config.firstRow) {
	            return this.update(config);
	        }
	        this.config = config;
	        var first = Math.max(firstRow, config.firstRow);
	        var last = Math.min(lastRow, config.lastRow);
	        var lineElements = this.element.childNodes;
	        var lineElementsIdx = 0;
	        for (var row = config.firstRow; row < first; row++) {
	            var foldLine = this.session.getFoldLine(row);
	            if (foldLine) {
	                if (foldLine.containsRow(first)) {
	                    first = foldLine.start.row;
	                    break;
	                }
	                else {
	                    row = foldLine.end.row;
	                }
	            }
	            lineElementsIdx++;
	        }
	        var heightChanged = false;
	        var row = first;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;
	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row + 1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row : Infinity;
	            }
	            if (row > last)
	                break; var lineElement = lineElements[lineElementsIdx++];
	            if (lineElement) {
	                this.dom.removeChildren(lineElement);
	                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
	                if (heightChanged)
	                    lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
	                var height = (config.lineHeight * this.session.getRowLength(row)) + "px";
	                if (lineElement.style.height != height) {
	                    heightChanged = true;
	                    lineElement.style.height = height;
	                }
	            }
	            row++;
	        }
	        if (heightChanged) {
	            while (lineElementsIdx < this.$lines.cells.length) {
	                var cell = this.$lines.cells[lineElementsIdx++];
	                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
	            }
	        }
	    };
	    Text.prototype.scrollLines = function (config) {
	        var oldConfig = this.config;
	        this.config = config;
	        if (this.$lines.pageChanged(oldConfig, config))
	            return this.update(config);
	        this.$lines.moveContainer(config);
	        var lastRow = config.lastRow;
	        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
	        if (!oldConfig || oldLastRow < config.firstRow)
	            return this.update(config);
	        if (lastRow < oldConfig.firstRow)
	            return this.update(config);
	        if (!oldConfig || oldConfig.lastRow < config.firstRow)
	            return this.update(config);
	        if (config.lastRow < oldConfig.firstRow)
	            return this.update(config);
	        if (oldConfig.firstRow < config.firstRow)
	            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
	                this.$lines.shift();
	        if (oldConfig.lastRow > config.lastRow)
	            for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
	                this.$lines.pop();
	        if (config.firstRow < oldConfig.firstRow) {
	            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
	        }
	        if (config.lastRow > oldConfig.lastRow) {
	            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
	        }
	        this.$highlightIndentGuide();
	    };
	    Text.prototype.$renderLinesFragment = function (config, firstRow, lastRow) {
	        var fragment = [];
	        var row = firstRow;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;
	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row + 1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row : Infinity;
	            }
	            if (row > lastRow)
	                break;
	            var line = this.$lines.createCell(row, config, this.session);
	            var lineEl = line.element;
	            this.dom.removeChildren(lineEl);
	            dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
	            dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
	            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
	            if (this.$useLineGroups()) {
	                lineEl.className = "ace_line_group";
	            }
	            else {
	                lineEl.className = "ace_line";
	            }
	            fragment.push(line);
	            row++;
	        }
	        return fragment;
	    };
	    Text.prototype.update = function (config) {
	        this.$lines.moveContainer(config);
	        this.config = config;
	        var firstRow = config.firstRow;
	        var lastRow = config.lastRow;
	        var lines = this.$lines;
	        while (lines.getLength())
	            lines.pop();
	        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
	    };
	    Text.prototype.$renderToken = function (parent, screenColumn, token, value) {
	        var self = this;
	        var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206B\u206C\u206D\u206E\u206F]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
	        var valueFragment = this.dom.createFragment(this.element);
	        var m;
	        var i = 0;
	        while (m = re.exec(value)) {
	            var tab = m[1];
	            var simpleSpace = m[2];
	            var controlCharacter = m[3];
	            var cjkSpace = m[4];
	            var cjk = m[5];
	            if (!self.showSpaces && simpleSpace)
	                continue;
	            var before = i != m.index ? value.slice(i, m.index) : "";
	            i = m.index + m[0].length;
	            if (before) {
	                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
	            }
	            if (tab) {
	                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);
	                var text = self.$tabStrings[tabSize].cloneNode(true);
	                text["charCount"] = 1;
	                valueFragment.appendChild(text);
	                screenColumn += tabSize - 1;
	            }
	            else if (simpleSpace) {
	                if (self.showSpaces) {
	                    var span = this.dom.createElement("span");
	                    span.className = "ace_invisible ace_invisible_space";
	                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);
	                    valueFragment.appendChild(span);
	                }
	                else {
	                    valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));
	                }
	            }
	            else if (controlCharacter) {
	                var span = this.dom.createElement("span");
	                span.className = "ace_invisible ace_invisible_space ace_invalid";
	                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);
	                valueFragment.appendChild(span);
	            }
	            else if (cjkSpace) {
	                screenColumn += 1;
	                var span = this.dom.createElement("span");
	                span.style.width = (self.config.characterWidth * 2) + "px";
	                span.className = self.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
	                span.textContent = self.showSpaces ? self.SPACE_CHAR : cjkSpace;
	                valueFragment.appendChild(span);
	            }
	            else if (cjk) {
	                screenColumn += 1;
	                var span = this.dom.createElement("span");
	                span.style.width = (self.config.characterWidth * 2) + "px";
	                span.className = "ace_cjk";
	                span.textContent = cjk;
	                valueFragment.appendChild(span);
	            }
	        }
	        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
	        if (!isTextToken(token.type)) {
	            var classes = "ace_" + token.type.replace(/\./g, " ace_");
	            var span = this.dom.createElement("span");
	            if (token.type == "fold") {
	                span.style.width = (token.value.length * this.config.characterWidth) + "px";
	                span.setAttribute("title", nls("inline-fold.closed.title", "Unfold code"));
	            }
	            span.className = classes;
	            span.appendChild(valueFragment);
	            parent.appendChild(span);
	        }
	        else {
	            parent.appendChild(valueFragment);
	        }
	        return screenColumn + value.length;
	    };
	    Text.prototype.renderIndentGuide = function (parent, value, max) {
	        var cols = value.search(this.$indentGuideRe);
	        if (cols <= 0 || cols >= max)
	            return value;
	        if (value[0] == " ") {
	            cols -= cols % this.tabSize;
	            var count = cols / this.tabSize;
	            for (var i = 0; i < count; i++) {
	                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
	            }
	            this.$highlightIndentGuide();
	            return value.substr(cols);
	        }
	        else if (value[0] == "\t") {
	            for (var i = 0; i < cols; i++) {
	                parent.appendChild(this.$tabStrings["\t"].cloneNode(true));
	            }
	            this.$highlightIndentGuide();
	            return value.substr(cols);
	        }
	        this.$highlightIndentGuide();
	        return value;
	    };
	    Text.prototype.$highlightIndentGuide = function () {
	        if (!this.$highlightIndentGuides || !this.displayIndentGuides)
	            return;
	        this.$highlightIndentGuideMarker = {
	            indentLevel: undefined,
	            start: undefined,
	            end: undefined,
	            dir: undefined
	        };
	        var lines = this.session.doc.$lines;
	        if (!lines)
	            return;
	        var cursor = this.session.selection.getCursor();
	        var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
	        var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
	        this.$highlightIndentGuideMarker = {
	            indentLevel: elementIndentLevel,
	            start: cursor.row
	        };
	        var bracketHighlight = this.session.$bracketHighlight;
	        if (bracketHighlight) {
	            var ranges = this.session.$bracketHighlight.ranges;
	            for (var i = 0; i < ranges.length; i++) {
	                if (cursor.row !== ranges[i].start.row) {
	                    this.$highlightIndentGuideMarker.end = ranges[i].start.row + 1;
	                    if (cursor.row > ranges[i].start.row) {
	                        this.$highlightIndentGuideMarker.dir = -1;
	                    }
	                    else {
	                        this.$highlightIndentGuideMarker.dir = 1;
	                    }
	                    break;
	                }
	            }
	        }
	        if (!this.$highlightIndentGuideMarker.end) {
	            if (lines[cursor.row] !== '' && cursor.column === lines[cursor.row].length) {
	                this.$highlightIndentGuideMarker.dir = 1;
	                for (var i = cursor.row + 1; i < lines.length; i++) {
	                    var line = lines[i];
	                    var currentIndent = /^\s*/.exec(line)[0].length;
	                    if (line !== '') {
	                        this.$highlightIndentGuideMarker.end = i;
	                        if (currentIndent <= initialIndent)
	                            break;
	                    }
	                }
	            }
	        }
	        this.$renderHighlightIndentGuide();
	    };
	    Text.prototype.$clearActiveIndentGuide = function () {
	        var activeIndentGuides = this.element.querySelectorAll(".ace_indent-guide-active");
	        for (var i = 0; i < activeIndentGuides.length; i++) {
	            activeIndentGuides[i].classList.remove("ace_indent-guide-active");
	        }
	    };
	    Text.prototype.$setIndentGuideActive = function (cell, indentLevel) {
	        var line = this.session.doc.getLine(cell.row);
	        if (line !== "") {
	            var element = cell.element;
	            if (cell.element.classList && cell.element.classList.contains("ace_line_group")) {
	                if (cell.element.childNodes.length > 0) {
	                    element = cell.element.childNodes[0];
	                }
	                else {
	                    return;
	                }
	            }
	            var childNodes = element.childNodes;
	            if (childNodes) {
	                var node = childNodes[indentLevel - 1];
	                if (node && node.classList && node.classList.contains("ace_indent-guide"))
	                    node.classList.add("ace_indent-guide-active");
	            }
	        }
	    };
	    Text.prototype.$renderHighlightIndentGuide = function () {
	        if (!this.$lines)
	            return;
	        var cells = this.$lines.cells;
	        this.$clearActiveIndentGuide();
	        var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
	        if (indentLevel !== 0) {
	            if (this.$highlightIndentGuideMarker.dir === 1) {
	                for (var i = 0; i < cells.length; i++) {
	                    var cell = cells[i];
	                    if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start
	                        + 1) {
	                        if (cell.row >= this.$highlightIndentGuideMarker.end)
	                            break;
	                        this.$setIndentGuideActive(cell, indentLevel);
	                    }
	                }
	            }
	            else {
	                for (var i = cells.length - 1; i >= 0; i--) {
	                    var cell = cells[i];
	                    if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
	                        if (cell.row < this.$highlightIndentGuideMarker.end)
	                            break;
	                        this.$setIndentGuideActive(cell, indentLevel);
	                    }
	                }
	            }
	        }
	    };
	    Text.prototype.$createLineElement = function (parent) {
	        var lineEl = this.dom.createElement("div");
	        lineEl.className = "ace_line";
	        lineEl.style.height = this.config.lineHeight + "px";
	        return lineEl;
	    };
	    Text.prototype.$renderWrappedLine = function (parent, tokens, splits) {
	        var chars = 0;
	        var split = 0;
	        var splitChars = splits[0];
	        var screenColumn = 0;
	        var lineEl = this.$createLineElement();
	        parent.appendChild(lineEl);
	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];
	            var value = token.value;
	            if (i == 0 && this.displayIndentGuides) {
	                chars = value.length;
	                value = this.renderIndentGuide(lineEl, value, splitChars);
	                if (!value)
	                    continue;
	                chars -= value.length;
	            }
	            if (chars + value.length < splitChars) {
	                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
	                chars += value.length;
	            }
	            else {
	                while (chars + value.length >= splitChars) {
	                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
	                    value = value.substring(splitChars - chars);
	                    chars = splitChars;
	                    lineEl = this.$createLineElement();
	                    parent.appendChild(lineEl);
	                    var text = this.dom.createTextNode(lang.stringRepeat("\xa0", splits.indent), this.element);
	                    text["charCount"] = 0; // not to take into account when we are counting columns
	                    lineEl.appendChild(text);
	                    split++;
	                    screenColumn = 0;
	                    splitChars = splits[split] || Number.MAX_VALUE;
	                }
	                if (value.length != 0) {
	                    chars += value.length;
	                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
	                }
	            }
	        }
	        if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
	            this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
	    };
	    Text.prototype.$renderSimpleLine = function (parent, tokens) {
	        var screenColumn = 0;
	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];
	            var value = token.value;
	            if (i == 0 && this.displayIndentGuides) {
	                value = this.renderIndentGuide(parent, value);
	                if (!value)
	                    continue;
	            }
	            if (screenColumn + value.length > this.MAX_LINE_LENGTH)
	                return this.$renderOverflowMessage(parent, screenColumn, token, value);
	            screenColumn = this.$renderToken(parent, screenColumn, token, value);
	        }
	    };
	    Text.prototype.$renderOverflowMessage = function (parent, screenColumn, token, value, hide) {
	        token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
	        var overflowEl = this.dom.createElement("span");
	        overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
	        overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
	        parent.appendChild(overflowEl);
	    };
	    Text.prototype.$renderLine = function (parent, row, foldLine) {
	        if (!foldLine && foldLine != false)
	            foldLine = this.session.getFoldLine(row);
	        if (foldLine)
	            var tokens = this.$getFoldLineTokens(row, foldLine);
	        else
	            var tokens = this.session.getTokens(row);
	        var lastLineEl = parent;
	        if (tokens.length) {
	            var splits = this.session.getRowSplitData(row);
	            if (splits && splits.length) {
	                this.$renderWrappedLine(parent, tokens, splits);
	                var lastLineEl = parent.lastChild;
	            }
	            else {
	                var lastLineEl = parent;
	                if (this.$useLineGroups()) {
	                    lastLineEl = this.$createLineElement();
	                    parent.appendChild(lastLineEl);
	                }
	                this.$renderSimpleLine(lastLineEl, tokens);
	            }
	        }
	        else if (this.$useLineGroups()) {
	            lastLineEl = this.$createLineElement();
	            parent.appendChild(lastLineEl);
	        }
	        if (this.showEOL && lastLineEl) {
	            if (foldLine)
	                row = foldLine.end.row;
	            var invisibleEl = this.dom.createElement("span");
	            invisibleEl.className = "ace_invisible ace_invisible_eol";
	            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
	            lastLineEl.appendChild(invisibleEl);
	        }
	    };
	    Text.prototype.$getFoldLineTokens = function (row, foldLine) {
	        var session = this.session;
	        var renderTokens = [];
	        function addTokens(tokens, from, to) {
	            var idx = 0, col = 0;
	            while ((col + tokens[idx].value.length) < from) {
	                col += tokens[idx].value.length;
	                idx++;
	                if (idx == tokens.length)
	                    return;
	            }
	            if (col != from) {
	                var value = tokens[idx].value.substring(from - col);
	                if (value.length > (to - from))
	                    value = value.substring(0, to - from);
	                renderTokens.push({
	                    type: tokens[idx].type,
	                    value: value
	                });
	                col = from + value.length;
	                idx += 1;
	            }
	            while (col < to && idx < tokens.length) {
	                var value = tokens[idx].value;
	                if (value.length + col > to) {
	                    renderTokens.push({
	                        type: tokens[idx].type,
	                        value: value.substring(0, to - col)
	                    });
	                }
	                else
	                    renderTokens.push(tokens[idx]);
	                col += value.length;
	                idx += 1;
	            }
	        }
	        var tokens = session.getTokens(row);
	        foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
	            if (placeholder != null) {
	                renderTokens.push({
	                    type: "fold",
	                    value: placeholder
	                });
	            }
	            else {
	                if (isNewRow)
	                    tokens = session.getTokens(row);
	                if (tokens.length)
	                    addTokens(tokens, lastColumn, column);
	            }
	        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
	        return renderTokens;
	    };
	    Text.prototype.$useLineGroups = function () {
	        return this.session.getUseWrapMode();
	    };
	    return Text;
	}());
	Text.prototype.EOF_CHAR = "\xB6";
	Text.prototype.EOL_CHAR_LF = "\xAC";
	Text.prototype.EOL_CHAR_CRLF = "\xa4";
	Text.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;
	Text.prototype.TAB_CHAR = "\u2014"; //"\u21E5";
	Text.prototype.SPACE_CHAR = "\xB7";
	Text.prototype.$padding = 0;
	Text.prototype.MAX_LINE_LENGTH = 10000;
	Text.prototype.showInvisibles = false;
	Text.prototype.showSpaces = false;
	Text.prototype.showTabs = false;
	Text.prototype.showEOL = false;
	Text.prototype.displayIndentGuides = true;
	Text.prototype.$highlightIndentGuides = true;
	Text.prototype.$tabStrings = [];
	Text.prototype.destroy = {};
	Text.prototype.onChangeTabSize = Text.prototype.$computeTabString;
	oop.implement(Text.prototype, EventEmitter);
	exports.Text = Text;

	});

	ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(require, exports, module){	var dom = require("../lib/dom");
	var Cursor = /** @class */ (function () {
	    function Cursor(parentEl) {
	        this.element = dom.createElement("div");
	        this.element.className = "ace_layer ace_cursor-layer";
	        parentEl.appendChild(this.element);
	        this.isVisible = false;
	        this.isBlinking = true;
	        this.blinkInterval = 1000;
	        this.smoothBlinking = false;
	        this.cursors = [];
	        this.cursor = this.addCursor();
	        dom.addCssClass(this.element, "ace_hidden-cursors");
	        this.$updateCursors = this.$updateOpacity.bind(this);
	    }
	    Cursor.prototype.$updateOpacity = function (val) {
	        var cursors = this.cursors;
	        for (var i = cursors.length; i--;)
	            dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
	    };
	    Cursor.prototype.$startCssAnimation = function () {
	        var cursors = this.cursors;
	        for (var i = cursors.length; i--;)
	            cursors[i].style.animationDuration = this.blinkInterval + "ms";
	        this.$isAnimating = true;
	        setTimeout(function () {
	            if (this.$isAnimating) {
	                dom.addCssClass(this.element, "ace_animate-blinking");
	            }
	        }.bind(this));
	    };
	    Cursor.prototype.$stopCssAnimation = function () {
	        this.$isAnimating = false;
	        dom.removeCssClass(this.element, "ace_animate-blinking");
	    };
	    Cursor.prototype.setPadding = function (padding) {
	        this.$padding = padding;
	    };
	    Cursor.prototype.setSession = function (session) {
	        this.session = session;
	    };
	    Cursor.prototype.setBlinking = function (blinking) {
	        if (blinking != this.isBlinking) {
	            this.isBlinking = blinking;
	            this.restartTimer();
	        }
	    };
	    Cursor.prototype.setBlinkInterval = function (blinkInterval) {
	        if (blinkInterval != this.blinkInterval) {
	            this.blinkInterval = blinkInterval;
	            this.restartTimer();
	        }
	    };
	    Cursor.prototype.setSmoothBlinking = function (smoothBlinking) {
	        if (smoothBlinking != this.smoothBlinking) {
	            this.smoothBlinking = smoothBlinking;
	            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
	            this.$updateCursors(true);
	            this.restartTimer();
	        }
	    };
	    Cursor.prototype.addCursor = function () {
	        var el = dom.createElement("div");
	        el.className = "ace_cursor";
	        this.element.appendChild(el);
	        this.cursors.push(el);
	        return el;
	    };
	    Cursor.prototype.removeCursor = function () {
	        if (this.cursors.length > 1) {
	            var el = this.cursors.pop();
	            el.parentNode.removeChild(el);
	            return el;
	        }
	    };
	    Cursor.prototype.hideCursor = function () {
	        this.isVisible = false;
	        dom.addCssClass(this.element, "ace_hidden-cursors");
	        this.restartTimer();
	    };
	    Cursor.prototype.showCursor = function () {
	        this.isVisible = true;
	        dom.removeCssClass(this.element, "ace_hidden-cursors");
	        this.restartTimer();
	    };
	    Cursor.prototype.restartTimer = function () {
	        var update = this.$updateCursors;
	        clearInterval(this.intervalId);
	        clearTimeout(this.timeoutId);
	        this.$stopCssAnimation();
	        if (this.smoothBlinking) {
	            this.$isSmoothBlinking = false;
	            dom.removeCssClass(this.element, "ace_smooth-blinking");
	        }
	        update(true);
	        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
	            this.$stopCssAnimation();
	            return;
	        }
	        if (this.smoothBlinking) {
	            this.$isSmoothBlinking = true;
	            setTimeout(function () {
	                if (this.$isSmoothBlinking) {
	                    dom.addCssClass(this.element, "ace_smooth-blinking");
	                }
	            }.bind(this));
	        }
	        if (dom.HAS_CSS_ANIMATION) {
	            this.$startCssAnimation();
	        }
	        else {
	            var blink = /**@this{Cursor}*/ function () {
	                this.timeoutId = setTimeout(function () {
	                    update(false);
	                }, 0.6 * this.blinkInterval);
	            }.bind(this);
	            this.intervalId = setInterval(function () {
	                update(true);
	                blink();
	            }, this.blinkInterval);
	            blink();
	        }
	    };
	    Cursor.prototype.getPixelPosition = function (position, onScreen) {
	        if (!this.config || !this.session)
	            return { left: 0, top: 0 };
	        if (!position)
	            position = this.session.selection.getCursor();
	        var pos = this.session.documentToScreenPosition(position);
	        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
	            ? this.session.$bidiHandler.getPosLeft(pos.column)
	            : pos.column * this.config.characterWidth);
	        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
	            this.config.lineHeight;
	        return { left: cursorLeft, top: cursorTop };
	    };
	    Cursor.prototype.isCursorInView = function (pixelPos, config) {
	        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
	    };
	    Cursor.prototype.update = function (config) {
	        this.config = config;
	        var selections = this.session.$selectionMarkers;
	        var i = 0, cursorIndex = 0;
	        if (selections === undefined || selections.length === 0) {
	            selections = [{ cursor: null }];
	        }
	        for (var i = 0, n = selections.length; i < n; i++) {
	            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
	            if ((pixelPos.top > config.height + config.offset ||
	                pixelPos.top < 0) && i > 1) {
	                continue;
	            }
	            var element = this.cursors[cursorIndex++] || this.addCursor();
	            var style = element.style;
	            if (!this.drawCursor) {
	                if (!this.isCursorInView(pixelPos, config)) {
	                    dom.setStyle(style, "display", "none");
	                }
	                else {
	                    dom.setStyle(style, "display", "block");
	                    dom.translate(element, pixelPos.left, pixelPos.top);
	                    dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
	                    dom.setStyle(style, "height", config.lineHeight + "px");
	                }
	            }
	            else {
	                this.drawCursor(element, pixelPos, config, selections[i], this.session);
	            }
	        }
	        while (this.cursors.length > cursorIndex)
	            this.removeCursor();
	        var overwrite = this.session.getOverwrite();
	        this.$setOverwrite(overwrite);
	        this.$pixelPos = pixelPos;
	        this.restartTimer();
	    };
	    Cursor.prototype.$setOverwrite = function (overwrite) {
	        if (overwrite != this.overwrite) {
	            this.overwrite = overwrite;
	            if (overwrite)
	                dom.addCssClass(this.element, "ace_overwrite-cursors");
	            else
	                dom.removeCssClass(this.element, "ace_overwrite-cursors");
	        }
	    };
	    Cursor.prototype.destroy = function () {
	        clearInterval(this.intervalId);
	        clearTimeout(this.timeoutId);
	    };
	    return Cursor;
	}());
	Cursor.prototype.$padding = 0;
	Cursor.prototype.drawCursor = null;
	exports.Cursor = Cursor;

	});

	ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(require, exports, module){	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var oop = require("./lib/oop");
	var dom = require("./lib/dom");
	var event = require("./lib/event");
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var MAX_SCROLL_H = 0x8000;
	var Scrollbar = /** @class */ (function () {
	    function Scrollbar(parent, classSuffix) {
	        this.element = dom.createElement("div");
	        this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
	        this.inner = dom.createElement("div");
	        this.inner.className = "ace_scrollbar-inner";
	        this.inner.textContent = "\xa0";
	        this.element.appendChild(this.inner);
	        parent.appendChild(this.element);
	        this.setVisible(false);
	        this.skipEvent = false;
	        event.addListener(this.element, "scroll", this.onScroll.bind(this));
	        event.addListener(this.element, "mousedown", event.preventDefault);
	    }
	    Scrollbar.prototype.setVisible = function (isVisible) {
	        this.element.style.display = isVisible ? "" : "none";
	        this.isVisible = isVisible;
	        this.coeff = 1;
	    };
	    return Scrollbar;
	}());
	oop.implement(Scrollbar.prototype, EventEmitter);
	var VScrollBar = /** @class */ (function (_super) {
	    __extends(VScrollBar, _super);
	    function VScrollBar(parent, renderer) {
	        var _this = _super.call(this, parent, '-v') || this;
	        _this.scrollTop = 0;
	        _this.scrollHeight = 0;
	        renderer.$scrollbarWidth =
	            _this.width = dom.scrollbarWidth(parent.ownerDocument);
	        _this.inner.style.width =
	            _this.element.style.width = (_this.width || 15) + 5 + "px";
	        _this.$minWidth = 0;
	        return _this;
	    }
	    VScrollBar.prototype.onScroll = function () {
	        if (!this.skipEvent) {
	            this.scrollTop = this.element.scrollTop;
	            if (this.coeff != 1) {
	                var h = this.element.clientHeight / this.scrollHeight;
	                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
	            }
	            this._emit("scroll", { data: this.scrollTop });
	        }
	        this.skipEvent = false;
	    };
	    VScrollBar.prototype.getWidth = function () {
	        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
	    };
	    VScrollBar.prototype.setHeight = function (height) {
	        this.element.style.height = height + "px";
	    };
	    VScrollBar.prototype.setScrollHeight = function (height) {
	        this.scrollHeight = height;
	        if (height > MAX_SCROLL_H) {
	            this.coeff = MAX_SCROLL_H / height;
	            height = MAX_SCROLL_H;
	        }
	        else if (this.coeff != 1) {
	            this.coeff = 1;
	        }
	        this.inner.style.height = height + "px";
	    };
	    VScrollBar.prototype.setScrollTop = function (scrollTop) {
	        if (this.scrollTop != scrollTop) {
	            this.skipEvent = true;
	            this.scrollTop = scrollTop;
	            this.element.scrollTop = scrollTop * this.coeff;
	        }
	    };
	    return VScrollBar;
	}(Scrollbar));
	VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
	var HScrollBar = /** @class */ (function (_super) {
	    __extends(HScrollBar, _super);
	    function HScrollBar(parent, renderer) {
	        var _this = _super.call(this, parent, '-h') || this;
	        _this.scrollLeft = 0;
	        _this.height = renderer.$scrollbarWidth;
	        _this.inner.style.height =
	            _this.element.style.height = (_this.height || 15) + 5 + "px";
	        return _this;
	    }
	    HScrollBar.prototype.onScroll = function () {
	        if (!this.skipEvent) {
	            this.scrollLeft = this.element.scrollLeft;
	            this._emit("scroll", { data: this.scrollLeft });
	        }
	        this.skipEvent = false;
	    };
	    HScrollBar.prototype.getHeight = function () {
	        return this.isVisible ? this.height : 0;
	    };
	    HScrollBar.prototype.setWidth = function (width) {
	        this.element.style.width = width + "px";
	    };
	    HScrollBar.prototype.setInnerWidth = function (width) {
	        this.inner.style.width = width + "px";
	    };
	    HScrollBar.prototype.setScrollWidth = function (width) {
	        this.inner.style.width = width + "px";
	    };
	    HScrollBar.prototype.setScrollLeft = function (scrollLeft) {
	        if (this.scrollLeft != scrollLeft) {
	            this.skipEvent = true;
	            this.scrollLeft = this.element.scrollLeft = scrollLeft;
	        }
	    };
	    return HScrollBar;
	}(Scrollbar));
	exports.ScrollBar = VScrollBar; // backward compatibility
	exports.ScrollBarV = VScrollBar; // backward compatibility
	exports.ScrollBarH = HScrollBar; // backward compatibility
	exports.VScrollBar = VScrollBar;
	exports.HScrollBar = HScrollBar;

	});

	ace.define("ace/scrollbar_custom",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(require, exports, module){	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var oop = require("./lib/oop");
	var dom = require("./lib/dom");
	var event = require("./lib/event");
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
	var ScrollBar = /** @class */ (function () {
	    function ScrollBar(parent, classSuffix) {
	        this.element = dom.createElement("div");
	        this.element.className = "ace_sb" + classSuffix;
	        this.inner = dom.createElement("div");
	        this.inner.className = "";
	        this.element.appendChild(this.inner);
	        this.VScrollWidth = 12;
	        this.HScrollHeight = 12;
	        parent.appendChild(this.element);
	        this.setVisible(false);
	        this.skipEvent = false;
	        event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
	    }
	    ScrollBar.prototype.setVisible = function (isVisible) {
	        this.element.style.display = isVisible ? "" : "none";
	        this.isVisible = isVisible;
	        this.coeff = 1;
	    };
	    return ScrollBar;
	}());
	oop.implement(ScrollBar.prototype, EventEmitter);
	var VScrollBar = /** @class */ (function (_super) {
	    __extends(VScrollBar, _super);
	    function VScrollBar(parent, renderer) {
	        var _this = _super.call(this, parent, '-v') || this;
	        _this.scrollTop = 0;
	        _this.scrollHeight = 0;
	        _this.parent = parent;
	        _this.width = _this.VScrollWidth;
	        _this.renderer = renderer;
	        _this.inner.style.width = _this.element.style.width = (_this.width || 15) + "px";
	        _this.$minWidth = 0;
	        return _this;
	    }
	    VScrollBar.prototype.onMouseDown = function (eType, e) {
	        if (eType !== "mousedown")
	            return;
	        if (event.getButton(e) !== 0 || e.detail === 2) {
	            return;
	        }
	        if (e.target === this.inner) {
	            var self = this;
	            var mousePageY = e.clientY;
	            var onMouseMove = function (e) {
	                mousePageY = e.clientY;
	            };
	            var onMouseUp = function () {
	                clearInterval(timerId);
	            };
	            var startY = e.clientY;
	            var startTop = this.thumbTop;
	            var onScrollInterval = function () {
	                if (mousePageY === undefined)
	                    return;
	                var scrollTop = self.scrollTopFromThumbTop(startTop + mousePageY - startY);
	                if (scrollTop === self.scrollTop)
	                    return;
	                self._emit("scroll", { data: scrollTop });
	            };
	            event.capture(this.inner, onMouseMove, onMouseUp);
	            var timerId = setInterval(onScrollInterval, 20);
	            return event.preventDefault(e);
	        }
	        var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
	        this._emit("scroll", { data: this.scrollTopFromThumbTop(top) });
	        return event.preventDefault(e);
	    };
	    VScrollBar.prototype.getHeight = function () {
	        return this.height;
	    };
	    VScrollBar.prototype.scrollTopFromThumbTop = function (thumbTop) {
	        var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
	        scrollTop = scrollTop >> 0;
	        if (scrollTop < 0) {
	            scrollTop = 0;
	        }
	        else if (scrollTop > this.pageHeight - this.viewHeight) {
	            scrollTop = this.pageHeight - this.viewHeight;
	        }
	        return scrollTop;
	    };
	    VScrollBar.prototype.getWidth = function () {
	        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
	    };
	    VScrollBar.prototype.setHeight = function (height) {
	        this.height = Math.max(0, height);
	        this.slideHeight = this.height;
	        this.viewHeight = this.height;
	        this.setScrollHeight(this.pageHeight, true);
	    };
	    VScrollBar.prototype.setScrollHeight = function (height, force) {
	        if (this.pageHeight === height && !force)
	            return;
	        this.pageHeight = height;
	        this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
	        if (this.thumbHeight > this.slideHeight)
	            this.thumbHeight = this.slideHeight;
	        if (this.thumbHeight < 15)
	            this.thumbHeight = 15;
	        this.inner.style.height = this.thumbHeight + "px";
	        if (this.scrollTop > (this.pageHeight - this.viewHeight)) {
	            this.scrollTop = (this.pageHeight - this.viewHeight);
	            if (this.scrollTop < 0)
	                this.scrollTop = 0;
	            this._emit("scroll", { data: this.scrollTop });
	        }
	    };
	    VScrollBar.prototype.setScrollTop = function (scrollTop) {
	        this.scrollTop = scrollTop;
	        if (scrollTop < 0)
	            scrollTop = 0;
	        this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
	        this.inner.style.top = this.thumbTop + "px";
	    };
	    return VScrollBar;
	}(ScrollBar));
	VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
	var HScrollBar = /** @class */ (function (_super) {
	    __extends(HScrollBar, _super);
	    function HScrollBar(parent, renderer) {
	        var _this = _super.call(this, parent, '-h') || this;
	        _this.scrollLeft = 0;
	        _this.scrollWidth = 0;
	        _this.height = _this.HScrollHeight;
	        _this.inner.style.height = _this.element.style.height = (_this.height || 12) + "px";
	        _this.renderer = renderer;
	        return _this;
	    }
	    HScrollBar.prototype.onMouseDown = function (eType, e) {
	        if (eType !== "mousedown")
	            return;
	        if (event.getButton(e) !== 0 || e.detail === 2) {
	            return;
	        }
	        if (e.target === this.inner) {
	            var self = this;
	            var mousePageX = e.clientX;
	            var onMouseMove = function (e) {
	                mousePageX = e.clientX;
	            };
	            var onMouseUp = function () {
	                clearInterval(timerId);
	            };
	            var startX = e.clientX;
	            var startLeft = this.thumbLeft;
	            var onScrollInterval = function () {
	                if (mousePageX === undefined)
	                    return;
	                var scrollLeft = self.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
	                if (scrollLeft === self.scrollLeft)
	                    return;
	                self._emit("scroll", { data: scrollLeft });
	            };
	            event.capture(this.inner, onMouseMove, onMouseUp);
	            var timerId = setInterval(onScrollInterval, 20);
	            return event.preventDefault(e);
	        }
	        var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
	        this._emit("scroll", { data: this.scrollLeftFromThumbLeft(left) });
	        return event.preventDefault(e);
	    };
	    HScrollBar.prototype.getHeight = function () {
	        return this.isVisible ? this.height : 0;
	    };
	    HScrollBar.prototype.scrollLeftFromThumbLeft = function (thumbLeft) {
	        var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
	        scrollLeft = scrollLeft >> 0;
	        if (scrollLeft < 0) {
	            scrollLeft = 0;
	        }
	        else if (scrollLeft > this.pageWidth - this.viewWidth) {
	            scrollLeft = this.pageWidth - this.viewWidth;
	        }
	        return scrollLeft;
	    };
	    HScrollBar.prototype.setWidth = function (width) {
	        this.width = Math.max(0, width);
	        this.element.style.width = this.width + "px";
	        this.slideWidth = this.width;
	        this.viewWidth = this.width;
	        this.setScrollWidth(this.pageWidth, true);
	    };
	    HScrollBar.prototype.setScrollWidth = function (width, force) {
	        if (this.pageWidth === width && !force)
	            return;
	        this.pageWidth = width;
	        this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
	        if (this.thumbWidth > this.slideWidth)
	            this.thumbWidth = this.slideWidth;
	        if (this.thumbWidth < 15)
	            this.thumbWidth = 15;
	        this.inner.style.width = this.thumbWidth + "px";
	        if (this.scrollLeft > (this.pageWidth - this.viewWidth)) {
	            this.scrollLeft = (this.pageWidth - this.viewWidth);
	            if (this.scrollLeft < 0)
	                this.scrollLeft = 0;
	            this._emit("scroll", { data: this.scrollLeft });
	        }
	    };
	    HScrollBar.prototype.setScrollLeft = function (scrollLeft) {
	        this.scrollLeft = scrollLeft;
	        if (scrollLeft < 0)
	            scrollLeft = 0;
	        this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
	        this.inner.style.left = (this.thumbLeft) + "px";
	    };
	    return HScrollBar;
	}(ScrollBar));
	HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;
	exports.ScrollBar = VScrollBar; // backward compatibility
	exports.ScrollBarV = VScrollBar; // backward compatibility
	exports.ScrollBarH = HScrollBar; // backward compatibility
	exports.VScrollBar = VScrollBar;
	exports.HScrollBar = HScrollBar;

	});

	ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(require, exports, module){	var event = require("./lib/event");
	var RenderLoop = /** @class */ (function () {
	    function RenderLoop(onRender, win) {
	        this.onRender = onRender;
	        this.pending = false;
	        this.changes = 0;
	        this.$recursionLimit = 2;
	        this.window = win || window;
	        var _self = this;
	        this._flush = function (ts) {
	            _self.pending = false;
	            var changes = _self.changes;
	            if (changes) {
	                event.blockIdle(100);
	                _self.changes = 0;
	                _self.onRender(changes);
	            }
	            if (_self.changes) {
	                if (_self.$recursionLimit-- < 0)
	                    return;
	                _self.schedule();
	            }
	            else {
	                _self.$recursionLimit = 2;
	            }
	        };
	    }
	    RenderLoop.prototype.schedule = function (change) {
	        this.changes = this.changes | change;
	        if (this.changes && !this.pending) {
	            event.nextFrame(this._flush);
	            this.pending = true;
	        }
	    };
	    RenderLoop.prototype.clear = function (change) {
	        var changes = this.changes;
	        this.changes = 0;
	        return changes;
	    };
	    return RenderLoop;
	}());
	exports.RenderLoop = RenderLoop;

	});

	ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/lib/useragent","ace/lib/event_emitter"], function(require, exports, module){var oop = require("../lib/oop");
	var dom = require("../lib/dom");
	var lang = require("../lib/lang");
	var event = require("../lib/event");
	var useragent = require("../lib/useragent");
	var EventEmitter = require("../lib/event_emitter").EventEmitter;
	var CHAR_COUNT = 512;
	var USE_OBSERVER = typeof ResizeObserver == "function";
	var L = 200;
	var FontMetrics = /** @class */ (function () {
	    function FontMetrics(parentEl) {
	        this.el = dom.createElement("div");
	        this.$setMeasureNodeStyles(this.el.style, true);
	        this.$main = dom.createElement("div");
	        this.$setMeasureNodeStyles(this.$main.style);
	        this.$measureNode = dom.createElement("div");
	        this.$setMeasureNodeStyles(this.$measureNode.style);
	        this.el.appendChild(this.$main);
	        this.el.appendChild(this.$measureNode);
	        parentEl.appendChild(this.el);
	        this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
	        this.$characterSize = { width: 0, height: 0 };
	        if (USE_OBSERVER)
	            this.$addObserver();
	        else
	            this.checkForSizeChanges();
	    }
	    FontMetrics.prototype.$setMeasureNodeStyles = function (style, isRoot) {
	        style.width = style.height = "auto";
	        style.left = style.top = "0px";
	        style.visibility = "hidden";
	        style.position = "absolute";
	        style.whiteSpace = "pre";
	        if (useragent.isIE < 8) {
	            style["font-family"] = "inherit";
	        }
	        else {
	            style.font = "inherit";
	        }
	        style.overflow = isRoot ? "hidden" : "visible";
	    };
	    FontMetrics.prototype.checkForSizeChanges = function (size) {
	        if (size === undefined)
	            size = this.$measureSizes();
	        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
	            this.$measureNode.style.fontWeight = "bold";
	            var boldSize = this.$measureSizes();
	            this.$measureNode.style.fontWeight = "";
	            this.$characterSize = size;
	            this.charSizes = Object.create(null);
	            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
	            this._emit("changeCharacterSize", { data: size });
	        }
	    };
	    FontMetrics.prototype.$addObserver = function () {
	        var self = this;
	        this.$observer = new window.ResizeObserver(function (e) {
	            self.checkForSizeChanges();
	        });
	        this.$observer.observe(this.$measureNode);
	    };
	    FontMetrics.prototype.$pollSizeChanges = function () {
	        if (this.$pollSizeChangesTimer || this.$observer)
	            return this.$pollSizeChangesTimer;
	        var self = this;
	        return this.$pollSizeChangesTimer = event.onIdle(function cb() {
	            self.checkForSizeChanges();
	            event.onIdle(cb, 500);
	        }, 500);
	    };
	    FontMetrics.prototype.setPolling = function (val) {
	        if (val) {
	            this.$pollSizeChanges();
	        }
	        else if (this.$pollSizeChangesTimer) {
	            clearInterval(this.$pollSizeChangesTimer);
	            this.$pollSizeChangesTimer = 0;
	        }
	    };
	    FontMetrics.prototype.$measureSizes = function (node) {
	        var size = {
	            height: (node || this.$measureNode).clientHeight,
	            width: (node || this.$measureNode).clientWidth / CHAR_COUNT
	        };
	        if (size.width === 0 || size.height === 0)
	            return null;
	        return size;
	    };
	    FontMetrics.prototype.$measureCharWidth = function (ch) {
	        this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
	        var rect = this.$main.getBoundingClientRect();
	        return rect.width / CHAR_COUNT;
	    };
	    FontMetrics.prototype.getCharacterWidth = function (ch) {
	        var w = this.charSizes[ch];
	        if (w === undefined) {
	            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
	        }
	        return w;
	    };
	    FontMetrics.prototype.destroy = function () {
	        clearInterval(this.$pollSizeChangesTimer);
	        if (this.$observer)
	            this.$observer.disconnect();
	        if (this.el && this.el.parentNode)
	            this.el.parentNode.removeChild(this.el);
	    };
	    FontMetrics.prototype.$getZoom = function (element) {
	        if (!element || !element.parentElement)
	            return 1;
	        return (Number(window.getComputedStyle(element)["zoom"]) || 1) * this.$getZoom(element.parentElement);
	    };
	    FontMetrics.prototype.$initTransformMeasureNodes = function () {
	        var t = function (t, l) {
	            return ["div", {
	                    style: "position: absolute;top:" + t + "px;left:" + l + "px;"
	                }];
	        };
	        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
	    };
	    FontMetrics.prototype.transformCoordinates = function (clientPos, elPos) {
	        if (clientPos) {
	            var zoom = this.$getZoom(this.el);
	            clientPos = mul(1 / zoom, clientPos);
	        }
	        function solve(l1, l2, r) {
	            var det = l1[1] * l2[0] - l1[0] * l2[1];
	            return [
	                (-l2[1] * r[0] + l2[0] * r[1]) / det,
	                (+l1[1] * r[0] - l1[0] * r[1]) / det
	            ];
	        }
	        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }
	        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }
	        function mul(a, b) { return [a * b[0], a * b[1]]; }
	        if (!this.els)
	            this.$initTransformMeasureNodes();
	        function p(el) {
	            var r = el.getBoundingClientRect();
	            return [r.left, r.top];
	        }
	        var a = p(this.els[0]);
	        var b = p(this.els[1]);
	        var c = p(this.els[2]);
	        var d = p(this.els[3]);
	        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));
	        var m1 = mul(1 + h[0], sub(b, a));
	        var m2 = mul(1 + h[1], sub(c, a));
	        if (elPos) {
	            var x = elPos;
	            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
	            var ut = add(mul(x[0], m1), mul(x[1], m2));
	            return add(mul(1 / k / L, ut), a);
	        }
	        var u = sub(clientPos, a);
	        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
	        return mul(L, f);
	    };
	    return FontMetrics;
	}());
	FontMetrics.prototype.$characterSize = { width: 0, height: 0 };
	oop.implement(FontMetrics.prototype, EventEmitter);
	exports.FontMetrics = FontMetrics;

	});

	ace.define("ace/css/editor-css",["require","exports","module"], function(require, exports, module){/*
	styles = []
	for (var i = 1; i < 16; i++) {
	    styles.push(".ace_br" + i + "{" + (
	        ["top-left", "top-right", "bottom-right", "bottom-left"]
	    ).map(function(x, j) {
	        return i & (1<<j) ? "border-" + x + "-radius: 3px;" : ""
	    }).filter(Boolean).join(" ") + "}")
	}
	styles.join("\\n")
	*/
	module.exports = "\n.ace_br1 {border-top-left-radius    : 3px;}\n.ace_br2 {border-top-right-radius   : 3px;}\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\n.ace_br4 {border-bottom-right-radius: 3px;}\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\n.ace_br8 {border-bottom-left-radius : 3px;}\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\n\n\n.ace_editor {\n    position: relative;\n    overflow: hidden;\n    padding: 0;\n    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;\n    direction: ltr;\n    text-align: left;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    forced-color-adjust: none;\n}\n\n.ace_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    background-color: inherit;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    cursor: text;\n}\n\n.ace_content {\n    position: absolute;\n    box-sizing: border-box;\n    min-width: 100%;\n    contain: style size layout;\n    font-variant-ligatures: no-common-ligatures;\n}\n.ace_invisible {\n    font-variant-ligatures: none;\n}\n\n.ace_keyboard-focus:focus {\n    box-shadow: inset 0 0 0 2px #5E9ED6;\n    outline: none;\n}\n\n.ace_dragging .ace_scroller:before{\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    content: '';\n    background: rgba(250, 250, 250, 0.01);\n    z-index: 1000;\n}\n.ace_dragging.ace_dark .ace_scroller:before{\n    background: rgba(0, 0, 0, 0.01);\n}\n\n.ace_gutter {\n    position: absolute;\n    overflow : hidden;\n    width: auto;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    cursor: default;\n    z-index: 4;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    contain: style size layout;\n}\n\n.ace_gutter-active-line {\n    position: absolute;\n    left: 0;\n    right: 0;\n}\n\n.ace_scroller.ace_scroll-left:after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\n    pointer-events: none;\n}\n\n.ace_gutter-cell, .ace_gutter-cell_svg-icons {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    padding-left: 19px;\n    padding-right: 6px;\n    background-repeat: no-repeat;\n}\n\n.ace_gutter-cell_svg-icons .ace_gutter_annotation {\n    margin-left: -14px;\n    float: left;\n}\n\n.ace_gutter-cell .ace_gutter_annotation {\n    margin-left: -19px;\n    float: left;\n}\n\n.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\n}\n\n.ace_icon_svg.ace_error {\n    -webkit-mask-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+\");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_security {\n    -webkit-mask-image: url(\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+\");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_warning {\n    -webkit-mask-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==\");\n    background-color: darkorange;\n}\n.ace_icon_svg.ace_info {\n    -webkit-mask-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==\");\n    background-color: royalblue;\n}\n.ace_icon_svg.ace_hint {\n    -webkit-mask-image: url(\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==\");\n    background-color: silver;\n}\n\n.ace_icon_svg.ace_error_fold {\n    -webkit-mask-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=\");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_security_fold {\n    -webkit-mask-image: url(\"data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=\");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_warning_fold {\n    -webkit-mask-image: url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=\");\n    background-color: darkorange;\n}\n\n.ace_scrollbar {\n    contain: strict;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    z-index: 6;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-v{\n    overflow-x: hidden;\n    overflow-y: scroll;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    overflow-x: scroll;\n    overflow-y: hidden;\n    left: 0;\n}\n\n.ace_print-margin {\n    position: absolute;\n    height: 100%;\n}\n\n.ace_text-input {\n    position: absolute;\n    z-index: 0;\n    width: 0.5em;\n    height: 1em;\n    opacity: 0;\n    background: transparent;\n    -moz-appearance: none;\n    appearance: none;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    font: inherit;\n    padding: 0 1px;\n    margin: 0 -1px;\n    contain: strict;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    /*with `pre-line` chrome inserts &nbsp; instead of space*/\n    white-space: pre!important;\n}\n.ace_text-input.ace_composition {\n    background: transparent;\n    color: inherit;\n    z-index: 1000;\n    opacity: 1;\n}\n.ace_composition_placeholder { color: transparent }\n.ace_composition_marker { \n    border-bottom: 1px solid;\n    position: absolute;\n    border-radius: 0;\n    margin-top: 1px;\n}\n\n[ace_nocontext=true] {\n    transform: none!important;\n    filter: none!important;\n    clip-path: none!important;\n    mask : none!important;\n    contain: none!important;\n    perspective: none!important;\n    mix-blend-mode: initial!important;\n    z-index: auto;\n}\n\n.ace_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\n    word-wrap: normal;\n    white-space: pre;\n    height: 100%;\n    width: 100%;\n    box-sizing: border-box;\n    /* setting pointer-events: auto; on node under the mouse, which changes\n        during scroll, will break mouse wheel scrolling in Safari */\n    pointer-events: none;\n}\n\n.ace_gutter-layer {\n    position: relative;\n    width: auto;\n    text-align: right;\n    pointer-events: auto;\n    height: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer {\n    font: inherit !important;\n    position: absolute;\n    height: 1000000px;\n    width: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\n    contain: style size layout;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n}\n\n.ace_hidpi .ace_text-layer,\n.ace_hidpi .ace_gutter-layer,\n.ace_hidpi .ace_content,\n.ace_hidpi .ace_gutter {\n    contain: strict;\n}\n.ace_hidpi .ace_text-layer > .ace_line, \n.ace_hidpi .ace_text-layer > .ace_line_group {\n    contain: strict;\n}\n\n.ace_cjk {\n    display: inline-block;\n    text-align: center;\n}\n\n.ace_cursor-layer {\n    z-index: 4;\n}\n\n.ace_cursor {\n    z-index: 4;\n    position: absolute;\n    box-sizing: border-box;\n    border-left: 2px solid;\n    /* workaround for smooth cursor repaintng whole screen in chrome */\n    transform: translatez(0);\n}\n\n.ace_multiselect .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_slim-cursors .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_overwrite-cursors .ace_cursor {\n    border-left-width: 0;\n    border-bottom: 1px solid;\n}\n\n.ace_hidden-cursors .ace_cursor {\n    opacity: 0.2;\n}\n\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\n    opacity: 0;\n}\n\n.ace_smooth-blinking .ace_cursor {\n    transition: opacity 0.18s;\n}\n\n.ace_animate-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: step-end;\n    animation-name: blink-ace-animate;\n    animation-iteration-count: infinite;\n}\n\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: ease-in-out;\n    animation-name: blink-ace-animate-smooth;\n}\n    \n@keyframes blink-ace-animate {\n    from, to { opacity: 1; }\n    60% { opacity: 0; }\n}\n\n@keyframes blink-ace-animate-smooth {\n    from, to { opacity: 1; }\n    45% { opacity: 1; }\n    60% { opacity: 0; }\n    85% { opacity: 0; }\n}\n\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\n    position: absolute;\n    z-index: 3;\n}\n\n.ace_marker-layer .ace_selection {\n    position: absolute;\n    z-index: 5;\n}\n\n.ace_marker-layer .ace_bracket {\n    position: absolute;\n    z-index: 6;\n}\n\n.ace_marker-layer .ace_error_bracket {\n    position: absolute;\n    border-bottom: 1px solid #DE5555;\n    border-radius: 0;\n}\n\n.ace_marker-layer .ace_active-line {\n    position: absolute;\n    z-index: 2;\n}\n\n.ace_marker-layer .ace_selected-word {\n    position: absolute;\n    z-index: 4;\n    box-sizing: border-box;\n}\n\n.ace_line .ace_fold {\n    box-sizing: border-box;\n\n    display: inline-block;\n    height: 11px;\n    margin-top: -2px;\n    vertical-align: middle;\n\n    background-image:\n        url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\n        url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\n    background-repeat: no-repeat, repeat-x;\n    background-position: center center, top left;\n    color: transparent;\n\n    border: 1px solid black;\n    border-radius: 2px;\n\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_dark .ace_fold {\n}\n\n.ace_fold:hover{\n    background-image:\n        url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\n        url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\n}\n\n.ace_tooltip {\n    background-color: #f5f5f5;\n    border: 1px solid gray;\n    border-radius: 1px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n    color: black;\n    padding: 3px 4px;\n    position: absolute;\n    z-index: 999999;\n    box-sizing: border-box;\n    cursor: default;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n    line-height: normal;\n    font-style: normal;\n    font-weight: normal;\n    letter-spacing: normal;\n    pointer-events: none;\n    overflow: auto;\n    max-width: min(33em, 66vw);\n    overscroll-behavior: contain;\n}\n.ace_tooltip pre {\n    white-space: pre-wrap;\n}\n\n.ace_tooltip.ace_dark {\n    background-color: #636363;\n    color: #fff;\n}\n\n.ace_tooltip:focus {\n    outline: 1px solid #5E9ED6;\n}\n\n.ace_icon {\n    display: inline-block;\n    width: 18px;\n    vertical-align: top;\n}\n\n.ace_icon_svg {\n    display: inline-block;\n    width: 12px;\n    vertical-align: top;\n    -webkit-mask-repeat: no-repeat;\n    -webkit-mask-size: 12px;\n    -webkit-mask-position: center;\n}\n\n.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {\n    padding-right: 13px;\n}\n\n.ace_fold-widget, .ace_custom-widget {\n    box-sizing: border-box;\n\n    margin: 0 -12px 0 1px;\n    display: none;\n    width: 11px;\n    vertical-align: top;\n\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\n    background-repeat: no-repeat;\n    background-position: center;\n\n    border-radius: 3px;\n    \n    border: 1px solid transparent;\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_custom-widget {\n    background: none;\n}\n\n.ace_folding-enabled .ace_fold-widget {\n    display: inline-block;   \n}\n\n.ace_fold-widget.ace_end {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\n}\n\n.ace_fold-widget.ace_closed {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\n}\n\n.ace_fold-widget:hover {\n    border: 1px solid rgba(0, 0, 0, 0.3);\n    background-color: rgba(255, 255, 255, 0.2);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n}\n\n.ace_fold-widget:active {\n    border: 1px solid rgba(0, 0, 0, 0.4);\n    background-color: rgba(0, 0, 0, 0.05);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n}\n/**\n * Dark version for fold widgets\n */\n.ace_dark .ace_fold-widget {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\n}\n.ace_dark .ace_fold-widget.ace_end {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\n}\n.ace_dark .ace_fold-widget.ace_closed {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\n}\n.ace_dark .ace_fold-widget:hover {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n    background-color: rgba(255, 255, 255, 0.1);\n}\n.ace_dark .ace_fold-widget:active {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n}\n\n.ace_inline_button {\n    border: 1px solid lightgray;\n    display: inline-block;\n    margin: -1px 8px;\n    padding: 0 5px;\n    pointer-events: auto;\n    cursor: pointer;\n}\n.ace_inline_button:hover {\n    border-color: gray;\n    background: rgba(200,200,200,0.2);\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_fold-widget.ace_invalid {\n    background-color: #FFB4B4;\n    border-color: #DE5555;\n}\n\n.ace_fade-fold-widgets .ace_fold-widget {\n    transition: opacity 0.4s ease 0.05s;\n    opacity: 0;\n}\n\n.ace_fade-fold-widgets:hover .ace_fold-widget {\n    transition: opacity 0.05s ease 0.05s;\n    opacity:1;\n}\n\n.ace_underline {\n    text-decoration: underline;\n}\n\n.ace_bold {\n    font-weight: bold;\n}\n\n.ace_nobold .ace_bold {\n    font-weight: normal;\n}\n\n.ace_italic {\n    font-style: italic;\n}\n\n\n.ace_error-marker {\n    background-color: rgba(255, 0, 0,0.2);\n    position: absolute;\n    z-index: 9;\n}\n\n.ace_highlight-marker {\n    background-color: rgba(255, 255, 0,0.2);\n    position: absolute;\n    z-index: 8;\n}\n\n.ace_mobile-menu {\n    position: absolute;\n    line-height: 1.5;\n    border-radius: 4px;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    background: white;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #dcdcdc;\n    color: black;\n}\n.ace_dark > .ace_mobile-menu {\n    background: #333;\n    color: #ccc;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #444;\n\n}\n.ace_mobile-button {\n    padding: 2px;\n    cursor: pointer;\n    overflow: hidden;\n}\n.ace_mobile-button:hover {\n    background-color: #eee;\n    opacity:1;\n}\n.ace_mobile-button:active {\n    background-color: #ddd;\n}\n\n.ace_placeholder {\n    position: relative;\n    font-family: arial;\n    transform: scale(0.9);\n    transform-origin: left;\n    white-space: pre;\n    opacity: 0.7;\n    margin: 0 10px;\n    z-index: 1;\n}\n\n.ace_ghost_text {\n    opacity: 0.5;\n    font-style: italic;\n}\n\n.ace_ghost_text_container > div {\n    white-space: pre;\n}\n\n.ghost_text_line_wrapped::after {\n    content: \"\u21A9\";\n    position: absolute;\n}\n\n.ace_lineWidgetContainer.ace_ghost_text {\n    margin: 0px 4px\n}\n\n.ace_screenreader-only {\n    position:absolute;\n    left:-10000px;\n    top:auto;\n    width:1px;\n    height:1px;\n    overflow:hidden;\n}\n\n.ace_hidden_token {\n    display: none;\n}";

	});

	ace.define("ace/layer/decorators",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module){	var dom = require("../lib/dom");
	var oop = require("../lib/oop");
	var EventEmitter = require("../lib/event_emitter").EventEmitter;
	var Decorator = /** @class */ (function () {
	    function Decorator(scrollbarV, renderer) {
	        this.renderer = renderer;
	        this.pixelRatio = 1;
	        this.maxHeight = renderer.layerConfig.maxHeight;
	        this.lineHeight = renderer.layerConfig.lineHeight;
	        this.minDecorationHeight = (2 * this.pixelRatio) | 0;
	        this.halfMinDecorationHeight = (this.minDecorationHeight / 2) | 0;
	        this.colors = {};
	        this.colors.dark = {
	            "error": "rgba(255, 18, 18, 1)",
	            "warning": "rgba(18, 136, 18, 1)",
	            "info": "rgba(18, 18, 136, 1)",
	        };
	        this.colors.light = {
	            "error": "rgb(255,51,51)",
	            "warning": "rgb(32,133,72)",
	            "info": "rgb(35,68,138)",
	        };
	        this.setScrollBarV(scrollbarV);
	    }
	    Decorator.prototype.$createCanvas = function () {
	        this.canvas = dom.createElement("canvas");
	        this.canvas.style.top = 0 + "px";
	        this.canvas.style.right = 0 + "px";
	        this.canvas.style.zIndex = "7";
	        this.canvas.style.position = "absolute";
	    };
	    Decorator.prototype.setScrollBarV = function (scrollbarV) {
	        this.$createCanvas();
	        this.scrollbarV = scrollbarV;
	        scrollbarV.element.appendChild(this.canvas);
	        this.setDimensions();
	    };
	    Decorator.prototype.$updateDecorators = function (config) {
	        if (typeof this.canvas.getContext !== "function") {
	            return;
	        }
	        var colors = (this.renderer.theme.isDark === true) ? this.colors.dark : this.colors.light;
	        this.setDimensions(config);
	        var ctx = this.canvas.getContext("2d");
	        function compare(a, b) {
	            if (a.priority < b.priority)
	                return -1;
	            if (a.priority > b.priority)
	                return 1;
	            return 0;
	        }
	        var annotations = this.renderer.session.$annotations;
	        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
	        if (annotations) {
	            var priorities = {
	                "info": 1,
	                "warning": 2,
	                "error": 3
	            };
	            annotations.forEach(function (item) {
	                item["priority"] = priorities[item.type] || null;
	            });
	            annotations = annotations.sort(compare);
	            for (var i = 0; i < annotations.length; i++) {
	                var row = annotations[i].row;
	                var offset1 = this.getVerticalOffsetForRow(row);
	                var offset2 = offset1 + this.lineHeight;
	                var y1 = Math.round(this.heightRatio * offset1);
	                var y2 = Math.round(this.heightRatio * offset2);
	                var ycenter = Math.round((y1 + y2) / 2);
	                var halfHeight = (y2 - ycenter);
	                if (halfHeight < this.halfMinDecorationHeight) {
	                    halfHeight = this.halfMinDecorationHeight;
	                }
	                if (ycenter - halfHeight < 0) {
	                    ycenter = halfHeight;
	                }
	                if (ycenter + halfHeight > this.canvasHeight) {
	                    ycenter = this.canvasHeight - halfHeight;
	                }
	                var from = ycenter - halfHeight;
	                var to = ycenter + halfHeight;
	                var zoneHeight = to - from;
	                ctx.fillStyle = colors[annotations[i].type] || null;
	                ctx.fillRect(0, from, Math.round(this.oneZoneWidth - 1), zoneHeight);
	            }
	        }
	        var cursor = this.renderer.session.selection.getCursor();
	        if (cursor) {
	            var currentY = Math.round(this.getVerticalOffsetForRow(cursor.row) * this.heightRatio);
	            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
	            ctx.fillRect(0, currentY, this.canvasWidth, 2);
	        }
	    };
	    Decorator.prototype.getVerticalOffsetForRow = function (row) {
	        row = row | 0;
	        var offset = this.renderer.session.documentToScreenRow(row, 0) * this.lineHeight;
	        return offset;
	    };
	    Decorator.prototype.setDimensions = function (config) {
	        config = config || this.renderer.layerConfig;
	        this.maxHeight = config.maxHeight;
	        this.lineHeight = config.lineHeight;
	        this.canvasHeight = config.height;
	        this.canvasWidth = this.scrollbarV.width || this.canvasWidth;
	        this.setZoneWidth();
	        this.canvas.width = this.canvasWidth;
	        this.canvas.height = this.canvasHeight;
	        if (this.maxHeight < this.canvasHeight) {
	            this.heightRatio = 1;
	        }
	        else {
	            this.heightRatio = this.canvasHeight / this.maxHeight;
	        }
	    };
	    Decorator.prototype.setZoneWidth = function () {
	        this.oneZoneWidth = this.canvasWidth;
	    };
	    Decorator.prototype.destroy = function () {
	        this.canvas.parentNode.removeChild(this.canvas);
	    };
	    return Decorator;
	}());
	oop.implement(Decorator.prototype, EventEmitter);
	exports.Decorator = Decorator;

	});

	ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/config","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/scrollbar_custom","ace/scrollbar_custom","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter","ace/css/editor-css","ace/layer/decorators","ace/lib/useragent","ace/layer/text_util"], function(require, exports, module){	var oop = require("./lib/oop");
	var dom = require("./lib/dom");
	var lang = require("./lib/lang");
	var config = require("./config");
	var GutterLayer = require("./layer/gutter").Gutter;
	var MarkerLayer = require("./layer/marker").Marker;
	var TextLayer = require("./layer/text").Text;
	var CursorLayer = require("./layer/cursor").Cursor;
	var HScrollBar = require("./scrollbar").HScrollBar;
	var VScrollBar = require("./scrollbar").VScrollBar;
	var HScrollBarCustom = require("./scrollbar_custom").HScrollBar;
	var VScrollBarCustom = require("./scrollbar_custom").VScrollBar;
	var RenderLoop = require("./renderloop").RenderLoop;
	var FontMetrics = require("./layer/font_metrics").FontMetrics;
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var editorCss = require("./css/editor-css");
	var Decorator = require("./layer/decorators").Decorator;
	var useragent = require("./lib/useragent");
	var isTextToken = require("./layer/text_util").isTextToken;
	dom.importCssString(editorCss, "ace_editor.css", false);
	var VirtualRenderer = /** @class */ (function () {
	    function VirtualRenderer(container, theme) {
	        var _self = this;
	        this.container = container || dom.createElement("div");
	        dom.addCssClass(this.container, "ace_editor");
	        if (dom.HI_DPI)
	            dom.addCssClass(this.container, "ace_hidpi");
	        this.setTheme(theme);
	        if (config.get("useStrictCSP") == null)
	            config.set("useStrictCSP", false);
	        this.$gutter = dom.createElement("div");
	        this.$gutter.className = "ace_gutter";
	        this.container.appendChild(this.$gutter);
	        this.$gutter.setAttribute("aria-hidden", "true");
	        this.scroller = dom.createElement("div");
	        this.scroller.className = "ace_scroller";
	        this.container.appendChild(this.scroller);
	        this.content = dom.createElement("div");
	        this.content.className = "ace_content";
	        this.scroller.appendChild(this.content);
	        this.$gutterLayer = new GutterLayer(this.$gutter);
	        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
	        this.$markerBack = new MarkerLayer(this.content);
	        var textLayer = this.$textLayer = new TextLayer(this.content);
	        this.canvas = textLayer.element;
	        this.$markerFront = new MarkerLayer(this.content);
	        this.$cursorLayer = new CursorLayer(this.content);
	        this.$horizScroll = false;
	        this.$vScroll = false;
	        this.scrollBar =
	            this.scrollBarV = new VScrollBar(this.container, this);
	        this.scrollBarH = new HScrollBar(this.container, this);
	        this.scrollBarV.on("scroll", function (e) {
	            if (!_self.$scrollAnimation)
	                _self.session.setScrollTop(e.data - _self.scrollMargin.top);
	        });
	        this.scrollBarH.on("scroll", function (e) {
	            if (!_self.$scrollAnimation)
	                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
	        });
	        this.scrollTop = 0;
	        this.scrollLeft = 0;
	        this.cursorPos = {
	            row: 0,
	            column: 0
	        };
	        this.$fontMetrics = new FontMetrics(this.container);
	        this.$textLayer.$setFontMetrics(this.$fontMetrics);
	        this.$textLayer.on("changeCharacterSize", function (e) {
	            _self.updateCharacterSize();
	            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
	            _self._signal("changeCharacterSize", e);
	        });
	        this.$size = {
	            width: 0,
	            height: 0,
	            scrollerHeight: 0,
	            scrollerWidth: 0,
	            $dirty: true
	        };
	        this.layerConfig = {
	            width: 1,
	            padding: 0,
	            firstRow: 0,
	            firstRowScreen: 0,
	            lastRow: 0,
	            lineHeight: 0,
	            characterWidth: 0,
	            minHeight: 1,
	            maxHeight: 1,
	            offset: 0,
	            height: 1,
	            gutterOffset: 1
	        };
	        this.scrollMargin = {
	            left: 0,
	            right: 0,
	            top: 0,
	            bottom: 0,
	            v: 0,
	            h: 0
	        };
	        this.margin = {
	            left: 0,
	            right: 0,
	            top: 0,
	            bottom: 0,
	            v: 0,
	            h: 0
	        };
	        this.$keepTextAreaAtCursor = !useragent.isIOS;
	        this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
	        this.$loop.schedule(this.CHANGE_FULL);
	        this.updateCharacterSize();
	        this.setPadding(4);
	        this.$addResizeObserver();
	        config.resetOptions(this);
	        config._signal("renderer", this);
	    }
	    VirtualRenderer.prototype.updateCharacterSize = function () {
	        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
	            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
	            this.setStyle("ace_nobold", !this.$allowBoldFonts);
	        }
	        this.layerConfig.characterWidth =
	            this.characterWidth = this.$textLayer.getCharacterWidth();
	        this.layerConfig.lineHeight =
	            this.lineHeight = this.$textLayer.getLineHeight();
	        this.$updatePrintMargin();
	        dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
	    };
	    VirtualRenderer.prototype.setSession = function (session) {
	        if (this.session)
	            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
	        this.session = session;
	        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
	            session.setScrollTop(-this.scrollMargin.top);
	        this.$cursorLayer.setSession(session);
	        this.$markerBack.setSession(session);
	        this.$markerFront.setSession(session);
	        this.$gutterLayer.setSession(session);
	        this.$textLayer.setSession(session);
	        if (!session)
	            return;
	        this.$loop.schedule(this.CHANGE_FULL);
	        this.session.$setFontMetrics(this.$fontMetrics);
	        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
	        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
	        this.onChangeNewLineMode();
	        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
	    };
	    VirtualRenderer.prototype.updateLines = function (firstRow, lastRow, force) {
	        if (lastRow === undefined)
	            lastRow = Infinity;
	        if (!this.$changedLines) {
	            this.$changedLines = {
	                firstRow: firstRow,
	                lastRow: lastRow
	            };
	        }
	        else {
	            if (this.$changedLines.firstRow > firstRow)
	                this.$changedLines.firstRow = firstRow;
	            if (this.$changedLines.lastRow < lastRow)
	                this.$changedLines.lastRow = lastRow;
	        }
	        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
	            if (force)
	                this.$changedLines.lastRow = this.layerConfig.lastRow;
	            else
	                return;
	        }
	        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
	            return;
	        this.$loop.schedule(this.CHANGE_LINES);
	    };
	    VirtualRenderer.prototype.onChangeNewLineMode = function () {
	        this.$loop.schedule(this.CHANGE_TEXT);
	        this.$textLayer.$updateEolChar();
	        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
	    };
	    VirtualRenderer.prototype.onChangeTabSize = function () {
	        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
	        this.$textLayer.onChangeTabSize();
	    };
	    VirtualRenderer.prototype.updateText = function () {
	        this.$loop.schedule(this.CHANGE_TEXT);
	    };
	    VirtualRenderer.prototype.updateFull = function (force) {
	        if (force)
	            this.$renderChanges(this.CHANGE_FULL, true);
	        else
	            this.$loop.schedule(this.CHANGE_FULL);
	    };
	    VirtualRenderer.prototype.updateFontSize = function () {
	        this.$textLayer.checkForSizeChanges();
	    };
	    VirtualRenderer.prototype.$updateSizeAsync = function () {
	        if (this.$loop.pending)
	            this.$size.$dirty = true;
	        else
	            this.onResize();
	    };
	    VirtualRenderer.prototype.onResize = function (force, gutterWidth, width, height) {
	        if (this.resizing > 2)
	            return;
	        else if (this.resizing > 0)
	            this.resizing++;
	        else
	            this.resizing = force ? 1 : 0;
	        var el = this.container;
	        if (!height)
	            height = el.clientHeight || el.scrollHeight;
	        if (!height && this.$maxLines && this.lineHeight > 1) {
	            if (!el.style.height || el.style.height == "0px") {
	                el.style.height = "1px";
	                height = el.clientHeight || el.scrollHeight;
	            }
	        }
	        if (!width)
	            width = el.clientWidth || el.scrollWidth;
	        var changes = this.$updateCachedSize(force, gutterWidth, width, height);
	        if (this.$resizeTimer)
	            this.$resizeTimer.cancel();
	        if (!this.$size.scrollerHeight || (!width && !height))
	            return this.resizing = 0;
	        if (force)
	            this.$gutterLayer.$padding = null;
	        if (force)
	            this.$renderChanges(changes | this.$changes, true);
	        else
	            this.$loop.schedule(changes | this.$changes);
	        if (this.resizing)
	            this.resizing = 0;
	        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
	        if (this.$customScrollbar) {
	            this.$updateCustomScrollbar(true);
	        }
	    };
	    VirtualRenderer.prototype.$updateCachedSize = function (force, gutterWidth, width, height) {
	        height -= (this.$extraHeight || 0);
	        var changes = 0;
	        var size = this.$size;
	        var oldSize = {
	            width: size.width,
	            height: size.height,
	            scrollerHeight: size.scrollerHeight,
	            scrollerWidth: size.scrollerWidth
	        };
	        if (height && (force || size.height != height)) {
	            size.height = height;
	            changes |= this.CHANGE_SIZE;
	            size.scrollerHeight = size.height;
	            if (this.$horizScroll)
	                size.scrollerHeight -= this.scrollBarH.getHeight();
	            this.scrollBarV.setHeight(size.scrollerHeight);
	            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
	            changes = changes | this.CHANGE_SCROLL;
	        }
	        if (width && (force || size.width != width)) {
	            changes |= this.CHANGE_SIZE;
	            size.width = width;
	            if (gutterWidth == null)
	                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
	            this.gutterWidth = gutterWidth;
	            dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
	            dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
	            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
	            dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
	            var right = this.scrollBarV.getWidth() + "px";
	            dom.setStyle(this.scrollBarH.element.style, "right", right);
	            dom.setStyle(this.scroller.style, "right", right);
	            dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
	            this.scrollBarH.setWidth(size.scrollerWidth);
	            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
	                changes |= this.CHANGE_FULL;
	            }
	        }
	        size.$dirty = !width || !height;
	        if (changes)
	            this._signal("resize", oldSize);
	        return changes;
	    };
	    VirtualRenderer.prototype.onGutterResize = function (width) {
	        var gutterWidth = this.$showGutter ? width : 0;
	        if (gutterWidth != this.gutterWidth)
	            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
	        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
	            this.$loop.schedule(this.CHANGE_FULL);
	        }
	        else if (this.$size.$dirty) {
	            this.$loop.schedule(this.CHANGE_FULL);
	        }
	        else {
	            this.$computeLayerConfig();
	        }
	    };
	    VirtualRenderer.prototype.adjustWrapLimit = function () {
	        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
	        var limit = Math.floor(availableWidth / this.characterWidth);
	        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
	    };
	    VirtualRenderer.prototype.setAnimatedScroll = function (shouldAnimate) {
	        this.setOption("animatedScroll", shouldAnimate);
	    };
	    VirtualRenderer.prototype.getAnimatedScroll = function () {
	        return this.$animatedScroll;
	    };
	    VirtualRenderer.prototype.setShowInvisibles = function (showInvisibles) {
	        this.setOption("showInvisibles", showInvisibles);
	        this.session.$bidiHandler.setShowInvisibles(showInvisibles);
	    };
	    VirtualRenderer.prototype.getShowInvisibles = function () {
	        return this.getOption("showInvisibles");
	    };
	    VirtualRenderer.prototype.getDisplayIndentGuides = function () {
	        return this.getOption("displayIndentGuides");
	    };
	    VirtualRenderer.prototype.setDisplayIndentGuides = function (display) {
	        this.setOption("displayIndentGuides", display);
	    };
	    VirtualRenderer.prototype.getHighlightIndentGuides = function () {
	        return this.getOption("highlightIndentGuides");
	    };
	    VirtualRenderer.prototype.setHighlightIndentGuides = function (highlight) {
	        this.setOption("highlightIndentGuides", highlight);
	    };
	    VirtualRenderer.prototype.setShowPrintMargin = function (showPrintMargin) {
	        this.setOption("showPrintMargin", showPrintMargin);
	    };
	    VirtualRenderer.prototype.getShowPrintMargin = function () {
	        return this.getOption("showPrintMargin");
	    };
	    VirtualRenderer.prototype.setPrintMarginColumn = function (printMarginColumn) {
	        this.setOption("printMarginColumn", printMarginColumn);
	    };
	    VirtualRenderer.prototype.getPrintMarginColumn = function () {
	        return this.getOption("printMarginColumn");
	    };
	    VirtualRenderer.prototype.getShowGutter = function () {
	        return this.getOption("showGutter");
	    };
	    VirtualRenderer.prototype.setShowGutter = function (show) {
	        return this.setOption("showGutter", show);
	    };
	    VirtualRenderer.prototype.getFadeFoldWidgets = function () {
	        return this.getOption("fadeFoldWidgets");
	    };
	    VirtualRenderer.prototype.setFadeFoldWidgets = function (show) {
	        this.setOption("fadeFoldWidgets", show);
	    };
	    VirtualRenderer.prototype.setHighlightGutterLine = function (shouldHighlight) {
	        this.setOption("highlightGutterLine", shouldHighlight);
	    };
	    VirtualRenderer.prototype.getHighlightGutterLine = function () {
	        return this.getOption("highlightGutterLine");
	    };
	    VirtualRenderer.prototype.$updatePrintMargin = function () {
	        if (!this.$showPrintMargin && !this.$printMarginEl)
	            return;
	        if (!this.$printMarginEl) {
	            var containerEl = dom.createElement("div");
	            containerEl.className = "ace_layer ace_print-margin-layer";
	            this.$printMarginEl = dom.createElement("div");
	            this.$printMarginEl.className = "ace_print-margin";
	            containerEl.appendChild(this.$printMarginEl);
	            this.content.insertBefore(containerEl, this.content.firstChild);
	        }
	        var style = this.$printMarginEl.style;
	        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
	        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
	        if (this.session && this.session.$wrap == -1)
	            this.adjustWrapLimit();
	    };
	    VirtualRenderer.prototype.getContainerElement = function () {
	        return this.container;
	    };
	    VirtualRenderer.prototype.getMouseEventTarget = function () {
	        return this.scroller;
	    };
	    VirtualRenderer.prototype.getTextAreaContainer = function () {
	        return this.container;
	    };
	    VirtualRenderer.prototype.$moveTextAreaToCursor = function () {
	        if (this.$isMousePressed)
	            return;
	        var style = this.textarea.style;
	        var composition = this.$composition;
	        if (!this.$keepTextAreaAtCursor && !composition) {
	            dom.translate(this.textarea, -100, 0);
	            return;
	        }
	        var pixelPos = this.$cursorLayer.$pixelPos;
	        if (!pixelPos)
	            return;
	        if (composition && composition.markerRange)
	            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
	        var config = this.layerConfig;
	        var posTop = pixelPos.top;
	        var posLeft = pixelPos.left;
	        posTop -= config.offset;
	        var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
	        if (posTop < 0 || posTop > config.height - h) {
	            dom.translate(this.textarea, 0, 0);
	            return;
	        }
	        var w = 1;
	        var maxTop = this.$size.height - h;
	        if (!composition) {
	            posTop += this.lineHeight;
	        }
	        else {
	            if (composition.useTextareaForIME) {
	                var val = this.textarea.value;
	                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);
	            }
	            else {
	                posTop += this.lineHeight + 2;
	            }
	        }
	        posLeft -= this.scrollLeft;
	        if (posLeft > this.$size.scrollerWidth - w)
	            posLeft = this.$size.scrollerWidth - w;
	        posLeft += this.gutterWidth + this.margin.left;
	        dom.setStyle(style, "height", h + "px");
	        dom.setStyle(style, "width", w + "px");
	        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
	    };
	    VirtualRenderer.prototype.getFirstVisibleRow = function () {
	        return this.layerConfig.firstRow;
	    };
	    VirtualRenderer.prototype.getFirstFullyVisibleRow = function () {
	        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
	    };
	    VirtualRenderer.prototype.getLastFullyVisibleRow = function () {
	        var config = this.layerConfig;
	        var lastRow = config.lastRow;
	        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
	        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
	            return lastRow - 1;
	        return lastRow;
	    };
	    VirtualRenderer.prototype.getLastVisibleRow = function () {
	        return this.layerConfig.lastRow;
	    };
	    VirtualRenderer.prototype.setPadding = function (padding) {
	        this.$padding = padding;
	        this.$textLayer.setPadding(padding);
	        this.$cursorLayer.setPadding(padding);
	        this.$markerFront.setPadding(padding);
	        this.$markerBack.setPadding(padding);
	        this.$loop.schedule(this.CHANGE_FULL);
	        this.$updatePrintMargin();
	    };
	    VirtualRenderer.prototype.setScrollMargin = function (top, bottom, left, right) {
	        var sm = this.scrollMargin;
	        sm.top = top | 0;
	        sm.bottom = bottom | 0;
	        sm.right = right | 0;
	        sm.left = left | 0;
	        sm.v = sm.top + sm.bottom;
	        sm.h = sm.left + sm.right;
	        if (sm.top && this.scrollTop <= 0 && this.session)
	            this.session.setScrollTop(-sm.top);
	        this.updateFull();
	    };
	    VirtualRenderer.prototype.setMargin = function (top, bottom, left, right) {
	        var sm = this.margin;
	        sm.top = top | 0;
	        sm.bottom = bottom | 0;
	        sm.right = right | 0;
	        sm.left = left | 0;
	        sm.v = sm.top + sm.bottom;
	        sm.h = sm.left + sm.right;
	        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
	        this.updateFull();
	    };
	    VirtualRenderer.prototype.getHScrollBarAlwaysVisible = function () {
	        return this.$hScrollBarAlwaysVisible;
	    };
	    VirtualRenderer.prototype.setHScrollBarAlwaysVisible = function (alwaysVisible) {
	        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
	    };
	    VirtualRenderer.prototype.getVScrollBarAlwaysVisible = function () {
	        return this.$vScrollBarAlwaysVisible;
	    };
	    VirtualRenderer.prototype.setVScrollBarAlwaysVisible = function (alwaysVisible) {
	        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
	    };
	    VirtualRenderer.prototype.$updateScrollBarV = function () {
	        var scrollHeight = this.layerConfig.maxHeight;
	        var scrollerHeight = this.$size.scrollerHeight;
	        if (!this.$maxLines && this.$scrollPastEnd) {
	            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
	            if (this.scrollTop > scrollHeight - scrollerHeight) {
	                scrollHeight = this.scrollTop + scrollerHeight;
	                this.scrollBarV.scrollTop = null;
	            }
	        }
	        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
	        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
	    };
	    VirtualRenderer.prototype.$updateScrollBarH = function () {
	        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
	        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
	    };
	    VirtualRenderer.prototype.freeze = function () {
	        this.$frozen = true;
	    };
	    VirtualRenderer.prototype.unfreeze = function () {
	        this.$frozen = false;
	    };
	    VirtualRenderer.prototype.$renderChanges = function (changes, force) {
	        if (this.$changes) {
	            changes |= this.$changes;
	            this.$changes = 0;
	        }
	        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
	            this.$changes |= changes;
	            return;
	        }
	        if (this.$size.$dirty) {
	            this.$changes |= changes;
	            return this.onResize(true);
	        }
	        if (!this.lineHeight) {
	            this.$textLayer.checkForSizeChanges();
	        }
	        this._signal("beforeRender", changes);
	        if (this.session && this.session.$bidiHandler)
	            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
	        var config = this.layerConfig;
	        if (changes & this.CHANGE_FULL ||
	            changes & this.CHANGE_SIZE ||
	            changes & this.CHANGE_TEXT ||
	            changes & this.CHANGE_LINES ||
	            changes & this.CHANGE_SCROLL ||
	            changes & this.CHANGE_H_SCROLL) {
	            changes |= this.$computeLayerConfig() | this.$loop.clear();
	            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
	                var st = this.scrollTop + (config.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
	                if (st > 0) {
	                    this.scrollTop = st;
	                    changes = changes | this.CHANGE_SCROLL;
	                    changes |= this.$computeLayerConfig() | this.$loop.clear();
	                }
	            }
	            config = this.layerConfig;
	            this.$updateScrollBarV();
	            if (changes & this.CHANGE_H_SCROLL)
	                this.$updateScrollBarH();
	            dom.translate(this.content, -this.scrollLeft, -config.offset);
	            var width = config.width + 2 * this.$padding + "px";
	            var height = config.minHeight + "px";
	            dom.setStyle(this.content.style, "width", width);
	            dom.setStyle(this.content.style, "height", height);
	        }
	        if (changes & this.CHANGE_H_SCROLL) {
	            dom.translate(this.content, -this.scrollLeft, -config.offset);
	            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ";
	            if (this.enableKeyboardAccessibility)
	                this.scroller.className += this.keyboardFocusClassName;
	        }
	        if (changes & this.CHANGE_FULL) {
	            this.$changedLines = null;
	            this.$textLayer.update(config);
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	            if (this.$customScrollbar) {
	                this.$scrollDecorator.$updateDecorators(config);
	            }
	            this.$markerBack.update(config);
	            this.$markerFront.update(config);
	            this.$cursorLayer.update(config);
	            this.$moveTextAreaToCursor();
	            this._signal("afterRender", changes);
	            return;
	        }
	        if (changes & this.CHANGE_SCROLL) {
	            this.$changedLines = null;
	            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
	                this.$textLayer.update(config);
	            else
	                this.$textLayer.scrollLines(config);
	            if (this.$showGutter) {
	                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
	                    this.$gutterLayer.update(config);
	                else
	                    this.$gutterLayer.scrollLines(config);
	            }
	            if (this.$customScrollbar) {
	                this.$scrollDecorator.$updateDecorators(config);
	            }
	            this.$markerBack.update(config);
	            this.$markerFront.update(config);
	            this.$cursorLayer.update(config);
	            this.$moveTextAreaToCursor();
	            this._signal("afterRender", changes);
	            return;
	        }
	        if (changes & this.CHANGE_TEXT) {
	            this.$changedLines = null;
	            this.$textLayer.update(config);
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	            if (this.$customScrollbar) {
	                this.$scrollDecorator.$updateDecorators(config);
	            }
	        }
	        else if (changes & this.CHANGE_LINES) {
	            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
	                this.$gutterLayer.update(config);
	            if (this.$customScrollbar) {
	                this.$scrollDecorator.$updateDecorators(config);
	            }
	        }
	        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	            if (this.$customScrollbar) {
	                this.$scrollDecorator.$updateDecorators(config);
	            }
	        }
	        else if (changes & this.CHANGE_CURSOR) {
	            if (this.$highlightGutterLine)
	                this.$gutterLayer.updateLineHighlight(config);
	            if (this.$customScrollbar) {
	                this.$scrollDecorator.$updateDecorators(config);
	            }
	        }
	        if (changes & this.CHANGE_CURSOR) {
	            this.$cursorLayer.update(config);
	            this.$moveTextAreaToCursor();
	        }
	        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
	            this.$markerFront.update(config);
	        }
	        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
	            this.$markerBack.update(config);
	        }
	        this._signal("afterRender", changes);
	    };
	    VirtualRenderer.prototype.$autosize = function () {
	        var height = this.session.getScreenLength() * this.lineHeight;
	        var maxHeight = this.$maxLines * this.lineHeight;
	        var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
	        if (this.$horizScroll)
	            desiredHeight += this.scrollBarH.getHeight();
	        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
	            desiredHeight = this.$maxPixelHeight;
	        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
	        var vScroll = !hideScrollbars && height > maxHeight;
	        if (desiredHeight != this.desiredHeight ||
	            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
	            if (vScroll != this.$vScroll) {
	                this.$vScroll = vScroll;
	                this.scrollBarV.setVisible(vScroll);
	            }
	            var w = this.container.clientWidth;
	            this.container.style.height = desiredHeight + "px";
	            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
	            this.desiredHeight = desiredHeight;
	            this._signal("autosize");
	        }
	    };
	    VirtualRenderer.prototype.$computeLayerConfig = function () {
	        var session = this.session;
	        var size = this.$size;
	        var hideScrollbars = size.height <= 2 * this.lineHeight;
	        var screenLines = this.session.getScreenLength();
	        var maxHeight = screenLines * this.lineHeight;
	        var longestLine = this.$getLongestLine();
	        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
	            size.scrollerWidth - longestLine - 2 * this.$padding < 0);
	        var hScrollChanged = this.$horizScroll !== horizScroll;
	        if (hScrollChanged) {
	            this.$horizScroll = horizScroll;
	            this.scrollBarH.setVisible(horizScroll);
	        }
	        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
	        if (this.$maxLines && this.lineHeight > 1) {
	            this.$autosize();
	            hideScrollbars = size.height <= 2 * this.lineHeight;
	        }
	        var minHeight = size.scrollerHeight + this.lineHeight;
	        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
	            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
	            : 0;
	        maxHeight += scrollPastEnd;
	        var sm = this.scrollMargin;
	        this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
	        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
	        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
	            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
	        var vScrollChanged = vScrollBefore !== vScroll;
	        if (vScrollChanged) {
	            this.$vScroll = vScroll;
	            this.scrollBarV.setVisible(vScroll);
	        }
	        var offset = this.scrollTop % this.lineHeight;
	        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
	        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
	        var lastRow = firstRow + lineCount;
	        var firstRowScreen, firstRowHeight;
	        var lineHeight = this.lineHeight;
	        firstRow = session.screenToDocumentRow(firstRow, 0);
	        var foldLine = session.getFoldLine(firstRow);
	        if (foldLine) {
	            firstRow = foldLine.start.row;
	        }
	        firstRowScreen = session.documentToScreenRow(firstRow, 0);
	        firstRowHeight = session.getRowLength(firstRow) * lineHeight;
	        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
	        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
	            firstRowHeight;
	        offset = this.scrollTop - firstRowScreen * lineHeight;
	        if (offset < 0 && firstRowScreen > 0) {
	            firstRowScreen = Math.max(0, firstRowScreen + Math.floor(offset / lineHeight));
	            offset = this.scrollTop - firstRowScreen * lineHeight;
	        }
	        var changes = 0;
	        if (this.layerConfig.width != longestLine || hScrollChanged)
	            changes = this.CHANGE_H_SCROLL;
	        if (hScrollChanged || vScrollChanged) {
	            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
	            this._signal("scrollbarVisibilityChanged");
	            if (vScrollChanged)
	                longestLine = this.$getLongestLine();
	        }
	        this.layerConfig = {
	            width: longestLine,
	            padding: this.$padding,
	            firstRow: firstRow,
	            firstRowScreen: firstRowScreen,
	            lastRow: lastRow,
	            lineHeight: lineHeight,
	            characterWidth: this.characterWidth,
	            minHeight: minHeight,
	            maxHeight: maxHeight,
	            offset: offset,
	            gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
	            height: this.$size.scrollerHeight
	        };
	        if (this.session.$bidiHandler)
	            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
	        return changes;
	    };
	    VirtualRenderer.prototype.$updateLines = function () {
	        if (!this.$changedLines)
	            return;
	        var firstRow = this.$changedLines.firstRow;
	        var lastRow = this.$changedLines.lastRow;
	        this.$changedLines = null;
	        var layerConfig = this.layerConfig;
	        if (firstRow > layerConfig.lastRow + 1) {
	            return;
	        }
	        if (lastRow < layerConfig.firstRow) {
	            return;
	        }
	        if (lastRow === Infinity) {
	            if (this.$showGutter)
	                this.$gutterLayer.update(layerConfig);
	            this.$textLayer.update(layerConfig);
	            return;
	        }
	        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
	        return true;
	    };
	    VirtualRenderer.prototype.$getLongestLine = function () {
	        var charCount = this.session.getScreenWidth();
	        if (this.showInvisibles && !this.session.$useWrapMode)
	            charCount += 1;
	        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
	            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
	        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
	    };
	    VirtualRenderer.prototype.updateFrontMarkers = function () {
	        this.$markerFront.setMarkers(this.session.getMarkers(true));
	        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
	    };
	    VirtualRenderer.prototype.updateBackMarkers = function () {
	        this.$markerBack.setMarkers(this.session.getMarkers());
	        this.$loop.schedule(this.CHANGE_MARKER_BACK);
	    };
	    VirtualRenderer.prototype.addGutterDecoration = function (row, className) {
	        this.$gutterLayer.addGutterDecoration(row, className);
	    };
	    VirtualRenderer.prototype.removeGutterDecoration = function (row, className) {
	        this.$gutterLayer.removeGutterDecoration(row, className);
	    };
	    VirtualRenderer.prototype.updateBreakpoints = function (rows) {
	        this._rows = rows;
	        this.$loop.schedule(this.CHANGE_GUTTER);
	    };
	    VirtualRenderer.prototype.setAnnotations = function (annotations) {
	        this.$gutterLayer.setAnnotations(annotations);
	        this.$loop.schedule(this.CHANGE_GUTTER);
	    };
	    VirtualRenderer.prototype.updateCursor = function () {
	        this.$loop.schedule(this.CHANGE_CURSOR);
	    };
	    VirtualRenderer.prototype.hideCursor = function () {
	        this.$cursorLayer.hideCursor();
	    };
	    VirtualRenderer.prototype.showCursor = function () {
	        this.$cursorLayer.showCursor();
	    };
	    VirtualRenderer.prototype.scrollSelectionIntoView = function (anchor, lead, offset) {
	        this.scrollCursorIntoView(anchor, offset);
	        this.scrollCursorIntoView(lead, offset);
	    };
	    VirtualRenderer.prototype.scrollCursorIntoView = function (cursor, offset, $viewMargin) {
	        if (this.$size.scrollerHeight === 0)
	            return;
	        var pos = this.$cursorLayer.getPixelPosition(cursor);
	        var newLeft = pos.left;
	        var newTop = pos.top;
	        var topMargin = $viewMargin && $viewMargin.top || 0;
	        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
	        if (this.$scrollAnimation) {
	            this.$stopAnimation = true;
	        }
	        var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
	        if (currentTop + topMargin > newTop) {
	            if (offset && currentTop + topMargin > newTop + this.lineHeight)
	                newTop -= offset * this.$size.scrollerHeight;
	            if (newTop === 0)
	                newTop = -this.scrollMargin.top;
	            this.session.setScrollTop(newTop);
	        }
	        else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
	            if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)
	                newTop += offset * this.$size.scrollerHeight;
	            this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
	        }
	        var currentLeft = this.scrollLeft;
	        var twoCharsWidth = 2 * this.layerConfig.characterWidth;
	        if (newLeft - twoCharsWidth < currentLeft) {
	            newLeft -= twoCharsWidth;
	            if (newLeft < this.$padding + twoCharsWidth) {
	                newLeft = -this.scrollMargin.left;
	            }
	            this.session.setScrollLeft(newLeft);
	        }
	        else {
	            newLeft += twoCharsWidth;
	            if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
	                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
	            }
	            else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
	                this.session.setScrollLeft(0);
	            }
	        }
	    };
	    VirtualRenderer.prototype.getScrollTop = function () {
	        return this.session.getScrollTop();
	    };
	    VirtualRenderer.prototype.getScrollLeft = function () {
	        return this.session.getScrollLeft();
	    };
	    VirtualRenderer.prototype.getScrollTopRow = function () {
	        return this.scrollTop / this.lineHeight;
	    };
	    VirtualRenderer.prototype.getScrollBottomRow = function () {
	        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
	    };
	    VirtualRenderer.prototype.scrollToRow = function (row) {
	        this.session.setScrollTop(row * this.lineHeight);
	    };
	    VirtualRenderer.prototype.alignCursor = function (cursor, alignment) {
	        if (typeof cursor == "number")
	            cursor = { row: cursor, column: 0 };
	        var pos = this.$cursorLayer.getPixelPosition(cursor);
	        var h = this.$size.scrollerHeight - this.lineHeight;
	        var offset = pos.top - h * (alignment || 0);
	        this.session.setScrollTop(offset);
	        return offset;
	    };
	    VirtualRenderer.prototype.$calcSteps = function (fromValue, toValue) {
	        var i = 0;
	        var l = this.STEPS;
	        var steps = [];
	        var func = function (t, x_min, dx) {
	            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
	        };
	        for (i = 0; i < l; ++i)
	            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
	        return steps;
	    };
	    VirtualRenderer.prototype.scrollToLine = function (line, center, animate, callback) {
	        var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
	        var offset = pos.top;
	        if (center)
	            offset -= this.$size.scrollerHeight / 2;
	        var initialScroll = this.scrollTop;
	        this.session.setScrollTop(offset);
	        if (animate !== false)
	            this.animateScrolling(initialScroll, callback);
	    };
	    VirtualRenderer.prototype.animateScrolling = function (fromValue, callback) {
	        var toValue = this.scrollTop;
	        if (!this.$animatedScroll)
	            return;
	        var _self = this;
	        if (fromValue == toValue)
	            return;
	        if (this.$scrollAnimation) {
	            var oldSteps = this.$scrollAnimation.steps;
	            if (oldSteps.length) {
	                fromValue = oldSteps[0];
	                if (fromValue == toValue)
	                    return;
	            }
	        }
	        var steps = _self.$calcSteps(fromValue, toValue);
	        this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };
	        clearInterval(this.$timer);
	        _self.session.setScrollTop(steps.shift());
	        _self.session.$scrollTop = toValue;
	        function endAnimation() {
	            _self.$timer = clearInterval(_self.$timer);
	            _self.$scrollAnimation = null;
	            _self.$stopAnimation = false;
	            callback && callback();
	        }
	        this.$timer = setInterval(function () {
	            if (_self.$stopAnimation) {
	                endAnimation();
	                return;
	            }
	            if (!_self.session)
	                return clearInterval(_self.$timer);
	            if (steps.length) {
	                _self.session.setScrollTop(steps.shift());
	                _self.session.$scrollTop = toValue;
	            }
	            else if (toValue != null) {
	                _self.session.$scrollTop = -1;
	                _self.session.setScrollTop(toValue);
	                toValue = null;
	            }
	            else {
	                endAnimation();
	            }
	        }, 10);
	    };
	    VirtualRenderer.prototype.scrollToY = function (scrollTop) {
	        if (this.scrollTop !== scrollTop) {
	            this.$loop.schedule(this.CHANGE_SCROLL);
	            this.scrollTop = scrollTop;
	        }
	    };
	    VirtualRenderer.prototype.scrollToX = function (scrollLeft) {
	        if (this.scrollLeft !== scrollLeft)
	            this.scrollLeft = scrollLeft;
	        this.$loop.schedule(this.CHANGE_H_SCROLL);
	    };
	    VirtualRenderer.prototype.scrollTo = function (x, y) {
	        this.session.setScrollTop(y);
	        this.session.setScrollLeft(x);
	    };
	    VirtualRenderer.prototype.scrollBy = function (deltaX, deltaY) {
	        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
	        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
	    };
	    VirtualRenderer.prototype.isScrollableBy = function (deltaX, deltaY) {
	        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
	            return true;
	        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
	            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
	            return true;
	        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
	            return true;
	        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
	            - this.layerConfig.width < -1 + this.scrollMargin.right)
	            return true;
	    };
	    VirtualRenderer.prototype.pixelToScreenCoordinates = function (x, y) {
	        var canvasPos;
	        if (this.$hasCssTransforms) {
	            canvasPos = { top: 0, left: 0 };
	            var p = this.$fontMetrics.transformCoordinates([x, y]);
	            x = p[1] - this.gutterWidth - this.margin.left;
	            y = p[0];
	        }
	        else {
	            canvasPos = this.scroller.getBoundingClientRect();
	        }
	        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
	        var offset = offsetX / this.characterWidth;
	        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
	        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
	        return { row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX: offsetX };
	    };
	    VirtualRenderer.prototype.screenToTextCoordinates = function (x, y) {
	        var canvasPos;
	        if (this.$hasCssTransforms) {
	            canvasPos = { top: 0, left: 0 };
	            var p = this.$fontMetrics.transformCoordinates([x, y]);
	            x = p[1] - this.gutterWidth - this.margin.left;
	            y = p[0];
	        }
	        else {
	            canvasPos = this.scroller.getBoundingClientRect();
	        }
	        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
	        var offset = offsetX / this.characterWidth;
	        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
	        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
	        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
	    };
	    VirtualRenderer.prototype.textToScreenCoordinates = function (row, column) {
	        var canvasPos = this.scroller.getBoundingClientRect();
	        var pos = this.session.documentToScreenPosition(row, column);
	        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
	            ? this.session.$bidiHandler.getPosLeft(pos.column)
	            : Math.round(pos.column * this.characterWidth));
	        var y = pos.row * this.lineHeight;
	        return {
	            pageX: canvasPos.left + x - this.scrollLeft,
	            pageY: canvasPos.top + y - this.scrollTop
	        };
	    };
	    VirtualRenderer.prototype.visualizeFocus = function () {
	        dom.addCssClass(this.container, "ace_focus");
	    };
	    VirtualRenderer.prototype.visualizeBlur = function () {
	        dom.removeCssClass(this.container, "ace_focus");
	    };
	    VirtualRenderer.prototype.showComposition = function (composition) {
	        this.$composition = composition;
	        if (!composition.cssText) {
	            composition.cssText = this.textarea.style.cssText;
	        }
	        if (composition.useTextareaForIME == undefined)
	            composition.useTextareaForIME = this.$useTextareaForIME;
	        if (this.$useTextareaForIME) {
	            dom.addCssClass(this.textarea, "ace_composition");
	            this.textarea.style.cssText = "";
	            this.$moveTextAreaToCursor();
	            this.$cursorLayer.element.style.display = "none";
	        }
	        else {
	            composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
	        }
	    };
	    VirtualRenderer.prototype.setCompositionText = function (text) {
	        var cursor = this.session.selection.cursor;
	        this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
	        this.$moveTextAreaToCursor();
	    };
	    VirtualRenderer.prototype.hideComposition = function () {
	        if (!this.$composition)
	            return;
	        if (this.$composition.markerId)
	            this.session.removeMarker(this.$composition.markerId);
	        dom.removeCssClass(this.textarea, "ace_composition");
	        this.textarea.style.cssText = this.$composition.cssText;
	        var cursor = this.session.selection.cursor;
	        this.removeExtraToken(cursor.row, cursor.column);
	        this.$composition = null;
	        this.$cursorLayer.element.style.display = "";
	    };
	    VirtualRenderer.prototype.setGhostText = function (text, position) {
	        var cursor = this.session.selection.cursor;
	        var insertPosition = position || { row: cursor.row, column: cursor.column };
	        this.removeGhostText();
	        var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);
	        this.addToken(textChunks[0].text, "ghost_text", insertPosition.row, insertPosition.column);
	        this.$ghostText = {
	            text: text,
	            position: {
	                row: insertPosition.row,
	                column: insertPosition.column
	            }
	        };
	        var widgetDiv = dom.createElement("div");
	        if (textChunks.length > 1) {
	            var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);
	            var lastLineDiv;
	            textChunks.slice(1).forEach(function (el) {
	                var chunkDiv = dom.createElement("div");
	                var chunkSpan = dom.createElement("span");
	                chunkSpan.className = "ace_ghost_text";
	                if (el.wrapped)
	                    chunkDiv.className = "ghost_text_line_wrapped";
	                if (el.text.length === 0)
	                    el.text = " ";
	                chunkSpan.appendChild(dom.createTextNode(el.text));
	                chunkDiv.appendChild(chunkSpan);
	                widgetDiv.appendChild(chunkDiv);
	                lastLineDiv = chunkDiv;
	            });
	            hiddenTokens.forEach(function (token) {
	                var element = dom.createElement("span");
	                if (!isTextToken(token.type))
	                    element.className = "ace_" + token.type.replace(/\./g, " ace_");
	                element.appendChild(dom.createTextNode(token.value));
	                lastLineDiv.appendChild(element);
	            });
	            this.$ghostTextWidget = {
	                el: widgetDiv,
	                row: insertPosition.row,
	                column: insertPosition.column,
	                className: "ace_ghost_text_container"
	            };
	            this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
	            var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);
	            var el = this.container;
	            var height = el.getBoundingClientRect().height;
	            var ghostTextHeight = textChunks.length * this.lineHeight;
	            var fitsY = ghostTextHeight < (height - pixelPosition.top);
	            if (fitsY)
	                return;
	            if (ghostTextHeight < height) {
	                this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);
	            }
	            else {
	                this.scrollToRow(insertPosition.row);
	            }
	        }
	    };
	    VirtualRenderer.prototype.$calculateWrappedTextChunks = function (text, position) {
	        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
	        var limit = Math.floor(availableWidth / this.characterWidth) - 2;
	        limit = limit <= 0 ? 60 : limit; // this is a hack to prevent the editor from crashing when the window is too small
	        var textLines = text.split(/\r?\n/);
	        var textChunks = [];
	        for (var i = 0; i < textLines.length; i++) {
	            var displayTokens = this.session.$getDisplayTokens(textLines[i], position.column);
	            var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit, this.session.$tabSize);
	            if (wrapSplits.length > 0) {
	                var start = 0;
	                wrapSplits.push(textLines[i].length);
	                for (var j = 0; j < wrapSplits.length; j++) {
	                    var textSlice = textLines[i].slice(start, wrapSplits[j]);
	                    textChunks.push({ text: textSlice, wrapped: true });
	                    start = wrapSplits[j];
	                }
	            }
	            else {
	                textChunks.push({ text: textLines[i], wrapped: false });
	            }
	        }
	        return textChunks;
	    };
	    VirtualRenderer.prototype.removeGhostText = function () {
	        if (!this.$ghostText)
	            return;
	        var position = this.$ghostText.position;
	        this.removeExtraToken(position.row, position.column);
	        if (this.$ghostTextWidget) {
	            this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
	            this.$ghostTextWidget = null;
	        }
	        this.$ghostText = null;
	    };
	    VirtualRenderer.prototype.addToken = function (text, type, row, column) {
	        var session = this.session;
	        session.bgTokenizer.lines[row] = null;
	        var newToken = { type: type, value: text };
	        var tokens = session.getTokens(row);
	        if (column == null || !tokens.length) {
	            tokens.push(newToken);
	        }
	        else {
	            var l = 0;
	            for (var i = 0; i < tokens.length; i++) {
	                var token = tokens[i];
	                l += token.value.length;
	                if (column <= l) {
	                    var diff = token.value.length - (l - column);
	                    var before = token.value.slice(0, diff);
	                    var after = token.value.slice(diff);
	                    tokens.splice(i, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });
	                    break;
	                }
	            }
	        }
	        this.updateLines(row, row);
	    };
	    VirtualRenderer.prototype.hideTokensAfterPosition = function (row, column) {
	        var tokens = this.session.getTokens(row);
	        var l = 0;
	        var hasPassedCursor = false;
	        var hiddenTokens = [];
	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];
	            l += token.value.length;
	            if (token.type === "ghost_text")
	                continue;
	            if (hasPassedCursor) {
	                hiddenTokens.push({ type: token.type, value: token.value });
	                token.type = "hidden_token";
	                continue;
	            }
	            if (l === column) {
	                hasPassedCursor = true;
	            }
	        }
	        this.updateLines(row, row);
	        return hiddenTokens;
	    };
	    VirtualRenderer.prototype.removeExtraToken = function (row, column) {
	        this.session.bgTokenizer.lines[row] = null;
	        this.updateLines(row, row);
	    };
	    VirtualRenderer.prototype.setTheme = function (theme, cb) {
	        var _self = this;
	        this.$themeId = theme;
	        _self._dispatchEvent('themeChange', { theme: theme });
	        if (!theme || typeof theme == "string") {
	            var moduleName = theme || this.$options.theme.initialValue;
	            config.loadModule(["theme", moduleName], afterLoad);
	        }
	        else {
	            afterLoad(theme);
	        }
	        function afterLoad(module) {
	            if (_self.$themeId != theme)
	                return cb && cb();
	            if (!module || !module.cssClass)
	                throw new Error("couldn't load module " + theme + " or it didn't call define");
	            if (module.$id)
	                _self.$themeId = module.$id;
	            dom.importCssString(module.cssText, module.cssClass, _self.container);
	            if (_self.theme)
	                dom.removeCssClass(_self.container, _self.theme.cssClass);
	            var padding = "padding" in module ? module.padding
	                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
	            if (_self.$padding && padding != _self.$padding)
	                _self.setPadding(padding);
	            _self.$theme = module.cssClass;
	            _self.theme = module;
	            dom.addCssClass(_self.container, module.cssClass);
	            dom.setCssClass(_self.container, "ace_dark", module.isDark);
	            if (_self.$size) {
	                _self.$size.width = 0;
	                _self.$updateSizeAsync();
	            }
	            _self._dispatchEvent('themeLoaded', { theme: module });
	            cb && cb();
	            if (useragent.isSafari && _self.scroller) {
	                _self.scroller.style.background = "red";
	                _self.scroller.style.background = "";
	            }
	        }
	    };
	    VirtualRenderer.prototype.getTheme = function () {
	        return this.$themeId;
	    };
	    VirtualRenderer.prototype.setStyle = function (style, include) {
	        dom.setCssClass(this.container, style, include !== false);
	    };
	    VirtualRenderer.prototype.unsetStyle = function (style) {
	        dom.removeCssClass(this.container, style);
	    };
	    VirtualRenderer.prototype.setCursorStyle = function (style) {
	        dom.setStyle(this.scroller.style, "cursor", style);
	    };
	    VirtualRenderer.prototype.setMouseCursor = function (cursorStyle) {
	        dom.setStyle(this.scroller.style, "cursor", cursorStyle);
	    };
	    VirtualRenderer.prototype.attachToShadowRoot = function () {
	        dom.importCssString(editorCss, "ace_editor.css", this.container);
	    };
	    VirtualRenderer.prototype.destroy = function () {
	        this.freeze();
	        this.$fontMetrics.destroy();
	        this.$cursorLayer.destroy();
	        this.removeAllListeners();
	        this.container.textContent = "";
	        this.setOption("useResizeObserver", false);
	    };
	    VirtualRenderer.prototype.$updateCustomScrollbar = function (val) {
	        var _self = this;
	        this.$horizScroll = this.$vScroll = null;
	        this.scrollBarV.element.remove();
	        this.scrollBarH.element.remove();
	        if (val === true) {
	            this.scrollBarV = new VScrollBarCustom(this.container, this);
	            this.scrollBarH = new HScrollBarCustom(this.container, this);
	            this.scrollBarV.setHeight(this.$size.scrollerHeight);
	            this.scrollBarH.setWidth(this.$size.scrollerWidth);
	            this.scrollBarV.addEventListener("scroll", function (e) {
	                if (!_self.$scrollAnimation)
	                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);
	            });
	            this.scrollBarH.addEventListener("scroll", function (e) {
	                if (!_self.$scrollAnimation)
	                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
	            });
	            if (!this.$scrollDecorator) {
	                this.$scrollDecorator = new Decorator(this.scrollBarV, this);
	                this.$scrollDecorator.$updateDecorators();
	            }
	            else {
	                this.$scrollDecorator.setScrollBarV(this.scrollBarV);
	                this.$scrollDecorator.$updateDecorators();
	            }
	        }
	        else {
	            this.scrollBarV = new VScrollBar(this.container, this);
	            this.scrollBarH = new HScrollBar(this.container, this);
	            this.scrollBarV.addEventListener("scroll", function (e) {
	                if (!_self.$scrollAnimation)
	                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);
	            });
	            this.scrollBarH.addEventListener("scroll", function (e) {
	                if (!_self.$scrollAnimation)
	                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
	            });
	        }
	    };
	    VirtualRenderer.prototype.$addResizeObserver = function () {
	        if (!window.ResizeObserver || this.$resizeObserver)
	            return;
	        var self = this;
	        this.$resizeTimer = lang.delayedCall(function () {
	            if (!self.destroyed)
	                self.onResize();
	        }, 50);
	        this.$resizeObserver = new window.ResizeObserver(function (e) {
	            var w = e[0].contentRect.width;
	            var h = e[0].contentRect.height;
	            if (Math.abs(self.$size.width - w) > 1
	                || Math.abs(self.$size.height - h) > 1) {
	                self.$resizeTimer.delay();
	            }
	            else {
	                self.$resizeTimer.cancel();
	            }
	        });
	        this.$resizeObserver.observe(this.container);
	    };
	    return VirtualRenderer;
	}());
	VirtualRenderer.prototype.CHANGE_CURSOR = 1;
	VirtualRenderer.prototype.CHANGE_MARKER = 2;
	VirtualRenderer.prototype.CHANGE_GUTTER = 4;
	VirtualRenderer.prototype.CHANGE_SCROLL = 8;
	VirtualRenderer.prototype.CHANGE_LINES = 16;
	VirtualRenderer.prototype.CHANGE_TEXT = 32;
	VirtualRenderer.prototype.CHANGE_SIZE = 64;
	VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
	VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
	VirtualRenderer.prototype.CHANGE_FULL = 512;
	VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
	VirtualRenderer.prototype.$changes = 0;
	VirtualRenderer.prototype.$padding = null;
	VirtualRenderer.prototype.$frozen = false;
	VirtualRenderer.prototype.STEPS = 8;
	oop.implement(VirtualRenderer.prototype, EventEmitter);
	config.defineOptions(VirtualRenderer.prototype, "renderer", {
	    useResizeObserver: {
	        set: function (value) {
	            if (!value && this.$resizeObserver) {
	                this.$resizeObserver.disconnect();
	                this.$resizeTimer.cancel();
	                this.$resizeTimer = this.$resizeObserver = null;
	            }
	            else if (value && !this.$resizeObserver) {
	                this.$addResizeObserver();
	            }
	        }
	    },
	    animatedScroll: { initialValue: false },
	    showInvisibles: {
	        set: function (value) {
	            if (this.$textLayer.setShowInvisibles(value))
	                this.$loop.schedule(this.CHANGE_TEXT);
	        },
	        initialValue: false
	    },
	    showPrintMargin: {
	        set: function () { this.$updatePrintMargin(); },
	        initialValue: true
	    },
	    printMarginColumn: {
	        set: function () { this.$updatePrintMargin(); },
	        initialValue: 80
	    },
	    printMargin: {
	        set: function (val) {
	            if (typeof val == "number")
	                this.$printMarginColumn = val;
	            this.$showPrintMargin = !!val;
	            this.$updatePrintMargin();
	        },
	        get: function () {
	            return this.$showPrintMargin && this.$printMarginColumn;
	        }
	    },
	    showGutter: {
	        set: function (show) {
	            this.$gutter.style.display = show ? "block" : "none";
	            this.$loop.schedule(this.CHANGE_FULL);
	            this.onGutterResize();
	        },
	        initialValue: true
	    },
	    useSvgGutterIcons: {
	        set: function (value) {
	            this.$gutterLayer.$useSvgGutterIcons = value;
	        },
	        initialValue: false
	    },
	    showFoldedAnnotations: {
	        set: function (value) {
	            this.$gutterLayer.$showFoldedAnnotations = value;
	        },
	        initialValue: false
	    },
	    fadeFoldWidgets: {
	        set: function (show) {
	            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
	        },
	        initialValue: false
	    },
	    showFoldWidgets: {
	        set: function (show) {
	            this.$gutterLayer.setShowFoldWidgets(show);
	            this.$loop.schedule(this.CHANGE_GUTTER);
	        },
	        initialValue: true
	    },
	    displayIndentGuides: {
	        set: function (show) {
	            if (this.$textLayer.setDisplayIndentGuides(show))
	                this.$loop.schedule(this.CHANGE_TEXT);
	        },
	        initialValue: true
	    },
	    highlightIndentGuides: {
	        set: function (show) {
	            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
	                this.$textLayer.$highlightIndentGuide();
	            }
	            else {
	                this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
	            }
	        },
	        initialValue: true
	    },
	    highlightGutterLine: {
	        set: function (shouldHighlight) {
	            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
	            this.$loop.schedule(this.CHANGE_GUTTER);
	        },
	        initialValue: true
	    },
	    hScrollBarAlwaysVisible: {
	        set: function (val) {
	            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
	                this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: false
	    },
	    vScrollBarAlwaysVisible: {
	        set: function (val) {
	            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
	                this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: false
	    },
	    fontSize: {
	        set: function (size) {
	            if (typeof size == "number")
	                size = size + "px";
	            this.container.style.fontSize = size;
	            this.updateFontSize();
	        },
	        initialValue: 12
	    },
	    fontFamily: {
	        set: function (name) {
	            this.container.style.fontFamily = name;
	            this.updateFontSize();
	        }
	    },
	    maxLines: {
	        set: function (val) {
	            this.updateFull();
	        }
	    },
	    minLines: {
	        set: function (val) {
	            if (!(this.$minLines < 0x1ffffffffffff))
	                this.$minLines = 0;
	            this.updateFull();
	        }
	    },
	    maxPixelHeight: {
	        set: function (val) {
	            this.updateFull();
	        },
	        initialValue: 0
	    },
	    scrollPastEnd: {
	        set: function (val) {
	            val = +val || 0;
	            if (this.$scrollPastEnd == val)
	                return;
	            this.$scrollPastEnd = val;
	            this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: 0,
	        handlesSet: true
	    },
	    fixedWidthGutter: {
	        set: function (val) {
	            this.$gutterLayer.$fixedWidth = !!val;
	            this.$loop.schedule(this.CHANGE_GUTTER);
	        }
	    },
	    customScrollbar: {
	        set: function (val) {
	            this.$updateCustomScrollbar(val);
	        },
	        initialValue: false
	    },
	    theme: {
	        set: function (val) { this.setTheme(val); },
	        get: function () { return this.$themeId || this.theme; },
	        initialValue: "./theme/textmate",
	        handlesSet: true
	    },
	    hasCssTransforms: {},
	    useTextareaForIME: {
	        initialValue: !useragent.isMobile && !useragent.isIE
	    }
	});
	exports.VirtualRenderer = VirtualRenderer;

	});

	ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(require, exports, module) {

	var oop = require("../lib/oop");
	var net = require("../lib/net");
	var EventEmitter = require("../lib/event_emitter").EventEmitter;
	var config = require("../config");

	function $workerBlob(workerUrl) {
	    var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
	    try {
	        return new Blob([script], {"type": "application/javascript"});
	    } catch (e) { // Backwards-compatibility
	        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
	        var blobBuilder = new BlobBuilder();
	        blobBuilder.append(script);
	        return blobBuilder.getBlob("application/javascript");
	    }
	}

	function createWorker(workerUrl) {
	    if (typeof Worker == "undefined")
	        return { postMessage: function() {}, terminate: function() {} };
	    if (config.get("loadWorkerFromBlob")) {
	        var blob = $workerBlob(workerUrl);
	        var URL = window.URL || window.webkitURL;
	        var blobURL = URL.createObjectURL(blob);
	        return new Worker(blobURL);
	    }
	    return new Worker(workerUrl);
	}

	var WorkerClient = function(worker) {
	    if (!worker.postMessage)
	        worker = this.$createWorkerFromOldConfig.apply(this, arguments);

	    this.$worker = worker;
	    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
	    this.changeListener = this.changeListener.bind(this);
	    this.onMessage = this.onMessage.bind(this);

	    this.callbackId = 1;
	    this.callbacks = {};

	    this.$worker.onmessage = this.onMessage;
	};

	(function(){

	    oop.implement(this, EventEmitter);

	    this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
	        if (require.nameToUrl && !require.toUrl)
	            require.toUrl = require.nameToUrl;

	        if (config.get("packaged") || !require.toUrl) {
	            workerUrl = workerUrl || config.moduleUrl(mod, "worker");
	        } else {
	            var normalizePath = this.$normalizePath;
	            workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

	            var tlns = {};
	            topLevelNamespaces.forEach(function(ns) {
	                tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
	            });
	        }

	        this.$worker = createWorker(workerUrl);
	        if (importScripts) {
	            this.send("importScripts", importScripts);
	        }
	        this.$worker.postMessage({
	            init : true,
	            tlns : tlns,
	            module : mod,
	            classname : classname
	        });
	        return this.$worker;
	    };

	    this.onMessage = function(e) {
	        var msg = e.data;
	        switch (msg.type) {
	            case "event":
	                this._signal(msg.name, {data: msg.data});
	                break;
	            case "call":
	                var callback = this.callbacks[msg.id];
	                if (callback) {
	                    callback(msg.data);
	                    delete this.callbacks[msg.id];
	                }
	                break;
	            case "error":
	                this.reportError(msg.data);
	                break;
	            case "log":
	                window.console && console.log && console.log.apply(console, msg.data);
	                break;
	        }
	    };
	    
	    this.reportError = function(err) {
	        window.console && console.error && console.error(err);
	    };

	    this.$normalizePath = function(path) {
	        return net.qualifyURL(path);
	    };

	    this.terminate = function() {
	        this._signal("terminate", {});
	        this.deltaQueue = null;
	        this.$worker.terminate();
	        this.$worker.onerror = function(e) {
	            e.preventDefault();
	        };
	        this.$worker = null;
	        if (this.$doc)
	            this.$doc.off("change", this.changeListener);
	        this.$doc = null;
	    };

	    this.send = function(cmd, args) {
	        this.$worker.postMessage({command: cmd, args: args});
	    };

	    this.call = function(cmd, args, callback) {
	        if (callback) {
	            var id = this.callbackId++;
	            this.callbacks[id] = callback;
	            args.push(id);
	        }
	        this.send(cmd, args);
	    };

	    this.emit = function(event, data) {
	        try {
	            if (data.data && data.data.err)
	                data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};
	                this.$worker && this.$worker.postMessage({event: event, data: {data: data.data}});
	        }
	        catch(ex) {
	            console.error(ex.stack);
	        }
	    };

	    this.attachToDocument = function(doc) {
	        if (this.$doc)
	            this.terminate();

	        this.$doc = doc;
	        this.call("setValue", [doc.getValue()]);
	        doc.on("change", this.changeListener, true);
	    };

	    this.changeListener = function(delta) {
	        if (!this.deltaQueue) {
	            this.deltaQueue = [];
	            setTimeout(this.$sendDeltaQueue, 0);
	        }
	        if (delta.action == "insert")
	            this.deltaQueue.push(delta.start, delta.lines);
	        else
	            this.deltaQueue.push(delta.start, delta.end);
	    };

	    this.$sendDeltaQueue = function() {
	        var q = this.deltaQueue;
	        if (!q) return;
	        this.deltaQueue = null;
	        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
	            this.call("setValue", [this.$doc.getValue()]);
	        } else
	            this.emit("change", {data: q});
	    };

	}).call(WorkerClient.prototype);


	var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
	    var main = null;
	    var emitSync = false;
	    var sender = Object.create(EventEmitter);

	    var messageBuffer = [];
	    var workerClient = new WorkerClient({
	        messageBuffer: messageBuffer,
	        terminate: function() {},
	        postMessage: function(e) {
	            messageBuffer.push(e);
	            if (!main) return;
	            if (emitSync)
	                setTimeout(processNext);
	            else
	                processNext();
	        }
	    });

	    workerClient.setEmitSync = function(val) { emitSync = val; };

	    var processNext = function() {
	        var msg = messageBuffer.shift();
	        if (msg.command)
	            main[msg.command].apply(main, msg.args);
	        else if (msg.event)
	            sender._signal(msg.event, msg.data);
	    };

	    sender.postMessage = function(msg) {
	        workerClient.onMessage({data: msg});
	    };
	    sender.callback = function(data, callbackId) {
	        this.postMessage({type: "call", id: callbackId, data: data});
	    };
	    sender.emit = function(name, data) {
	        this.postMessage({type: "event", name: name, data: data});
	    };

	    config.loadModule(["worker", mod], function(Main) {
	        main = new Main[classname](sender);
	        while (messageBuffer.length)
	            processNext();
	    });

	    return workerClient;
	};

	exports.UIWorkerClient = UIWorkerClient;
	exports.WorkerClient = WorkerClient;
	exports.createWorker = createWorker;


	});

	ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(require, exports, module){	var Range = require("./range").Range;
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var oop = require("./lib/oop");
	var PlaceHolder = /** @class */ (function () {
	    function PlaceHolder(session, length, pos, others, mainClass, othersClass) {
	        var _self = this;
	        this.length = length;
	        this.session = session;
	        this.doc = session.getDocument();
	        this.mainClass = mainClass;
	        this.othersClass = othersClass;
	        this.$onUpdate = this.onUpdate.bind(this);
	        this.doc.on("change", this.$onUpdate, true);
	        this.$others = others;
	        this.$onCursorChange = function () {
	            setTimeout(function () {
	                _self.onCursorChange();
	            });
	        };
	        this.$pos = pos;
	        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()["$undostack"] || { length: -1 };
	        this.$undoStackDepth = undoStack.length;
	        this.setup();
	        session.selection.on("changeCursor", this.$onCursorChange);
	    }
	    PlaceHolder.prototype.setup = function () {
	        var _self = this;
	        var doc = this.doc;
	        var session = this.session;
	        this.selectionBefore = session.selection.toJSON();
	        if (session.selection.inMultiSelectMode)
	            session.selection.toSingleRange();
	        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
	        var pos = this.pos;
	        pos.$insertRight = true;
	        pos.detach();
	        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
	        this.others = [];
	        this.$others.forEach(function (other) {
	            var anchor = doc.createAnchor(other.row, other.column);
	            anchor.$insertRight = true;
	            anchor.detach();
	            _self.others.push(anchor);
	        });
	        session.setUndoSelect(false);
	    };
	    PlaceHolder.prototype.showOtherMarkers = function () {
	        if (this.othersActive)
	            return;
	        var session = this.session;
	        var _self = this;
	        this.othersActive = true;
	        this.others.forEach(function (anchor) {
	            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
	        });
	    };
	    PlaceHolder.prototype.hideOtherMarkers = function () {
	        if (!this.othersActive)
	            return;
	        this.othersActive = false;
	        for (var i = 0; i < this.others.length; i++) {
	            this.session.removeMarker(this.others[i].markerId);
	        }
	    };
	    PlaceHolder.prototype.onUpdate = function (delta) {
	        if (this.$updating)
	            return this.updateAnchors(delta);
	        var range = delta;
	        if (range.start.row !== range.end.row)
	            return;
	        if (range.start.row !== this.pos.row)
	            return;
	        this.$updating = true;
	        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
	        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
	        var distanceFromStart = range.start.column - this.pos.column;
	        this.updateAnchors(delta);
	        if (inMainRange)
	            this.length += lengthDiff;
	        if (inMainRange && !this.session.$fromUndo) {
	            if (delta.action === 'insert') {
	                for (var i = this.others.length - 1; i >= 0; i--) {
	                    var otherPos = this.others[i];
	                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
	                    this.doc.insertMergedLines(newPos, delta.lines);
	                }
	            }
	            else if (delta.action === 'remove') {
	                for (var i = this.others.length - 1; i >= 0; i--) {
	                    var otherPos = this.others[i];
	                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
	                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
	                }
	            }
	        }
	        this.$updating = false;
	        this.updateMarkers();
	    };
	    PlaceHolder.prototype.updateAnchors = function (delta) {
	        this.pos.onChange(delta);
	        for (var i = this.others.length; i--;)
	            this.others[i].onChange(delta);
	        this.updateMarkers();
	    };
	    PlaceHolder.prototype.updateMarkers = function () {
	        if (this.$updating)
	            return;
	        var _self = this;
	        var session = this.session;
	        var updateMarker = function (pos, className) {
	            session.removeMarker(pos.markerId);
	            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
	        };
	        updateMarker(this.pos, this.mainClass);
	        for (var i = this.others.length; i--;)
	            updateMarker(this.others[i], this.othersClass);
	    };
	    PlaceHolder.prototype.onCursorChange = function (event) {
	        if (this.$updating || !this.session)
	            return;
	        var pos = this.session.selection.getCursor();
	        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
	            this.showOtherMarkers();
	            this._emit("cursorEnter", event);
	        }
	        else {
	            this.hideOtherMarkers();
	            this._emit("cursorLeave", event);
	        }
	    };
	    PlaceHolder.prototype.detach = function () {
	        this.session.removeMarker(this.pos && this.pos.markerId);
	        this.hideOtherMarkers();
	        this.doc.off("change", this.$onUpdate);
	        this.session.selection.off("changeCursor", this.$onCursorChange);
	        this.session.setUndoSelect(true);
	        this.session = null;
	    };
	    PlaceHolder.prototype.cancel = function () {
	        if (this.$undoStackDepth === -1)
	            return;
	        var undoManager = this.session.getUndoManager();
	        var undosRequired = (undoManager.$undoStack || undoManager["$undostack"]).length - this.$undoStackDepth;
	        for (var i = 0; i < undosRequired; i++) {
	            undoManager.undo(this.session, true);
	        }
	        if (this.selectionBefore)
	            this.session.selection.fromJSON(this.selectionBefore);
	    };
	    return PlaceHolder;
	}());
	oop.implement(PlaceHolder.prototype, EventEmitter);
	exports.PlaceHolder = PlaceHolder;

	});

	ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module){var event = require("../lib/event");
	var useragent = require("../lib/useragent");
	function isSamePoint(p1, p2) {
	    return p1.row == p2.row && p1.column == p2.column;
	}
	function onMouseDown(e) {
	    var ev = e.domEvent;
	    var alt = ev.altKey;
	    var shift = ev.shiftKey;
	    var ctrl = ev.ctrlKey;
	    var accel = e.getAccelKey();
	    var button = e.getButton();
	    if (ctrl && useragent.isMac)
	        button = ev.button;
	    if (e.editor.inMultiSelectMode && button == 2) {
	        e.editor.textInput.onContextMenu(e.domEvent);
	        return;
	    }
	    if (!ctrl && !alt && !accel) {
	        if (button === 0 && e.editor.inMultiSelectMode)
	            e.editor.exitMultiSelectMode();
	        return;
	    }
	    if (button !== 0)
	        return;
	    var editor = e.editor;
	    var selection = editor.selection;
	    var isMultiSelect = editor.inMultiSelectMode;
	    var pos = e.getDocumentPosition();
	    var cursor = selection.getCursor();
	    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));
	    var mouseX = e.x, mouseY = e.y;
	    var onMouseSelection = function (e) {
	        mouseX = e.clientX;
	        mouseY = e.clientY;
	    };
	    var session = editor.session;
	    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
	    var screenCursor = screenAnchor;
	    var selectionMode;
	    if (editor.$mouseHandler.$enableJumpToDef) {
	        if (ctrl && alt || accel && alt)
	            selectionMode = shift ? "block" : "add";
	        else if (alt && editor.$blockSelectEnabled)
	            selectionMode = "block";
	    }
	    else {
	        if (accel && !alt) {
	            selectionMode = "add";
	            if (!isMultiSelect && shift)
	                return;
	        }
	        else if (alt && editor.$blockSelectEnabled) {
	            selectionMode = "block";
	        }
	    }
	    if (selectionMode && useragent.isMac && ev.ctrlKey) {
	        editor.$mouseHandler.cancelContextMenu();
	    }
	    if (selectionMode == "add") {
	        if (!isMultiSelect && inSelection)
	            return; // dragging
	        if (!isMultiSelect) {
	            var range = selection.toOrientedRange();
	            editor.addSelectionMarker(range);
	        }
	        var oldRange = selection.rangeList.rangeAtPoint(pos);
	        editor.inVirtualSelectionMode = true;
	        if (shift) {
	            oldRange = null;
	            range = selection.ranges[0] || range;
	            editor.removeSelectionMarker(range);
	        }
	        editor.once("mouseup", function () {
	            var tmpSel = selection.toOrientedRange();
	            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
	                selection.substractPoint(tmpSel.cursor);
	            else {
	                if (shift) {
	                    selection.substractPoint(range.cursor);
	                }
	                else if (range) {
	                    editor.removeSelectionMarker(range);
	                    selection.addRange(range);
	                }
	                selection.addRange(tmpSel);
	            }
	            editor.inVirtualSelectionMode = false;
	        });
	    }
	    else if (selectionMode == "block") {
	        e.stop();
	        editor.inVirtualSelectionMode = true;
	        var initialRange;
	        var rectSel = [];
	        var blockSelect = function () {
	            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
	            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
	            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
	                return;
	            screenCursor = newCursor;
	            editor.selection.moveToPosition(cursor);
	            editor.renderer.scrollCursorIntoView();
	            editor.removeSelectionMarkers(rectSel);
	            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
	            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
	                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
	            rectSel.forEach(editor.addSelectionMarker, editor);
	            editor.updateSelectionMarkers();
	        };
	        if (isMultiSelect && !accel) {
	            selection.toSingleRange();
	        }
	        else if (!isMultiSelect && accel) {
	            initialRange = selection.toOrientedRange();
	            editor.addSelectionMarker(initialRange);
	        }
	        if (shift)
	            screenAnchor = session.documentToScreenPosition(selection.lead);
	        else
	            selection.moveToPosition(pos);
	        screenCursor = { row: -1, column: -1 };
	        var onMouseSelectionEnd = function (e) {
	            blockSelect();
	            clearInterval(timerId);
	            editor.removeSelectionMarkers(rectSel);
	            if (!rectSel.length)
	                rectSel = [selection.toOrientedRange()];
	            if (initialRange) {
	                editor.removeSelectionMarker(initialRange);
	                selection.toSingleRange(initialRange);
	            }
	            for (var i = 0; i < rectSel.length; i++)
	                selection.addRange(rectSel[i]);
	            editor.inVirtualSelectionMode = false;
	            editor.$mouseHandler.$clickSelection = null;
	        };
	        var onSelectionInterval = blockSelect;
	        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
	        var timerId = setInterval(function () { onSelectionInterval(); }, 20);
	        return e.preventDefault();
	    }
	}
	exports.onMouseDown = onMouseDown;

	});

	ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(require, exports, module){/**
	 * commands to enter multiselect mode
	 * @type {import("../../ace-internal").Ace.Command[]}
	 */
	exports.defaultCommands = [{
	        name: "addCursorAbove",
	        description: "Add cursor above",
	        exec: function (editor) { editor.selectMoreLines(-1); },
	        bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "addCursorBelow",
	        description: "Add cursor below",
	        exec: function (editor) { editor.selectMoreLines(1); },
	        bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "addCursorAboveSkipCurrent",
	        description: "Add cursor above (skip current)",
	        exec: function (editor) { editor.selectMoreLines(-1, true); },
	        bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "addCursorBelowSkipCurrent",
	        description: "Add cursor below (skip current)",
	        exec: function (editor) { editor.selectMoreLines(1, true); },
	        bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectMoreBefore",
	        description: "Select more before",
	        exec: function (editor) { editor.selectMore(-1); },
	        bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectMoreAfter",
	        description: "Select more after",
	        exec: function (editor) { editor.selectMore(1); },
	        bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectNextBefore",
	        description: "Select next before",
	        exec: function (editor) { editor.selectMore(-1, true); },
	        bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "selectNextAfter",
	        description: "Select next after",
	        exec: function (editor) { editor.selectMore(1, true); },
	        bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
	        scrollIntoView: "cursor",
	        readOnly: true
	    }, {
	        name: "toggleSplitSelectionIntoLines",
	        description: "Split selection into lines",
	        exec: function (editor) {
	            if (editor.multiSelect.rangeCount > 1)
	                editor.multiSelect.joinSelections();
	            else
	                editor.multiSelect.splitIntoLines();
	        },
	        bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
	        readOnly: true
	    }, {
	        name: "splitSelectionIntoLines",
	        description: "Split into lines",
	        exec: function (editor) { editor.multiSelect.splitIntoLines(); },
	        readOnly: true
	    }, {
	        name: "alignCursors",
	        description: "Align cursors",
	        exec: function (editor) { editor.alignCursors(); },
	        bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
	        scrollIntoView: "cursor"
	    }, {
	        name: "findAll",
	        description: "Find all",
	        exec: function (editor) { editor.findAll(); },
	        bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
	        scrollIntoView: "cursor",
	        readOnly: true
	    }];
	exports.multiSelectCommands = [{
	        name: "singleSelection",
	        description: "Single selection",
	        bindKey: "esc",
	        exec: function (editor) { editor.exitMultiSelectMode(); },
	        scrollIntoView: "cursor",
	        readOnly: true,
	        isAvailable: function (editor) { return editor && editor.inMultiSelectMode; }
	    }];
	var HashHandler = require("../keyboard/hash_handler").HashHandler;
	exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

	});

	ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(require, exports, module){/**
	 * @typedef {import("./anchor").Anchor} Anchor
	 * @typedef {import("../ace-internal").Ace.Point} Point
	 * @typedef {import("../ace-internal").Ace.ScreenCoordinates} ScreenCoordinates
	 */
	var RangeList = require("./range_list").RangeList;
	var Range = require("./range").Range;
	var Selection = require("./selection").Selection;
	var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
	var event = require("./lib/event");
	var lang = require("./lib/lang");
	var commands = require("./commands/multi_select_commands");
	exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
	var Search = require("./search").Search;
	var search = new Search();
	function find(session, needle, dir) {
	    search.$options.wrap = true;
	    search.$options.needle = needle;
	    search.$options.backwards = dir == -1;
	    return search.find(session);
	}
	var EditSession = require("./edit_session").EditSession;
	(function () {
	    this.getSelectionMarkers = function () {
	        return this.$selectionMarkers;
	    };
	}).call(EditSession.prototype);
	(function () {
	    this.ranges = null;
	    this.rangeList = null;
	    this.addRange = function (range, $blockChangeEvents) {
	        if (!range)
	            return;
	        if (!this.inMultiSelectMode && this.rangeCount === 0) {
	            var oldRange = this.toOrientedRange();
	            this.rangeList.add(oldRange);
	            this.rangeList.add(range);
	            if (this.rangeList.ranges.length != 2) {
	                this.rangeList.removeAll();
	                return $blockChangeEvents || this.fromOrientedRange(range);
	            }
	            this.rangeList.removeAll();
	            this.rangeList.add(oldRange);
	            this.$onAddRange(oldRange);
	        }
	        if (!range.cursor)
	            range.cursor = range.end;
	        var removed = this.rangeList.add(range);
	        this.$onAddRange(range);
	        if (removed.length)
	            this.$onRemoveRange(removed);
	        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
	            this._signal("multiSelect");
	            this.inMultiSelectMode = true;
	            this.session.$undoSelect = false;
	            this.rangeList.attach(this.session);
	        }
	        return $blockChangeEvents || this.fromOrientedRange(range);
	    };
	    this.toSingleRange = function (range) {
	        range = range || this.ranges[0];
	        var removed = this.rangeList.removeAll();
	        if (removed.length)
	            this.$onRemoveRange(removed);
	        range && this.fromOrientedRange(range);
	    };
	    this.substractPoint = function (pos) {
	        var removed = this.rangeList.substractPoint(pos);
	        if (removed) {
	            this.$onRemoveRange(removed);
	            return removed[0];
	        }
	    };
	    this.mergeOverlappingRanges = function () {
	        var removed = this.rangeList.merge();
	        if (removed.length)
	            this.$onRemoveRange(removed);
	    };
	    this.$onAddRange = function (range) {
	        this.rangeCount = this.rangeList.ranges.length;
	        this.ranges.unshift(range);
	        this._signal("addRange", { range: range });
	    };
	    this.$onRemoveRange = function (removed) {
	        this.rangeCount = this.rangeList.ranges.length;
	        if (this.rangeCount == 1 && this.inMultiSelectMode) {
	            var lastRange = this.rangeList.ranges.pop();
	            removed.push(lastRange);
	            this.rangeCount = 0;
	        }
	        for (var i = removed.length; i--;) {
	            var index = this.ranges.indexOf(removed[i]);
	            this.ranges.splice(index, 1);
	        }
	        this._signal("removeRange", { ranges: removed });
	        if (this.rangeCount === 0 && this.inMultiSelectMode) {
	            this.inMultiSelectMode = false;
	            this._signal("singleSelect");
	            this.session.$undoSelect = true;
	            this.rangeList.detach(this.session);
	        }
	        lastRange = lastRange || this.ranges[0];
	        if (lastRange && !lastRange.isEqual(this.getRange()))
	            this.fromOrientedRange(lastRange);
	    };
	    this.$initRangeList = function () {
	        if (this.rangeList)
	            return;
	        this.rangeList = new RangeList();
	        this.ranges = [];
	        this.rangeCount = 0;
	    };
	    this.getAllRanges = function () {
	        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
	    };
	    this.splitIntoLines = function () {
	        var ranges = this.ranges.length ? this.ranges : [this.getRange()];
	        var newRanges = [];
	        for (var i = 0; i < ranges.length; i++) {
	            var range = ranges[i];
	            var row = range.start.row;
	            var endRow = range.end.row;
	            if (row === endRow) {
	                newRanges.push(range.clone());
	            }
	            else {
	                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
	                while (++row < endRow)
	                    newRanges.push(this.getLineRange(row, true));
	                newRanges.push(new Range(endRow, 0, endRow, range.end.column));
	            }
	            if (i == 0 && !this.isBackwards())
	                newRanges = newRanges.reverse();
	        }
	        this.toSingleRange();
	        for (var i = newRanges.length; i--;)
	            this.addRange(newRanges[i]);
	    };
	    this.joinSelections = function () {
	        var ranges = this.rangeList.ranges;
	        var lastRange = ranges[ranges.length - 1];
	        var range = Range.fromPoints(ranges[0].start, lastRange.end);
	        this.toSingleRange();
	        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
	    };
	    this.toggleBlockSelection = function () {
	        if (this.rangeCount > 1) {
	            var ranges = this.rangeList.ranges;
	            var lastRange = ranges[ranges.length - 1];
	            var range = Range.fromPoints(ranges[0].start, lastRange.end);
	            this.toSingleRange();
	            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
	        }
	        else {
	            var cursor = this.session.documentToScreenPosition(this.cursor);
	            var anchor = this.session.documentToScreenPosition(this.anchor);
	            var rectSel = this.rectangularRangeBlock(cursor, anchor);
	            rectSel.forEach(this.addRange, this);
	        }
	    };
	    this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {
	        var rectSel = [];
	        var xBackwards = screenCursor.column < screenAnchor.column;
	        if (xBackwards) {
	            var startColumn = screenCursor.column;
	            var endColumn = screenAnchor.column;
	            var startOffsetX = screenCursor.offsetX;
	            var endOffsetX = screenAnchor.offsetX;
	        }
	        else {
	            var startColumn = screenAnchor.column;
	            var endColumn = screenCursor.column;
	            var startOffsetX = screenAnchor.offsetX;
	            var endOffsetX = screenCursor.offsetX;
	        }
	        var yBackwards = screenCursor.row < screenAnchor.row;
	        if (yBackwards) {
	            var startRow = screenCursor.row;
	            var endRow = screenAnchor.row;
	        }
	        else {
	            var startRow = screenAnchor.row;
	            var endRow = screenCursor.row;
	        }
	        if (startColumn < 0)
	            startColumn = 0;
	        if (startRow < 0)
	            startRow = 0;
	        if (startRow == endRow)
	            includeEmptyLines = true;
	        var docEnd;
	        for (var row = startRow; row <= endRow; row++) {
	            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
	            if (range.isEmpty()) {
	                if (docEnd && isSamePoint(range.end, docEnd))
	                    break;
	                docEnd = range.end;
	            }
	            range.cursor = xBackwards ? range.start : range.end;
	            rectSel.push(range);
	        }
	        if (yBackwards)
	            rectSel.reverse();
	        if (!includeEmptyLines) {
	            var end = rectSel.length - 1;
	            while (rectSel[end].isEmpty() && end > 0)
	                end--;
	            if (end > 0) {
	                var start = 0;
	                while (rectSel[start].isEmpty())
	                    start++;
	            }
	            for (var i = end; i >= start; i--) {
	                if (rectSel[i].isEmpty())
	                    rectSel.splice(i, 1);
	            }
	        }
	        return rectSel;
	    };
	}).call(Selection.prototype);
	var Editor = require("./editor").Editor;
	(function () {
	    this.updateSelectionMarkers = function () {
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };
	    this.addSelectionMarker = function (orientedRange) {
	        if (!orientedRange.cursor)
	            orientedRange.cursor = orientedRange.end;
	        var style = this.getSelectionStyle();
	        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
	        this.session.$selectionMarkers.push(orientedRange);
	        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
	        return orientedRange;
	    };
	    this.removeSelectionMarker = function (range) {
	        if (!range.marker)
	            return;
	        this.session.removeMarker(range.marker);
	        var index = this.session.$selectionMarkers.indexOf(range);
	        if (index != -1)
	            this.session.$selectionMarkers.splice(index, 1);
	        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
	    };
	    this.removeSelectionMarkers = function (ranges) {
	        var markerList = this.session.$selectionMarkers;
	        for (var i = ranges.length; i--;) {
	            var range = ranges[i];
	            if (!range.marker)
	                continue;
	            this.session.removeMarker(range.marker);
	            var index = markerList.indexOf(range);
	            if (index != -1)
	                markerList.splice(index, 1);
	        }
	        this.session.selectionMarkerCount = markerList.length;
	    };
	    this.$onAddRange = function (e) {
	        this.addSelectionMarker(e.range);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };
	    this.$onRemoveRange = function (e) {
	        this.removeSelectionMarkers(e.ranges);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };
	    this.$onMultiSelect = function (e) {
	        if (this.inMultiSelectMode)
	            return;
	        this.inMultiSelectMode = true;
	        this.setStyle("ace_multiselect");
	        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
	        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };
	    this.$onSingleSelect = function (e) {
	        if (this.session.multiSelect.inVirtualMode)
	            return;
	        this.inMultiSelectMode = false;
	        this.unsetStyle("ace_multiselect");
	        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
	        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	        this._emit("changeSelection");
	    };
	    this.$onMultiSelectExec = function (e) {
	        var command = e.command;
	        var editor = e.editor;
	        if (!editor.multiSelect)
	            return;
	        if (!command.multiSelectAction) {
	            var result = command.exec(editor, e.args || {});
	            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
	            editor.multiSelect.mergeOverlappingRanges();
	        }
	        else if (command.multiSelectAction == "forEach") {
	            result = editor.forEachSelection(command, e.args);
	        }
	        else if (command.multiSelectAction == "forEachLine") {
	            result = editor.forEachSelection(command, e.args, true);
	        }
	        else if (command.multiSelectAction == "single") {
	            editor.exitMultiSelectMode();
	            result = command.exec(editor, e.args || {});
	        }
	        else {
	            result = command.multiSelectAction(editor, e.args || {});
	        }
	        return result;
	    };
	    this.forEachSelection = function (cmd, args, options) {
	        if (this.inVirtualSelectionMode)
	            return;
	        var keepOrder = options && options.keepOrder;
	        var $byLines = options == true || options && options.$byLines;
	        var session = this.session;
	        var selection = this.selection;
	        var rangeList = selection.rangeList;
	        var ranges = (keepOrder ? selection : rangeList).ranges;
	        var result;
	        if (!ranges.length)
	            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
	        var reg = selection._eventRegistry;
	        selection._eventRegistry = {};
	        var tmpSel = new Selection(session);
	        this.inVirtualSelectionMode = true;
	        for (var i = ranges.length; i--;) {
	            if ($byLines) {
	                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
	                    i--;
	            }
	            tmpSel.fromOrientedRange(ranges[i]);
	            tmpSel.index = i;
	            this.selection = session.selection = tmpSel;
	            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
	            if (!result && cmdResult !== undefined)
	                result = cmdResult;
	            tmpSel.toOrientedRange(ranges[i]);
	        }
	        tmpSel.detach();
	        this.selection = session.selection = selection;
	        this.inVirtualSelectionMode = false;
	        selection._eventRegistry = reg;
	        selection.mergeOverlappingRanges();
	        if (selection.ranges[0])
	            selection.fromOrientedRange(selection.ranges[0]);
	        var anim = this.renderer.$scrollAnimation;
	        this.onCursorChange();
	        this.onSelectionChange();
	        if (anim && anim.from == anim.to)
	            this.renderer.animateScrolling(anim.from);
	        return result;
	    };
	    this.exitMultiSelectMode = function () {
	        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
	            return;
	        this.multiSelect.toSingleRange();
	    };
	    this.getSelectedText = function () {
	        var text = "";
	        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
	            var ranges = this.multiSelect.rangeList.ranges;
	            var buf = [];
	            for (var i = 0; i < ranges.length; i++) {
	                buf.push(this.session.getTextRange(ranges[i]));
	            }
	            var nl = this.session.getDocument().getNewLineCharacter();
	            text = buf.join(nl);
	            if (text.length == (buf.length - 1) * nl.length)
	                text = "";
	        }
	        else if (!this.selection.isEmpty()) {
	            text = this.session.getTextRange(this.getSelectionRange());
	        }
	        return text;
	    };
	    this.$checkMultiselectChange = function (e, anchor) {
	        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
	            var range = this.multiSelect.ranges[0];
	            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
	                return;
	            var pos = anchor == this.multiSelect.anchor
	                ? range.cursor == range.start ? range.end : range.start
	                : range.cursor;
	            if (pos.row != anchor.row
	                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
	                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
	            else
	                this.multiSelect.mergeOverlappingRanges();
	        }
	    };
	    this.findAll = function (needle, options, additive) {
	        options = options || {};
	        options.needle = needle || options.needle;
	        if (options.needle == undefined) {
	            var range = this.selection.isEmpty()
	                ? this.selection.getWordRange()
	                : this.selection.getRange();
	            options.needle = this.session.getTextRange(range);
	        }
	        this.$search.set(options);
	        var ranges = this.$search.findAll(this.session);
	        if (!ranges.length)
	            return 0;
	        var selection = this.multiSelect;
	        if (!additive)
	            selection.toSingleRange(ranges[0]);
	        for (var i = ranges.length; i--;)
	            selection.addRange(ranges[i], true);
	        if (range && selection.rangeList.rangeAtPoint(range.start))
	            selection.addRange(range, true);
	        return ranges.length;
	    };
	    this.selectMoreLines = function (dir, skip) {
	        var range = this.selection.toOrientedRange();
	        var isBackwards = range.cursor == range.end;
	        var screenLead = this.session.documentToScreenPosition(range.cursor);
	        if (this.selection.$desiredColumn)
	            screenLead.column = this.selection.$desiredColumn;
	        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
	        if (!range.isEmpty()) {
	            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
	            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
	        }
	        else {
	            var anchor = lead;
	        }
	        if (isBackwards) {
	            var newRange = Range.fromPoints(lead, anchor);
	            newRange.cursor = newRange.start;
	        }
	        else {
	            var newRange = Range.fromPoints(anchor, lead);
	            newRange.cursor = newRange.end;
	        }
	        newRange.desiredColumn = screenLead.column;
	        if (!this.selection.inMultiSelectMode) {
	            this.selection.addRange(range);
	        }
	        else {
	            if (skip)
	                var toRemove = range.cursor;
	        }
	        this.selection.addRange(newRange);
	        if (toRemove)
	            this.selection.substractPoint(toRemove);
	    };
	    this.transposeSelections = function (dir) {
	        var session = this.session;
	        var sel = session.multiSelect;
	        var all = sel.ranges;
	        for (var i = all.length; i--;) {
	            var range = all[i];
	            if (range.isEmpty()) {
	                var tmp_1 = session.getWordRange(range.start.row, range.start.column);
	                range.start.row = tmp_1.start.row;
	                range.start.column = tmp_1.start.column;
	                range.end.row = tmp_1.end.row;
	                range.end.column = tmp_1.end.column;
	            }
	        }
	        sel.mergeOverlappingRanges();
	        var words = [];
	        for (var i = all.length; i--;) {
	            var range = all[i];
	            words.unshift(session.getTextRange(range));
	        }
	        if (dir < 0)
	            words.unshift(words.pop());
	        else
	            words.push(words.shift());
	        for (var i = all.length; i--;) {
	            var range = all[i];
	            var tmp = range.clone();
	            session.replace(range, words[i]);
	            range.start.row = tmp.start.row;
	            range.start.column = tmp.start.column;
	        }
	        sel.fromOrientedRange(sel.ranges[0]);
	    };
	    this.selectMore = function (dir, skip, stopAtFirst) {
	        var session = this.session;
	        var sel = session.multiSelect;
	        var range = sel.toOrientedRange();
	        if (range.isEmpty()) {
	            range = session.getWordRange(range.start.row, range.start.column);
	            range.cursor = dir == -1 ? range.start : range.end;
	            this.multiSelect.addRange(range);
	            if (stopAtFirst)
	                return;
	        }
	        var needle = session.getTextRange(range);
	        var newRange = find(session, needle, dir);
	        if (newRange) {
	            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
	            this.session.unfold(newRange);
	            this.multiSelect.addRange(newRange);
	            this.renderer.scrollCursorIntoView(null, 0.5);
	        }
	        if (skip)
	            this.multiSelect.substractPoint(range.cursor);
	    };
	    this.alignCursors = function () {
	        var session = this.session;
	        var sel = session.multiSelect;
	        var ranges = sel.ranges;
	        var row = -1;
	        var sameRowRanges = ranges.filter(function (r) {
	            if (r.cursor.row == row)
	                return true;
	            row = r.cursor.row;
	        });
	        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
	            var range = this.selection.getRange();
	            var fr = range.start.row, lr = range.end.row;
	            var guessRange = fr == lr;
	            if (guessRange) {
	                var max = this.session.getLength();
	                var line;
	                do {
	                    line = this.session.getLine(lr);
	                } while (/[=:]/.test(line) && ++lr < max);
	                do {
	                    line = this.session.getLine(fr);
	                } while (/[=:]/.test(line) && --fr > 0);
	                if (fr < 0)
	                    fr = 0;
	                if (lr >= max)
	                    lr = max - 1;
	            }
	            var lines = this.session.removeFullLines(fr, lr);
	            lines = this.$reAlignText(lines, guessRange);
	            this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
	            if (!guessRange) {
	                range.start.column = 0;
	                range.end.column = lines[lines.length - 1].length;
	            }
	            this.selection.setRange(range);
	        }
	        else {
	            sameRowRanges.forEach(function (r) {
	                sel.substractPoint(r.cursor);
	            });
	            var maxCol = 0;
	            var minSpace = Infinity;
	            var spaceOffsets = ranges.map(function (r) {
	                var p = r.cursor;
	                var line = session.getLine(p.row);
	                var spaceOffset = line.substr(p.column).search(/\S/g);
	                if (spaceOffset == -1)
	                    spaceOffset = 0;
	                if (p.column > maxCol)
	                    maxCol = p.column;
	                if (spaceOffset < minSpace)
	                    minSpace = spaceOffset;
	                return spaceOffset;
	            });
	            ranges.forEach(function (r, i) {
	                var p = r.cursor;
	                var l = maxCol - p.column;
	                var d = spaceOffsets[i] - minSpace;
	                if (l > d)
	                    session.insert(p, lang.stringRepeat(" ", l - d));
	                else
	                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
	                r.start.column = r.end.column = maxCol;
	                r.start.row = r.end.row = p.row;
	                r.cursor = r.end;
	            });
	            sel.fromOrientedRange(ranges[0]);
	            this.renderer.updateCursor();
	            this.renderer.updateBackMarkers();
	        }
	    };
	    this.$reAlignText = function (lines, forceLeft) {
	        var isLeftAligned = true, isRightAligned = true;
	        var startW, textW, endW;
	        return lines.map(function (line) {
	            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
	            if (!m)
	                return [line];
	            if (startW == null) {
	                startW = m[1].length;
	                textW = m[2].length;
	                endW = m[3].length;
	                return m;
	            }
	            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
	                isRightAligned = false;
	            if (startW != m[1].length)
	                isLeftAligned = false;
	            if (startW > m[1].length)
	                startW = m[1].length;
	            if (textW < m[2].length)
	                textW = m[2].length;
	            if (endW > m[3].length)
	                endW = m[3].length;
	            return m;
	        }).map(forceLeft ? alignLeft :
	            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
	        function spaces(n) {
	            return lang.stringRepeat(" ", n);
	        }
	        function alignLeft(m) {
	            return !m[2] ? m[0] : spaces(startW) + m[2]
	                + spaces(textW - m[2].length + endW)
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	        function alignRight(m) {
	            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
	                + spaces(endW)
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	        function unAlign(m) {
	            return !m[2] ? m[0] : spaces(startW) + m[2]
	                + spaces(endW)
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	    };
	}).call(Editor.prototype);
	function isSamePoint(p1, p2) {
	    return p1.row == p2.row && p1.column == p2.column;
	}
	exports.onSessionChange = function (e) {
	    var session = e.session;
	    if (session && !session.multiSelect) {
	        session.$selectionMarkers = [];
	        session.selection.$initRangeList();
	        session.multiSelect = session.selection;
	    }
	    this.multiSelect = session && session.multiSelect;
	    var oldSession = e.oldSession;
	    if (oldSession) {
	        oldSession.multiSelect.off("addRange", this.$onAddRange);
	        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
	        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
	        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
	        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
	        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
	    }
	    if (session) {
	        session.multiSelect.on("addRange", this.$onAddRange);
	        session.multiSelect.on("removeRange", this.$onRemoveRange);
	        session.multiSelect.on("multiSelect", this.$onMultiSelect);
	        session.multiSelect.on("singleSelect", this.$onSingleSelect);
	        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
	        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
	    }
	    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
	        if (session.selection.inMultiSelectMode)
	            this.$onMultiSelect();
	        else
	            this.$onSingleSelect();
	    }
	};
	function MultiSelect(editor) {
	    if (editor.$multiselectOnSessionChange)
	        return;
	    editor.$onAddRange = editor.$onAddRange.bind(editor);
	    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
	    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
	    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
	    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
	    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
	    editor.$multiselectOnSessionChange(editor);
	    editor.on("changeSession", editor.$multiselectOnSessionChange);
	    editor.on("mousedown", onMouseDown);
	    editor.commands.addCommands(commands.defaultCommands);
	    addAltCursorListeners(editor);
	}
	function addAltCursorListeners(editor) {
	    if (!editor.textInput)
	        return;
	    var el = editor.textInput.getElement();
	    var altCursor = false;
	    event.addListener(el, "keydown", function (e) {
	        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
	        if (editor.$blockSelectEnabled && altDown) {
	            if (!altCursor) {
	                editor.renderer.setMouseCursor("crosshair");
	                altCursor = true;
	            }
	        }
	        else if (altCursor) {
	            reset();
	        }
	    }, editor);
	    event.addListener(el, "keyup", reset, editor);
	    event.addListener(el, "blur", reset, editor);
	    function reset(e) {
	        if (altCursor) {
	            editor.renderer.setMouseCursor("");
	            altCursor = false;
	        }
	    }
	}
	exports.MultiSelect = MultiSelect;
	require("./config").defineOptions(Editor.prototype, "editor", {
	    enableMultiselect: {
	        set: function (val) {
	            MultiSelect(this);
	            if (val) {
	                this.on("mousedown", onMouseDown);
	            }
	            else {
	                this.off("mousedown", onMouseDown);
	            }
	        },
	        value: true
	    },
	    enableBlockSelect: {
	        set: function (val) {
	            this.$blockSelectEnabled = val;
	        },
	        value: true
	    }
	});

	});

	ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(require, exports, module){	var Range = require("../../range").Range;
	var FoldMode = exports.FoldMode = function () { };
	(function () {
	    this.foldingStartMarker = null;
	    this.foldingStopMarker = null;
	    this.getFoldWidget = function (session, foldStyle, row) {
	        var line = session.getLine(row);
	        if (this.foldingStartMarker.test(line))
	            return "start";
	        if (foldStyle == "markbeginend"
	            && this.foldingStopMarker
	            && this.foldingStopMarker.test(line))
	            return "end";
	        return "";
	    };
	    this.getFoldWidgetRange = function (session, foldStyle, row) {
	        return null;
	    };
	    this.indentationBlock = function (session, row, column) {
	        var re = /\S/;
	        var line = session.getLine(row);
	        var startLevel = line.search(re);
	        if (startLevel == -1)
	            return;
	        var startColumn = column || line.length;
	        var maxRow = session.getLength();
	        var startRow = row;
	        var endRow = row;
	        while (++row < maxRow) {
	            var level = session.getLine(row).search(re);
	            if (level == -1)
	                continue;
	            if (level <= startLevel) {
	                var token = session.getTokenAt(row, 0);
	                if (!token || token.type !== "string")
	                    break;
	            }
	            endRow = row;
	        }
	        if (endRow > startRow) {
	            var endColumn = session.getLine(endRow).length;
	            return new Range(startRow, startColumn, endRow, endColumn);
	        }
	    };
	    this.openingBracketBlock = function (session, bracket, row, column, typeRe) {
	        var start = { row: row, column: column + 1 };
	        var end = session.$findClosingBracket(bracket, start, typeRe);
	        if (!end)
	            return;
	        var fw = session.foldWidgets[end.row];
	        if (fw == null)
	            fw = session.getFoldWidget(end.row);
	        if (fw == "start" && end.row > start.row) {
	            end.row--;
	            end.column = session.getLine(end.row).length;
	        }
	        return Range.fromPoints(start, end);
	    };
	    this.closingBracketBlock = function (session, bracket, row, column, typeRe) {
	        var end = { row: row, column: column };
	        var start = session.$findOpeningBracket(bracket, end);
	        if (!start)
	            return;
	        start.column++;
	        end.column--;
	        return Range.fromPoints(start, end);
	    };
	}).call(FoldMode.prototype);

	});

	ace.define("ace/ext/error_marker",["require","exports","module","ace/lib/dom","ace/range","ace/config"], function(require, exports, module){/**
	 * ## Error Marker extension
	 *
	 * Provides inline error display functionality for Ace editor. Creates visual error markers that appear as tooltips
	 * below editor lines containing annotations (errors, warnings, info). Enables navigation between error locations with
	 * keyboard shortcuts and displays context-sensitive messages with proper styling based on annotation severity.
	 *
	 * @module
	 */
	var dom = require("../lib/dom");
	var Range = require("../range").Range;
	var nls = require("../config").nls;
	function binarySearch(array, needle, comparator) {
	    var first = 0;
	    var last = array.length - 1;
	    while (first <= last) {
	        var mid = (first + last) >> 1;
	        var c = comparator(needle, array[mid]);
	        if (c > 0)
	            first = mid + 1;
	        else if (c < 0)
	            last = mid - 1;
	        else
	            return mid;
	    }
	    return -(first + 1);
	}
	function findAnnotations(session, row, dir) {
	    var annotations = session.getAnnotations().sort(Range.comparePoints);
	    if (!annotations.length)
	        return;
	    var i = binarySearch(annotations, { row: row, column: -1 }, Range.comparePoints);
	    if (i < 0)
	        i = -i - 1;
	    if (i >= annotations.length)
	        i = dir > 0 ? 0 : annotations.length - 1;
	    else if (i === 0 && dir < 0)
	        i = annotations.length - 1;
	    var annotation = annotations[i];
	    if (!annotation || !dir)
	        return;
	    if (annotation.row === row) {
	        do {
	            annotation = annotations[i += dir];
	        } while (annotation && annotation.row === row);
	        if (!annotation)
	            return annotations.slice();
	    }
	    var matched = [];
	    row = annotation.row;
	    do {
	        matched[dir < 0 ? "unshift" : "push"](annotation);
	        annotation = annotations[i += dir];
	    } while (annotation && annotation.row == row);
	    return matched.length && matched;
	}
	exports.showErrorMarker = function (editor, dir) {
	    var session = editor.session;
	    var pos = editor.getCursorPosition();
	    var row = pos.row;
	    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {
	        return w.type == "errorMarker";
	    })[0];
	    if (oldWidget) {
	        oldWidget.destroy();
	    }
	    else {
	        row -= dir;
	    }
	    var annotations = findAnnotations(session, row, dir);
	    var gutterAnno;
	    if (annotations) {
	        var annotation = annotations[0];
	        pos.column = (annotation.pos && typeof annotation.column != "number"
	            ? annotation.pos.sc
	            : annotation.column) || 0;
	        pos.row = annotation.row;
	        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
	    }
	    else if (oldWidget) {
	        return;
	    }
	    else {
	        gutterAnno = {
	            displayText: [nls("error-marker.good-state", "Looks good!")],
	            className: "ace_ok"
	        };
	    }
	    editor.session.unfold(pos.row);
	    editor.selection.moveToPosition(pos);
	    var w = {
	        row: pos.row,
	        fixedWidth: true,
	        coverGutter: true,
	        el: dom.createElement("div"),
	        type: "errorMarker"
	    };
	    var el = w.el.appendChild(dom.createElement("div"));
	    var arrow = w.el.appendChild(dom.createElement("div"));
	    arrow.className = "error_widget_arrow " + gutterAnno.className;
	    var left = editor.renderer.$cursorLayer
	        .getPixelPosition(pos).left;
	    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
	    w.el.className = "error_widget_wrapper";
	    el.className = "error_widget " + gutterAnno.className;
	    gutterAnno.displayText.forEach(function (annoTextLine, i) {
	        el.appendChild(dom.createTextNode(annoTextLine));
	        if (i < gutterAnno.displayText.length - 1) {
	            el.appendChild(dom.createElement("br"));
	        }
	    });
	    el.appendChild(dom.createElement("div"));
	    var kb = function (_, hashId, keyString) {
	        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
	            w.destroy();
	            return { command: "null" };
	        }
	    };
	    w.destroy = function () {
	        if (editor.$mouseHandler.isMousePressed)
	            return;
	        editor.keyBinding.removeKeyboardHandler(kb);
	        session.widgetManager.removeLineWidget(w);
	        editor.off("changeSelection", w.destroy);
	        editor.off("changeSession", w.destroy);
	        editor.off("mouseup", w.destroy);
	        editor.off("change", w.destroy);
	    };
	    editor.keyBinding.addKeyboardHandler(kb);
	    editor.on("changeSelection", w.destroy);
	    editor.on("changeSession", w.destroy);
	    editor.on("mouseup", w.destroy);
	    editor.on("change", w.destroy);
	    editor.session.widgetManager.addLineWidget(w);
	    w.el.onmousedown = editor.focus.bind(editor);
	    editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
	};
	dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);

	});

	ace.define("ace/ace",["require","exports","module","ace/lib/dom","ace/range","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config","ace/loader_build"], function(require, exports, module){/**
	 * The main class required to set up an Ace instance in the browser.
	 *
	 * @namespace Ace
	 **/
	require("./loader_build")(exports);
	var dom = require("./lib/dom");
	var Range = require("./range").Range;
	var Editor = require("./editor").Editor;
	var EditSession = require("./edit_session").EditSession;
	var UndoManager = require("./undomanager").UndoManager;
	var Renderer = require("./virtual_renderer").VirtualRenderer;
	require("./worker/worker_client");
	require("./keyboard/hash_handler");
	require("./placeholder");
	require("./multi_select");
	require("./mode/folding/fold_mode");
	require("./theme/textmate");
	require("./ext/error_marker");
	exports.config = require("./config");
	exports.edit = function (el, options) {
	    if (typeof el == "string") {
	        var _id = el;
	        el = document.getElementById(_id);
	        if (!el)
	            throw new Error("ace.edit can't find div #" + _id);
	    }
	    if (el && el.env && el.env.editor instanceof Editor)
	        return el.env.editor;
	    var value = "";
	    if (el && /input|textarea/i.test(el.tagName)) {
	        var oldNode = el;
	        value = oldNode.value;
	        el = dom.createElement("pre");
	        oldNode.parentNode.replaceChild(el, oldNode);
	    }
	    else if (el) {
	        value = el.textContent;
	        el.innerHTML = "";
	    }
	    var doc = exports.createEditSession(value);
	    var editor = new Editor(new Renderer(el), doc, options);
	    var env = {
	        document: doc,
	        editor: editor,
	        onResize: editor.resize.bind(editor, null)
	    };
	    if (oldNode)
	        env.textarea = oldNode;
	    editor.on("destroy", function () {
	        env.editor.container.env = null; // prevent memory leak on old ie
	    });
	    editor.container.env = editor.env = env;
	    return editor;
	};
	exports.createEditSession = function (text, mode) {
	    var doc = new EditSession(text, mode);
	    doc.setUndoManager(new UndoManager());
	    return doc;
	};
	exports.Range = Range;
	exports.Editor = Editor;
	exports.EditSession = EditSession;
	exports.UndoManager = UndoManager;
	exports.VirtualRenderer = Renderer;
	var version = exports.config.version;
	exports.version = version;

	});            (function() {
	                ace.require(["ace/ace"], function(a) {
	                    if (a) {
	                        a.config.init(true);
	                        a.define = ace.define;
	                    }
	                    var global = (function () {
	                        return this;
	                    })();
	                    if (!global && typeof window != "undefined") global = window; // can happen in strict mode
	                    if (!global && typeof self != "undefined") global = self; // can happen in webworker
	                    
	                    if (!global.ace)
	                        global.ace = a;
	                    for (var key in a) if (a.hasOwnProperty(key))
	                        global.ace[key] = a[key];
	                    global.ace["default"] = global.ace;
	                    if (module) {
	                        module.exports = global.ace;
	                    }
	                });
	            })(); 
} (ace$3));

var aceExports = ace$3.exports;

var lodash_isequal = {exports: {}};

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash_isequal.exports;

(function (module, exports) {
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols,
	    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = isEqual; 
} (lodash_isequal, lodash_isequal.exports));

var lodash_isequalExports = lodash_isequal.exports;

var editorOptions$1 = {};

Object.defineProperty(editorOptions$1, "__esModule", { value: true });
editorOptions$1.getAceInstance = editorOptions$1.debounce = editorOptions$1.editorEvents = editorOptions$1.editorOptions = void 0;
var editorOptions = [
    "minLines",
    "maxLines",
    "readOnly",
    "highlightActiveLine",
    "tabSize",
    "enableBasicAutocompletion",
    "enableLiveAutocompletion",
    "enableSnippets"
];
editorOptions$1.editorOptions = editorOptions;
var editorEvents = [
    "onChange",
    "onFocus",
    "onInput",
    "onBlur",
    "onCopy",
    "onPaste",
    "onSelectionChange",
    "onCursorChange",
    "onScroll",
    "handleOptions",
    "updateRef"
];
editorOptions$1.editorEvents = editorEvents;
var getAceInstance = function () {
    var ace;
    if (typeof window === "undefined") {
        // ace-builds just needs some window object to attach ace to.
        // During SSR even just an empty object will work.
        commonjsGlobal.window = {};
        ace = aceExports;
        // And it can be discarded immediately afterward to avoid confusing
        // other libraries that might detect SSR the same way we did.
        delete commonjsGlobal.window;
    }
    else if (window.ace) {
        // Fallback for ace.require when vanilla ACE is hosted over a CDN
        ace = window.ace;
        ace.acequire = window.ace.require || window.ace.acequire;
    }
    else {
        ace = aceExports;
    }
    return ace;
};
editorOptions$1.getAceInstance = getAceInstance;
var debounce = function (fn, delay) {
    var timer = null;
    // tslint:disable-next-line
    return function () {
        var context = this;
        var args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function () {
            fn.apply(context, args);
        }, delay);
    };
};
editorOptions$1.debounce = debounce;

var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$1 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
Object.defineProperty(ace$4, "__esModule", { value: true });
var ace_builds_1$1 = aceExports;
var PropTypes$2 = propTypesExports;
var React$B = reactExports;
var isEqual$1 = lodash_isequalExports;
var editorOptions_1$1 = editorOptions$1;
var ace$2 = (0, editorOptions_1$1.getAceInstance)();
var ReactAce = /** @class */ (function (_super) {
    __extends$2(ReactAce, _super);
    function ReactAce(props) {
        var _this = _super.call(this, props) || this;
        editorOptions_1$1.editorEvents.forEach(function (method) {
            _this[method] = _this[method].bind(_this);
        });
        _this.debounce = editorOptions_1$1.debounce;
        return _this;
    }
    ReactAce.prototype.isInShadow = function (node) {
        var parent = node && node.parentNode;
        while (parent) {
            if (parent.toString() === "[object ShadowRoot]") {
                return true;
            }
            parent = parent.parentNode;
        }
        return false;
    };
    ReactAce.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, className = _a.className, onBeforeLoad = _a.onBeforeLoad, onValidate = _a.onValidate, mode = _a.mode, focus = _a.focus, theme = _a.theme, fontSize = _a.fontSize, lineHeight = _a.lineHeight, value = _a.value, defaultValue = _a.defaultValue, showGutter = _a.showGutter, wrapEnabled = _a.wrapEnabled, showPrintMargin = _a.showPrintMargin, _b = _a.scrollMargin, scrollMargin = _b === void 0 ? [0, 0, 0, 0] : _b, keyboardHandler = _a.keyboardHandler, onLoad = _a.onLoad, commands = _a.commands, annotations = _a.annotations, markers = _a.markers, placeholder = _a.placeholder;
        this.editor = ace$2.edit(this.refEditor);
        if (onBeforeLoad) {
            onBeforeLoad(ace$2);
        }
        var editorProps = Object.keys(this.props.editorProps);
        for (var i = 0; i < editorProps.length; i++) {
            this.editor[editorProps[i]] = this.props.editorProps[editorProps[i]];
        }
        if (this.props.debounceChangePeriod) {
            this.onChange = this.debounce(this.onChange, this.props.debounceChangePeriod);
        }
        this.editor.renderer.setScrollMargin(scrollMargin[0], scrollMargin[1], scrollMargin[2], scrollMargin[3]);
        if (this.isInShadow(this.refEditor)) {
            this.editor.renderer.attachToShadowRoot();
        }
        this.editor
            .getSession()
            .setMode(typeof mode === "string" ? "ace/mode/".concat(mode) : mode);
        if (theme && theme !== "")
            this.editor.setTheme("ace/theme/".concat(theme));
        this.editor.setFontSize(typeof fontSize === "number" ? "".concat(fontSize, "px") : fontSize);
        if (lineHeight) {
            this.editor.container.style.lineHeight =
                typeof lineHeight === "number" ? "".concat(lineHeight, "px") : "".concat(lineHeight);
            this.editor.renderer.updateFontSize();
        }
        this.editor
            .getSession()
            .setValue(!defaultValue ? value || "" : defaultValue);
        if (this.props.navigateToFileEnd) {
            this.editor.navigateFileEnd();
        }
        this.editor.renderer.setShowGutter(showGutter);
        this.editor.getSession().setUseWrapMode(wrapEnabled);
        this.editor.setShowPrintMargin(showPrintMargin);
        this.editor.on("focus", this.onFocus);
        this.editor.on("blur", this.onBlur);
        this.editor.on("copy", this.onCopy);
        this.editor.on("paste", this.onPaste);
        this.editor.on("change", this.onChange);
        this.editor.on("input", this.onInput);
        if (placeholder) {
            this.updatePlaceholder();
        }
        this.editor
            .getSession()
            .selection.on("changeSelection", this.onSelectionChange);
        this.editor.getSession().selection.on("changeCursor", this.onCursorChange);
        if (onValidate) {
            // @ts-ignore types don't include
            this.editor.getSession().on("changeAnnotation", function () {
                // tslint:disable-next-line:no-shadowed-variable
                var annotations = _this.editor.getSession().getAnnotations();
                _this.props.onValidate(annotations);
            });
        }
        this.editor.session.on("changeScrollTop", this.onScroll);
        this.editor.getSession().setAnnotations(annotations || []);
        if (markers && markers.length > 0) {
            this.handleMarkers(markers);
        }
        // get a list of possible options to avoid 'misspelled option errors'
        var availableOptions = this.editor.$options;
        editorOptions_1$1.editorOptions.forEach(function (option) {
            if (availableOptions.hasOwnProperty(option)) {
                // @ts-ignore
                _this.editor.setOption(option, _this.props[option]);
            }
            else if (_this.props[option]) {
                console.warn("ReactAce: editor option ".concat(option, " was activated but not found. Did you need to import a related tool or did you possibly mispell the option?"));
            }
        });
        this.handleOptions(this.props);
        if (Array.isArray(commands)) {
            commands.forEach(function (command) {
                if (typeof command.exec === "string") {
                    _this.editor.commands.bindKey(command.bindKey, command.exec);
                }
                else {
                    _this.editor.commands.addCommand(command);
                }
            });
        }
        if (keyboardHandler) {
            this.editor.setKeyboardHandler("ace/keyboard/" + keyboardHandler);
        }
        if (className) {
            this.refEditor.className += " " + className;
        }
        if (onLoad) {
            onLoad(this.editor);
        }
        this.editor.resize();
        if (focus) {
            this.editor.focus();
        }
    };
    ReactAce.prototype.componentDidUpdate = function (prevProps) {
        var oldProps = prevProps;
        var nextProps = this.props;
        for (var i = 0; i < editorOptions_1$1.editorOptions.length; i++) {
            var option = editorOptions_1$1.editorOptions[i];
            if (nextProps[option] !== oldProps[option]) {
                // @ts-ignore
                this.editor.setOption(option, nextProps[option]);
            }
        }
        if (nextProps.className !== oldProps.className) {
            var appliedClasses = this.refEditor.className;
            var appliedClassesArray_1 = appliedClasses.trim().split(" ");
            var oldClassesArray = oldProps.className.trim().split(" ");
            oldClassesArray.forEach(function (oldClass) {
                var index = appliedClassesArray_1.indexOf(oldClass);
                appliedClassesArray_1.splice(index, 1);
            });
            this.refEditor.className =
                " " + nextProps.className + " " + appliedClassesArray_1.join(" ");
        }
        // First process editor value, as it may create a new session (see issue #300)
        var valueChanged = this.editor &&
            nextProps.value != null &&
            this.editor.getValue() !== nextProps.value;
        if (valueChanged) {
            // editor.setValue is a synchronous function call, change event is emitted before setValue return.
            this.silent = true;
            var pos = this.editor.session.selection.toJSON();
            this.editor.setValue(nextProps.value, nextProps.cursorStart);
            this.editor.session.selection.fromJSON(pos);
            this.silent = false;
        }
        if (nextProps.placeholder !== oldProps.placeholder) {
            this.updatePlaceholder();
        }
        if (nextProps.mode !== oldProps.mode) {
            this.editor
                .getSession()
                .setMode(typeof nextProps.mode === "string"
                ? "ace/mode/".concat(nextProps.mode)
                : nextProps.mode);
        }
        if (nextProps.theme !== oldProps.theme) {
            this.editor.setTheme("ace/theme/" + nextProps.theme);
        }
        if (nextProps.keyboardHandler !== oldProps.keyboardHandler) {
            if (nextProps.keyboardHandler) {
                this.editor.setKeyboardHandler("ace/keyboard/" + nextProps.keyboardHandler);
            }
            else {
                this.editor.setKeyboardHandler(null);
            }
        }
        if (nextProps.fontSize !== oldProps.fontSize) {
            this.editor.setFontSize(typeof nextProps.fontSize === "number"
                ? "".concat(nextProps.fontSize, "px")
                : nextProps.fontSize);
        }
        if (nextProps.lineHeight !== oldProps.lineHeight) {
            this.editor.container.style.lineHeight =
                typeof nextProps.lineHeight === "number"
                    ? "".concat(nextProps.lineHeight, "px")
                    : nextProps.lineHeight;
            this.editor.renderer.updateFontSize();
        }
        if (nextProps.wrapEnabled !== oldProps.wrapEnabled) {
            this.editor.getSession().setUseWrapMode(nextProps.wrapEnabled);
        }
        if (nextProps.showPrintMargin !== oldProps.showPrintMargin) {
            this.editor.setShowPrintMargin(nextProps.showPrintMargin);
        }
        if (nextProps.showGutter !== oldProps.showGutter) {
            this.editor.renderer.setShowGutter(nextProps.showGutter);
        }
        if (!isEqual$1(nextProps.setOptions, oldProps.setOptions)) {
            this.handleOptions(nextProps);
        }
        // if the value or annotations changed, set the annotations
        // changing the value may create create a new session which will require annotations to be re-set
        if (valueChanged || !isEqual$1(nextProps.annotations, oldProps.annotations)) {
            this.editor.getSession().setAnnotations(nextProps.annotations || []);
        }
        if (!isEqual$1(nextProps.markers, oldProps.markers) &&
            Array.isArray(nextProps.markers)) {
            this.handleMarkers(nextProps.markers);
        }
        // this doesn't look like it works at all....
        if (!isEqual$1(nextProps.scrollMargin, oldProps.scrollMargin)) {
            this.handleScrollMargins(nextProps.scrollMargin);
        }
        if (prevProps.height !== this.props.height ||
            prevProps.width !== this.props.width) {
            this.editor.resize();
        }
        if (this.props.focus && !prevProps.focus) {
            this.editor.focus();
        }
    };
    ReactAce.prototype.handleScrollMargins = function (margins) {
        if (margins === void 0) { margins = [0, 0, 0, 0]; }
        this.editor.renderer.setScrollMargin(margins[0], margins[1], margins[2], margins[3]);
    };
    ReactAce.prototype.componentWillUnmount = function () {
        if (this.editor) {
            this.editor.destroy();
            this.editor = null;
        }
    };
    ReactAce.prototype.onChange = function (event) {
        if (this.editor && this.props.onChange && !this.silent) {
            var value = this.editor.getValue();
            this.props.onChange(value, event);
        }
    };
    ReactAce.prototype.onSelectionChange = function (event) {
        if (this.props.onSelectionChange) {
            var value = this.editor.getSelection();
            this.props.onSelectionChange(value, event);
        }
    };
    ReactAce.prototype.onCursorChange = function (event) {
        if (this.props.onCursorChange) {
            var value = this.editor.getSelection();
            this.props.onCursorChange(value, event);
        }
    };
    ReactAce.prototype.onInput = function (event) {
        if (this.props.onInput) {
            this.props.onInput(event);
        }
        if (this.props.placeholder) {
            this.updatePlaceholder();
        }
    };
    ReactAce.prototype.onFocus = function (event) {
        if (this.props.onFocus) {
            this.props.onFocus(event, this.editor);
        }
    };
    ReactAce.prototype.onBlur = function (event) {
        if (this.props.onBlur) {
            this.props.onBlur(event, this.editor);
        }
    };
    ReactAce.prototype.onCopy = function (_a) {
        var text = _a.text;
        if (this.props.onCopy) {
            this.props.onCopy(text);
        }
    };
    ReactAce.prototype.onPaste = function (_a) {
        var text = _a.text;
        if (this.props.onPaste) {
            this.props.onPaste(text);
        }
    };
    ReactAce.prototype.onScroll = function () {
        if (this.props.onScroll) {
            this.props.onScroll(this.editor);
        }
    };
    ReactAce.prototype.handleOptions = function (props) {
        var setOptions = Object.keys(props.setOptions);
        for (var y = 0; y < setOptions.length; y++) {
            // @ts-ignore
            this.editor.setOption(setOptions[y], props.setOptions[setOptions[y]]);
        }
    };
    ReactAce.prototype.handleMarkers = function (markers) {
        var _this = this;
        // remove foreground markers
        var currentMarkers = this.editor.getSession().getMarkers(true);
        for (var i in currentMarkers) {
            if (currentMarkers.hasOwnProperty(i)) {
                this.editor.getSession().removeMarker(currentMarkers[i].id);
            }
        }
        // remove background markers except active line marker and selected word marker
        currentMarkers = this.editor.getSession().getMarkers(false);
        for (var i in currentMarkers) {
            if (currentMarkers.hasOwnProperty(i) &&
                currentMarkers[i].clazz !== "ace_active-line" &&
                currentMarkers[i].clazz !== "ace_selected-word") {
                this.editor.getSession().removeMarker(currentMarkers[i].id);
            }
        }
        // add new markers
        markers.forEach(function (_a) {
            var startRow = _a.startRow, startCol = _a.startCol, endRow = _a.endRow, endCol = _a.endCol, className = _a.className, type = _a.type, _b = _a.inFront, inFront = _b === void 0 ? false : _b;
            var range = new ace_builds_1$1.Range(startRow, startCol, endRow, endCol);
            _this.editor.getSession().addMarker(range, className, type, inFront);
        });
    };
    ReactAce.prototype.updatePlaceholder = function () {
        // Adapted from https://stackoverflow.com/questions/26695708/how-can-i-add-placeholder-text-when-the-editor-is-empty
        var editor = this.editor;
        var placeholder = this.props.placeholder;
        var showPlaceholder = !editor.session.getValue().length;
        var node = editor.renderer.placeholderNode;
        if (!showPlaceholder && node) {
            editor.renderer.scroller.removeChild(editor.renderer.placeholderNode);
            editor.renderer.placeholderNode = null;
        }
        else if (showPlaceholder && !node) {
            node = editor.renderer.placeholderNode = document.createElement("div");
            node.textContent = placeholder || "";
            node.className = "ace_comment ace_placeholder";
            node.style.padding = "0 9px";
            node.style.position = "absolute";
            node.style.zIndex = "3";
            editor.renderer.scroller.appendChild(node);
        }
        else if (showPlaceholder && node) {
            node.textContent = placeholder;
        }
    };
    ReactAce.prototype.updateRef = function (item) {
        this.refEditor = item;
    };
    ReactAce.prototype.render = function () {
        var _a = this.props, name = _a.name, width = _a.width, height = _a.height, style = _a.style;
        var divStyle = __assign$1({ width: width, height: height }, style);
        return React$B.createElement("div", { ref: this.updateRef, id: name, style: divStyle });
    };
    ReactAce.propTypes = {
        mode: PropTypes$2.oneOfType([PropTypes$2.string, PropTypes$2.object]),
        focus: PropTypes$2.bool,
        theme: PropTypes$2.string,
        name: PropTypes$2.string,
        className: PropTypes$2.string,
        height: PropTypes$2.string,
        width: PropTypes$2.string,
        fontSize: PropTypes$2.oneOfType([PropTypes$2.number, PropTypes$2.string]),
        lineHeight: PropTypes$2.oneOfType([PropTypes$2.number, PropTypes$2.string]),
        showGutter: PropTypes$2.bool,
        onChange: PropTypes$2.func,
        onCopy: PropTypes$2.func,
        onPaste: PropTypes$2.func,
        onFocus: PropTypes$2.func,
        onInput: PropTypes$2.func,
        onBlur: PropTypes$2.func,
        onScroll: PropTypes$2.func,
        value: PropTypes$2.string,
        defaultValue: PropTypes$2.string,
        onLoad: PropTypes$2.func,
        onSelectionChange: PropTypes$2.func,
        onCursorChange: PropTypes$2.func,
        onBeforeLoad: PropTypes$2.func,
        onValidate: PropTypes$2.func,
        minLines: PropTypes$2.number,
        maxLines: PropTypes$2.number,
        readOnly: PropTypes$2.bool,
        highlightActiveLine: PropTypes$2.bool,
        tabSize: PropTypes$2.number,
        showPrintMargin: PropTypes$2.bool,
        cursorStart: PropTypes$2.number,
        debounceChangePeriod: PropTypes$2.number,
        editorProps: PropTypes$2.object,
        setOptions: PropTypes$2.object,
        style: PropTypes$2.object,
        scrollMargin: PropTypes$2.array,
        annotations: PropTypes$2.array,
        markers: PropTypes$2.array,
        keyboardHandler: PropTypes$2.string,
        wrapEnabled: PropTypes$2.bool,
        enableSnippets: PropTypes$2.bool,
        enableBasicAutocompletion: PropTypes$2.oneOfType([
            PropTypes$2.bool,
            PropTypes$2.array
        ]),
        enableLiveAutocompletion: PropTypes$2.oneOfType([
            PropTypes$2.bool,
            PropTypes$2.array
        ]),
        navigateToFileEnd: PropTypes$2.bool,
        commands: PropTypes$2.array,
        placeholder: PropTypes$2.string
    };
    ReactAce.defaultProps = {
        name: "ace-editor",
        focus: false,
        mode: "",
        theme: "",
        height: "500px",
        width: "500px",
        fontSize: 12,
        enableSnippets: false,
        showGutter: true,
        onChange: null,
        onPaste: null,
        onLoad: null,
        onScroll: null,
        minLines: null,
        maxLines: null,
        readOnly: false,
        highlightActiveLine: true,
        showPrintMargin: true,
        tabSize: 4,
        cursorStart: 1,
        editorProps: {},
        style: {},
        scrollMargin: [0, 0, 0, 0],
        setOptions: {},
        wrapEnabled: false,
        enableBasicAutocompletion: false,
        enableLiveAutocompletion: false,
        placeholder: null,
        navigateToFileEnd: true
    };
    return ReactAce;
}(React$B.Component));
ace$4.default = ReactAce;

var diff = {};

var split = {};

var extSplit = {exports: {}};

(function (module, exports) {
	ace.define("ace/split",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/editor","ace/virtual_renderer","ace/edit_session"], function(require, exports, module){	var oop = require("./lib/oop");
	require("./lib/lang");
	var EventEmitter = require("./lib/event_emitter").EventEmitter;
	var Editor = require("./editor").Editor;
	var Renderer = require("./virtual_renderer").VirtualRenderer;
	var EditSession = require("./edit_session").EditSession;
	var Split;
	Split = function (container, theme, splits) {
	    this.BELOW = 1;
	    this.BESIDE = 0;
	    this.$container = container;
	    this.$theme = theme;
	    this.$splits = 0;
	    this.$editorCSS = "";
	    this.$editors = [];
	    this.$orientation = this.BESIDE;
	    this.setSplits(splits || 1);
	    this.$cEditor = this.$editors[0];
	    this.on("focus", function (editor) {
	        this.$cEditor = editor;
	    }.bind(this));
	};
	(function () {
	    oop.implement(this, EventEmitter);
	    this.$createEditor = function () {
	        var el = document.createElement("div");
	        el.className = this.$editorCSS;
	        el.style.cssText = "position: absolute; top:0px; bottom:0px";
	        this.$container.appendChild(el);
	        var editor = new Editor(new Renderer(el, this.$theme));
	        editor.on("focus", function () {
	            this._emit("focus", editor);
	        }.bind(this));
	        this.$editors.push(editor);
	        editor.setFontSize(this.$fontSize);
	        return editor;
	    };
	    this.setSplits = function (splits) {
	        var editor;
	        if (splits < 1) {
	            throw "The number of splits have to be > 0!";
	        }
	        if (splits == this.$splits) {
	            return;
	        }
	        else if (splits > this.$splits) {
	            while (this.$splits < this.$editors.length && this.$splits < splits) {
	                editor = this.$editors[this.$splits];
	                this.$container.appendChild(editor.container);
	                editor.setFontSize(this.$fontSize);
	                this.$splits++;
	            }
	            while (this.$splits < splits) {
	                this.$createEditor();
	                this.$splits++;
	            }
	        }
	        else {
	            while (this.$splits > splits) {
	                editor = this.$editors[this.$splits - 1];
	                this.$container.removeChild(editor.container);
	                this.$splits--;
	            }
	        }
	        this.resize();
	    };
	    this.getSplits = function () {
	        return this.$splits;
	    };
	    this.getEditor = function (idx) {
	        return this.$editors[idx];
	    };
	    this.getCurrentEditor = function () {
	        return this.$cEditor;
	    };
	    this.focus = function () {
	        this.$cEditor.focus();
	    };
	    this.blur = function () {
	        this.$cEditor.blur();
	    };
	    this.setTheme = function (theme) {
	        this.$editors.forEach(function (editor) {
	            editor.setTheme(theme);
	        });
	    };
	    this.setKeyboardHandler = function (keybinding) {
	        this.$editors.forEach(function (editor) {
	            editor.setKeyboardHandler(keybinding);
	        });
	    };
	    this.forEach = function (callback, scope) {
	        this.$editors.forEach(callback, scope);
	    };
	    this.$fontSize = "";
	    this.setFontSize = function (size) {
	        this.$fontSize = size;
	        this.forEach(function (editor) {
	            editor.setFontSize(size);
	        });
	    };
	    this.$cloneSession = function (session) {
	        var s = new EditSession(session.getDocument(), session.getMode());
	        var undoManager = session.getUndoManager();
	        s.setUndoManager(undoManager);
	        s.setTabSize(session.getTabSize());
	        s.setUseSoftTabs(session.getUseSoftTabs());
	        s.setOverwrite(session.getOverwrite());
	        s.setBreakpoints(session.getBreakpoints());
	        s.setUseWrapMode(session.getUseWrapMode());
	        s.setUseWorker(session.getUseWorker());
	        s.setWrapLimitRange(session.$wrapLimitRange.min, session.$wrapLimitRange.max);
	        s.$foldData = session.$cloneFoldData();
	        return s;
	    };
	    this.setSession = function (session, idx) {
	        var editor;
	        if (idx == null) {
	            editor = this.$cEditor;
	        }
	        else {
	            editor = this.$editors[idx];
	        }
	        var isUsed = this.$editors.some(function (editor) {
	            return editor.session === session;
	        });
	        if (isUsed) {
	            session = this.$cloneSession(session);
	        }
	        editor.setSession(session);
	        return session;
	    };
	    this.getOrientation = function () {
	        return this.$orientation;
	    };
	    this.setOrientation = function (orientation) {
	        if (this.$orientation == orientation) {
	            return;
	        }
	        this.$orientation = orientation;
	        this.resize();
	    };
	    this.resize = function () {
	        var width = this.$container.clientWidth;
	        var height = this.$container.clientHeight;
	        var editor;
	        if (this.$orientation == this.BESIDE) {
	            var editorWidth = width / this.$splits;
	            for (var i = 0; i < this.$splits; i++) {
	                editor = this.$editors[i];
	                editor.container.style.width = editorWidth + "px";
	                editor.container.style.top = "0px";
	                editor.container.style.left = i * editorWidth + "px";
	                editor.container.style.height = height + "px";
	                editor.resize();
	            }
	        }
	        else {
	            var editorHeight = height / this.$splits;
	            for (var i = 0; i < this.$splits; i++) {
	                editor = this.$editors[i];
	                editor.container.style.width = width + "px";
	                editor.container.style.top = i * editorHeight + "px";
	                editor.container.style.left = "0px";
	                editor.container.style.height = editorHeight + "px";
	                editor.resize();
	            }
	        }
	    };
	}).call(Split.prototype);
	exports.Split = Split;

	});

	ace.define("ace/ext/split",["require","exports","module","ace/ext/split","ace/split"], function(require, exports, module){/**
	 * ## Split editor container extension for multiple editor instances
	 *
	 * Provides functionality to create and manage multiple editor instances within a single container,
	 * arranged either horizontally (beside) or vertically (below). Enables synchronized editing sessions
	 * with shared configurations while maintaining independent cursor positions and selections.
	 *
	 * **Usage:**
	 * ```javascript
	 * var Split = require("ace/ext/split").Split;
	 * var split = new Split(container, theme, numberOfSplits);
	 * split.setOrientation(split.BESIDE); // or split.BELOW
	 * ```
	 *
	 * @experimental
	 * @module
	 */
	module.exports = require("../split");

	});                (function() {
	                    ace.require(["ace/ext/split"], function(m) {
	                        if (module) {
	                            module.exports = m;
	                        }
	                    });
	                })(); 
} (extSplit));

var extSplitExports = extSplit.exports;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol$1 = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get$1(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

var lodash_get = get$1;

var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(split, "__esModule", { value: true });
var editorOptions_1 = editorOptions$1;
var ace$1 = (0, editorOptions_1.getAceInstance)();
var ace_builds_1 = aceExports;
var ext_split_1 = extSplitExports;
var PropTypes$1 = propTypesExports;
var React$A = reactExports;
var isEqual = lodash_isequalExports;
var get = lodash_get;
var SplitComponent = /** @class */ (function (_super) {
    __extends$1(SplitComponent, _super);
    function SplitComponent(props) {
        var _this = _super.call(this, props) || this;
        editorOptions_1.editorEvents.forEach(function (method) {
            _this[method] = _this[method].bind(_this);
        });
        _this.debounce = editorOptions_1.debounce;
        return _this;
    }
    SplitComponent.prototype.isInShadow = function (node) {
        var parent = node && node.parentNode;
        while (parent) {
            if (parent.toString() === "[object ShadowRoot]") {
                return true;
            }
            parent = parent.parentNode;
        }
        return false;
    };
    SplitComponent.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, className = _a.className, onBeforeLoad = _a.onBeforeLoad, mode = _a.mode, focus = _a.focus, theme = _a.theme, fontSize = _a.fontSize, value = _a.value, defaultValue = _a.defaultValue, cursorStart = _a.cursorStart, showGutter = _a.showGutter, wrapEnabled = _a.wrapEnabled, showPrintMargin = _a.showPrintMargin, _b = _a.scrollMargin, scrollMargin = _b === void 0 ? [0, 0, 0, 0] : _b, keyboardHandler = _a.keyboardHandler, onLoad = _a.onLoad, commands = _a.commands, annotations = _a.annotations, markers = _a.markers, splits = _a.splits;
        this.editor = ace$1.edit(this.refEditor);
        if (this.isInShadow(this.refEditor)) {
            this.editor.renderer.attachToShadowRoot();
        }
        this.editor.setTheme("ace/theme/".concat(theme));
        if (onBeforeLoad) {
            onBeforeLoad(ace$1);
        }
        var editorProps = Object.keys(this.props.editorProps);
        var split = new ext_split_1.Split(this.editor.container, "ace/theme/".concat(theme), splits);
        this.editor.env.split = split;
        this.splitEditor = split.getEditor(0);
        this.split = split;
        // in a split scenario we don't want a print margin for the entire application
        this.editor.setShowPrintMargin(false);
        this.editor.renderer.setShowGutter(false);
        // get a list of possible options to avoid 'misspelled option errors'
        var availableOptions = this.splitEditor.$options;
        if (this.props.debounceChangePeriod) {
            this.onChange = this.debounce(this.onChange, this.props.debounceChangePeriod);
        }
        split.forEach(function (editor, index) {
            for (var i = 0; i < editorProps.length; i++) {
                editor[editorProps[i]] = _this.props.editorProps[editorProps[i]];
            }
            var defaultValueForEditor = get(defaultValue, index);
            var valueForEditor = get(value, index, "");
            editor.session.setUndoManager(new ace$1.UndoManager());
            editor.setTheme("ace/theme/".concat(theme));
            editor.renderer.setScrollMargin(scrollMargin[0], scrollMargin[1], scrollMargin[2], scrollMargin[3]);
            editor.getSession().setMode("ace/mode/".concat(mode));
            editor.setFontSize(fontSize);
            editor.renderer.setShowGutter(showGutter);
            editor.getSession().setUseWrapMode(wrapEnabled);
            editor.setShowPrintMargin(showPrintMargin);
            editor.on("focus", _this.onFocus);
            editor.on("blur", _this.onBlur);
            editor.on("input", _this.onInput);
            editor.on("copy", _this.onCopy);
            editor.on("paste", _this.onPaste);
            editor.on("change", _this.onChange);
            editor
                .getSession()
                .selection.on("changeSelection", _this.onSelectionChange);
            editor.getSession().selection.on("changeCursor", _this.onCursorChange);
            editor.session.on("changeScrollTop", _this.onScroll);
            editor.setValue(defaultValueForEditor === undefined
                ? valueForEditor
                : defaultValueForEditor, cursorStart);
            var newAnnotations = get(annotations, index, []);
            var newMarkers = get(markers, index, []);
            editor.getSession().setAnnotations(newAnnotations);
            if (newMarkers && newMarkers.length > 0) {
                _this.handleMarkers(newMarkers, editor);
            }
            for (var i = 0; i < editorOptions_1.editorOptions.length; i++) {
                var option = editorOptions_1.editorOptions[i];
                if (availableOptions.hasOwnProperty(option)) {
                    editor.setOption(option, _this.props[option]);
                }
                else if (_this.props[option]) {
                    console.warn("ReaceAce: editor option ".concat(option, " was activated but not found. Did you need to import a related tool or did you possibly mispell the option?"));
                }
            }
            _this.handleOptions(_this.props, editor);
            if (Array.isArray(commands)) {
                commands.forEach(function (command) {
                    if (typeof command.exec === "string") {
                        editor.commands.bindKey(command.bindKey, command.exec);
                    }
                    else {
                        editor.commands.addCommand(command);
                    }
                });
            }
            if (keyboardHandler) {
                editor.setKeyboardHandler("ace/keyboard/" + keyboardHandler);
            }
        });
        if (className) {
            this.refEditor.className += " " + className;
        }
        if (focus) {
            this.splitEditor.focus();
        }
        var sp = this.editor.env.split;
        sp.setOrientation(this.props.orientation === "below" ? sp.BELOW : sp.BESIDE);
        sp.resize(true);
        if (onLoad) {
            onLoad(sp);
        }
    };
    SplitComponent.prototype.componentDidUpdate = function (prevProps) {
        var _this = this;
        var oldProps = prevProps;
        var nextProps = this.props;
        var split = this.editor.env.split;
        if (nextProps.splits !== oldProps.splits) {
            split.setSplits(nextProps.splits);
        }
        if (nextProps.orientation !== oldProps.orientation) {
            split.setOrientation(nextProps.orientation === "below" ? split.BELOW : split.BESIDE);
        }
        split.forEach(function (editor, index) {
            if (nextProps.mode !== oldProps.mode) {
                editor.getSession().setMode("ace/mode/" + nextProps.mode);
            }
            if (nextProps.keyboardHandler !== oldProps.keyboardHandler) {
                if (nextProps.keyboardHandler) {
                    editor.setKeyboardHandler("ace/keyboard/" + nextProps.keyboardHandler);
                }
                else {
                    editor.setKeyboardHandler(null);
                }
            }
            if (nextProps.fontSize !== oldProps.fontSize) {
                editor.setFontSize(nextProps.fontSize);
            }
            if (nextProps.wrapEnabled !== oldProps.wrapEnabled) {
                editor.getSession().setUseWrapMode(nextProps.wrapEnabled);
            }
            if (nextProps.showPrintMargin !== oldProps.showPrintMargin) {
                editor.setShowPrintMargin(nextProps.showPrintMargin);
            }
            if (nextProps.showGutter !== oldProps.showGutter) {
                editor.renderer.setShowGutter(nextProps.showGutter);
            }
            for (var i = 0; i < editorOptions_1.editorOptions.length; i++) {
                var option = editorOptions_1.editorOptions[i];
                if (nextProps[option] !== oldProps[option]) {
                    editor.setOption(option, nextProps[option]);
                }
            }
            if (!isEqual(nextProps.setOptions, oldProps.setOptions)) {
                _this.handleOptions(nextProps, editor);
            }
            var nextValue = get(nextProps.value, index, "");
            if (editor.getValue() !== nextValue) {
                // editor.setValue is a synchronous function call, change event is emitted before setValue return.
                _this.silent = true;
                var pos = editor.session.selection.toJSON();
                editor.setValue(nextValue, nextProps.cursorStart);
                editor.session.selection.fromJSON(pos);
                _this.silent = false;
            }
            var newAnnotations = get(nextProps.annotations, index, []);
            var oldAnnotations = get(oldProps.annotations, index, []);
            if (!isEqual(newAnnotations, oldAnnotations)) {
                editor.getSession().setAnnotations(newAnnotations);
            }
            var newMarkers = get(nextProps.markers, index, []);
            var oldMarkers = get(oldProps.markers, index, []);
            if (!isEqual(newMarkers, oldMarkers) && Array.isArray(newMarkers)) {
                _this.handleMarkers(newMarkers, editor);
            }
        });
        if (nextProps.className !== oldProps.className) {
            var appliedClasses = this.refEditor.className;
            var appliedClassesArray_1 = appliedClasses.trim().split(" ");
            var oldClassesArray = oldProps.className.trim().split(" ");
            oldClassesArray.forEach(function (oldClass) {
                var index = appliedClassesArray_1.indexOf(oldClass);
                appliedClassesArray_1.splice(index, 1);
            });
            this.refEditor.className =
                " " + nextProps.className + " " + appliedClassesArray_1.join(" ");
        }
        if (nextProps.theme !== oldProps.theme) {
            split.setTheme("ace/theme/" + nextProps.theme);
        }
        if (nextProps.focus && !oldProps.focus) {
            this.splitEditor.focus();
        }
        if (nextProps.height !== this.props.height ||
            nextProps.width !== this.props.width) {
            this.editor.resize();
        }
    };
    SplitComponent.prototype.componentWillUnmount = function () {
        this.editor.destroy();
        this.editor = null;
    };
    SplitComponent.prototype.onChange = function (event) {
        if (this.props.onChange && !this.silent) {
            var value_1 = [];
            this.editor.env.split.forEach(function (editor) {
                value_1.push(editor.getValue());
            });
            this.props.onChange(value_1, event);
        }
    };
    SplitComponent.prototype.onSelectionChange = function (event) {
        if (this.props.onSelectionChange) {
            var value_2 = [];
            this.editor.env.split.forEach(function (editor) {
                value_2.push(editor.getSelection());
            });
            this.props.onSelectionChange(value_2, event);
        }
    };
    SplitComponent.prototype.onCursorChange = function (event) {
        if (this.props.onCursorChange) {
            var value_3 = [];
            this.editor.env.split.forEach(function (editor) {
                value_3.push(editor.getSelection());
            });
            this.props.onCursorChange(value_3, event);
        }
    };
    SplitComponent.prototype.onFocus = function (event) {
        if (this.props.onFocus) {
            this.props.onFocus(event);
        }
    };
    SplitComponent.prototype.onInput = function (event) {
        if (this.props.onInput) {
            this.props.onInput(event);
        }
    };
    SplitComponent.prototype.onBlur = function (event) {
        if (this.props.onBlur) {
            this.props.onBlur(event);
        }
    };
    SplitComponent.prototype.onCopy = function (text) {
        if (this.props.onCopy) {
            this.props.onCopy(text);
        }
    };
    SplitComponent.prototype.onPaste = function (text) {
        if (this.props.onPaste) {
            this.props.onPaste(text);
        }
    };
    SplitComponent.prototype.onScroll = function () {
        if (this.props.onScroll) {
            this.props.onScroll(this.editor);
        }
    };
    SplitComponent.prototype.handleOptions = function (props, editor) {
        var setOptions = Object.keys(props.setOptions);
        for (var y = 0; y < setOptions.length; y++) {
            editor.setOption(setOptions[y], props.setOptions[setOptions[y]]);
        }
    };
    SplitComponent.prototype.handleMarkers = function (markers, editor) {
        // remove foreground markers
        var currentMarkers = editor.getSession().getMarkers(true);
        for (var i in currentMarkers) {
            if (currentMarkers.hasOwnProperty(i)) {
                editor.getSession().removeMarker(currentMarkers[i].id);
            }
        }
        // remove background markers
        currentMarkers = editor.getSession().getMarkers(false);
        for (var i in currentMarkers) {
            if (currentMarkers.hasOwnProperty(i)) {
                editor.getSession().removeMarker(currentMarkers[i].id);
            }
        }
        // add new markers
        markers.forEach(function (_a) {
            var startRow = _a.startRow, startCol = _a.startCol, endRow = _a.endRow, endCol = _a.endCol, className = _a.className, type = _a.type, _b = _a.inFront, inFront = _b === void 0 ? false : _b;
            var range = new ace_builds_1.Range(startRow, startCol, endRow, endCol);
            editor
                .getSession()
                .addMarker(range, className, type, inFront);
        });
    };
    SplitComponent.prototype.updateRef = function (item) {
        this.refEditor = item;
    };
    SplitComponent.prototype.render = function () {
        var _a = this.props, name = _a.name, width = _a.width, height = _a.height, style = _a.style;
        var divStyle = __assign({ width: width, height: height }, style);
        return React$A.createElement("div", { ref: this.updateRef, id: name, style: divStyle });
    };
    SplitComponent.propTypes = {
        className: PropTypes$1.string,
        debounceChangePeriod: PropTypes$1.number,
        defaultValue: PropTypes$1.arrayOf(PropTypes$1.string),
        focus: PropTypes$1.bool,
        fontSize: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
        height: PropTypes$1.string,
        mode: PropTypes$1.string,
        name: PropTypes$1.string,
        onBlur: PropTypes$1.func,
        onChange: PropTypes$1.func,
        onCopy: PropTypes$1.func,
        onFocus: PropTypes$1.func,
        onInput: PropTypes$1.func,
        onLoad: PropTypes$1.func,
        onPaste: PropTypes$1.func,
        onScroll: PropTypes$1.func,
        orientation: PropTypes$1.string,
        showGutter: PropTypes$1.bool,
        splits: PropTypes$1.number,
        theme: PropTypes$1.string,
        value: PropTypes$1.arrayOf(PropTypes$1.string),
        width: PropTypes$1.string,
        onSelectionChange: PropTypes$1.func,
        onCursorChange: PropTypes$1.func,
        onBeforeLoad: PropTypes$1.func,
        minLines: PropTypes$1.number,
        maxLines: PropTypes$1.number,
        readOnly: PropTypes$1.bool,
        highlightActiveLine: PropTypes$1.bool,
        tabSize: PropTypes$1.number,
        showPrintMargin: PropTypes$1.bool,
        cursorStart: PropTypes$1.number,
        editorProps: PropTypes$1.object,
        setOptions: PropTypes$1.object,
        style: PropTypes$1.object,
        scrollMargin: PropTypes$1.array,
        annotations: PropTypes$1.array,
        markers: PropTypes$1.array,
        keyboardHandler: PropTypes$1.string,
        wrapEnabled: PropTypes$1.bool,
        enableBasicAutocompletion: PropTypes$1.oneOfType([
            PropTypes$1.bool,
            PropTypes$1.array
        ]),
        enableLiveAutocompletion: PropTypes$1.oneOfType([
            PropTypes$1.bool,
            PropTypes$1.array
        ]),
        commands: PropTypes$1.array
    };
    SplitComponent.defaultProps = {
        name: "ace-editor",
        focus: false,
        orientation: "beside",
        splits: 2,
        mode: "",
        theme: "",
        height: "500px",
        width: "500px",
        value: [],
        fontSize: 12,
        showGutter: true,
        onChange: null,
        onPaste: null,
        onLoad: null,
        onScroll: null,
        minLines: null,
        maxLines: null,
        readOnly: false,
        highlightActiveLine: true,
        showPrintMargin: true,
        tabSize: 4,
        cursorStart: 1,
        editorProps: {},
        style: {},
        scrollMargin: [0, 0, 0, 0],
        setOptions: {},
        wrapEnabled: false,
        enableBasicAutocompletion: false,
        enableLiveAutocompletion: false
    };
    return SplitComponent;
}(React$A.Component));
split.default = SplitComponent;

var diffMatchPatch = {exports: {}};

/**
 * Diff Match and Patch
 * Copyright 2018 The diff-match-patch Authors.
 * https://github.com/google/diff-match-patch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function (module) {
	/**
	 * @fileoverview Computes the difference between two texts to create a patch.
	 * Applies the patch onto another text, allowing for errors.
	 * @author fraser@google.com (Neil Fraser)
	 */

	/**
	 * Class containing the diff, match and patch methods.
	 * @constructor
	 */
	var diff_match_patch = function() {

	  // Defaults.
	  // Redefine these in your program to override the defaults.

	  // Number of seconds to map a diff before giving up (0 for infinity).
	  this.Diff_Timeout = 1.0;
	  // Cost of an empty edit operation in terms of edit characters.
	  this.Diff_EditCost = 4;
	  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
	  this.Match_Threshold = 0.5;
	  // How far to search for a match (0 = exact location, 1000+ = broad match).
	  // A match this many characters away from the expected location will add
	  // 1.0 to the score (0.0 is a perfect match).
	  this.Match_Distance = 1000;
	  // When deleting a large block of text (over ~64 characters), how close do
	  // the contents have to be to match the expected contents. (0.0 = perfection,
	  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
	  // end points of a delete need to match.
	  this.Patch_DeleteThreshold = 0.5;
	  // Chunk size for context length.
	  this.Patch_Margin = 4;

	  // The number of bits in an int.
	  this.Match_MaxBits = 32;
	};


	//  DIFF FUNCTIONS


	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE = -1;
	var DIFF_INSERT = 1;
	var DIFF_EQUAL = 0;

	/**
	 * Class representing one diff tuple.
	 * ~Attempts to look like a two-element array (which is what this used to be).~
	 * Constructor returns an actual two-element array, to allow destructing @JackuB
	 * See https://github.com/JackuB/diff-match-patch/issues/14 for details
	 * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
	 * @param {string} text Text to be deleted, inserted, or retained.
	 * @constructor
	 */
	diff_match_patch.Diff = function(op, text) {
	  return [op, text];
	};

	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
	 *     then don't run a line-level diff first to identify the changed areas.
	 *     Defaults to true, which does a faster, slightly less optimal diff.
	 * @param {number=} opt_deadline Optional time when the diff should be complete
	 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
	 *     instead.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
	    opt_deadline) {
	  // Set a deadline by which time the diff must be complete.
	  if (typeof opt_deadline == 'undefined') {
	    if (this.Diff_Timeout <= 0) {
	      opt_deadline = Number.MAX_VALUE;
	    } else {
	      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
	    }
	  }
	  var deadline = opt_deadline;

	  // Check for null inputs.
	  if (text1 == null || text2 == null) {
	    throw new Error('Null input. (diff_main)');
	  }

	  // Check for equality (speedup).
	  if (text1 == text2) {
	    if (text1) {
	      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
	    }
	    return [];
	  }

	  if (typeof opt_checklines == 'undefined') {
	    opt_checklines = true;
	  }
	  var checklines = opt_checklines;

	  // Trim off common prefix (speedup).
	  var commonlength = this.diff_commonPrefix(text1, text2);
	  var commonprefix = text1.substring(0, commonlength);
	  text1 = text1.substring(commonlength);
	  text2 = text2.substring(commonlength);

	  // Trim off common suffix (speedup).
	  commonlength = this.diff_commonSuffix(text1, text2);
	  var commonsuffix = text1.substring(text1.length - commonlength);
	  text1 = text1.substring(0, text1.length - commonlength);
	  text2 = text2.substring(0, text2.length - commonlength);

	  // Compute the diff on the middle block.
	  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

	  // Restore the prefix and suffix.
	  if (commonprefix) {
	    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
	  }
	  if (commonsuffix) {
	    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
	  }
	  this.diff_cleanupMerge(diffs);
	  return diffs;
	};


	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {boolean} checklines Speedup flag.  If false, then don't run a
	 *     line-level diff first to identify the changed areas.
	 *     If true, then run a faster, slightly less optimal diff.
	 * @param {number} deadline Time when the diff should be complete by.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
	    deadline) {
	  var diffs;

	  if (!text1) {
	    // Just add some text (speedup).
	    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
	  }

	  if (!text2) {
	    // Just delete some text (speedup).
	    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
	  }

	  var longtext = text1.length > text2.length ? text1 : text2;
	  var shorttext = text1.length > text2.length ? text2 : text1;
	  var i = longtext.indexOf(shorttext);
	  if (i != -1) {
	    // Shorter text is inside the longer text (speedup).
	    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
	             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
	             new diff_match_patch.Diff(DIFF_INSERT,
	                 longtext.substring(i + shorttext.length))];
	    // Swap insertions for deletions if diff is reversed.
	    if (text1.length > text2.length) {
	      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
	    }
	    return diffs;
	  }

	  if (shorttext.length == 1) {
	    // Single character string.
	    // After the previous speedup, the character can't be an equality.
	    return [new diff_match_patch.Diff(DIFF_DELETE, text1),
	            new diff_match_patch.Diff(DIFF_INSERT, text2)];
	  }

	  // Check to see if the problem can be split in two.
	  var hm = this.diff_halfMatch_(text1, text2);
	  if (hm) {
	    // A half-match was found, sort out the return data.
	    var text1_a = hm[0];
	    var text1_b = hm[1];
	    var text2_a = hm[2];
	    var text2_b = hm[3];
	    var mid_common = hm[4];
	    // Send both pairs off for separate processing.
	    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
	    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
	    // Merge the results.
	    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
	                          diffs_b);
	  }

	  if (checklines && text1.length > 100 && text2.length > 100) {
	    return this.diff_lineMode_(text1, text2, deadline);
	  }

	  return this.diff_bisect_(text1, text2, deadline);
	};


	/**
	 * Do a quick line-level diff on both strings, then rediff the parts for
	 * greater accuracy.
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} deadline Time when the diff should be complete by.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
	  // Scan the text on a line-by-line basis first.
	  var a = this.diff_linesToChars_(text1, text2);
	  text1 = a.chars1;
	  text2 = a.chars2;
	  var linearray = a.lineArray;

	  var diffs = this.diff_main(text1, text2, false, deadline);

	  // Convert the diff back to original text.
	  this.diff_charsToLines_(diffs, linearray);
	  // Eliminate freak matches (e.g. blank lines)
	  this.diff_cleanupSemantic(diffs);

	  // Rediff any replacement blocks, this time character-by-character.
	  // Add a dummy entry at the end.
	  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
	  var pointer = 0;
	  var count_delete = 0;
	  var count_insert = 0;
	  var text_delete = '';
	  var text_insert = '';
	  while (pointer < diffs.length) {
	    switch (diffs[pointer][0]) {
	      case DIFF_INSERT:
	        count_insert++;
	        text_insert += diffs[pointer][1];
	        break;
	      case DIFF_DELETE:
	        count_delete++;
	        text_delete += diffs[pointer][1];
	        break;
	      case DIFF_EQUAL:
	        // Upon reaching an equality, check for prior redundancies.
	        if (count_delete >= 1 && count_insert >= 1) {
	          // Delete the offending records and add the merged ones.
	          diffs.splice(pointer - count_delete - count_insert,
	                       count_delete + count_insert);
	          pointer = pointer - count_delete - count_insert;
	          var subDiff =
	              this.diff_main(text_delete, text_insert, false, deadline);
	          for (var j = subDiff.length - 1; j >= 0; j--) {
	            diffs.splice(pointer, 0, subDiff[j]);
	          }
	          pointer = pointer + subDiff.length;
	        }
	        count_insert = 0;
	        count_delete = 0;
	        text_delete = '';
	        text_insert = '';
	        break;
	    }
	    pointer++;
	  }
	  diffs.pop();  // Remove the dummy entry at the end.

	  return diffs;
	};


	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} deadline Time at which to bail if not yet complete.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
	  // Cache the text lengths to prevent multiple calls.
	  var text1_length = text1.length;
	  var text2_length = text2.length;
	  var max_d = Math.ceil((text1_length + text2_length) / 2);
	  var v_offset = max_d;
	  var v_length = 2 * max_d;
	  var v1 = new Array(v_length);
	  var v2 = new Array(v_length);
	  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	  // integers and undefined.
	  for (var x = 0; x < v_length; x++) {
	    v1[x] = -1;
	    v2[x] = -1;
	  }
	  v1[v_offset + 1] = 0;
	  v2[v_offset + 1] = 0;
	  var delta = text1_length - text2_length;
	  // If the total number of characters is odd, then the front path will collide
	  // with the reverse path.
	  var front = (delta % 2 != 0);
	  // Offsets for start and end of k loop.
	  // Prevents mapping of space beyond the grid.
	  var k1start = 0;
	  var k1end = 0;
	  var k2start = 0;
	  var k2end = 0;
	  for (var d = 0; d < max_d; d++) {
	    // Bail out if deadline is reached.
	    if ((new Date()).getTime() > deadline) {
	      break;
	    }

	    // Walk the front path one step.
	    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	      var k1_offset = v_offset + k1;
	      var x1;
	      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	        x1 = v1[k1_offset + 1];
	      } else {
	        x1 = v1[k1_offset - 1] + 1;
	      }
	      var y1 = x1 - k1;
	      while (x1 < text1_length && y1 < text2_length &&
	             text1.charAt(x1) == text2.charAt(y1)) {
	        x1++;
	        y1++;
	      }
	      v1[k1_offset] = x1;
	      if (x1 > text1_length) {
	        // Ran off the right of the graph.
	        k1end += 2;
	      } else if (y1 > text2_length) {
	        // Ran off the bottom of the graph.
	        k1start += 2;
	      } else if (front) {
	        var k2_offset = v_offset + delta - k1;
	        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	          // Mirror x2 onto top-left coordinate system.
	          var x2 = text1_length - v2[k2_offset];
	          if (x1 >= x2) {
	            // Overlap detected.
	            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
	          }
	        }
	      }
	    }

	    // Walk the reverse path one step.
	    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	      var k2_offset = v_offset + k2;
	      var x2;
	      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	        x2 = v2[k2_offset + 1];
	      } else {
	        x2 = v2[k2_offset - 1] + 1;
	      }
	      var y2 = x2 - k2;
	      while (x2 < text1_length && y2 < text2_length &&
	             text1.charAt(text1_length - x2 - 1) ==
	             text2.charAt(text2_length - y2 - 1)) {
	        x2++;
	        y2++;
	      }
	      v2[k2_offset] = x2;
	      if (x2 > text1_length) {
	        // Ran off the left of the graph.
	        k2end += 2;
	      } else if (y2 > text2_length) {
	        // Ran off the top of the graph.
	        k2start += 2;
	      } else if (!front) {
	        var k1_offset = v_offset + delta - k2;
	        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	          var x1 = v1[k1_offset];
	          var y1 = v_offset + x1 - k1_offset;
	          // Mirror x2 onto top-left coordinate system.
	          x2 = text1_length - x2;
	          if (x1 >= x2) {
	            // Overlap detected.
	            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
	          }
	        }
	      }
	    }
	  }
	  // Diff took too long and hit the deadline or
	  // number of diffs equals number of characters, no commonality at all.
	  return [new diff_match_patch.Diff(DIFF_DELETE, text1),
	          new diff_match_patch.Diff(DIFF_INSERT, text2)];
	};


	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @param {number} deadline Time at which to bail if not yet complete.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
	    deadline) {
	  var text1a = text1.substring(0, x);
	  var text2a = text2.substring(0, y);
	  var text1b = text1.substring(x);
	  var text2b = text2.substring(y);

	  // Compute both diffs serially.
	  var diffs = this.diff_main(text1a, text2a, false, deadline);
	  var diffsb = this.diff_main(text1b, text2b, false, deadline);

	  return diffs.concat(diffsb);
	};


	/**
	 * Split two texts into an array of strings.  Reduce the texts to a string of
	 * hashes where each Unicode character represents one line.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
	 *     An object containing the encoded text1, the encoded text2 and
	 *     the array of unique strings.
	 *     The zeroth element of the array of unique strings is intentionally blank.
	 * @private
	 */
	diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
	  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
	  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

	  // '\x00' is a valid character, but various debuggers don't like it.
	  // So we'll insert a junk entry to avoid generating a null character.
	  lineArray[0] = '';

	  /**
	   * Split a text into an array of strings.  Reduce the texts to a string of
	   * hashes where each Unicode character represents one line.
	   * Modifies linearray and linehash through being a closure.
	   * @param {string} text String to encode.
	   * @return {string} Encoded string.
	   * @private
	   */
	  function diff_linesToCharsMunge_(text) {
	    var chars = '';
	    // Walk the text, pulling out a substring for each line.
	    // text.split('\n') would would temporarily double our memory footprint.
	    // Modifying text would create many large strings to garbage collect.
	    var lineStart = 0;
	    var lineEnd = -1;
	    // Keeping our own length variable is faster than looking it up.
	    var lineArrayLength = lineArray.length;
	    while (lineEnd < text.length - 1) {
	      lineEnd = text.indexOf('\n', lineStart);
	      if (lineEnd == -1) {
	        lineEnd = text.length - 1;
	      }
	      var line = text.substring(lineStart, lineEnd + 1);

	      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
	          (lineHash[line] !== undefined)) {
	        chars += String.fromCharCode(lineHash[line]);
	      } else {
	        if (lineArrayLength == maxLines) {
	          // Bail out at 65535 because
	          // String.fromCharCode(65536) == String.fromCharCode(0)
	          line = text.substring(lineStart);
	          lineEnd = text.length;
	        }
	        chars += String.fromCharCode(lineArrayLength);
	        lineHash[line] = lineArrayLength;
	        lineArray[lineArrayLength++] = line;
	      }
	      lineStart = lineEnd + 1;
	    }
	    return chars;
	  }
	  // Allocate 2/3rds of the space for text1, the rest for text2.
	  var maxLines = 40000;
	  var chars1 = diff_linesToCharsMunge_(text1);
	  maxLines = 65535;
	  var chars2 = diff_linesToCharsMunge_(text2);
	  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
	};


	/**
	 * Rehydrate the text in a diff from a string of line hashes to real lines of
	 * text.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @param {!Array.<string>} lineArray Array of unique strings.
	 * @private
	 */
	diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
	  for (var i = 0; i < diffs.length; i++) {
	    var chars = diffs[i][1];
	    var text = [];
	    for (var j = 0; j < chars.length; j++) {
	      text[j] = lineArray[chars.charCodeAt(j)];
	    }
	    diffs[i][1] = text.join('');
	  }
	};


	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
	  // Quick check for common null cases.
	  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	    return 0;
	  }
	  // Binary search.
	  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
	  var pointermin = 0;
	  var pointermax = Math.min(text1.length, text2.length);
	  var pointermid = pointermax;
	  var pointerstart = 0;
	  while (pointermin < pointermid) {
	    if (text1.substring(pointerstart, pointermid) ==
	        text2.substring(pointerstart, pointermid)) {
	      pointermin = pointermid;
	      pointerstart = pointermin;
	    } else {
	      pointermax = pointermid;
	    }
	    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	  }
	  return pointermid;
	};


	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
	  // Quick check for common null cases.
	  if (!text1 || !text2 ||
	      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	    return 0;
	  }
	  // Binary search.
	  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
	  var pointermin = 0;
	  var pointermax = Math.min(text1.length, text2.length);
	  var pointermid = pointermax;
	  var pointerend = 0;
	  while (pointermin < pointermid) {
	    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	      pointermin = pointermid;
	      pointerend = pointermin;
	    } else {
	      pointermax = pointermid;
	    }
	    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	  }
	  return pointermid;
	};


	/**
	 * Determine if the suffix of one string is the prefix of another.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of the first
	 *     string and the start of the second string.
	 * @private
	 */
	diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
	  // Cache the text lengths to prevent multiple calls.
	  var text1_length = text1.length;
	  var text2_length = text2.length;
	  // Eliminate the null case.
	  if (text1_length == 0 || text2_length == 0) {
	    return 0;
	  }
	  // Truncate the longer string.
	  if (text1_length > text2_length) {
	    text1 = text1.substring(text1_length - text2_length);
	  } else if (text1_length < text2_length) {
	    text2 = text2.substring(0, text1_length);
	  }
	  var text_length = Math.min(text1_length, text2_length);
	  // Quick check for the worst case.
	  if (text1 == text2) {
	    return text_length;
	  }

	  // Start by looking for a single character match
	  // and increase length until no match is found.
	  // Performance analysis: https://neil.fraser.name/news/2010/11/04/
	  var best = 0;
	  var length = 1;
	  while (true) {
	    var pattern = text1.substring(text_length - length);
	    var found = text2.indexOf(pattern);
	    if (found == -1) {
	      return best;
	    }
	    length += found;
	    if (found == 0 || text1.substring(text_length - length) ==
	        text2.substring(0, length)) {
	      best = length;
	      length++;
	    }
	  }
	};


	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 * @private
	 */
	diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
	  if (this.Diff_Timeout <= 0) {
	    // Don't risk returning a non-optimal diff if we have unlimited time.
	    return null;
	  }
	  var longtext = text1.length > text2.length ? text1 : text2;
	  var shorttext = text1.length > text2.length ? text2 : text1;
	  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	    return null;  // Pointless.
	  }
	  var dmp = this;  // 'this' becomes 'window' in a closure.

	  /**
	   * Does a substring of shorttext exist within longtext such that the substring
	   * is at least half the length of longtext?
	   * Closure, but does not reference any external variables.
	   * @param {string} longtext Longer string.
	   * @param {string} shorttext Shorter string.
	   * @param {number} i Start index of quarter length substring within longtext.
	   * @return {Array.<string>} Five element Array, containing the prefix of
	   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	   *     of shorttext and the common middle.  Or null if there was no match.
	   * @private
	   */
	  function diff_halfMatchI_(longtext, shorttext, i) {
	    // Start with a 1/4 length substring at position i as a seed.
	    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	    var j = -1;
	    var best_common = '';
	    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
	                                               shorttext.substring(j));
	      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
	                                               shorttext.substring(0, j));
	      if (best_common.length < suffixLength + prefixLength) {
	        best_common = shorttext.substring(j - suffixLength, j) +
	            shorttext.substring(j, j + prefixLength);
	        best_longtext_a = longtext.substring(0, i - suffixLength);
	        best_longtext_b = longtext.substring(i + prefixLength);
	        best_shorttext_a = shorttext.substring(0, j - suffixLength);
	        best_shorttext_b = shorttext.substring(j + prefixLength);
	      }
	    }
	    if (best_common.length * 2 >= longtext.length) {
	      return [best_longtext_a, best_longtext_b,
	              best_shorttext_a, best_shorttext_b, best_common];
	    } else {
	      return null;
	    }
	  }

	  // First check if the second quarter is the seed for a half-match.
	  var hm1 = diff_halfMatchI_(longtext, shorttext,
	                             Math.ceil(longtext.length / 4));
	  // Check again based on the third quarter.
	  var hm2 = diff_halfMatchI_(longtext, shorttext,
	                             Math.ceil(longtext.length / 2));
	  var hm;
	  if (!hm1 && !hm2) {
	    return null;
	  } else if (!hm2) {
	    hm = hm1;
	  } else if (!hm1) {
	    hm = hm2;
	  } else {
	    // Both matched.  Select the longest.
	    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	  }

	  // A half-match was found, sort out the return data.
	  var text1_a, text1_b, text2_a, text2_b;
	  if (text1.length > text2.length) {
	    text1_a = hm[0];
	    text1_b = hm[1];
	    text2_a = hm[2];
	    text2_b = hm[3];
	  } else {
	    text2_a = hm[0];
	    text2_b = hm[1];
	    text1_a = hm[2];
	    text1_b = hm[3];
	  }
	  var mid_common = hm[4];
	  return [text1_a, text1_b, text2_a, text2_b, mid_common];
	};


	/**
	 * Reduce the number of edits by eliminating semantically trivial equalities.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
	  var changes = false;
	  var equalities = [];  // Stack of indices where equalities are found.
	  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
	  /** @type {?string} */
	  var lastEquality = null;
	  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
	  var pointer = 0;  // Index of current position.
	  // Number of characters that changed prior to the equality.
	  var length_insertions1 = 0;
	  var length_deletions1 = 0;
	  // Number of characters that changed after the equality.
	  var length_insertions2 = 0;
	  var length_deletions2 = 0;
	  while (pointer < diffs.length) {
	    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
	      equalities[equalitiesLength++] = pointer;
	      length_insertions1 = length_insertions2;
	      length_deletions1 = length_deletions2;
	      length_insertions2 = 0;
	      length_deletions2 = 0;
	      lastEquality = diffs[pointer][1];
	    } else {  // An insertion or deletion.
	      if (diffs[pointer][0] == DIFF_INSERT) {
	        length_insertions2 += diffs[pointer][1].length;
	      } else {
	        length_deletions2 += diffs[pointer][1].length;
	      }
	      // Eliminate an equality that is smaller or equal to the edits on both
	      // sides of it.
	      if (lastEquality && (lastEquality.length <=
	          Math.max(length_insertions1, length_deletions1)) &&
	          (lastEquality.length <= Math.max(length_insertions2,
	                                           length_deletions2))) {
	        // Duplicate record.
	        diffs.splice(equalities[equalitiesLength - 1], 0,
	                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
	        // Change second copy to insert.
	        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
	        // Throw away the equality we just deleted.
	        equalitiesLength--;
	        // Throw away the previous equality (it needs to be reevaluated).
	        equalitiesLength--;
	        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
	        length_insertions1 = 0;  // Reset the counters.
	        length_deletions1 = 0;
	        length_insertions2 = 0;
	        length_deletions2 = 0;
	        lastEquality = null;
	        changes = true;
	      }
	    }
	    pointer++;
	  }

	  // Normalize the diff.
	  if (changes) {
	    this.diff_cleanupMerge(diffs);
	  }
	  this.diff_cleanupSemanticLossless(diffs);

	  // Find any overlaps between deletions and insertions.
	  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
	  //   -> <del>abc</del>xxx<ins>def</ins>
	  // e.g: <del>xxxabc</del><ins>defxxx</ins>
	  //   -> <ins>def</ins>xxx<del>abc</del>
	  // Only extract an overlap if it is as big as the edit ahead or behind it.
	  pointer = 1;
	  while (pointer < diffs.length) {
	    if (diffs[pointer - 1][0] == DIFF_DELETE &&
	        diffs[pointer][0] == DIFF_INSERT) {
	      var deletion = diffs[pointer - 1][1];
	      var insertion = diffs[pointer][1];
	      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
	      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
	      if (overlap_length1 >= overlap_length2) {
	        if (overlap_length1 >= deletion.length / 2 ||
	            overlap_length1 >= insertion.length / 2) {
	          // Overlap found.  Insert an equality and trim the surrounding edits.
	          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
	              insertion.substring(0, overlap_length1)));
	          diffs[pointer - 1][1] =
	              deletion.substring(0, deletion.length - overlap_length1);
	          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
	          pointer++;
	        }
	      } else {
	        if (overlap_length2 >= deletion.length / 2 ||
	            overlap_length2 >= insertion.length / 2) {
	          // Reverse overlap found.
	          // Insert an equality and swap and trim the surrounding edits.
	          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
	              deletion.substring(0, overlap_length2)));
	          diffs[pointer - 1][0] = DIFF_INSERT;
	          diffs[pointer - 1][1] =
	              insertion.substring(0, insertion.length - overlap_length2);
	          diffs[pointer + 1][0] = DIFF_DELETE;
	          diffs[pointer + 1][1] =
	              deletion.substring(overlap_length2);
	          pointer++;
	        }
	      }
	      pointer++;
	    }
	    pointer++;
	  }
	};


	/**
	 * Look for single edits surrounded on both sides by equalities
	 * which can be shifted sideways to align the edit to a word boundary.
	 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
	  /**
	   * Given two strings, compute a score representing whether the internal
	   * boundary falls on logical boundaries.
	   * Scores range from 6 (best) to 0 (worst).
	   * Closure, but does not reference any external variables.
	   * @param {string} one First string.
	   * @param {string} two Second string.
	   * @return {number} The score.
	   * @private
	   */
	  function diff_cleanupSemanticScore_(one, two) {
	    if (!one || !two) {
	      // Edges are the best.
	      return 6;
	    }

	    // Each port of this function behaves slightly differently due to
	    // subtle differences in each language's definition of things like
	    // 'whitespace'.  Since this function's purpose is largely cosmetic,
	    // the choice has been made to use each language's native features
	    // rather than force total conformity.
	    var char1 = one.charAt(one.length - 1);
	    var char2 = two.charAt(0);
	    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
	    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
	    var whitespace1 = nonAlphaNumeric1 &&
	        char1.match(diff_match_patch.whitespaceRegex_);
	    var whitespace2 = nonAlphaNumeric2 &&
	        char2.match(diff_match_patch.whitespaceRegex_);
	    var lineBreak1 = whitespace1 &&
	        char1.match(diff_match_patch.linebreakRegex_);
	    var lineBreak2 = whitespace2 &&
	        char2.match(diff_match_patch.linebreakRegex_);
	    var blankLine1 = lineBreak1 &&
	        one.match(diff_match_patch.blanklineEndRegex_);
	    var blankLine2 = lineBreak2 &&
	        two.match(diff_match_patch.blanklineStartRegex_);

	    if (blankLine1 || blankLine2) {
	      // Five points for blank lines.
	      return 5;
	    } else if (lineBreak1 || lineBreak2) {
	      // Four points for line breaks.
	      return 4;
	    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
	      // Three points for end of sentences.
	      return 3;
	    } else if (whitespace1 || whitespace2) {
	      // Two points for whitespace.
	      return 2;
	    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
	      // One point for non-alphanumeric.
	      return 1;
	    }
	    return 0;
	  }

	  var pointer = 1;
	  // Intentionally ignore the first and last element (don't need checking).
	  while (pointer < diffs.length - 1) {
	    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
	        diffs[pointer + 1][0] == DIFF_EQUAL) {
	      // This is a single edit surrounded by equalities.
	      var equality1 = diffs[pointer - 1][1];
	      var edit = diffs[pointer][1];
	      var equality2 = diffs[pointer + 1][1];

	      // First, shift the edit as far left as possible.
	      var commonOffset = this.diff_commonSuffix(equality1, edit);
	      if (commonOffset) {
	        var commonString = edit.substring(edit.length - commonOffset);
	        equality1 = equality1.substring(0, equality1.length - commonOffset);
	        edit = commonString + edit.substring(0, edit.length - commonOffset);
	        equality2 = commonString + equality2;
	      }

	      // Second, step character by character right, looking for the best fit.
	      var bestEquality1 = equality1;
	      var bestEdit = edit;
	      var bestEquality2 = equality2;
	      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
	          diff_cleanupSemanticScore_(edit, equality2);
	      while (edit.charAt(0) === equality2.charAt(0)) {
	        equality1 += edit.charAt(0);
	        edit = edit.substring(1) + equality2.charAt(0);
	        equality2 = equality2.substring(1);
	        var score = diff_cleanupSemanticScore_(equality1, edit) +
	            diff_cleanupSemanticScore_(edit, equality2);
	        // The >= encourages trailing rather than leading whitespace on edits.
	        if (score >= bestScore) {
	          bestScore = score;
	          bestEquality1 = equality1;
	          bestEdit = edit;
	          bestEquality2 = equality2;
	        }
	      }

	      if (diffs[pointer - 1][1] != bestEquality1) {
	        // We have an improvement, save it back to the diff.
	        if (bestEquality1) {
	          diffs[pointer - 1][1] = bestEquality1;
	        } else {
	          diffs.splice(pointer - 1, 1);
	          pointer--;
	        }
	        diffs[pointer][1] = bestEdit;
	        if (bestEquality2) {
	          diffs[pointer + 1][1] = bestEquality2;
	        } else {
	          diffs.splice(pointer + 1, 1);
	          pointer--;
	        }
	      }
	    }
	    pointer++;
	  }
	};

	// Define some regex patterns for matching boundaries.
	diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
	diff_match_patch.whitespaceRegex_ = /\s/;
	diff_match_patch.linebreakRegex_ = /[\r\n]/;
	diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
	diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

	/**
	 * Reduce the number of edits by eliminating operationally trivial equalities.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
	  var changes = false;
	  var equalities = [];  // Stack of indices where equalities are found.
	  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
	  /** @type {?string} */
	  var lastEquality = null;
	  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
	  var pointer = 0;  // Index of current position.
	  // Is there an insertion operation before the last equality.
	  var pre_ins = false;
	  // Is there a deletion operation before the last equality.
	  var pre_del = false;
	  // Is there an insertion operation after the last equality.
	  var post_ins = false;
	  // Is there a deletion operation after the last equality.
	  var post_del = false;
	  while (pointer < diffs.length) {
	    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
	      if (diffs[pointer][1].length < this.Diff_EditCost &&
	          (post_ins || post_del)) {
	        // Candidate found.
	        equalities[equalitiesLength++] = pointer;
	        pre_ins = post_ins;
	        pre_del = post_del;
	        lastEquality = diffs[pointer][1];
	      } else {
	        // Not a candidate, and can never become one.
	        equalitiesLength = 0;
	        lastEquality = null;
	      }
	      post_ins = post_del = false;
	    } else {  // An insertion or deletion.
	      if (diffs[pointer][0] == DIFF_DELETE) {
	        post_del = true;
	      } else {
	        post_ins = true;
	      }
	      /*
	       * Five types to be split:
	       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
	       * <ins>A</ins>X<ins>C</ins><del>D</del>
	       * <ins>A</ins><del>B</del>X<ins>C</ins>
	       * <ins>A</del>X<ins>C</ins><del>D</del>
	       * <ins>A</ins><del>B</del>X<del>C</del>
	       */
	      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||
	                           ((lastEquality.length < this.Diff_EditCost / 2) &&
	                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
	        // Duplicate record.
	        diffs.splice(equalities[equalitiesLength - 1], 0,
	                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
	        // Change second copy to insert.
	        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
	        equalitiesLength--;  // Throw away the equality we just deleted;
	        lastEquality = null;
	        if (pre_ins && pre_del) {
	          // No changes made which could affect previous entry, keep going.
	          post_ins = post_del = true;
	          equalitiesLength = 0;
	        } else {
	          equalitiesLength--;  // Throw away the previous equality.
	          pointer = equalitiesLength > 0 ?
	              equalities[equalitiesLength - 1] : -1;
	          post_ins = post_del = false;
	        }
	        changes = true;
	      }
	    }
	    pointer++;
	  }

	  if (changes) {
	    this.diff_cleanupMerge(diffs);
	  }
	};


	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
	  // Add a dummy entry at the end.
	  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
	  var pointer = 0;
	  var count_delete = 0;
	  var count_insert = 0;
	  var text_delete = '';
	  var text_insert = '';
	  var commonlength;
	  while (pointer < diffs.length) {
	    switch (diffs[pointer][0]) {
	      case DIFF_INSERT:
	        count_insert++;
	        text_insert += diffs[pointer][1];
	        pointer++;
	        break;
	      case DIFF_DELETE:
	        count_delete++;
	        text_delete += diffs[pointer][1];
	        pointer++;
	        break;
	      case DIFF_EQUAL:
	        // Upon reaching an equality, check for prior redundancies.
	        if (count_delete + count_insert > 1) {
	          if (count_delete !== 0 && count_insert !== 0) {
	            // Factor out any common prefixies.
	            commonlength = this.diff_commonPrefix(text_insert, text_delete);
	            if (commonlength !== 0) {
	              if ((pointer - count_delete - count_insert) > 0 &&
	                  diffs[pointer - count_delete - count_insert - 1][0] ==
	                  DIFF_EQUAL) {
	                diffs[pointer - count_delete - count_insert - 1][1] +=
	                    text_insert.substring(0, commonlength);
	              } else {
	                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,
	                    text_insert.substring(0, commonlength)));
	                pointer++;
	              }
	              text_insert = text_insert.substring(commonlength);
	              text_delete = text_delete.substring(commonlength);
	            }
	            // Factor out any common suffixies.
	            commonlength = this.diff_commonSuffix(text_insert, text_delete);
	            if (commonlength !== 0) {
	              diffs[pointer][1] = text_insert.substring(text_insert.length -
	                  commonlength) + diffs[pointer][1];
	              text_insert = text_insert.substring(0, text_insert.length -
	                  commonlength);
	              text_delete = text_delete.substring(0, text_delete.length -
	                  commonlength);
	            }
	          }
	          // Delete the offending records and add the merged ones.
	          pointer -= count_delete + count_insert;
	          diffs.splice(pointer, count_delete + count_insert);
	          if (text_delete.length) {
	            diffs.splice(pointer, 0,
	                new diff_match_patch.Diff(DIFF_DELETE, text_delete));
	            pointer++;
	          }
	          if (text_insert.length) {
	            diffs.splice(pointer, 0,
	                new diff_match_patch.Diff(DIFF_INSERT, text_insert));
	            pointer++;
	          }
	          pointer++;
	        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
	          // Merge this equality with the previous one.
	          diffs[pointer - 1][1] += diffs[pointer][1];
	          diffs.splice(pointer, 1);
	        } else {
	          pointer++;
	        }
	        count_insert = 0;
	        count_delete = 0;
	        text_delete = '';
	        text_insert = '';
	        break;
	    }
	  }
	  if (diffs[diffs.length - 1][1] === '') {
	    diffs.pop();  // Remove the dummy entry at the end.
	  }

	  // Second pass: look for single edits surrounded on both sides by equalities
	  // which can be shifted sideways to eliminate an equality.
	  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	  var changes = false;
	  pointer = 1;
	  // Intentionally ignore the first and last element (don't need checking).
	  while (pointer < diffs.length - 1) {
	    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
	        diffs[pointer + 1][0] == DIFF_EQUAL) {
	      // This is a single edit surrounded by equalities.
	      if (diffs[pointer][1].substring(diffs[pointer][1].length -
	          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	        // Shift the edit over the previous equality.
	        diffs[pointer][1] = diffs[pointer - 1][1] +
	            diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                                        diffs[pointer - 1][1].length);
	        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	        diffs.splice(pointer - 1, 1);
	        changes = true;
	      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	          diffs[pointer + 1][1]) {
	        // Shift the edit over the next equality.
	        diffs[pointer - 1][1] += diffs[pointer + 1][1];
	        diffs[pointer][1] =
	            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	            diffs[pointer + 1][1];
	        diffs.splice(pointer + 1, 1);
	        changes = true;
	      }
	    }
	    pointer++;
	  }
	  // If shifts were made, the diff needs reordering and another shift sweep.
	  if (changes) {
	    this.diff_cleanupMerge(diffs);
	  }
	};


	/**
	 * loc is a location in text1, compute and return the equivalent location in
	 * text2.
	 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @param {number} loc Location within text1.
	 * @return {number} Location within text2.
	 */
	diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
	  var chars1 = 0;
	  var chars2 = 0;
	  var last_chars1 = 0;
	  var last_chars2 = 0;
	  var x;
	  for (x = 0; x < diffs.length; x++) {
	    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
	      chars1 += diffs[x][1].length;
	    }
	    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
	      chars2 += diffs[x][1].length;
	    }
	    if (chars1 > loc) {  // Overshot the location.
	      break;
	    }
	    last_chars1 = chars1;
	    last_chars2 = chars2;
	  }
	  // Was the location was deleted?
	  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
	    return last_chars2;
	  }
	  // Add the remaining character length.
	  return last_chars2 + (loc - last_chars1);
	};


	/**
	 * Convert a diff array into a pretty HTML report.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} HTML representation.
	 */
	diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
	  var html = [];
	  var pattern_amp = /&/g;
	  var pattern_lt = /</g;
	  var pattern_gt = />/g;
	  var pattern_para = /\n/g;
	  for (var x = 0; x < diffs.length; x++) {
	    var op = diffs[x][0];    // Operation (insert, delete, equal)
	    var data = diffs[x][1];  // Text of change.
	    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
	        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
	    switch (op) {
	      case DIFF_INSERT:
	        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
	        break;
	      case DIFF_DELETE:
	        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
	        break;
	      case DIFF_EQUAL:
	        html[x] = '<span>' + text + '</span>';
	        break;
	    }
	  }
	  return html.join('');
	};


	/**
	 * Compute and return the source text (all equalities and deletions).
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} Source text.
	 */
	diff_match_patch.prototype.diff_text1 = function(diffs) {
	  var text = [];
	  for (var x = 0; x < diffs.length; x++) {
	    if (diffs[x][0] !== DIFF_INSERT) {
	      text[x] = diffs[x][1];
	    }
	  }
	  return text.join('');
	};


	/**
	 * Compute and return the destination text (all equalities and insertions).
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} Destination text.
	 */
	diff_match_patch.prototype.diff_text2 = function(diffs) {
	  var text = [];
	  for (var x = 0; x < diffs.length; x++) {
	    if (diffs[x][0] !== DIFF_DELETE) {
	      text[x] = diffs[x][1];
	    }
	  }
	  return text.join('');
	};


	/**
	 * Compute the Levenshtein distance; the number of inserted, deleted or
	 * substituted characters.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {number} Number of changes.
	 */
	diff_match_patch.prototype.diff_levenshtein = function(diffs) {
	  var levenshtein = 0;
	  var insertions = 0;
	  var deletions = 0;
	  for (var x = 0; x < diffs.length; x++) {
	    var op = diffs[x][0];
	    var data = diffs[x][1];
	    switch (op) {
	      case DIFF_INSERT:
	        insertions += data.length;
	        break;
	      case DIFF_DELETE:
	        deletions += data.length;
	        break;
	      case DIFF_EQUAL:
	        // A deletion and an insertion is one substitution.
	        levenshtein += Math.max(insertions, deletions);
	        insertions = 0;
	        deletions = 0;
	        break;
	    }
	  }
	  levenshtein += Math.max(insertions, deletions);
	  return levenshtein;
	};


	/**
	 * Crush the diff into an encoded string which describes the operations
	 * required to transform text1 into text2.
	 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
	 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} Delta text.
	 */
	diff_match_patch.prototype.diff_toDelta = function(diffs) {
	  var text = [];
	  for (var x = 0; x < diffs.length; x++) {
	    switch (diffs[x][0]) {
	      case DIFF_INSERT:
	        text[x] = '+' + encodeURI(diffs[x][1]);
	        break;
	      case DIFF_DELETE:
	        text[x] = '-' + diffs[x][1].length;
	        break;
	      case DIFF_EQUAL:
	        text[x] = '=' + diffs[x][1].length;
	        break;
	    }
	  }
	  return text.join('\t').replace(/%20/g, ' ');
	};


	/**
	 * Given the original text1, and an encoded string which describes the
	 * operations required to transform text1 into text2, compute the full diff.
	 * @param {string} text1 Source string for the diff.
	 * @param {string} delta Delta text.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @throws {!Error} If invalid input.
	 */
	diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
	  var diffs = [];
	  var diffsLength = 0;  // Keeping our own length var is faster in JS.
	  var pointer = 0;  // Cursor in text1
	  var tokens = delta.split(/\t/g);
	  for (var x = 0; x < tokens.length; x++) {
	    // Each token begins with a one character parameter which specifies the
	    // operation of this token (delete, insert, equality).
	    var param = tokens[x].substring(1);
	    switch (tokens[x].charAt(0)) {
	      case '+':
	        try {
	          diffs[diffsLength++] =
	              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
	        } catch (ex) {
	          // Malformed URI sequence.
	          throw new Error('Illegal escape in diff_fromDelta: ' + param);
	        }
	        break;
	      case '-':
	        // Fall through.
	      case '=':
	        var n = parseInt(param, 10);
	        if (isNaN(n) || n < 0) {
	          throw new Error('Invalid number in diff_fromDelta: ' + param);
	        }
	        var text = text1.substring(pointer, pointer += n);
	        if (tokens[x].charAt(0) == '=') {
	          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
	        } else {
	          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
	        }
	        break;
	      default:
	        // Blank tokens are ok (from a trailing \t).
	        // Anything else is an error.
	        if (tokens[x]) {
	          throw new Error('Invalid diff operation in diff_fromDelta: ' +
	                          tokens[x]);
	        }
	    }
	  }
	  if (pointer != text1.length) {
	    throw new Error('Delta length (' + pointer +
	        ') does not equal source text length (' + text1.length + ').');
	  }
	  return diffs;
	};


	//  MATCH FUNCTIONS


	/**
	 * Locate the best instance of 'pattern' in 'text' near 'loc'.
	 * @param {string} text The text to search.
	 * @param {string} pattern The pattern to search for.
	 * @param {number} loc The location to search around.
	 * @return {number} Best match index or -1.
	 */
	diff_match_patch.prototype.match_main = function(text, pattern, loc) {
	  // Check for null inputs.
	  if (text == null || pattern == null || loc == null) {
	    throw new Error('Null input. (match_main)');
	  }

	  loc = Math.max(0, Math.min(loc, text.length));
	  if (text == pattern) {
	    // Shortcut (potentially not guaranteed by the algorithm)
	    return 0;
	  } else if (!text.length) {
	    // Nothing to match.
	    return -1;
	  } else if (text.substring(loc, loc + pattern.length) == pattern) {
	    // Perfect match at the perfect spot!  (Includes case of null pattern)
	    return loc;
	  } else {
	    // Do a fuzzy compare.
	    return this.match_bitap_(text, pattern, loc);
	  }
	};


	/**
	 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
	 * Bitap algorithm.
	 * @param {string} text The text to search.
	 * @param {string} pattern The pattern to search for.
	 * @param {number} loc The location to search around.
	 * @return {number} Best match index or -1.
	 * @private
	 */
	diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
	  if (pattern.length > this.Match_MaxBits) {
	    throw new Error('Pattern too long for this browser.');
	  }

	  // Initialise the alphabet.
	  var s = this.match_alphabet_(pattern);

	  var dmp = this;  // 'this' becomes 'window' in a closure.

	  /**
	   * Compute and return the score for a match with e errors and x location.
	   * Accesses loc and pattern through being a closure.
	   * @param {number} e Number of errors in match.
	   * @param {number} x Location of match.
	   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
	   * @private
	   */
	  function match_bitapScore_(e, x) {
	    var accuracy = e / pattern.length;
	    var proximity = Math.abs(loc - x);
	    if (!dmp.Match_Distance) {
	      // Dodge divide by zero error.
	      return proximity ? 1.0 : accuracy;
	    }
	    return accuracy + (proximity / dmp.Match_Distance);
	  }

	  // Highest score beyond which we give up.
	  var score_threshold = this.Match_Threshold;
	  // Is there a nearby exact match? (speedup)
	  var best_loc = text.indexOf(pattern, loc);
	  if (best_loc != -1) {
	    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
	    // What about in the other direction? (speedup)
	    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
	    if (best_loc != -1) {
	      score_threshold =
	          Math.min(match_bitapScore_(0, best_loc), score_threshold);
	    }
	  }

	  // Initialise the bit arrays.
	  var matchmask = 1 << (pattern.length - 1);
	  best_loc = -1;

	  var bin_min, bin_mid;
	  var bin_max = pattern.length + text.length;
	  var last_rd;
	  for (var d = 0; d < pattern.length; d++) {
	    // Scan for the best match; each iteration allows for one more error.
	    // Run a binary search to determine how far from 'loc' we can stray at this
	    // error level.
	    bin_min = 0;
	    bin_mid = bin_max;
	    while (bin_min < bin_mid) {
	      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
	        bin_min = bin_mid;
	      } else {
	        bin_max = bin_mid;
	      }
	      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
	    }
	    // Use the result from this iteration as the maximum for the next.
	    bin_max = bin_mid;
	    var start = Math.max(1, loc - bin_mid + 1);
	    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

	    var rd = Array(finish + 2);
	    rd[finish + 1] = (1 << d) - 1;
	    for (var j = finish; j >= start; j--) {
	      // The alphabet (s) is a sparse hash, so the following line generates
	      // warnings.
	      var charMatch = s[text.charAt(j - 1)];
	      if (d === 0) {  // First pass: exact match.
	        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
	      } else {  // Subsequent passes: fuzzy match.
	        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
	                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
	                last_rd[j + 1];
	      }
	      if (rd[j] & matchmask) {
	        var score = match_bitapScore_(d, j - 1);
	        // This match will almost certainly be better than any existing match.
	        // But check anyway.
	        if (score <= score_threshold) {
	          // Told you so.
	          score_threshold = score;
	          best_loc = j - 1;
	          if (best_loc > loc) {
	            // When passing loc, don't exceed our current distance from loc.
	            start = Math.max(1, 2 * loc - best_loc);
	          } else {
	            // Already passed loc, downhill from here on in.
	            break;
	          }
	        }
	      }
	    }
	    // No hope for a (better) match at greater error levels.
	    if (match_bitapScore_(d + 1, loc) > score_threshold) {
	      break;
	    }
	    last_rd = rd;
	  }
	  return best_loc;
	};


	/**
	 * Initialise the alphabet for the Bitap algorithm.
	 * @param {string} pattern The text to encode.
	 * @return {!Object} Hash of character locations.
	 * @private
	 */
	diff_match_patch.prototype.match_alphabet_ = function(pattern) {
	  var s = {};
	  for (var i = 0; i < pattern.length; i++) {
	    s[pattern.charAt(i)] = 0;
	  }
	  for (var i = 0; i < pattern.length; i++) {
	    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
	  }
	  return s;
	};


	//  PATCH FUNCTIONS


	/**
	 * Increase the context until it is unique,
	 * but don't let the pattern expand beyond Match_MaxBits.
	 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
	 * @param {string} text Source text.
	 * @private
	 */
	diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
	  if (text.length == 0) {
	    return;
	  }
	  if (patch.start2 === null) {
	    throw Error('patch not initialized');
	  }
	  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
	  var padding = 0;

	  // Look for the first and last matches of pattern in text.  If two different
	  // matches are found, increase the pattern length.
	  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
	         pattern.length < this.Match_MaxBits - this.Patch_Margin -
	         this.Patch_Margin) {
	    padding += this.Patch_Margin;
	    pattern = text.substring(patch.start2 - padding,
	                             patch.start2 + patch.length1 + padding);
	  }
	  // Add one chunk for good luck.
	  padding += this.Patch_Margin;

	  // Add the prefix.
	  var prefix = text.substring(patch.start2 - padding, patch.start2);
	  if (prefix) {
	    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
	  }
	  // Add the suffix.
	  var suffix = text.substring(patch.start2 + patch.length1,
	                              patch.start2 + patch.length1 + padding);
	  if (suffix) {
	    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
	  }

	  // Roll back the start points.
	  patch.start1 -= prefix.length;
	  patch.start2 -= prefix.length;
	  // Extend the lengths.
	  patch.length1 += prefix.length + suffix.length;
	  patch.length2 += prefix.length + suffix.length;
	};


	/**
	 * Compute a list of patches to turn text1 into text2.
	 * Use diffs if provided, otherwise compute it ourselves.
	 * There are four ways to call this function, depending on what data is
	 * available to the caller:
	 * Method 1:
	 * a = text1, b = text2
	 * Method 2:
	 * a = diffs
	 * Method 3 (optimal):
	 * a = text1, b = diffs
	 * Method 4 (deprecated, use method 3):
	 * a = text1, b = text2, c = diffs
	 *
	 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
	 * Array of diff tuples for text1 to text2 (method 2).
	 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or
	 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
	 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples
	 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
	 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
	 */
	diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
	  var text1, diffs;
	  if (typeof a == 'string' && typeof opt_b == 'string' &&
	      typeof opt_c == 'undefined') {
	    // Method 1: text1, text2
	    // Compute diffs from text1 and text2.
	    text1 = /** @type {string} */(a);
	    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
	    if (diffs.length > 2) {
	      this.diff_cleanupSemantic(diffs);
	      this.diff_cleanupEfficiency(diffs);
	    }
	  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
	      typeof opt_c == 'undefined') {
	    // Method 2: diffs
	    // Compute text1 from diffs.
	    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
	    text1 = this.diff_text1(diffs);
	  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
	      typeof opt_c == 'undefined') {
	    // Method 3: text1, diffs
	    text1 = /** @type {string} */(a);
	    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
	  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
	      opt_c && typeof opt_c == 'object') {
	    // Method 4: text1, text2, diffs
	    // text2 is not used.
	    text1 = /** @type {string} */(a);
	    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
	  } else {
	    throw new Error('Unknown call format to patch_make.');
	  }

	  if (diffs.length === 0) {
	    return [];  // Get rid of the null case.
	  }
	  var patches = [];
	  var patch = new diff_match_patch.patch_obj();
	  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
	  var char_count1 = 0;  // Number of characters into the text1 string.
	  var char_count2 = 0;  // Number of characters into the text2 string.
	  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
	  // text2 (postpatch_text).  We recreate the patches one by one to determine
	  // context info.
	  var prepatch_text = text1;
	  var postpatch_text = text1;
	  for (var x = 0; x < diffs.length; x++) {
	    var diff_type = diffs[x][0];
	    var diff_text = diffs[x][1];

	    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
	      // A new patch starts here.
	      patch.start1 = char_count1;
	      patch.start2 = char_count2;
	    }

	    switch (diff_type) {
	      case DIFF_INSERT:
	        patch.diffs[patchDiffLength++] = diffs[x];
	        patch.length2 += diff_text.length;
	        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
	                         postpatch_text.substring(char_count2);
	        break;
	      case DIFF_DELETE:
	        patch.length1 += diff_text.length;
	        patch.diffs[patchDiffLength++] = diffs[x];
	        postpatch_text = postpatch_text.substring(0, char_count2) +
	                         postpatch_text.substring(char_count2 +
	                             diff_text.length);
	        break;
	      case DIFF_EQUAL:
	        if (diff_text.length <= 2 * this.Patch_Margin &&
	            patchDiffLength && diffs.length != x + 1) {
	          // Small equality inside a patch.
	          patch.diffs[patchDiffLength++] = diffs[x];
	          patch.length1 += diff_text.length;
	          patch.length2 += diff_text.length;
	        } else if (diff_text.length >= 2 * this.Patch_Margin) {
	          // Time for a new patch.
	          if (patchDiffLength) {
	            this.patch_addContext_(patch, prepatch_text);
	            patches.push(patch);
	            patch = new diff_match_patch.patch_obj();
	            patchDiffLength = 0;
	            // Unlike Unidiff, our patch lists have a rolling context.
	            // https://github.com/google/diff-match-patch/wiki/Unidiff
	            // Update prepatch text & pos to reflect the application of the
	            // just completed patch.
	            prepatch_text = postpatch_text;
	            char_count1 = char_count2;
	          }
	        }
	        break;
	    }

	    // Update the current character count.
	    if (diff_type !== DIFF_INSERT) {
	      char_count1 += diff_text.length;
	    }
	    if (diff_type !== DIFF_DELETE) {
	      char_count2 += diff_text.length;
	    }
	  }
	  // Pick up the leftover patch if not empty.
	  if (patchDiffLength) {
	    this.patch_addContext_(patch, prepatch_text);
	    patches.push(patch);
	  }

	  return patches;
	};


	/**
	 * Given an array of patches, return another array that is identical.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
	 */
	diff_match_patch.prototype.patch_deepCopy = function(patches) {
	  // Making deep copies is hard in JavaScript.
	  var patchesCopy = [];
	  for (var x = 0; x < patches.length; x++) {
	    var patch = patches[x];
	    var patchCopy = new diff_match_patch.patch_obj();
	    patchCopy.diffs = [];
	    for (var y = 0; y < patch.diffs.length; y++) {
	      patchCopy.diffs[y] =
	          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
	    }
	    patchCopy.start1 = patch.start1;
	    patchCopy.start2 = patch.start2;
	    patchCopy.length1 = patch.length1;
	    patchCopy.length2 = patch.length2;
	    patchesCopy[x] = patchCopy;
	  }
	  return patchesCopy;
	};


	/**
	 * Merge a set of patches onto the text.  Return a patched text, as well
	 * as a list of true/false values indicating which patches were applied.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @param {string} text Old text.
	 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
	 *      new text and an array of boolean values.
	 */
	diff_match_patch.prototype.patch_apply = function(patches, text) {
	  if (patches.length == 0) {
	    return [text, []];
	  }

	  // Deep copy the patches so that no changes are made to originals.
	  patches = this.patch_deepCopy(patches);

	  var nullPadding = this.patch_addPadding(patches);
	  text = nullPadding + text + nullPadding;

	  this.patch_splitMax(patches);
	  // delta keeps track of the offset between the expected and actual location
	  // of the previous patch.  If there are patches expected at positions 10 and
	  // 20, but the first patch was found at 12, delta is 2 and the second patch
	  // has an effective expected position of 22.
	  var delta = 0;
	  var results = [];
	  for (var x = 0; x < patches.length; x++) {
	    var expected_loc = patches[x].start2 + delta;
	    var text1 = this.diff_text1(patches[x].diffs);
	    var start_loc;
	    var end_loc = -1;
	    if (text1.length > this.Match_MaxBits) {
	      // patch_splitMax will only provide an oversized pattern in the case of
	      // a monster delete.
	      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
	                                  expected_loc);
	      if (start_loc != -1) {
	        end_loc = this.match_main(text,
	            text1.substring(text1.length - this.Match_MaxBits),
	            expected_loc + text1.length - this.Match_MaxBits);
	        if (end_loc == -1 || start_loc >= end_loc) {
	          // Can't find valid trailing context.  Drop this patch.
	          start_loc = -1;
	        }
	      }
	    } else {
	      start_loc = this.match_main(text, text1, expected_loc);
	    }
	    if (start_loc == -1) {
	      // No match found.  :(
	      results[x] = false;
	      // Subtract the delta for this failed patch from subsequent patches.
	      delta -= patches[x].length2 - patches[x].length1;
	    } else {
	      // Found a match.  :)
	      results[x] = true;
	      delta = start_loc - expected_loc;
	      var text2;
	      if (end_loc == -1) {
	        text2 = text.substring(start_loc, start_loc + text1.length);
	      } else {
	        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
	      }
	      if (text1 == text2) {
	        // Perfect match, just shove the replacement text in.
	        text = text.substring(0, start_loc) +
	               this.diff_text2(patches[x].diffs) +
	               text.substring(start_loc + text1.length);
	      } else {
	        // Imperfect match.  Run a diff to get a framework of equivalent
	        // indices.
	        var diffs = this.diff_main(text1, text2, false);
	        if (text1.length > this.Match_MaxBits &&
	            this.diff_levenshtein(diffs) / text1.length >
	            this.Patch_DeleteThreshold) {
	          // The end points match, but the content is unacceptably bad.
	          results[x] = false;
	        } else {
	          this.diff_cleanupSemanticLossless(diffs);
	          var index1 = 0;
	          var index2;
	          for (var y = 0; y < patches[x].diffs.length; y++) {
	            var mod = patches[x].diffs[y];
	            if (mod[0] !== DIFF_EQUAL) {
	              index2 = this.diff_xIndex(diffs, index1);
	            }
	            if (mod[0] === DIFF_INSERT) {  // Insertion
	              text = text.substring(0, start_loc + index2) + mod[1] +
	                     text.substring(start_loc + index2);
	            } else if (mod[0] === DIFF_DELETE) {  // Deletion
	              text = text.substring(0, start_loc + index2) +
	                     text.substring(start_loc + this.diff_xIndex(diffs,
	                         index1 + mod[1].length));
	            }
	            if (mod[0] !== DIFF_DELETE) {
	              index1 += mod[1].length;
	            }
	          }
	        }
	      }
	    }
	  }
	  // Strip the padding off.
	  text = text.substring(nullPadding.length, text.length - nullPadding.length);
	  return [text, results];
	};


	/**
	 * Add some padding on text start and end so that edges can match something.
	 * Intended to be called only from within patch_apply.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @return {string} The padding string added to each side.
	 */
	diff_match_patch.prototype.patch_addPadding = function(patches) {
	  var paddingLength = this.Patch_Margin;
	  var nullPadding = '';
	  for (var x = 1; x <= paddingLength; x++) {
	    nullPadding += String.fromCharCode(x);
	  }

	  // Bump all the patches forward.
	  for (var x = 0; x < patches.length; x++) {
	    patches[x].start1 += paddingLength;
	    patches[x].start2 += paddingLength;
	  }

	  // Add some padding on start of first diff.
	  var patch = patches[0];
	  var diffs = patch.diffs;
	  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
	    // Add nullPadding equality.
	    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
	    patch.start1 -= paddingLength;  // Should be 0.
	    patch.start2 -= paddingLength;  // Should be 0.
	    patch.length1 += paddingLength;
	    patch.length2 += paddingLength;
	  } else if (paddingLength > diffs[0][1].length) {
	    // Grow first equality.
	    var extraLength = paddingLength - diffs[0][1].length;
	    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
	    patch.start1 -= extraLength;
	    patch.start2 -= extraLength;
	    patch.length1 += extraLength;
	    patch.length2 += extraLength;
	  }

	  // Add some padding on end of last diff.
	  patch = patches[patches.length - 1];
	  diffs = patch.diffs;
	  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
	    // Add nullPadding equality.
	    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
	    patch.length1 += paddingLength;
	    patch.length2 += paddingLength;
	  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
	    // Grow last equality.
	    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
	    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
	    patch.length1 += extraLength;
	    patch.length2 += extraLength;
	  }

	  return nullPadding;
	};


	/**
	 * Look through the patches and break up any which are longer than the maximum
	 * limit of the match algorithm.
	 * Intended to be called only from within patch_apply.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 */
	diff_match_patch.prototype.patch_splitMax = function(patches) {
	  var patch_size = this.Match_MaxBits;
	  for (var x = 0; x < patches.length; x++) {
	    if (patches[x].length1 <= patch_size) {
	      continue;
	    }
	    var bigpatch = patches[x];
	    // Remove the big old patch.
	    patches.splice(x--, 1);
	    var start1 = bigpatch.start1;
	    var start2 = bigpatch.start2;
	    var precontext = '';
	    while (bigpatch.diffs.length !== 0) {
	      // Create one of several smaller patches.
	      var patch = new diff_match_patch.patch_obj();
	      var empty = true;
	      patch.start1 = start1 - precontext.length;
	      patch.start2 = start2 - precontext.length;
	      if (precontext !== '') {
	        patch.length1 = patch.length2 = precontext.length;
	        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
	      }
	      while (bigpatch.diffs.length !== 0 &&
	             patch.length1 < patch_size - this.Patch_Margin) {
	        var diff_type = bigpatch.diffs[0][0];
	        var diff_text = bigpatch.diffs[0][1];
	        if (diff_type === DIFF_INSERT) {
	          // Insertions are harmless.
	          patch.length2 += diff_text.length;
	          start2 += diff_text.length;
	          patch.diffs.push(bigpatch.diffs.shift());
	          empty = false;
	        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
	                   patch.diffs[0][0] == DIFF_EQUAL &&
	                   diff_text.length > 2 * patch_size) {
	          // This is a large deletion.  Let it pass in one chunk.
	          patch.length1 += diff_text.length;
	          start1 += diff_text.length;
	          empty = false;
	          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
	          bigpatch.diffs.shift();
	        } else {
	          // Deletion or equality.  Only take as much as we can stomach.
	          diff_text = diff_text.substring(0,
	              patch_size - patch.length1 - this.Patch_Margin);
	          patch.length1 += diff_text.length;
	          start1 += diff_text.length;
	          if (diff_type === DIFF_EQUAL) {
	            patch.length2 += diff_text.length;
	            start2 += diff_text.length;
	          } else {
	            empty = false;
	          }
	          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
	          if (diff_text == bigpatch.diffs[0][1]) {
	            bigpatch.diffs.shift();
	          } else {
	            bigpatch.diffs[0][1] =
	                bigpatch.diffs[0][1].substring(diff_text.length);
	          }
	        }
	      }
	      // Compute the head context for the next patch.
	      precontext = this.diff_text2(patch.diffs);
	      precontext =
	          precontext.substring(precontext.length - this.Patch_Margin);
	      // Append the end context for this patch.
	      var postcontext = this.diff_text1(bigpatch.diffs)
	                            .substring(0, this.Patch_Margin);
	      if (postcontext !== '') {
	        patch.length1 += postcontext.length;
	        patch.length2 += postcontext.length;
	        if (patch.diffs.length !== 0 &&
	            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
	          patch.diffs[patch.diffs.length - 1][1] += postcontext;
	        } else {
	          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
	        }
	      }
	      if (!empty) {
	        patches.splice(++x, 0, patch);
	      }
	    }
	  }
	};


	/**
	 * Take a list of patches and return a textual representation.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @return {string} Text representation of patches.
	 */
	diff_match_patch.prototype.patch_toText = function(patches) {
	  var text = [];
	  for (var x = 0; x < patches.length; x++) {
	    text[x] = patches[x];
	  }
	  return text.join('');
	};


	/**
	 * Parse a textual representation of patches and return a list of Patch objects.
	 * @param {string} textline Text representation of patches.
	 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
	 * @throws {!Error} If invalid input.
	 */
	diff_match_patch.prototype.patch_fromText = function(textline) {
	  var patches = [];
	  if (!textline) {
	    return patches;
	  }
	  var text = textline.split('\n');
	  var textPointer = 0;
	  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
	  while (textPointer < text.length) {
	    var m = text[textPointer].match(patchHeader);
	    if (!m) {
	      throw new Error('Invalid patch string: ' + text[textPointer]);
	    }
	    var patch = new diff_match_patch.patch_obj();
	    patches.push(patch);
	    patch.start1 = parseInt(m[1], 10);
	    if (m[2] === '') {
	      patch.start1--;
	      patch.length1 = 1;
	    } else if (m[2] == '0') {
	      patch.length1 = 0;
	    } else {
	      patch.start1--;
	      patch.length1 = parseInt(m[2], 10);
	    }

	    patch.start2 = parseInt(m[3], 10);
	    if (m[4] === '') {
	      patch.start2--;
	      patch.length2 = 1;
	    } else if (m[4] == '0') {
	      patch.length2 = 0;
	    } else {
	      patch.start2--;
	      patch.length2 = parseInt(m[4], 10);
	    }
	    textPointer++;

	    while (textPointer < text.length) {
	      var sign = text[textPointer].charAt(0);
	      try {
	        var line = decodeURI(text[textPointer].substring(1));
	      } catch (ex) {
	        // Malformed URI sequence.
	        throw new Error('Illegal escape in patch_fromText: ' + line);
	      }
	      if (sign == '-') {
	        // Deletion.
	        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
	      } else if (sign == '+') {
	        // Insertion.
	        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
	      } else if (sign == ' ') {
	        // Minor equality.
	        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
	      } else if (sign == '@') {
	        // Start of next patch.
	        break;
	      } else if (sign === '') ; else {
	        // WTF?
	        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
	      }
	      textPointer++;
	    }
	  }
	  return patches;
	};


	/**
	 * Class representing one patch operation.
	 * @constructor
	 */
	diff_match_patch.patch_obj = function() {
	  /** @type {!Array.<!diff_match_patch.Diff>} */
	  this.diffs = [];
	  /** @type {?number} */
	  this.start1 = null;
	  /** @type {?number} */
	  this.start2 = null;
	  /** @type {number} */
	  this.length1 = 0;
	  /** @type {number} */
	  this.length2 = 0;
	};


	/**
	 * Emulate GNU diff's format.
	 * Header: @@ -382,8 +481,9 @@
	 * Indices are printed as 1-based, not 0-based.
	 * @return {string} The GNU diff string.
	 */
	diff_match_patch.patch_obj.prototype.toString = function() {
	  var coords1, coords2;
	  if (this.length1 === 0) {
	    coords1 = this.start1 + ',0';
	  } else if (this.length1 == 1) {
	    coords1 = this.start1 + 1;
	  } else {
	    coords1 = (this.start1 + 1) + ',' + this.length1;
	  }
	  if (this.length2 === 0) {
	    coords2 = this.start2 + ',0';
	  } else if (this.length2 == 1) {
	    coords2 = this.start2 + 1;
	  } else {
	    coords2 = (this.start2 + 1) + ',' + this.length2;
	  }
	  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
	  var op;
	  // Escape the body of the patch with %xx notation.
	  for (var x = 0; x < this.diffs.length; x++) {
	    switch (this.diffs[x][0]) {
	      case DIFF_INSERT:
	        op = '+';
	        break;
	      case DIFF_DELETE:
	        op = '-';
	        break;
	      case DIFF_EQUAL:
	        op = ' ';
	        break;
	    }
	    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
	  }
	  return text.join('').replace(/%20/g, ' ');
	};


	// The following export code was added by @ForbesLindesay
	module.exports = diff_match_patch;
	module.exports['diff_match_patch'] = diff_match_patch;
	module.exports['DIFF_DELETE'] = DIFF_DELETE;
	module.exports['DIFF_INSERT'] = DIFF_INSERT;
	module.exports['DIFF_EQUAL'] = DIFF_EQUAL; 
} (diffMatchPatch));

var diffMatchPatchExports = diffMatchPatch.exports;

var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(diff, "__esModule", { value: true });
var PropTypes = propTypesExports;
var React$z = reactExports;
var split_1$1 = split;
var DiffMatchPatch = diffMatchPatchExports;
var DiffComponent = /** @class */ (function (_super) {
    __extends(DiffComponent, _super);
    function DiffComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            value: _this.props.value
        };
        _this.onChange = _this.onChange.bind(_this);
        _this.diff = _this.diff.bind(_this);
        return _this;
    }
    DiffComponent.prototype.componentDidUpdate = function () {
        var value = this.props.value;
        if (value !== this.state.value) {
            this.setState({ value: value });
        }
    };
    DiffComponent.prototype.onChange = function (value) {
        this.setState({
            value: value
        });
        if (this.props.onChange) {
            this.props.onChange(value);
        }
    };
    DiffComponent.prototype.diff = function () {
        var dmp = new DiffMatchPatch();
        var lhString = this.state.value[0];
        var rhString = this.state.value[1];
        if (lhString.length === 0 && rhString.length === 0) {
            return [];
        }
        var diff = dmp.diff_main(lhString, rhString);
        dmp.diff_cleanupSemantic(diff);
        var diffedLines = this.generateDiffedLines(diff);
        var codeEditorSettings = this.setCodeMarkers(diffedLines);
        return codeEditorSettings;
    };
    DiffComponent.prototype.generateDiffedLines = function (diff) {
        var C = {
            DIFF_EQUAL: 0,
            DIFF_DELETE: -1,
            DIFF_INSERT: 1
        };
        var diffedLines = {
            left: [],
            right: []
        };
        var cursor = {
            left: 1,
            right: 1
        };
        diff.forEach(function (chunk) {
            var chunkType = chunk[0];
            var text = chunk[1];
            var lines = text.split("\n").length - 1;
            // diff-match-patch sometimes returns empty strings at random
            if (text.length === 0) {
                return;
            }
            var firstChar = text[0];
            var lastChar = text[text.length - 1];
            var linesToHighlight = 0;
            switch (chunkType) {
                case C.DIFF_EQUAL:
                    cursor.left += lines;
                    cursor.right += lines;
                    break;
                case C.DIFF_DELETE:
                    // If the deletion starts with a newline, push the cursor down to that line
                    if (firstChar === "\n") {
                        cursor.left++;
                        lines--;
                    }
                    linesToHighlight = lines;
                    // If the deletion does not include a newline, highlight the same line on the right
                    if (linesToHighlight === 0) {
                        diffedLines.right.push({
                            startLine: cursor.right,
                            endLine: cursor.right
                        });
                    }
                    // If the last character is a newline, we don't want to highlight that line
                    if (lastChar === "\n") {
                        linesToHighlight -= 1;
                    }
                    diffedLines.left.push({
                        startLine: cursor.left,
                        endLine: cursor.left + linesToHighlight
                    });
                    cursor.left += lines;
                    break;
                case C.DIFF_INSERT:
                    // If the insertion starts with a newline, push the cursor down to that line
                    if (firstChar === "\n") {
                        cursor.right++;
                        lines--;
                    }
                    linesToHighlight = lines;
                    // If the insertion does not include a newline, highlight the same line on the left
                    if (linesToHighlight === 0) {
                        diffedLines.left.push({
                            startLine: cursor.left,
                            endLine: cursor.left
                        });
                    }
                    // If the last character is a newline, we don't want to highlight that line
                    if (lastChar === "\n") {
                        linesToHighlight -= 1;
                    }
                    diffedLines.right.push({
                        startLine: cursor.right,
                        endLine: cursor.right + linesToHighlight
                    });
                    cursor.right += lines;
                    break;
                default:
                    throw new Error("Diff type was not defined.");
            }
        });
        return diffedLines;
    };
    // Receives a collection of line numbers and iterates through them to highlight appropriately
    // Returns an object that tells the render() method how to display the code editors
    DiffComponent.prototype.setCodeMarkers = function (diffedLines) {
        if (diffedLines === void 0) { diffedLines = { left: [], right: [] }; }
        var codeEditorSettings = [];
        var newMarkerSet = {
            left: [],
            right: []
        };
        for (var i = 0; i < diffedLines.left.length; i++) {
            var markerObj = {
                startRow: diffedLines.left[i].startLine - 1,
                endRow: diffedLines.left[i].endLine,
                type: "text",
                className: "codeMarker"
            };
            newMarkerSet.left.push(markerObj);
        }
        for (var i = 0; i < diffedLines.right.length; i++) {
            var markerObj = {
                startRow: diffedLines.right[i].startLine - 1,
                endRow: diffedLines.right[i].endLine,
                type: "text",
                className: "codeMarker"
            };
            newMarkerSet.right.push(markerObj);
        }
        codeEditorSettings[0] = newMarkerSet.left;
        codeEditorSettings[1] = newMarkerSet.right;
        return codeEditorSettings;
    };
    DiffComponent.prototype.render = function () {
        var markers = this.diff();
        return (React$z.createElement(split_1$1.default, { name: this.props.name, className: this.props.className, focus: this.props.focus, orientation: this.props.orientation, splits: this.props.splits, mode: this.props.mode, theme: this.props.theme, height: this.props.height, width: this.props.width, fontSize: this.props.fontSize, showGutter: this.props.showGutter, onChange: this.onChange, onPaste: this.props.onPaste, onLoad: this.props.onLoad, onScroll: this.props.onScroll, minLines: this.props.minLines, maxLines: this.props.maxLines, readOnly: this.props.readOnly, highlightActiveLine: this.props.highlightActiveLine, showPrintMargin: this.props.showPrintMargin, tabSize: this.props.tabSize, cursorStart: this.props.cursorStart, editorProps: this.props.editorProps, style: this.props.style, scrollMargin: this.props.scrollMargin, setOptions: this.props.setOptions, wrapEnabled: this.props.wrapEnabled, enableBasicAutocompletion: this.props.enableBasicAutocompletion, enableLiveAutocompletion: this.props.enableLiveAutocompletion, value: this.state.value, markers: markers }));
    };
    DiffComponent.propTypes = {
        cursorStart: PropTypes.number,
        editorProps: PropTypes.object,
        enableBasicAutocompletion: PropTypes.bool,
        enableLiveAutocompletion: PropTypes.bool,
        focus: PropTypes.bool,
        fontSize: PropTypes.number,
        height: PropTypes.string,
        highlightActiveLine: PropTypes.bool,
        maxLines: PropTypes.number,
        minLines: PropTypes.number,
        mode: PropTypes.string,
        name: PropTypes.string,
        className: PropTypes.string,
        onLoad: PropTypes.func,
        onPaste: PropTypes.func,
        onScroll: PropTypes.func,
        onChange: PropTypes.func,
        orientation: PropTypes.string,
        readOnly: PropTypes.bool,
        scrollMargin: PropTypes.array,
        setOptions: PropTypes.object,
        showGutter: PropTypes.bool,
        showPrintMargin: PropTypes.bool,
        splits: PropTypes.number,
        style: PropTypes.object,
        tabSize: PropTypes.number,
        theme: PropTypes.string,
        value: PropTypes.array,
        width: PropTypes.string,
        wrapEnabled: PropTypes.bool
    };
    DiffComponent.defaultProps = {
        cursorStart: 1,
        editorProps: {},
        enableBasicAutocompletion: false,
        enableLiveAutocompletion: false,
        focus: false,
        fontSize: 12,
        height: "500px",
        highlightActiveLine: true,
        maxLines: null,
        minLines: null,
        mode: "",
        name: "ace-editor",
        onLoad: null,
        onScroll: null,
        onPaste: null,
        onChange: null,
        orientation: "beside",
        readOnly: false,
        scrollMargin: [0, 0, 0, 0],
        setOptions: {},
        showGutter: true,
        showPrintMargin: true,
        splits: 2,
        style: {},
        tabSize: 4,
        theme: "github",
        value: ["", ""],
        width: "500px",
        wrapEnabled: true
    };
    return DiffComponent;
}(React$z.Component));
diff.default = DiffComponent;

Object.defineProperty(lib, "__esModule", { value: true });
lib.diff = lib.split = void 0;
var ace_1 = ace$4;
var diff_1 = diff;
lib.diff = diff_1.default;
var split_1 = split;
lib.split = split_1.default;
var _default = lib.default = ace_1.default;

var modeJson = {exports: {}};

(function (module, exports) {
	ace.define("ace/mode/json_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"],function(e,t,n){var r=e("../lib/oop"),i=e("./text_highlight_rules").TextHighlightRules,s=function(){this.$rules={start:[{token:"variable",regex:'["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'},{token:"string",regex:'"',next:"string"},{token:"constant.numeric",regex:"0[xX][0-9a-fA-F]+\\b"},{token:"constant.numeric",regex:"[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"},{token:"constant.language.boolean",regex:"(?:true|false)\\b"},{token:"text",regex:"['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"},{token:"comment",regex:"\\/\\/.*$"},{token:"comment.start",regex:"\\/\\*",next:"comment"},{token:"paren.lparen",regex:"[[({]"},{token:"paren.rparen",regex:"[\\])}]"},{token:"punctuation.operator",regex:/[,]/},{token:"text",regex:"\\s+"}],string:[{token:"constant.language.escape",regex:/\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/},{token:"string",regex:'"|$',next:"start"},{defaultToken:"string"}],comment:[{token:"comment.end",regex:"\\*\\/",next:"start"},{defaultToken:"comment"}]};};r.inherits(s,i),t.JsonHighlightRules=s;}),ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"],function(e,t,n){var r=e("../range").Range,i=function(){};((function(){this.checkOutdent=function(e,t){return /^\s+$/.test(e)?/^\s*\}/.test(t):false},this.autoOutdent=function(e,t){var n=e.getLine(t),i=n.match(/^(\s*\})/);if(!i)return 0;var s=i[1].length,o=e.findMatchingBracket({row:t,column:s});if(!o||o.row==t)return 0;var u=this.$getIndent(e.getLine(o.row));e.replace(new r(t,0,t,s-1),u);},this.$getIndent=function(e){return e.match(/^\s*/)[0]};})).call(i.prototype),t.MatchingBraceOutdent=i;}),ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"],function(e,t,n){var r=e("../../lib/oop"),i=e("../../range").Range,s=e("./fold_mode").FoldMode,o=t.FoldMode=function(e){e&&(this.foldingStartMarker=new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/,"|"+e.start)),this.foldingStopMarker=new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/,"|"+e.end)));};r.inherits(o,s),function(){this.foldingStartMarker=/([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/,this.foldingStopMarker=/^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/,this.singleLineBlockCommentRe=/^\s*(\/\*).*\*\/\s*$/,this.tripleStarBlockCommentRe=/^\s*(\/\*\*\*).*\*\/\s*$/,this.startRegionRe=/^\s*(\/\*|\/\/)#?region\b/,this._getFoldWidgetBase=this.getFoldWidget,this.getFoldWidget=function(e,t,n){var r=e.getLine(n);if(this.singleLineBlockCommentRe.test(r)&&!this.startRegionRe.test(r)&&!this.tripleStarBlockCommentRe.test(r))return "";var i=this._getFoldWidgetBase(e,t,n);return !i&&this.startRegionRe.test(r)?"start":i},this.getFoldWidgetRange=function(e,t,n,r){var i=e.getLine(n);if(this.startRegionRe.test(i))return this.getCommentRegionBlock(e,i,n);var s=i.match(this.foldingStartMarker);if(s){var o=s.index;if(s[1])return this.openingBracketBlock(e,s[1],n,o);var u=e.getCommentFoldRange(n,o+s[0].length,1);return u&&!u.isMultiLine()&&(r?u=this.getSectionRange(e,n):t!="all"&&(u=null)),u}if(t==="markbegin")return;var s=i.match(this.foldingStopMarker);if(s){var o=s.index+s[0].length;return s[1]?this.closingBracketBlock(e,s[1],n,o):e.getCommentFoldRange(n,o,-1)}},this.getSectionRange=function(e,t){var n=e.getLine(t),r=n.search(/\S/),s=t,o=n.length;t+=1;var u=t,a=e.getLength();while(++t<a){n=e.getLine(t);var f=n.search(/\S/);if(f===-1)continue;if(r>f)break;var l=this.getFoldWidgetRange(e,"all",t);if(l){if(l.start.row<=s)break;if(l.isMultiLine())t=l.end.row;else if(r==f)break}u=t;}return new i(s,o,u,e.getLine(u).length)},this.getCommentRegionBlock=function(e,t,n){var r=t.search(/\s*$/),s=e.getLength(),o=n,u=/^\s*(?:\/\*|\/\/|--)#?(end)?region\b/,a=1;while(++n<s){t=e.getLine(n);var f=u.exec(t);if(!f)continue;f[1]?a--:a++;if(!a)break}var l=n;if(l>o)return new i(o,r,l,t.length)};}.call(o.prototype);}),ace.define("ace/mode/json",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/json_highlight_rules","ace/mode/matching_brace_outdent","ace/mode/folding/cstyle","ace/worker/worker_client"],function(e,t,n){var r=e("../lib/oop"),i=e("./text").Mode,s=e("./json_highlight_rules").JsonHighlightRules,o=e("./matching_brace_outdent").MatchingBraceOutdent,u=e("./folding/cstyle").FoldMode,a=e("../worker/worker_client").WorkerClient,f=function(){this.HighlightRules=s,this.$outdent=new o,this.$behaviour=this.$defaultBehaviour,this.foldingRules=new u;};r.inherits(f,i),function(){this.lineCommentStart="//",this.blockComment={start:"/*",end:"*/"},this.getNextLineIndent=function(e,t,n){var r=this.$getIndent(t);if(e=="start"){var i=t.match(/^.*[\{\(\[]\s*$/);i&&(r+=n);}return r},this.checkOutdent=function(e,t,n){return this.$outdent.checkOutdent(t,n)},this.autoOutdent=function(e,t,n){this.$outdent.autoOutdent(t,n);},this.createWorker=function(e){var t=new a(["ace"],"ace/mode/json_worker","JsonWorker");return t.attachToDocument(e.getDocument()),t.on("annotate",function(t){e.setAnnotations(t.data);}),t.on("terminate",function(){e.clearAnnotations();}),t},this.$id="ace/mode/json";}.call(f.prototype),t.Mode=f;});                (function() {
	                    ace.require(["ace/mode/json"], function(m) {
	                        if (module) {
	                            module.exports = m;
	                        }
	                    });
	                })(); 
} (modeJson));

var modeJson5 = {exports: {}};

(function (module, exports) {
	ace.define("ace/mode/json_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"],function(e,t,n){var r=e("../lib/oop"),i=e("./text_highlight_rules").TextHighlightRules,s=function(){this.$rules={start:[{token:"variable",regex:'["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'},{token:"string",regex:'"',next:"string"},{token:"constant.numeric",regex:"0[xX][0-9a-fA-F]+\\b"},{token:"constant.numeric",regex:"[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"},{token:"constant.language.boolean",regex:"(?:true|false)\\b"},{token:"text",regex:"['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"},{token:"comment",regex:"\\/\\/.*$"},{token:"comment.start",regex:"\\/\\*",next:"comment"},{token:"paren.lparen",regex:"[[({]"},{token:"paren.rparen",regex:"[\\])}]"},{token:"punctuation.operator",regex:/[,]/},{token:"text",regex:"\\s+"}],string:[{token:"constant.language.escape",regex:/\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/},{token:"string",regex:'"|$',next:"start"},{defaultToken:"string"}],comment:[{token:"comment.end",regex:"\\*\\/",next:"start"},{defaultToken:"comment"}]};};r.inherits(s,i),t.JsonHighlightRules=s;}),ace.define("ace/mode/json5_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/json_highlight_rules"],function(e,t,n){var r=e("../lib/oop"),i=e("./json_highlight_rules").JsonHighlightRules,s=function(){i.call(this);var e=[{token:"variable",regex:/[a-zA-Z$_\u00a1-\uffff][\w$\u00a1-\uffff]*\s*(?=:)/},{token:"variable",regex:/['](?:(?:\\.)|(?:[^'\\]))*?[']\s*(?=:)/},{token:"constant.language.boolean",regex:/(?:null)\b/},{token:"string",regex:/'/,next:[{token:"constant.language.escape",regex:/\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\/bfnrt]|$)/,consumeLineEnd:true},{token:"string",regex:/'|$/,next:"start"},{defaultToken:"string"}]},{token:"string",regex:/"(?![^"]*":)/,next:[{token:"constant.language.escape",regex:/\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\/bfnrt]|$)/,consumeLineEnd:true},{token:"string",regex:/"|$/,next:"start"},{defaultToken:"string"}]},{token:"constant.numeric",regex:/[+-]?(?:Infinity|NaN)\b/}];for(var t in this.$rules)this.$rules[t].unshift.apply(this.$rules[t],e);this.normalizeRules();};r.inherits(s,i),t.Json5HighlightRules=s;}),ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"],function(e,t,n){var r=e("../range").Range,i=function(){};((function(){this.checkOutdent=function(e,t){return /^\s+$/.test(e)?/^\s*\}/.test(t):false},this.autoOutdent=function(e,t){var n=e.getLine(t),i=n.match(/^(\s*\})/);if(!i)return 0;var s=i[1].length,o=e.findMatchingBracket({row:t,column:s});if(!o||o.row==t)return 0;var u=this.$getIndent(e.getLine(o.row));e.replace(new r(t,0,t,s-1),u);},this.$getIndent=function(e){return e.match(/^\s*/)[0]};})).call(i.prototype),t.MatchingBraceOutdent=i;}),ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"],function(e,t,n){var r=e("../../lib/oop"),i=e("../../range").Range,s=e("./fold_mode").FoldMode,o=t.FoldMode=function(e){e&&(this.foldingStartMarker=new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/,"|"+e.start)),this.foldingStopMarker=new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/,"|"+e.end)));};r.inherits(o,s),function(){this.foldingStartMarker=/([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/,this.foldingStopMarker=/^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/,this.singleLineBlockCommentRe=/^\s*(\/\*).*\*\/\s*$/,this.tripleStarBlockCommentRe=/^\s*(\/\*\*\*).*\*\/\s*$/,this.startRegionRe=/^\s*(\/\*|\/\/)#?region\b/,this._getFoldWidgetBase=this.getFoldWidget,this.getFoldWidget=function(e,t,n){var r=e.getLine(n);if(this.singleLineBlockCommentRe.test(r)&&!this.startRegionRe.test(r)&&!this.tripleStarBlockCommentRe.test(r))return "";var i=this._getFoldWidgetBase(e,t,n);return !i&&this.startRegionRe.test(r)?"start":i},this.getFoldWidgetRange=function(e,t,n,r){var i=e.getLine(n);if(this.startRegionRe.test(i))return this.getCommentRegionBlock(e,i,n);var s=i.match(this.foldingStartMarker);if(s){var o=s.index;if(s[1])return this.openingBracketBlock(e,s[1],n,o);var u=e.getCommentFoldRange(n,o+s[0].length,1);return u&&!u.isMultiLine()&&(r?u=this.getSectionRange(e,n):t!="all"&&(u=null)),u}if(t==="markbegin")return;var s=i.match(this.foldingStopMarker);if(s){var o=s.index+s[0].length;return s[1]?this.closingBracketBlock(e,s[1],n,o):e.getCommentFoldRange(n,o,-1)}},this.getSectionRange=function(e,t){var n=e.getLine(t),r=n.search(/\S/),s=t,o=n.length;t+=1;var u=t,a=e.getLength();while(++t<a){n=e.getLine(t);var f=n.search(/\S/);if(f===-1)continue;if(r>f)break;var l=this.getFoldWidgetRange(e,"all",t);if(l){if(l.start.row<=s)break;if(l.isMultiLine())t=l.end.row;else if(r==f)break}u=t;}return new i(s,o,u,e.getLine(u).length)},this.getCommentRegionBlock=function(e,t,n){var r=t.search(/\s*$/),s=e.getLength(),o=n,u=/^\s*(?:\/\*|\/\/|--)#?(end)?region\b/,a=1;while(++n<s){t=e.getLine(n);var f=u.exec(t);if(!f)continue;f[1]?a--:a++;if(!a)break}var l=n;if(l>o)return new i(o,r,l,t.length)};}.call(o.prototype);}),ace.define("ace/mode/json5",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/json5_highlight_rules","ace/mode/matching_brace_outdent","ace/mode/folding/cstyle"],function(e,t,n){var r=e("../lib/oop"),i=e("./text").Mode,s=e("./json5_highlight_rules").Json5HighlightRules,o=e("./matching_brace_outdent").MatchingBraceOutdent,u=e("./folding/cstyle").FoldMode,a=function(){this.HighlightRules=s,this.$outdent=new o,this.$behaviour=this.$defaultBehaviour,this.foldingRules=new u;};r.inherits(a,i),function(){this.lineCommentStart="//",this.blockComment={start:"/*",end:"*/"},this.checkOutdent=function(e,t,n){return this.$outdent.checkOutdent(t,n)},this.autoOutdent=function(e,t,n){this.$outdent.autoOutdent(t,n);},this.$id="ace/mode/json5";}.call(a.prototype),t.Mode=a;});                (function() {
	                    ace.require(["ace/mode/json5"], function(m) {
	                        if (module) {
	                            module.exports = m;
	                        }
	                    });
	                })(); 
} (modeJson5));

!function(e){function t(e,t){var n=e,r="";while(n){var i=t[n];if(typeof i=="string")return i+r;if(i)return i.location.replace(/\/*$/,"/")+(r||i.main||i.name);if(i===false)return "";var s=n.lastIndexOf("/");if(s===-1)break;r=n.substr(s)+r,n=n.slice(0,s);}return e}if(typeof e.window!="undefined"&&e.document)return;if(e.require&&e.define)return;e.console||(e.console=function(){var e=Array.prototype.slice.call(arguments,0);postMessage({type:"log",data:e});},e.console.error=e.console.warn=e.console.log=e.console.trace=e.console),e.window=e,e.ace=e,e.onerror=function(e,t,n,r,i){postMessage({type:"error",data:{message:e,data:i&&i.data,file:t,line:n,col:r,stack:i&&i.stack}});},e.normalizeModule=function(t,n){if(n.indexOf("!")!==-1){var r=n.split("!");return e.normalizeModule(t,r[0])+"!"+e.normalizeModule(t,r[1])}if(n.charAt(0)=="."){var i=t.split("/").slice(0,-1).join("/");n=(i?i+"/":"")+n;while(n.indexOf(".")!==-1&&s!=n){var s=n;n=n.replace(/^\.\//,"").replace(/\/\.\//,"/").replace(/[^\/]+\/\.\.\//,"");}}return n},e.require=function(r,i){i||(i=r,r=null);if(!i.charAt)throw new Error("worker.js require() accepts only (parentId, id) as arguments");i=e.normalizeModule(r,i);var s=e.require.modules[i];if(s)return s.initialized||(s.initialized=true,s.exports=s.factory().exports),s.exports;if(!e.require.tlns)return console.log("unable to load "+i);var o=t(i,e.require.tlns);return o.slice(-3)!=".js"&&(o+=".js"),e.require.id=i,e.require.modules[i]={},importScripts(o),e.require(r,i)},e.require.modules={},e.require.tlns={},e.define=function(t,n,r){arguments.length==2?(r=n,typeof t!="string"&&(n=t,t=e.require.id)):arguments.length==1&&(r=t,n=[],t=e.require.id);if(typeof r!="function"){e.require.modules[t]={exports:r,initialized:true};return}n.length||(n=["require","exports","module"]);var i=function(n){return e.require(t,n)};e.require.modules[t]={exports:{},factory:function(){var e=this,t=r.apply(this,n.slice(0,r.length).map(function(t){switch(t){case "require":return i;case "exports":return e.exports;case "module":return e;default:return i(t)}}));return t&&(e.exports=t),e}};},e.define.amd={},e.require.tlns={},e.initBaseUrls=function(t){for(var n in t)this.require.tlns[n]=t[n];},e.initSender=function(){var n=e.require("ace/lib/event_emitter").EventEmitter,r=e.require("ace/lib/oop"),i=function(){};return function(){r.implement(this,n),this.callback=function(e,t){postMessage({type:"call",id:t,data:e});},this.emit=function(e,t){postMessage({type:"event",name:e,data:t});};}.call(i.prototype),new i};var n=e.main=null,r=e.sender=null;e.onmessage=function(t){var i=t.data;if(i.event&&r)r._signal(i.event,i.data);else if(i.command)if(n[i.command])n[i.command].apply(n,i.args);else {if(!e[i.command])throw new Error("Unknown command:"+i.command);e[i.command].apply(e,i.args);}else if(i.init){e.initBaseUrls(i.tlns),r=e.sender=e.initSender();var s=this.require(i.module)[i.classname];n=e.main=new s(r);}};}(commonjsGlobal),ace.define("ace/lib/oop",[],function(e,t,n){t.inherits=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:false,writable:true,configurable:true}});},t.mixin=function(e,t){for(var n in t)e[n]=t[n];return e},t.implement=function(e,n){t.mixin(e,n);};}),ace.define("ace/apply_delta",[],function(e,t,n){t.applyDelta=function(e,t,n){var r=t.start.row,i=t.start.column,s=e[r]||"";switch(t.action){case "insert":var o=t.lines;if(o.length===1)e[r]=s.substring(0,i)+t.lines[0]+s.substring(i);else {var u=[r,1].concat(t.lines);e.splice.apply(e,u),e[r]=s.substring(0,i)+e[r],e[r+t.lines.length-1]+=s.substring(i);}break;case "remove":var a=t.end.column,f=t.end.row;r===f?e[r]=s.substring(0,i)+s.substring(a):e.splice(r,f-r+1,s.substring(0,i)+e[f].substring(a));}};}),ace.define("ace/lib/event_emitter",[],function(e,t,n){var r={},i=function(){this.propagationStopped=true;},s=function(){this.defaultPrevented=true;};r._emit=r._dispatchEvent=function(e,t){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var n=this._eventRegistry[e]||[],r=this._defaultHandlers[e];if(!n.length&&!r)return;if(typeof t!="object"||!t)t={};t.type||(t.type=e),t.stopPropagation||(t.stopPropagation=i),t.preventDefault||(t.preventDefault=s),n=n.slice();for(var o=0;o<n.length;o++){n[o](t,this);if(t.propagationStopped)break}if(r&&!t.defaultPrevented)return r(t,this)},r._signal=function(e,t){var n=(this._eventRegistry||{})[e];if(!n)return;n=n.slice();for(var r=0;r<n.length;r++)n[r](t,this);},r.once=function(e,t){var n=this;this.on(e,function r(){n.off(e,r),t.apply(null,arguments);});if(!t)return new Promise(function(e){t=e;})},r.setDefaultHandler=function(e,t){var n=this._defaultHandlers;n||(n=this._defaultHandlers={_disabled_:{}});if(n[e]){var r=n[e],i=n._disabled_[e];i||(n._disabled_[e]=i=[]),i.push(r);var s=i.indexOf(t);s!=-1&&i.splice(s,1);}n[e]=t;},r.removeDefaultHandler=function(e,t){var n=this._defaultHandlers;if(!n)return;var r=n._disabled_[e];if(n[e]==t)r&&this.setDefaultHandler(e,r.pop());else if(r){var i=r.indexOf(t);i!=-1&&r.splice(i,1);}},r.on=r.addEventListener=function(e,t,n){this._eventRegistry=this._eventRegistry||{};var r=this._eventRegistry[e];return r||(r=this._eventRegistry[e]=[]),r.indexOf(t)==-1&&r[n?"unshift":"push"](t),t},r.off=r.removeListener=r.removeEventListener=function(e,t){this._eventRegistry=this._eventRegistry||{};var n=this._eventRegistry[e];if(!n)return;var r=n.indexOf(t);r!==-1&&n.splice(r,1);},r.removeAllListeners=function(e){e||(this._eventRegistry=this._defaultHandlers=undefined),this._eventRegistry&&(this._eventRegistry[e]=undefined),this._defaultHandlers&&(this._defaultHandlers[e]=undefined);},t.EventEmitter=r;}),ace.define("ace/range",[],function(e,t,n){var r=function(){function e(e,t,n,r){this.start={row:e,column:t},this.end={row:n,column:r};}return e.prototype.isEqual=function(e){return this.start.row===e.start.row&&this.end.row===e.end.row&&this.start.column===e.start.column&&this.end.column===e.end.column},e.prototype.toString=function(){return "Range: ["+this.start.row+"/"+this.start.column+"] -> ["+this.end.row+"/"+this.end.column+"]"},e.prototype.contains=function(e,t){return this.compare(e,t)==0},e.prototype.compareRange=function(e){var t,n=e.end,r=e.start;return t=this.compare(n.row,n.column),t==1?(t=this.compare(r.row,r.column),t==1?2:t==0?1:0):t==-1?-2:(t=this.compare(r.row,r.column),t==-1?-1:t==1?42:0)},e.prototype.comparePoint=function(e){return this.compare(e.row,e.column)},e.prototype.containsRange=function(e){return this.comparePoint(e.start)==0&&this.comparePoint(e.end)==0},e.prototype.intersects=function(e){var t=this.compareRange(e);return t==-1||t==0||t==1},e.prototype.isEnd=function(e,t){return this.end.row==e&&this.end.column==t},e.prototype.isStart=function(e,t){return this.start.row==e&&this.start.column==t},e.prototype.setStart=function(e,t){typeof e=="object"?(this.start.column=e.column,this.start.row=e.row):(this.start.row=e,this.start.column=t);},e.prototype.setEnd=function(e,t){typeof e=="object"?(this.end.column=e.column,this.end.row=e.row):(this.end.row=e,this.end.column=t);},e.prototype.inside=function(e,t){return this.compare(e,t)==0?this.isEnd(e,t)||this.isStart(e,t)?false:true:false},e.prototype.insideStart=function(e,t){return this.compare(e,t)==0?this.isEnd(e,t)?false:true:false},e.prototype.insideEnd=function(e,t){return this.compare(e,t)==0?this.isStart(e,t)?false:true:false},e.prototype.compare=function(e,t){return !this.isMultiLine()&&e===this.start.row?t<this.start.column?-1:t>this.end.column?1:0:e<this.start.row?-1:e>this.end.row?1:this.start.row===e?t>=this.start.column?0:-1:this.end.row===e?t<=this.end.column?0:1:0},e.prototype.compareStart=function(e,t){return this.start.row==e&&this.start.column==t?-1:this.compare(e,t)},e.prototype.compareEnd=function(e,t){return this.end.row==e&&this.end.column==t?1:this.compare(e,t)},e.prototype.compareInside=function(e,t){return this.end.row==e&&this.end.column==t?1:this.start.row==e&&this.start.column==t?-1:this.compare(e,t)},e.prototype.clipRows=function(t,n){if(this.end.row>n)var r={row:n+1,column:0};else if(this.end.row<t)var r={row:t,column:0};if(this.start.row>n)var i={row:n+1,column:0};else if(this.start.row<t)var i={row:t,column:0};return e.fromPoints(i||this.start,r||this.end)},e.prototype.extend=function(t,n){var r=this.compare(t,n);if(r==0)return this;if(r==-1)var i={row:t,column:n};else var s={row:t,column:n};return e.fromPoints(i||this.start,s||this.end)},e.prototype.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},e.prototype.isMultiLine=function(){return this.start.row!==this.end.row},e.prototype.clone=function(){return e.fromPoints(this.start,this.end)},e.prototype.collapseRows=function(){return this.end.column==0?new e(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new e(this.start.row,0,this.end.row,0)},e.prototype.toScreenRange=function(t){var n=t.documentToScreenPosition(this.start),r=t.documentToScreenPosition(this.end);return new e(n.row,n.column,r.row,r.column)},e.prototype.moveBy=function(e,t){this.start.row+=e,this.start.column+=t,this.end.row+=e,this.end.column+=t;},e}();r.fromPoints=function(e,t){return new r(e.row,e.column,t.row,t.column)},r.comparePoints=function(e,t){return e.row-t.row||e.column-t.column},t.Range=r;}),ace.define("ace/anchor",[],function(e,t,n){function o(e,t,n){var r=n?e.column<=t.column:e.column<t.column;return e.row<t.row||e.row==t.row&&r}function u(e,t,n){var r=e.action=="insert",i=(r?1:-1)*(e.end.row-e.start.row),s=(r?1:-1)*(e.end.column-e.start.column),u=e.start,a=r?u:e.end;return o(t,u,n)?{row:t.row,column:t.column}:o(a,t,!n)?{row:t.row+i,column:t.column+(t.row==a.row?s:0)}:{row:u.row,column:u.column}}var r=e("./lib/oop"),i=e("./lib/event_emitter").EventEmitter,s=function(){function e(e,t,n){this.$onChange=this.onChange.bind(this),this.attach(e),typeof t!="number"?this.setPosition(t.row,t.column):this.setPosition(t,n);}return e.prototype.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},e.prototype.getDocument=function(){return this.document},e.prototype.onChange=function(e){if(e.start.row==e.end.row&&e.start.row!=this.row)return;if(e.start.row>this.row)return;var t=u(e,{row:this.row,column:this.column},this.$insertRight);this.setPosition(t.row,t.column,true);},e.prototype.setPosition=function(e,t,n){var r;n?r={row:e,column:t}:r=this.$clipPositionToDocument(e,t);if(this.row==r.row&&this.column==r.column)return;var i={row:this.row,column:this.column};this.row=r.row,this.column=r.column,this._signal("change",{old:i,value:r});},e.prototype.detach=function(){this.document.off("change",this.$onChange);},e.prototype.attach=function(e){this.document=e||this.document,this.document.on("change",this.$onChange);},e.prototype.$clipPositionToDocument=function(e,t){var n={};return e>=this.document.getLength()?(n.row=Math.max(0,this.document.getLength()-1),n.column=this.document.getLine(n.row).length):e<0?(n.row=0,n.column=0):(n.row=e,n.column=Math.min(this.document.getLine(n.row).length,Math.max(0,t))),t<0&&(n.column=0),n},e}();s.prototype.$insertRight=false,r.implement(s.prototype,i),t.Anchor=s;}),ace.define("ace/document",[],function(e,t,n){var r=e("./lib/oop"),i=e("./apply_delta").applyDelta,s=e("./lib/event_emitter").EventEmitter,o=e("./range").Range,u=e("./anchor").Anchor,a=function(){function e(e){this.$lines=[""],e.length===0?this.$lines=[""]:Array.isArray(e)?this.insertMergedLines({row:0,column:0},e):this.insert({row:0,column:0},e);}return e.prototype.setValue=function(e){var t=this.getLength()-1;this.remove(new o(0,0,t,this.getLine(t).length)),this.insert({row:0,column:0},e||"");},e.prototype.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},e.prototype.createAnchor=function(e,t){return new u(this,e,t)},e.prototype.$detectNewLine=function(e){var t=e.match(/^.*?(\r\n|\r|\n)/m);this.$autoNewLine=t?t[1]:"\n",this._signal("changeNewLineMode");},e.prototype.getNewLineCharacter=function(){switch(this.$newLineMode){case "windows":return "\r\n";case "unix":return "\n";default:return this.$autoNewLine||"\n"}},e.prototype.setNewLineMode=function(e){if(this.$newLineMode===e)return;this.$newLineMode=e,this._signal("changeNewLineMode");},e.prototype.getNewLineMode=function(){return this.$newLineMode},e.prototype.isNewLine=function(e){return e=="\r\n"||e=="\r"||e=="\n"},e.prototype.getLine=function(e){return this.$lines[e]||""},e.prototype.getLines=function(e,t){return this.$lines.slice(e,t+1)},e.prototype.getAllLines=function(){return this.getLines(0,this.getLength())},e.prototype.getLength=function(){return this.$lines.length},e.prototype.getTextRange=function(e){return this.getLinesForRange(e).join(this.getNewLineCharacter())},e.prototype.getLinesForRange=function(e){var t;if(e.start.row===e.end.row)t=[this.getLine(e.start.row).substring(e.start.column,e.end.column)];else {t=this.getLines(e.start.row,e.end.row),t[0]=(t[0]||"").substring(e.start.column);var n=t.length-1;e.end.row-e.start.row==n&&(t[n]=t[n].substring(0,e.end.column));}return t},e.prototype.insertLines=function(e,t){return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."),this.insertFullLines(e,t)},e.prototype.removeLines=function(e,t){return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."),this.removeFullLines(e,t)},e.prototype.insertNewLine=function(e){return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead."),this.insertMergedLines(e,["",""])},e.prototype.insert=function(e,t){return this.getLength()<=1&&this.$detectNewLine(t),this.insertMergedLines(e,this.$split(t))},e.prototype.insertInLine=function(e,t){var n=this.clippedPos(e.row,e.column),r=this.pos(e.row,e.column+t.length);return this.applyDelta({start:n,end:r,action:"insert",lines:[t]},true),this.clonePos(r)},e.prototype.clippedPos=function(e,t){var n=this.getLength();e===undefined?e=n:e<0?e=0:e>=n&&(e=n-1,t=undefined);var r=this.getLine(e);return t==undefined&&(t=r.length),t=Math.min(Math.max(t,0),r.length),{row:e,column:t}},e.prototype.clonePos=function(e){return {row:e.row,column:e.column}},e.prototype.pos=function(e,t){return {row:e,column:t}},e.prototype.$clipPosition=function(e){var t=this.getLength();return e.row>=t?(e.row=Math.max(0,t-1),e.column=this.getLine(t-1).length):(e.row=Math.max(0,e.row),e.column=Math.min(Math.max(e.column,0),this.getLine(e.row).length)),e},e.prototype.insertFullLines=function(e,t){e=Math.min(Math.max(e,0),this.getLength());var n=0;e<this.getLength()?(t=t.concat([""]),n=0):(t=[""].concat(t),e--,n=this.$lines[e].length),this.insertMergedLines({row:e,column:n},t);},e.prototype.insertMergedLines=function(e,t){var n=this.clippedPos(e.row,e.column),r={row:n.row+t.length-1,column:(t.length==1?n.column:0)+t[t.length-1].length};return this.applyDelta({start:n,end:r,action:"insert",lines:t}),this.clonePos(r)},e.prototype.remove=function(e){var t=this.clippedPos(e.start.row,e.start.column),n=this.clippedPos(e.end.row,e.end.column);return this.applyDelta({start:t,end:n,action:"remove",lines:this.getLinesForRange({start:t,end:n})}),this.clonePos(t)},e.prototype.removeInLine=function(e,t,n){var r=this.clippedPos(e,t),i=this.clippedPos(e,n);return this.applyDelta({start:r,end:i,action:"remove",lines:this.getLinesForRange({start:r,end:i})},true),this.clonePos(r)},e.prototype.removeFullLines=function(e,t){e=Math.min(Math.max(0,e),this.getLength()-1),t=Math.min(Math.max(0,t),this.getLength()-1);var n=t==this.getLength()-1&&e>0,r=t<this.getLength()-1,i=n?e-1:e,s=n?this.getLine(i).length:0,u=r?t+1:t,a=r?0:this.getLine(u).length,f=new o(i,s,u,a),l=this.$lines.slice(e,t+1);return this.applyDelta({start:f.start,end:f.end,action:"remove",lines:this.getLinesForRange(f)}),l},e.prototype.removeNewLine=function(e){e<this.getLength()-1&&e>=0&&this.applyDelta({start:this.pos(e,this.getLine(e).length),end:this.pos(e+1,0),action:"remove",lines:["",""]});},e.prototype.replace=function(e,t){e instanceof o||(e=o.fromPoints(e.start,e.end));if(t.length===0&&e.isEmpty())return e.start;if(t==this.getTextRange(e))return e.end;this.remove(e);var n;return t?n=this.insert(e.start,t):n=e.start,n},e.prototype.applyDeltas=function(e){for(var t=0;t<e.length;t++)this.applyDelta(e[t]);},e.prototype.revertDeltas=function(e){for(var t=e.length-1;t>=0;t--)this.revertDelta(e[t]);},e.prototype.applyDelta=function(e,t){var n=e.action=="insert";if(n?e.lines.length<=1&&!e.lines[0]:!o.comparePoints(e.start,e.end))return;n&&e.lines.length>2e4?this.$splitAndapplyLargeDelta(e,2e4):(i(this.$lines,e,t),this._signal("change",e));},e.prototype.$safeApplyDelta=function(e){var t=this.$lines.length;(e.action=="remove"&&e.start.row<t&&e.end.row<t||e.action=="insert"&&e.start.row<=t)&&this.applyDelta(e);},e.prototype.$splitAndapplyLargeDelta=function(e,t){var n=e.lines,r=n.length-t+1,i=e.start.row,s=e.start.column;for(var o=0,u=0;o<r;o=u){u+=t-1;var a=n.slice(o,u);a.push(""),this.applyDelta({start:this.pos(i+o,s),end:this.pos(i+u,s=0),action:e.action,lines:a},true);}e.lines=n.slice(o),e.start.row=i+o,e.start.column=s,this.applyDelta(e,true);},e.prototype.revertDelta=function(e){this.$safeApplyDelta({start:this.clonePos(e.start),end:this.clonePos(e.end),action:e.action=="insert"?"remove":"insert",lines:e.lines.slice()});},e.prototype.indexToPosition=function(e,t){var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length;for(var i=t||0,s=n.length;i<s;i++){e-=n[i].length+r;if(e<0)return {row:i,column:e+n[i].length+r}}return {row:s-1,column:e+n[s-1].length+r}},e.prototype.positionToIndex=function(e,t){var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length,i=0,s=Math.min(e.row,n.length);for(var o=t||0;o<s;++o)i+=n[o].length+r;return i+e.column},e.prototype.$split=function(e){return e.split(/\r\n|\r|\n/)},e}();a.prototype.$autoNewLine="",a.prototype.$newLineMode="auto",r.implement(a.prototype,s),t.Document=a;}),ace.define("ace/lib/deep_copy",[],function(e,t,n){t.deepCopy=function r(e){if(typeof e!="object"||!e)return e;var t;if(Array.isArray(e)){t=[];for(var n=0;n<e.length;n++)t[n]=r(e[n]);return t}if(Object.prototype.toString.call(e)!=="[object Object]")return e;t={};for(var n in e)t[n]=r(e[n]);return t};}),ace.define("ace/lib/lang",[],function(e,t,n){t.last=function(e){return e[e.length-1]},t.stringReverse=function(e){return e.split("").reverse().join("")},t.stringRepeat=function(e,t){var n="";while(t>0){t&1&&(n+=e);if(t>>=1)e+=e;}return n};var r=/^\s\s*/,i=/\s\s*$/;t.stringTrimLeft=function(e){return e.replace(r,"")},t.stringTrimRight=function(e){return e.replace(i,"")},t.copyObject=function(e){var t={};for(var n in e)t[n]=e[n];return t},t.copyArray=function(e){var t=[];for(var n=0,r=e.length;n<r;n++)e[n]&&typeof e[n]=="object"?t[n]=this.copyObject(e[n]):t[n]=e[n];return t},t.deepCopy=e("./deep_copy").deepCopy,t.arrayToMap=function(e){var t={};for(var n=0;n<e.length;n++)t[e[n]]=1;return t},t.createMap=function(e){var t=Object.create(null);for(var n in e)t[n]=e[n];return t},t.arrayRemove=function(e,t){for(var n=0;n<=e.length;n++)t===e[n]&&e.splice(n,1);},t.escapeRegExp=function(e){return e.replace(/([.*+?^${}()|[\]\/\\])/g,"\\$1")},t.escapeHTML=function(e){return (""+e).replace(/&/g,"&#38;").replace(/"/g,"&#34;").replace(/'/g,"&#39;").replace(/</g,"&#60;")},t.getMatchOffsets=function(e,t){var n=[];return e.replace(t,function(e){n.push({offset:arguments[arguments.length-2],length:e.length});}),n},t.deferredCall=function(e){var t=null,n=function(){t=null,e();},r=function(e){return r.cancel(),t=setTimeout(n,e||0),r};return r.schedule=r,r.call=function(){return this.cancel(),e(),r},r.cancel=function(){return clearTimeout(t),t=null,r},r.isPending=function(){return t},r},t.delayedCall=function(e,t){var n=null,r=function(){n=null,e();},i=function(e){n==null&&(n=setTimeout(r,e||t));};return i.delay=function(e){n&&clearTimeout(n),n=setTimeout(r,e||t);},i.schedule=i,i.call=function(){this.cancel(),e();},i.cancel=function(){n&&clearTimeout(n),n=null;},i.isPending=function(){return n},i},t.supportsLookbehind=function(){try{new RegExp("(?<=.)");}catch(e){return  false}return  true},t.skipEmptyMatch=function(e,t,n){return n&&e.codePointAt(t)>65535?2:1};}),ace.define("ace/worker/mirror",[],function(e,t,n){var r=e("../document").Document,i=e("../lib/lang"),s=t.Mirror=function(e){this.sender=e;var t=this.doc=new r(""),n=this.deferredUpdate=i.delayedCall(this.onUpdate.bind(this)),s=this;e.on("change",function(e){var r=e.data;if(r[0].start)t.applyDeltas(r);else for(var i=0;i<r.length;i+=2){var o,u;Array.isArray(r[i+1])?o={action:"insert",start:r[i],lines:r[i+1]}:o={action:"remove",start:r[i],end:r[i+1]};if((o.action=="insert"?o.start:o.end).row>=t.$lines.length)throw u=new Error("Invalid delta"),u.data={path:s.$path,linesLength:t.$lines.length,start:o.start,end:o.end},u;t.applyDelta(o,true);}if(s.$timeout)return n.schedule(s.$timeout);s.onUpdate();});};(function(){this.$timeout=500,this.setTimeout=function(e){this.$timeout=e;},this.setValue=function(e){this.doc.setValue(e),this.deferredUpdate.schedule(this.$timeout);},this.getValue=function(e){this.sender.callback(this.doc.getValue(),e);},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()};}).call(s.prototype);}),ace.define("ace/mode/json/json_parse",[],function(e,t,n){var r,i,s={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"	"},o,u=function(e){throw {name:"SyntaxError",message:e,at:r,text:o}},a=function(e){return e&&e!==i&&u("Expected '"+e+"' instead of '"+i+"'"),i=o.charAt(r),r+=1,i},f=function(){var e,t="";i==="-"&&(t="-",a("-"));while(i>="0"&&i<="9")t+=i,a();if(i==="."){t+=".";while(a()&&i>="0"&&i<="9")t+=i;}if(i==="e"||i==="E"){t+=i,a();if(i==="-"||i==="+")t+=i,a();while(i>="0"&&i<="9")t+=i,a();}e=+t;if(!isNaN(e))return e;u("Bad number");},l=function(){var e,t,n="",r;if(i==='"')while(a()){if(i==='"')return a(),n;if(i==="\\"){a();if(i==="u"){r=0;for(t=0;t<4;t+=1){e=parseInt(a(),16);if(!isFinite(e))break;r=r*16+e;}n+=String.fromCharCode(r);}else {if(typeof s[i]!="string")break;n+=s[i];}}else {if(i=="\n"||i=="\r")break;n+=i;}}u("Bad string");},c=function(){while(i&&i<=" ")a();},h=function(){switch(i){case "t":return a("t"),a("r"),a("u"),a("e"),true;case "f":return a("f"),a("a"),a("l"),a("s"),a("e"),false;case "n":return a("n"),a("u"),a("l"),a("l"),null}u("Unexpected '"+i+"'");},p,d=function(){var e=[];if(i==="["){a("["),c();if(i==="]")return a("]"),e;while(i){e.push(p()),c();if(i==="]")return a("]"),e;a(","),c();}}u("Bad array");},v=function(){var e,t={};if(i==="{"){a("{"),c();if(i==="}")return a("}"),t;while(i){e=l(),c(),a(":"),Object.hasOwnProperty.call(t,e)&&u('Duplicate key "'+e+'"'),t[e]=p(),c();if(i==="}")return a("}"),t;a(","),c();}}u("Bad object");};return p=function(){c();switch(i){case "{":return v();case "[":return d();case '"':return l();case "-":return f();default:return i>="0"&&i<="9"?f():h()}},function(e,t){var n;return o=e,r=0,i=" ",n=p(),c(),i&&u("Syntax error"),typeof t=="function"?function s(e,n){var r,i,o=e[n];if(o&&typeof o=="object")for(r in o)Object.hasOwnProperty.call(o,r)&&(i=s(o,r),i!==undefined?o[r]=i:delete o[r]);return t.call(e,n,o)}({"":n},""):n}}),ace.define("ace/mode/json_worker",[],function(e,t,n){var r=e("../lib/oop"),i=e("../worker/mirror").Mirror,s=e("./json/json_parse"),o=t.JsonWorker=function(e){i.call(this,e),this.setTimeout(200);};r.inherits(o,i),function(){this.onUpdate=function(){var e=this.doc.getValue(),t=[];try{e&&s(e);}catch(n){var r=this.doc.indexToPosition(n.at-1);t.push({row:r.row,column:r.column,text:n.message,type:"error"});}this.sender.emit("annotate",t);};}.call(o.prototype);});

var themeClouds_midnight = {exports: {}};

(function (module, exports) {
	ace.define("ace/theme/clouds_midnight-css",["require","exports","module"],function(e,t,n){n.exports=".ace-clouds-midnight .ace_gutter {\n  background: #232323;\n  color: #929292\n}\n\n.ace-clouds-midnight .ace_print-margin {\n  width: 1px;\n  background: #232323\n}\n\n.ace-clouds-midnight {\n  background-color: #191919;\n  color: #929292\n}\n\n.ace-clouds-midnight .ace_cursor {\n  color: #7DA5DC\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_selection {\n  background: #000000\n}\n\n.ace-clouds-midnight.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #191919;\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #BFBFBF\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_active-line {\n  background: rgba(215, 215, 215, 0.031)\n}\n\n.ace-clouds-midnight .ace_gutter-active-line {\n  background-color: rgba(215, 215, 215, 0.031)\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_selected-word {\n  border: 1px solid #000000\n}\n\n.ace-clouds-midnight .ace_invisible {\n  color: #666\n}\n\n.ace-clouds-midnight .ace_keyword,\n.ace-clouds-midnight .ace_meta,\n.ace-clouds-midnight .ace_support.ace_constant.ace_property-value {\n  color: #927C5D\n}\n\n.ace-clouds-midnight .ace_keyword.ace_operator {\n  color: #4B4B4B\n}\n\n.ace-clouds-midnight .ace_keyword.ace_other.ace_unit {\n  color: #366F1A\n}\n\n.ace-clouds-midnight .ace_constant.ace_language {\n  color: #39946A\n}\n\n.ace-clouds-midnight .ace_constant.ace_numeric {\n  color: #46A609\n}\n\n.ace-clouds-midnight .ace_constant.ace_character.ace_entity {\n  color: #A165AC\n}\n\n.ace-clouds-midnight .ace_invalid {\n  color: #FFFFFF;\n  background-color: #E92E2E\n}\n\n.ace-clouds-midnight .ace_fold {\n  background-color: #927C5D;\n  border-color: #929292\n}\n\n.ace-clouds-midnight .ace_storage,\n.ace-clouds-midnight .ace_support.ace_class,\n.ace-clouds-midnight .ace_support.ace_function,\n.ace-clouds-midnight .ace_support.ace_other,\n.ace-clouds-midnight .ace_support.ace_type {\n  color: #E92E2E\n}\n\n.ace-clouds-midnight .ace_string {\n  color: #5D90CD\n}\n\n.ace-clouds-midnight .ace_comment {\n  color: #3C403B\n}\n\n.ace-clouds-midnight .ace_entity.ace_name.ace_tag,\n.ace-clouds-midnight .ace_entity.ace_other.ace_attribute-name {\n  color: #606060\n}\n\n.ace-clouds-midnight .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHB3d/8PAAOIAdULw8qMAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-clouds-midnight .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";}),ace.define("ace/theme/clouds_midnight",["require","exports","module","ace/theme/clouds_midnight-css","ace/lib/dom"],function(e,t,n){t.isDark=true,t.cssClass="ace-clouds-midnight",t.cssText=e("./clouds_midnight-css");var r=e("../lib/dom");r.importCssString(t.cssText,t.cssClass,false);});                (function() {
	                    ace.require(["ace/theme/clouds_midnight"], function(m) {
	                        if (module) {
	                            module.exports = m;
	                        }
	                    });
	                })(); 
} (themeClouds_midnight));

var themeChrome = {exports: {}};

(function (module, exports) {
	ace.define("ace/theme/chrome-css",["require","exports","module"],function(e,t,n){n.exports='.ace-chrome .ace_gutter {\n  background: #ebebeb;\n  color: #333;\n  overflow : hidden;\n}\n\n.ace-chrome .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-chrome {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-chrome .ace_cursor {\n  color: black;\n}\n\n.ace-chrome .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-chrome .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-chrome .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-chrome .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-chrome .ace_invalid {\n  background-color: rgb(153, 0, 0);\n  color: white;\n}\n\n.ace-chrome .ace_fold {\n}\n\n.ace-chrome .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-chrome .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-chrome .ace_support.ace_type,\n.ace-chrome .ace_support.ace_class\n.ace-chrome .ace_support.ace_other {\n  color: rgb(109, 121, 222);\n}\n\n.ace-chrome .ace_variable.ace_parameter {\n  font-style:italic;\n  color:#FD971F;\n}\n.ace-chrome .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-chrome .ace_comment {\n  color: #236e24;\n}\n\n.ace-chrome .ace_comment.ace_doc {\n  color: #236e24;\n}\n\n.ace-chrome .ace_comment.ace_doc.ace_tag {\n  color: #236e24;\n}\n\n.ace-chrome .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-chrome .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-chrome .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-chrome .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-chrome .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-chrome .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-chrome .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n\n.ace-chrome .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-chrome .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-chrome .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-chrome .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-chrome .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-chrome .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-chrome .ace_storage,\n.ace-chrome .ace_keyword,\n.ace-chrome .ace_meta.ace_tag {\n  color: rgb(147, 15, 128);\n}\n\n.ace-chrome .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-chrome .ace_string {\n  color: #1A1AA6;\n}\n\n.ace-chrome .ace_entity.ace_other.ace_attribute-name {\n  color: #994409;\n}\n\n.ace-chrome .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n  \n.ace-chrome .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';}),ace.define("ace/theme/chrome",["require","exports","module","ace/theme/chrome-css","ace/lib/dom"],function(e,t,n){t.isDark=false,t.cssClass="ace-chrome",t.cssText=e("./chrome-css");var r=e("../lib/dom");r.importCssString(t.cssText,t.cssClass,false);});                (function() {
	                    ace.require(["ace/theme/chrome"], function(m) {
	                        if (module) {
	                            module.exports = m;
	                        }
	                    });
	                })(); 
} (themeChrome));

var extLanguage_tools = {exports: {}};

(function (module, exports) {
	ace.define("ace/snippets",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event_emitter","ace/lib/lang","ace/range","ace/range_list","ace/keyboard/hash_handler","ace/tokenizer","ace/clipboard","ace/editor"],function(e,t,n){function p(e){var t=(new Date).toLocaleString("en-us",e);return t.length==1?"0"+t:t}var r=e("./lib/dom"),i=e("./lib/oop"),s=e("./lib/event_emitter").EventEmitter,o=e("./lib/lang"),u=e("./range").Range,a=e("./range_list").RangeList,f=e("./keyboard/hash_handler").HashHandler,l=e("./tokenizer").Tokenizer,c=e("./clipboard"),h={CURRENT_WORD:function(e){return e.session.getTextRange(e.session.getWordRange())},SELECTION:function(e,t,n){var r=e.session.getTextRange();return n?r.replace(/\n\r?([ \t]*\S)/g,"\n"+n+"$1"):r},CURRENT_LINE:function(e){return e.session.getLine(e.getCursorPosition().row)},PREV_LINE:function(e){return e.session.getLine(e.getCursorPosition().row-1)},LINE_INDEX:function(e){return e.getCursorPosition().row},LINE_NUMBER:function(e){return e.getCursorPosition().row+1},SOFT_TABS:function(e){return e.session.getUseSoftTabs()?"YES":"NO"},TAB_SIZE:function(e){return e.session.getTabSize()},CLIPBOARD:function(e){return c.getText&&c.getText()},FILENAME:function(e){return /[^/\\]*$/.exec(this.FILEPATH(e))[0]},FILENAME_BASE:function(e){return /[^/\\]*$/.exec(this.FILEPATH(e))[0].replace(/\.[^.]*$/,"")},DIRECTORY:function(e){return this.FILEPATH(e).replace(/[^/\\]*$/,"")},FILEPATH:function(e){return "/not implemented.txt"},WORKSPACE_NAME:function(){return "Unknown"},FULLNAME:function(){return "Unknown"},BLOCK_COMMENT_START:function(e){var t=e.session.$mode||{};return t.blockComment&&t.blockComment.start||""},BLOCK_COMMENT_END:function(e){var t=e.session.$mode||{};return t.blockComment&&t.blockComment.end||""},LINE_COMMENT:function(e){var t=e.session.$mode||{};return t.lineCommentStart||""},CURRENT_YEAR:p.bind(null,{year:"numeric"}),CURRENT_YEAR_SHORT:p.bind(null,{year:"2-digit"}),CURRENT_MONTH:p.bind(null,{month:"numeric"}),CURRENT_MONTH_NAME:p.bind(null,{month:"long"}),CURRENT_MONTH_NAME_SHORT:p.bind(null,{month:"short"}),CURRENT_DATE:p.bind(null,{day:"2-digit"}),CURRENT_DAY_NAME:p.bind(null,{weekday:"long"}),CURRENT_DAY_NAME_SHORT:p.bind(null,{weekday:"short"}),CURRENT_HOUR:p.bind(null,{hour:"2-digit",hour12:false}),CURRENT_MINUTE:p.bind(null,{minute:"2-digit"}),CURRENT_SECOND:p.bind(null,{second:"2-digit"})};h.SELECTED_TEXT=h.SELECTION;var d=function(){function e(){this.snippetMap={},this.snippetNameMap={},this.variables=h;}return e.prototype.getTokenizer=function(){return e.$tokenizer||this.createTokenizer()},e.prototype.createTokenizer=function(){function t(e){return e=e.substr(1),/^\d+$/.test(e)?[{tabstopId:parseInt(e,10)}]:[{text:e}]}function n(e){return "(?:[^\\\\"+e+"]|\\\\.)"}var r={regex:"/("+n("/")+"+)/",onMatch:function(e,t,n){var r=n[0];return r.fmtString=true,r.guard=e.slice(1,-1),r.flag="",""},next:"formatString"};return e.$tokenizer=new l({start:[{regex:/\\./,onMatch:function(e,t,n){var r=e[1];return r=="}"&&n.length?e=r:"`$\\".indexOf(r)!=-1&&(e=r),[e]}},{regex:/}/,onMatch:function(e,t,n){return [n.length?n.shift():e]}},{regex:/\$(?:\d+|\w+)/,onMatch:t},{regex:/\$\{[\dA-Z_a-z]+/,onMatch:function(e,n,r){var i=t(e.substr(1));return r.unshift(i[0]),i},next:"snippetVar"},{regex:/\n/,token:"newline",merge:false}],snippetVar:[{regex:"\\|"+n("\\|")+"*\\|",onMatch:function(e,t,n){var r=e.slice(1,-1).replace(/\\[,|\\]|,/g,function(e){return e.length==2?e[1]:"\0"}).split("\0").map(function(e){return {value:e}});return n[0].choices=r,[r[0]]},next:"start"},r,{regex:"([^:}\\\\]|\\\\.)*:?",token:"",next:"start"}],formatString:[{regex:/:/,onMatch:function(e,t,n){return n.length&&n[0].expectElse?(n[0].expectElse=false,n[0].ifEnd={elseEnd:n[0]},[n[0].ifEnd]):":"}},{regex:/\\./,onMatch:function(e,t,n){var r=e[1];return r=="}"&&n.length?e=r:"`$\\".indexOf(r)!=-1?e=r:r=="n"?e="\n":r=="t"?e="	":"ulULE".indexOf(r)!=-1&&(e={changeCase:r,local:r>"a"}),[e]}},{regex:"/\\w*}",onMatch:function(e,t,n){var r=n.shift();return r&&(r.flag=e.slice(1,-1)),this.next=r&&r.tabstopId?"start":"",[r||e]},next:"start"},{regex:/\$(?:\d+|\w+)/,onMatch:function(e,t,n){return [{text:e.slice(1)}]}},{regex:/\${\w+/,onMatch:function(e,t,n){var r={text:e.slice(2)};return n.unshift(r),[r]},next:"formatStringVar"},{regex:/\n/,token:"newline",merge:false},{regex:/}/,onMatch:function(e,t,n){var r=n.shift();return this.next=r&&r.tabstopId?"start":"",[r||e]},next:"start"}],formatStringVar:[{regex:/:\/\w+}/,onMatch:function(e,t,n){var r=n[0];return r.formatFunction=e.slice(2,-1),[n.shift()]},next:"formatString"},r,{regex:/:[\?\-+]?/,onMatch:function(e,t,n){e[1]=="+"&&(n[0].ifEnd=n[0]),e[1]=="?"&&(n[0].expectElse=true);},next:"formatString"},{regex:"([^:}\\\\]|\\\\.)*:?",token:"",next:"formatString"}]}),e.$tokenizer},e.prototype.tokenizeTmSnippet=function(e,t){return this.getTokenizer().getLineTokens(e,t).tokens.map(function(e){return e.value||e})},e.prototype.getVariableValue=function(e,t,n){if(/^\d+$/.test(t))return (this.variables.__||{})[t]||"";if(/^[A-Z]\d+$/.test(t))return (this.variables[t[0]+"__"]||{})[t.substr(1)]||"";t=t.replace(/^TM_/,"");if(!this.variables.hasOwnProperty(t))return "";var r=this.variables[t];return typeof r=="function"&&(r=this.variables[t](e,t,n)),r==null?"":r},e.prototype.tmStrFormat=function(e,t,n){if(!t.fmt)return e;var r=t.flag||"",i=t.guard;i=new RegExp(i,r.replace(/[^gim]/g,""));var s=typeof t.fmt=="string"?this.tokenizeTmSnippet(t.fmt,"formatString"):t.fmt,o=this,u=e.replace(i,function(){var e=o.variables.__;o.variables.__=[].slice.call(arguments);var t=o.resolveVariables(s,n),r="E";for(var i=0;i<t.length;i++){var u=t[i];if(typeof u=="object"){t[i]="";if(u.changeCase&&u.local){var a=t[i+1];a&&typeof a=="string"&&(u.changeCase=="u"?t[i]=a[0].toUpperCase():t[i]=a[0].toLowerCase(),t[i+1]=a.substr(1));}else u.changeCase&&(r=u.changeCase);}else r=="U"?t[i]=u.toUpperCase():r=="L"&&(t[i]=u.toLowerCase());}return o.variables.__=e,t.join("")});return u},e.prototype.tmFormatFunction=function(e,t,n){return t.formatFunction=="upcase"?e.toUpperCase():t.formatFunction=="downcase"?e.toLowerCase():e},e.prototype.resolveVariables=function(e,t){function f(t){var n=e.indexOf(t,s+1);n!=-1&&(s=n);}var n=[],r="",i=true;for(var s=0;s<e.length;s++){var o=e[s];if(typeof o=="string"){n.push(o),o=="\n"?(i=true,r=""):i&&(r=/^\t*/.exec(o)[0],i=/\S/.test(o));continue}if(!o)continue;i=false;if(o.fmtString){var u=e.indexOf(o,s+1);u==-1&&(u=e.length),o.fmt=e.slice(s+1,u),s=u;}if(o.text){var a=this.getVariableValue(t,o.text,r)+"";o.fmtString&&(a=this.tmStrFormat(a,o,t)),o.formatFunction&&(a=this.tmFormatFunction(a,o,t)),a&&!o.ifEnd?(n.push(a),f(o)):!a&&o.ifEnd&&f(o.ifEnd);}else o.elseEnd?f(o.elseEnd):o.tabstopId!=null?n.push(o):o.changeCase!=null&&n.push(o);}return n},e.prototype.getDisplayTextForSnippet=function(e,t){var n=v.call(this,e,t);return n.text},e.prototype.insertSnippetForSelection=function(e,t,n){n===void 0&&(n={});var r=v.call(this,e,t,n),i=e.getSelectionRange(),s=e.session.replace(i,r.text),o=new m(e),u=e.inVirtualSelectionMode&&e.selection.index;o.addTabstops(r.tabstops,i.start,s,u);},e.prototype.insertSnippet=function(e,t,n){n===void 0&&(n={});var r=this;if(e.inVirtualSelectionMode)return r.insertSnippetForSelection(e,t,n);e.forEachSelection(function(){r.insertSnippetForSelection(e,t,n);},null,{keepOrder:true}),e.tabstopManager&&e.tabstopManager.tabNext();},e.prototype.$getScope=function(e){var t=e.session.$mode.$id||"";t=t.split("/").pop();if(t==="html"||t==="php"){t==="php"&&!e.session.$mode.inlinePhp&&(t="html");var n=e.getCursorPosition(),r=e.session.getState(n.row);typeof r=="object"&&(r=r[0]),r.substring&&(r.substring(0,3)=="js-"?t="javascript":r.substring(0,4)=="css-"?t="css":r.substring(0,4)=="php-"&&(t="php"));}return t},e.prototype.getActiveScopes=function(e){var t=this.$getScope(e),n=[t],r=this.snippetMap;return r[t]&&r[t].includeScopes&&n.push.apply(n,r[t].includeScopes),n.push("_"),n},e.prototype.expandWithTab=function(e,t){var n=this,r=e.forEachSelection(function(){return n.expandSnippetForSelection(e,t)},null,{keepOrder:true});return r&&e.tabstopManager&&e.tabstopManager.tabNext(),r},e.prototype.expandSnippetForSelection=function(e,t){var n=e.getCursorPosition(),r=e.session.getLine(n.row),i=r.substring(0,n.column),s=r.substr(n.column),o=this.snippetMap,u;return this.getActiveScopes(e).some(function(e){var t=o[e];return t&&(u=this.findMatchingSnippet(t,i,s)),!!u},this),u?t&&t.dryRun?true:(e.session.doc.removeInLine(n.row,n.column-u.replaceBefore.length,n.column+u.replaceAfter.length),this.variables.M__=u.matchBefore,this.variables.T__=u.matchAfter,this.insertSnippetForSelection(e,u.content),this.variables.M__=this.variables.T__=null,true):false},e.prototype.findMatchingSnippet=function(e,t,n){for(var r=e.length;r--;){var i=e[r];if(i.startRe&&!i.startRe.test(t))continue;if(i.endRe&&!i.endRe.test(n))continue;if(!i.startRe&&!i.endRe)continue;return i.matchBefore=i.startRe?i.startRe.exec(t):[""],i.matchAfter=i.endRe?i.endRe.exec(n):[""],i.replaceBefore=i.triggerRe?i.triggerRe.exec(t)[0]:"",i.replaceAfter=i.endTriggerRe?i.endTriggerRe.exec(n)[0]:"",i}},e.prototype.register=function(e,t){function s(e){return e&&!/^\^?\(.*\)\$?$|^\\b$/.test(e)&&(e="(?:"+e+")"),e||""}function u(e,t,n){return e=s(e),t=s(t),(e=t+e,e&&e[e.length-1]!="$"&&(e+="$")),new RegExp(e)}function a(e){e.scope||(e.scope=t||"_"),t=e.scope,n[t]||(n[t]=[],r[t]={});var s=r[t];if(e.name){var a=s[e.name];a&&i.unregister(a),s[e.name]=e;}n[t].push(e),e.prefix&&(e.tabTrigger=e.prefix),!e.content&&e.body&&(e.content=Array.isArray(e.body)?e.body.join("\n"):e.body),e.tabTrigger&&!e.trigger&&(!e.guard&&/^\w/.test(e.tabTrigger)&&(e.guard="\\b"),e.trigger=o.escapeRegExp(e.tabTrigger));if(!e.trigger&&!e.guard&&!e.endTrigger&&!e.endGuard)return;e.startRe=u(e.trigger,e.guard),e.triggerRe=new RegExp(e.trigger),e.endRe=u(e.endTrigger,e.endGuard),e.endTriggerRe=new RegExp(e.endTrigger);}var n=this.snippetMap,r=this.snippetNameMap,i=this;e||(e=[]),Array.isArray(e)?e.forEach(a):Object.keys(e).forEach(function(t){a(e[t]);}),this._signal("registerSnippets",{scope:t});},e.prototype.unregister=function(e,t){function i(e){var i=r[e.scope||t];if(i&&i[e.name]){delete i[e.name];var s=n[e.scope||t],o=s&&s.indexOf(e);o>=0&&s.splice(o,1);}}var n=this.snippetMap,r=this.snippetNameMap;e.content?i(e):Array.isArray(e)&&e.forEach(i);},e.prototype.parseSnippetFile=function(e){e=e.replace(/\r/g,"");var t=[],n={},r=/^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm,i;while(i=r.exec(e)){if(i[1])try{n=JSON.parse(i[1]),t.push(n);}catch(s){}if(i[4])n.content=i[4].replace(/^\t/gm,""),t.push(n),n={};else {var o=i[2],u=i[3];if(o=="regex"){var a=/\/((?:[^\/\\]|\\.)*)|$/g;n.guard=a.exec(u)[1],n.trigger=a.exec(u)[1],n.endTrigger=a.exec(u)[1],n.endGuard=a.exec(u)[1];}else o=="snippet"?(n.tabTrigger=u.match(/^\S*/)[0],n.name||(n.name=u)):o&&(n[o]=u);}}return t},e.prototype.getSnippetByName=function(e,t){var n=this.snippetNameMap,r;return this.getActiveScopes(t).some(function(t){var i=n[t];return i&&(r=i[e]),!!r},this),r},e}();i.implement(d.prototype,s);var v=function(e,t,n){function l(e){var t=[];for(var n=0;n<e.length;n++){var r=e[n];if(typeof r=="object"){if(f[r.tabstopId])continue;var i=e.lastIndexOf(r,n-1);r=t[i]||{tabstopId:r.tabstopId};}t[n]=r;}return t}n===void 0&&(n={});var r=e.getCursorPosition(),i=e.session.getLine(r.row),s=e.session.getTabString(),o=i.match(/^\s*/)[0];r.column<o.length&&(o=o.slice(0,r.column)),t=t.replace(/\r/g,"");var u=this.tokenizeTmSnippet(t);u=this.resolveVariables(u,e),u=u.map(function(e){return e=="\n"&&!n.excludeExtraIndent?e+o:typeof e=="string"?e.replace(/\t/g,s):e});var a=[];u.forEach(function(e,t){if(typeof e!="object")return;var n=e.tabstopId,r=a[n];r||(r=a[n]=[],r.index=n,r.value="",r.parents={});if(r.indexOf(e)!==-1)return;e.choices&&!r.choices&&(r.choices=e.choices),r.push(e);var i=u.indexOf(e,t+1);if(i===-1)return;var s=u.slice(t+1,i),o=s.some(function(e){return typeof e=="object"});o&&!r.value?r.value=s:s.length&&(!r.value||typeof r.value!="string")&&(r.value=s.join(""));}),a.forEach(function(e){e.length=0;});var f={};for(var c=0;c<u.length;c++){var h=u[c];if(typeof h!="object")continue;var p=h.tabstopId,d=a[p],v=u.indexOf(h,c+1);if(f[p]){f[p]===h&&(delete f[p],Object.keys(f).forEach(function(e){d.parents[e]=true;}));continue}f[p]=h;var m=d.value;typeof m!="string"?m=l(m):h.fmt&&(m=this.tmStrFormat(m,h,e)),u.splice.apply(u,[c+1,Math.max(0,v-c)].concat(m,h)),d.indexOf(h)===-1&&d.push(h);}var g=0,y=0,b="";return u.forEach(function(e){if(typeof e=="string"){var t=e.split("\n");t.length>1?(y=t[t.length-1].length,g+=t.length-1):y+=e.length,b+=e;}else e&&(e.start?e.end={row:g,column:y}:e.start={row:g,column:y});}),{text:b,tabstops:a,tokens:u}},m=function(){function e(e){this.index=0,this.ranges=[],this.tabstops=[];if(e.tabstopManager)return e.tabstopManager;e.tabstopManager=this,this.$onChange=this.onChange.bind(this),this.$onChangeSelection=o.delayedCall(this.onChangeSelection.bind(this)).schedule,this.$onChangeSession=this.onChangeSession.bind(this),this.$onAfterExec=this.onAfterExec.bind(this),this.attach(e);}return e.prototype.attach=function(e){this.$openTabstops=null,this.selectedTabstop=null,this.editor=e,this.session=e.session,this.editor.on("change",this.$onChange),this.editor.on("changeSelection",this.$onChangeSelection),this.editor.on("changeSession",this.$onChangeSession),this.editor.commands.on("afterExec",this.$onAfterExec),this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);},e.prototype.detach=function(){this.tabstops.forEach(this.removeTabstopMarkers,this),this.ranges.length=0,this.tabstops.length=0,this.selectedTabstop=null,this.editor.off("change",this.$onChange),this.editor.off("changeSelection",this.$onChangeSelection),this.editor.off("changeSession",this.$onChangeSession),this.editor.commands.off("afterExec",this.$onAfterExec),this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler),this.editor.tabstopManager=null,this.session=null,this.editor=null;},e.prototype.onChange=function(e){var t=e.action[0]=="r",n=this.selectedTabstop||{},r=n.parents||{},i=this.tabstops.slice();for(var s=0;s<i.length;s++){var o=i[s],u=o==n||r[o.index];o.rangeList.$bias=u?0:1;if(e.action=="remove"&&o!==n){var a=o.parents&&o.parents[n.index],f=o.rangeList.pointIndex(e.start,a);f=f<0?-f-1:f+1;var l=o.rangeList.pointIndex(e.end,a);l=l<0?-l-1:l-1;var c=o.rangeList.ranges.slice(f,l);for(var h=0;h<c.length;h++)this.removeRange(c[h]);}o.rangeList.$onChange(e);}var p=this.session;!this.$inChange&&t&&p.getLength()==1&&!p.getValue()&&this.detach();},e.prototype.updateLinkedFields=function(){var e=this.selectedTabstop;if(!e||!e.hasLinkedRanges||!e.firstNonLinked)return;this.$inChange=true;var n=this.session,r=n.getTextRange(e.firstNonLinked);for(var i=0;i<e.length;i++){var s=e[i];if(!s.linked)continue;var o=s.original,u=t.snippetManager.tmStrFormat(r,o,this.editor);n.replace(s,u);}this.$inChange=false;},e.prototype.onAfterExec=function(e){e.command&&!e.command.readOnly&&this.updateLinkedFields();},e.prototype.onChangeSelection=function(){if(!this.editor)return;var e=this.editor.selection.lead,t=this.editor.selection.anchor,n=this.editor.selection.isEmpty();for(var r=0;r<this.ranges.length;r++){if(this.ranges[r].linked)continue;var i=this.ranges[r].contains(e.row,e.column),s=n||this.ranges[r].contains(t.row,t.column);if(i&&s)return}this.detach();},e.prototype.onChangeSession=function(){this.detach();},e.prototype.tabNext=function(e){var t=this.tabstops.length,n=this.index+(e||1);n=Math.min(Math.max(n,1),t),n==t&&(n=0),this.selectTabstop(n),this.updateTabstopMarkers(),n===0&&this.detach();},e.prototype.selectTabstop=function(e){this.$openTabstops=null;var t=this.tabstops[this.index];t&&this.addTabstopMarkers(t),this.index=e,t=this.tabstops[this.index];if(!t||!t.length)return;this.selectedTabstop=t;var n=t.firstNonLinked||t;t.choices&&(n.cursor=n.start);if(!this.editor.inVirtualSelectionMode){var r=this.editor.multiSelect;r.toSingleRange(n);for(var i=0;i<t.length;i++){if(t.hasLinkedRanges&&t[i].linked)continue;r.addRange(t[i].clone(),true);}}else this.editor.selection.fromOrientedRange(n);this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler),this.selectedTabstop&&this.selectedTabstop.choices&&this.editor.execCommand("startAutocomplete",{matches:this.selectedTabstop.choices});},e.prototype.addTabstops=function(e,t,n){var r=this.useLink||!this.editor.getOption("enableMultiselect");this.$openTabstops||(this.$openTabstops=[]);if(!e[0]){var i=u.fromPoints(n,n);y(i.start,t),y(i.end,t),e[0]=[i],e[0].index=0;}var s=this.index,o=[s+1,0],f=this.ranges,l=this.snippetId=(this.snippetId||0)+1;e.forEach(function(e,n){var i=this.$openTabstops[n]||e;i.snippetId=l;for(var s=0;s<e.length;s++){var c=e[s],h=u.fromPoints(c.start,c.end||c.start);g(h.start,t),g(h.end,t),h.original=c,h.tabstop=i,f.push(h),i!=e?i.unshift(h):i[s]=h,c.fmtString||i.firstNonLinked&&r?(h.linked=true,i.hasLinkedRanges=true):i.firstNonLinked||(i.firstNonLinked=h);}i.firstNonLinked||(i.hasLinkedRanges=false),i===e&&(o.push(i),this.$openTabstops[n]=i),this.addTabstopMarkers(i),i.rangeList=i.rangeList||new a,i.rangeList.$bias=0,i.rangeList.addList(i);},this),o.length>2&&(this.tabstops.length&&o.push(o.splice(2,1)[0]),this.tabstops.splice.apply(this.tabstops,o));},e.prototype.addTabstopMarkers=function(e){var t=this.session;e.forEach(function(e){e.markerId||(e.markerId=t.addMarker(e,"ace_snippet-marker","text"));});},e.prototype.removeTabstopMarkers=function(e){var t=this.session;e.forEach(function(e){t.removeMarker(e.markerId),e.markerId=null;});},e.prototype.updateTabstopMarkers=function(){if(!this.selectedTabstop)return;var e=this.selectedTabstop.snippetId;this.selectedTabstop.index===0&&e--,this.tabstops.forEach(function(t){t.snippetId===e?this.addTabstopMarkers(t):this.removeTabstopMarkers(t);},this);},e.prototype.removeRange=function(e){var t=e.tabstop.indexOf(e);t!=-1&&e.tabstop.splice(t,1),t=this.ranges.indexOf(e),t!=-1&&this.ranges.splice(t,1),t=e.tabstop.rangeList.ranges.indexOf(e),t!=-1&&e.tabstop.splice(t,1),this.session.removeMarker(e.markerId),e.tabstop.length||(t=this.tabstops.indexOf(e.tabstop),t!=-1&&this.tabstops.splice(t,1),this.tabstops.length||this.detach());},e}();m.prototype.keyboardHandler=new f,m.prototype.keyboardHandler.bindKeys({Tab:function(e){if(t.snippetManager&&t.snippetManager.expandWithTab(e))return;e.tabstopManager.tabNext(1),e.renderer.scrollCursorIntoView();},"Shift-Tab":function(e){e.tabstopManager.tabNext(-1),e.renderer.scrollCursorIntoView();},Esc:function(e){e.tabstopManager.detach();}});var g=function(e,t){e.row==0&&(e.column+=t.column),e.row+=t.row;},y=function(e,t){e.row==t.row&&(e.column-=t.column),e.row-=t.row;};r.importCssString("\n.ace_snippet-marker {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    background: rgba(194, 193, 208, 0.09);\n    border: 1px dotted rgba(211, 208, 235, 0.62);\n    position: absolute;\n}","snippets.css",false),t.snippetManager=new d;var b=e("./editor").Editor;(function(){this.insertSnippet=function(e,n){return t.snippetManager.insertSnippet(this,e,n)},this.expandSnippet=function(e){return t.snippetManager.expandWithTab(this,e)};}).call(b.prototype);}),ace.define("ace/autocomplete/popup",["require","exports","module","ace/virtual_renderer","ace/editor","ace/range","ace/lib/event","ace/lib/lang","ace/lib/dom","ace/config","ace/lib/useragent"],function(e,t,n){var r=e("../virtual_renderer").VirtualRenderer,i=e("../editor").Editor,s=e("../range").Range,o=e("../lib/event"),u=e("../lib/lang"),a=e("../lib/dom"),f=e("../config").nls,l=e("./../lib/useragent"),c=function(e){return "suggest-aria-id:".concat(e)},h=l.isSafari?"menu":"listbox",p=l.isSafari?"menuitem":"option",d=l.isSafari?"aria-current":"aria-selected",v=function(e){var t=new r(e);t.$maxLines=4;var n=new i(t);return n.setHighlightActiveLine(false),n.setShowPrintMargin(false),n.renderer.setShowGutter(false),n.renderer.setHighlightGutterLine(false),n.$mouseHandler.$focusTimeout=0,n.$highlightTagPending=true,n},m=function(){function e(e){var t=a.createElement("div"),n=v(t);e&&e.appendChild(t),t.style.display="none",n.renderer.content.style.cursor="default",n.renderer.setStyle("ace_autocomplete"),n.renderer.$textLayer.element.setAttribute("role",h),n.renderer.$textLayer.element.setAttribute("aria-roledescription",f("autocomplete.popup.aria-roledescription","Autocomplete suggestions")),n.renderer.$textLayer.element.setAttribute("aria-label",f("autocomplete.popup.aria-label","Autocomplete suggestions")),n.renderer.textarea.setAttribute("aria-hidden","true"),n.setOption("displayIndentGuides",false),n.setOption("dragDelay",150);var r=function(){};n.focus=r,n.$isFocused=true,n.renderer.$cursorLayer.restartTimer=r,n.renderer.$cursorLayer.element.style.opacity="0",n.renderer.$maxLines=8,n.renderer.$keepTextAreaAtCursor=false,n.setHighlightActiveLine(false),n.session.highlight(""),n.session.$searchHighlight.clazz="ace_highlight-marker",n.on("mousedown",function(e){var t=e.getDocumentPosition();n.selection.moveToPosition(t),m.start.row=m.end.row=t.row,e.stop();});var i,l=new s(-1,0,-1,Infinity),m=new s(-1,0,-1,Infinity);m.id=n.session.addMarker(m,"ace_active-line","fullLine"),n.setSelectOnHover=function(e){e?l.id&&(n.session.removeMarker(l.id),l.id=null):l.id=n.session.addMarker(l,"ace_line-hover","fullLine");},n.setSelectOnHover(false),n.on("mousemove",function(e){if(!i){i=e;return}if(i.x==e.x&&i.y==e.y)return;i=e,i.scrollTop=n.renderer.scrollTop,n.isMouseOver=true;var t=i.getDocumentPosition().row;l.start.row!=t&&(l.id||n.setRow(t),y(t));}),n.renderer.on("beforeRender",function(){if(i&&l.start.row!=-1){i.$pos=null;var e=i.getDocumentPosition().row;l.id||n.setRow(e),y(e,true);}}),n.renderer.on("afterRender",function(){var e=n.renderer.$textLayer;for(var t=e.config.firstRow,r=e.config.lastRow;t<=r;t++){var i=e.element.childNodes[t-e.config.firstRow];i.setAttribute("role",p),i.setAttribute("aria-roledescription",f("autocomplete.popup.item.aria-roledescription","item")),i.setAttribute("aria-setsize",n.data.length),i.setAttribute("aria-describedby","doc-tooltip"),i.setAttribute("aria-posinset",t+1);var s=n.getData(t);if(s){var o="".concat(s.caption||s.value).concat(s.meta?", ".concat(s.meta):"");i.setAttribute("aria-label",o);}var u=i.querySelectorAll(".ace_completion-highlight");u.forEach(function(e){e.setAttribute("role","mark");});}}),n.renderer.on("afterRender",function(){var e=n.getRow(),t=n.renderer.$textLayer,r=t.element.childNodes[e-t.config.firstRow],i=document.activeElement;r!==n.selectedNode&&n.selectedNode&&(a.removeCssClass(n.selectedNode,"ace_selected"),n.selectedNode.removeAttribute(d),n.selectedNode.removeAttribute("id")),i.removeAttribute("aria-activedescendant"),n.selectedNode=r;if(r){var s=c(e);a.addCssClass(r,"ace_selected"),r.id=s,t.element.setAttribute("aria-activedescendant",s),i.setAttribute("aria-activedescendant",s),r.setAttribute(d,"true");}});var g=function(){y(-1);},y=function(e,t){e!==l.start.row&&(l.start.row=l.end.row=e,t||n.session._emit("changeBackMarker"),n._emit("changeHoverMarker"));};n.getHoveredRow=function(){return l.start.row},o.addListener(n.container,"mouseout",function(){n.isMouseOver=false,g();}),n.on("hide",g),n.on("changeSelection",g),n.session.doc.getLength=function(){return n.data.length},n.session.doc.getLine=function(e){var t=n.data[e];return typeof t=="string"?t:t&&t.value||""};var b=n.session.bgTokenizer;return b.$tokenizeRow=function(e){function s(e,n){e&&r.push({type:(t.className||"")+(n||""),value:e});}var t=n.data[e],r=[];if(!t)return r;typeof t=="string"&&(t={value:t});var i=t.caption||t.value||t.name,o=i.toLowerCase(),u=(n.filterText||"").toLowerCase(),a=0,f=0;for(var l=0;l<=u.length;l++)if(l!=f&&(t.matchMask&1<<l||l==u.length)){var c=u.slice(f,l);f=l;var h=o.indexOf(c,a);if(h==-1)continue;s(i.slice(a,h),""),a=h+c.length,s(i.slice(h,a),"completion-highlight");}return s(i.slice(a,i.length),""),r.push({type:"completion-spacer",value:" "}),t.meta&&r.push({type:"completion-meta",value:t.meta}),t.message&&r.push({type:"completion-message",value:t.message}),r},b.$updateOnChange=r,b.start=r,n.session.$computeWidth=function(){return this.screenWidth=0},n.isOpen=false,n.isTopdown=false,n.autoSelect=true,n.filterText="",n.isMouseOver=false,n.data=[],n.setData=function(e,t){n.filterText=t||"",n.setValue(u.stringRepeat("\n",e.length),-1),n.data=e||[],n.setRow(0);},n.getData=function(e){return n.data[e]},n.getRow=function(){return m.start.row},n.setRow=function(e){e=Math.max(this.autoSelect?0:-1,Math.min(this.data.length-1,e)),m.start.row!=e&&(n.selection.clearSelection(),m.start.row=m.end.row=e||0,n.session._emit("changeBackMarker"),n.moveCursorTo(e||0,0),n.isOpen&&n._signal("select"));},n.on("changeSelection",function(){n.isOpen&&n.setRow(n.selection.lead.row),n.renderer.scrollCursorIntoView();}),n.hide=function(){this.container.style.display="none",n.anchorPos=null,n.anchor=null,n.isOpen&&(n.isOpen=false,this._signal("hide"));},n.tryShow=function(e,t,r,s){if(!s&&n.isOpen&&n.anchorPos&&n.anchor&&n.anchorPos.top===e.top&&n.anchorPos.left===e.left&&n.anchor===r)return  true;var o=this.container,u=this.renderer.scrollBar.width||10,a=window.innerHeight-u,f=window.innerWidth-u,l=this.renderer,c=l.$maxLines*t*1.4,h={top:0,bottom:0},p=a-e.top-3*this.$borderSize-t,d=e.top-3*this.$borderSize;r||(d<=p||p>=c?r="bottom":r="top"),r==="top"?(h.bottom=e.top-this.$borderSize,h.top=h.bottom-c):r==="bottom"&&(h.top=e.top+t+this.$borderSize,h.bottom=h.top+c);var v=h.top>=0&&h.bottom<=a;if(!s&&!v)return  false;v?l.$maxPixelHeight=null:r==="top"?l.$maxPixelHeight=d:l.$maxPixelHeight=p,o.style.display="";var m=o.offsetParent&&o.offsetParent.getBoundingClientRect();r==="top"?(o.style.top="",o.style.bottom=a+u-h.bottom-(m?a+u-m.bottom:0)+"px",n.isTopdown=false):(o.style.top=h.top-(m?m.top:0)+"px",o.style.bottom="",n.isTopdown=true);var g=e.left;return g+o.offsetWidth>f&&(g=f-o.offsetWidth),o.style.left=g-(m?m.left:0)+"px",o.style.right="",n.isOpen||(n.isOpen=true,this._signal("show"),i=null),n.anchorPos=e,n.anchor=r,true},n.show=function(e,t,n){this.tryShow(e,t,n?"bottom":undefined,true);},n.goTo=function(e){var t=this.getRow(),n=this.session.getLength()-1;switch(e){case "up":t=t<=0?n:t-1;break;case "down":t=t>=n?-1:t+1;break;case "start":t=0;break;case "end":t=n;}this.setRow(t);},n.getTextLeftOffset=function(){return this.$borderSize+this.renderer.$padding+this.$imageSize},n.$imageSize=0,n.$borderSize=1,n}return e}();a.importCssString('\n.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #CAD6FA;\n    z-index: 1;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #3a674e;\n}\n.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid #abbffe;\n    margin-top: -1px;\n    background: rgba(233,233,253,0.4);\n    position: absolute;\n    z-index: 2;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid rgba(109, 150, 13, 0.8);\n    background: rgba(58, 103, 78, 0.62);\n}\n.ace_completion-meta {\n    opacity: 0.5;\n    margin-left: 0.9em;\n}\n.ace_completion-message {\n    margin-left: 0.9em;\n    color: blue;\n}\n.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #2d69c7;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #93ca12;\n}\n.ace_editor.ace_autocomplete {\n    width: 300px;\n    z-index: 200000;\n    border: 1px lightgray solid;\n    position: absolute;\n    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n    line-height: 1.4;\n    background: #fefefe;\n    color: #111;\n}\n.ace_dark.ace_editor.ace_autocomplete {\n    border: 1px #484747 solid;\n    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\n    line-height: 1.4;\n    background: #25282c;\n    color: #c1c1c1;\n}\n.ace_autocomplete .ace_text-layer  {\n    width: calc(100% - 8px);\n}\n.ace_autocomplete .ace_line {\n    display: flex;\n    align-items: center;\n}\n.ace_autocomplete .ace_line > * {\n    min-width: 0;\n    flex: 0 0 auto;\n}\n.ace_autocomplete .ace_line .ace_ {\n    flex: 0 1 auto;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n.ace_autocomplete .ace_completion-spacer {\n    flex: 1;\n}\n.ace_autocomplete.ace_loading:after  {\n    content: "";\n    position: absolute;\n    top: 0px;\n    height: 2px;\n    width: 8%;\n    background: blue;\n    z-index: 100;\n    animation: ace_progress 3s infinite linear;\n    animation-delay: 300ms;\n    transform: translateX(-100%) scaleX(1);\n}\n@keyframes ace_progress {\n    0% { transform: translateX(-100%) scaleX(1) }\n    50% { transform: translateX(625%) scaleX(2) } \n    100% { transform: translateX(1500%) scaleX(3) } \n}\n@media (prefers-reduced-motion) {\n    .ace_autocomplete.ace_loading:after {\n        transform: translateX(625%) scaleX(2);\n        animation: none;\n     }\n}\n',"autocompletion.css",false),t.AcePopup=m,t.$singleLineEditor=v,t.getAriaId=c;}),ace.define("ace/autocomplete/inline_screenreader",["require","exports","module"],function(e,t,n){var r=function(){function e(e){this.editor=e,this.screenReaderDiv=document.createElement("div"),this.screenReaderDiv.classList.add("ace_screenreader-only"),this.editor.container.appendChild(this.screenReaderDiv);}return e.prototype.setScreenReaderContent=function(e){!this.popup&&this.editor.completer&&this.editor.completer.popup&&(this.popup=this.editor.completer.popup,this.popup.renderer.on("afterRender",function(){var e=this.popup.getRow(),t=this.popup.renderer.$textLayer,n=t.element.childNodes[e-t.config.firstRow];if(n){var r="doc-tooltip ";for(var i=0;i<this._lines.length;i++)r+="ace-inline-screenreader-line-".concat(i," ");n.setAttribute("aria-describedby",r);}}.bind(this)));while(this.screenReaderDiv.firstChild)this.screenReaderDiv.removeChild(this.screenReaderDiv.firstChild);this._lines=e.split(/\r\n|\r|\n/);var t=this.createCodeBlock();this.screenReaderDiv.appendChild(t);},e.prototype.destroy=function(){this.screenReaderDiv.remove();},e.prototype.createCodeBlock=function(){var e=document.createElement("pre");e.setAttribute("id","ace-inline-screenreader");for(var t=0;t<this._lines.length;t++){var n=document.createElement("code");n.setAttribute("id","ace-inline-screenreader-line-".concat(t));var r=document.createTextNode(this._lines[t]);n.appendChild(r),e.appendChild(n);}return e},e}();t.AceInlineScreenReader=r;}),ace.define("ace/autocomplete/inline",["require","exports","module","ace/snippets","ace/autocomplete/inline_screenreader"],function(e,t,n){var r=e("../snippets").snippetManager,i=e("./inline_screenreader").AceInlineScreenReader,s=function(){function e(){this.editor=null;}return e.prototype.show=function(e,t,n){n=n||"",e&&this.editor&&this.editor!==e&&(this.hide(),this.editor=null,this.inlineScreenReader=null);if(!e||!t)return  false;this.inlineScreenReader||(this.inlineScreenReader=new i(e));var s=t.snippet?r.getDisplayTextForSnippet(e,t.snippet):t.value;return t.hideInlinePreview||!s||!s.startsWith(n)?false:(this.editor=e,this.inlineScreenReader.setScreenReaderContent(s),s=s.slice(n.length),s===""?e.removeGhostText():e.setGhostText(s),true)},e.prototype.isOpen=function(){return this.editor?!!this.editor.renderer.$ghostText:false},e.prototype.hide=function(){return this.editor?(this.editor.removeGhostText(),true):false},e.prototype.destroy=function(){this.hide(),this.editor=null,this.inlineScreenReader&&(this.inlineScreenReader.destroy(),this.inlineScreenReader=null);},e}();t.AceInline=s;}),ace.define("ace/autocomplete/util",["require","exports","module"],function(e,t,n){t.parForEach=function(e,t,n){var r=0,i=e.length;i===0&&n();for(var s=0;s<i;s++)t(e[s],function(e,t){r++,r===i&&n(e,t);});};var r=/[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;t.retrievePrecedingIdentifier=function(e,t,n){n=n||r;var i=[];for(var s=t-1;s>=0;s--){if(!n.test(e[s]))break;i.push(e[s]);}return i.reverse().join("")},t.retrieveFollowingIdentifier=function(e,t,n){n=n||r;var i=[];for(var s=t;s<e.length;s++){if(!n.test(e[s]))break;i.push(e[s]);}return i},t.getCompletionPrefix=function(e){var t=e.getCursorPosition(),n=e.session.getLine(t.row),r;return e.completers.forEach(function(e){e.identifierRegexps&&e.identifierRegexps.forEach(function(e){!r&&e&&(r=this.retrievePrecedingIdentifier(n,t.column,e));}.bind(this));}.bind(this)),r||this.retrievePrecedingIdentifier(n,t.column)},t.triggerAutocomplete=function(e,t){var t=t==null?e.session.getPrecedingCharacter():t;return e.completers.some(function(e){if(e.triggerCharacters&&Array.isArray(e.triggerCharacters))return e.triggerCharacters.includes(t)})};}),ace.define("ace/autocomplete",["require","exports","module","ace/keyboard/hash_handler","ace/autocomplete/popup","ace/autocomplete/inline","ace/autocomplete/popup","ace/autocomplete/util","ace/lib/lang","ace/lib/dom","ace/snippets","ace/config","ace/lib/event","ace/lib/scroll"],function(e,t,n){var r=e("./keyboard/hash_handler").HashHandler,i=e("./autocomplete/popup").AcePopup,s=e("./autocomplete/inline").AceInline,o=e("./autocomplete/popup").getAriaId,u=e("./autocomplete/util"),a=e("./lib/lang"),f=e("./lib/dom"),l=e("./snippets").snippetManager,c=e("./config"),h=e("./lib/event"),p=e("./lib/scroll").preventParentScroll,d=function(e,t){t.completer&&t.completer.destroy();},v=function(){function e(){this.autoInsert=false,this.autoSelect=true,this.autoShown=false,this.exactMatch=false,this.inlineEnabled=false,this.keyboardHandler=new r,this.keyboardHandler.bindKeys(this.commands),this.parentNode=null,this.setSelectOnHover=false,this.hasSeen=new Set,this.showLoadingState=false,this.stickySelectionDelay=500,this.blurListener=this.blurListener.bind(this),this.changeListener=this.changeListener.bind(this),this.mousedownListener=this.mousedownListener.bind(this),this.mousewheelListener=this.mousewheelListener.bind(this),this.onLayoutChange=this.onLayoutChange.bind(this),this.changeTimer=a.delayedCall(function(){this.updateCompletions(true);}.bind(this)),this.tooltipTimer=a.delayedCall(this.updateDocTooltip.bind(this),50),this.popupTimer=a.delayedCall(this.$updatePopupPosition.bind(this),50),this.stickySelectionTimer=a.delayedCall(function(){this.stickySelection=true;}.bind(this),this.stickySelectionDelay),this.$firstOpenTimer=a.delayedCall(function(){var t=this.completionProvider&&this.completionProvider.initialPosition;if(this.autoShown||this.popup&&this.popup.isOpen||!t||this.editor.completers.length===0)return;this.completions=new g(e.completionsForLoading),this.openPopup(this.editor,t.prefix,false),this.popup.renderer.setStyle("ace_loading",true);}.bind(this),this.stickySelectionDelay);}return Object.defineProperty(e,"completionsForLoading",{get:function(){return [{caption:c.nls("autocomplete.loading","Loading..."),value:""}]},enumerable:false,configurable:true}),e.prototype.$init=function(){return this.popup=new i(this.parentNode||document.body||document.documentElement),this.popup.on("click",function(e){this.insertMatch(),e.stop();}.bind(this)),this.popup.focus=this.editor.focus.bind(this.editor),this.popup.on("show",this.$onPopupShow.bind(this)),this.popup.on("hide",this.$onHidePopup.bind(this)),this.popup.on("select",this.$onPopupChange.bind(this)),h.addListener(this.popup.container,"mouseout",this.mouseOutListener.bind(this)),this.popup.on("changeHoverMarker",this.tooltipTimer.bind(null,null)),this.popup.renderer.on("afterRender",this.$onPopupRender.bind(this)),this.popup},e.prototype.$initInline=function(){if(!this.inlineEnabled||this.inlineRenderer)return;return this.inlineRenderer=new s,this.inlineRenderer},e.prototype.getPopup=function(){return this.popup||this.$init()},e.prototype.$onHidePopup=function(){this.inlineRenderer&&this.inlineRenderer.hide(),this.hideDocTooltip(),this.stickySelectionTimer.cancel(),this.popupTimer.cancel(),this.stickySelection=false;},e.prototype.$seen=function(e){!this.hasSeen.has(e)&&e&&e.completer&&e.completer.onSeen&&typeof e.completer.onSeen=="function"&&(e.completer.onSeen(this.editor,e),this.hasSeen.add(e));},e.prototype.$onPopupChange=function(e){if(this.inlineRenderer&&this.inlineEnabled){var t=e?null:this.popup.getData(this.popup.getRow());this.$updateGhostText(t);if(this.popup.isMouseOver&&this.setSelectOnHover){this.tooltipTimer.call(null,null);return}this.popupTimer.schedule(),this.tooltipTimer.schedule();}else this.popupTimer.call(null,null),this.tooltipTimer.call(null,null);},e.prototype.$updateGhostText=function(e){var t=this.base.row,n=this.base.column,r=this.editor.getCursorPosition().column,i=this.editor.session.getLine(t).slice(n,r);this.inlineRenderer.show(this.editor,e,i)?this.$seen(e):this.inlineRenderer.hide();},e.prototype.$onPopupRender=function(){var e=this.inlineRenderer&&this.inlineEnabled;if(this.completions&&this.completions.filtered&&this.completions.filtered.length>0)for(var t=this.popup.getFirstVisibleRow();t<=this.popup.getLastVisibleRow();t++){var n=this.popup.getData(t);n&&(!e||n.hideInlinePreview)&&this.$seen(n);}},e.prototype.$onPopupShow=function(e){this.$onPopupChange(e),this.stickySelection=false,this.stickySelectionDelay>=0&&this.stickySelectionTimer.schedule(this.stickySelectionDelay);},e.prototype.observeLayoutChanges=function(){if(this.$elements||!this.editor)return;window.addEventListener("resize",this.onLayoutChange,{passive:true}),window.addEventListener("wheel",this.mousewheelListener);var e=this.editor.container.parentNode,t=[];while(e)t.push(e),e.addEventListener("scroll",this.onLayoutChange,{passive:true}),e=e.parentNode;this.$elements=t;},e.prototype.unObserveLayoutChanges=function(){var e=this;window.removeEventListener("resize",this.onLayoutChange,{passive:true}),window.removeEventListener("wheel",this.mousewheelListener),this.$elements&&this.$elements.forEach(function(t){t.removeEventListener("scroll",e.onLayoutChange,{passive:true});}),this.$elements=null;},e.prototype.onLayoutChange=function(){if(!this.popup.isOpen)return this.unObserveLayoutChanges();this.$updatePopupPosition(),this.updateDocTooltip();},e.prototype.$updatePopupPosition=function(){var e=this.editor,t=e.renderer,n=t.layerConfig.lineHeight,r=t.$cursorLayer.getPixelPosition(this.base,true);r.left-=this.popup.getTextLeftOffset();var i=e.container.getBoundingClientRect();r.top+=i.top-t.layerConfig.offset,r.left+=i.left-e.renderer.scrollLeft,r.left+=t.gutterWidth;var s={top:r.top,left:r.left};t.$ghostText&&t.$ghostTextWidget&&this.base.row===t.$ghostText.position.row&&(s.top+=t.$ghostTextWidget.el.offsetHeight);var o=e.container.getBoundingClientRect().bottom-n,u=o<s.top?{top:o,left:s.left}:s;if(this.popup.tryShow(u,n,"bottom"))return;if(this.popup.tryShow(r,n,"top"))return;this.popup.show(r,n);},e.prototype.openPopup=function(e,t,n){this.$firstOpenTimer.cancel(),this.popup||this.$init(),this.inlineEnabled&&!this.inlineRenderer&&this.$initInline(),this.popup.autoSelect=this.autoSelect,this.popup.setSelectOnHover(this.setSelectOnHover);var r=this.popup.getRow(),i=this.popup.data[r];this.popup.setData(this.completions.filtered,this.completions.filterText),this.editor.textInput.setAriaOptions&&this.editor.textInput.setAriaOptions({activeDescendant:o(this.popup.getRow()),inline:this.inlineEnabled}),e.keyBinding.addKeyboardHandler(this.keyboardHandler);var s;this.stickySelection&&(s=this.popup.data.indexOf(i));if(!s||s===-1)s=0;this.popup.setRow(this.autoSelect?s:-1),s===r&&i!==this.completions.filtered[s]&&this.$onPopupChange();var u=this.inlineRenderer&&this.inlineEnabled;if(s===r&&u){var a=this.popup.getData(this.popup.getRow());this.$updateGhostText(a);}n||(this.popup.setTheme(e.getTheme()),this.popup.setFontSize(e.getFontSize()),this.$updatePopupPosition(),this.tooltipNode&&this.updateDocTooltip()),this.changeTimer.cancel(),this.observeLayoutChanges();},e.prototype.detach=function(){this.editor&&(this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler),this.editor.off("changeSelection",this.changeListener),this.editor.off("blur",this.blurListener),this.editor.off("mousedown",this.mousedownListener),this.editor.off("mousewheel",this.mousewheelListener)),this.$firstOpenTimer.cancel(),this.changeTimer.cancel(),this.hideDocTooltip(),this.completionProvider&&this.completionProvider.detach(),this.popup&&this.popup.isOpen&&this.popup.hide(),this.popup&&this.popup.renderer&&this.popup.renderer.off("afterRender",this.$onPopupRender),this.base&&this.base.detach(),this.activated=false,this.completionProvider=this.completions=this.base=null,this.unObserveLayoutChanges();},e.prototype.changeListener=function(e){var t=this.editor.selection.lead;(t.row!=this.base.row||t.column<this.base.column)&&this.detach(),this.activated?this.changeTimer.schedule():this.detach();},e.prototype.blurListener=function(e){var t=document.activeElement,n=this.editor.textInput.getElement(),r=e.relatedTarget&&this.tooltipNode&&this.tooltipNode.contains(e.relatedTarget),i=this.popup&&this.popup.container;t!=n&&t.parentNode!=i&&!r&&t!=this.tooltipNode&&e.relatedTarget!=n&&this.detach();},e.prototype.mousedownListener=function(e){this.detach();},e.prototype.mousewheelListener=function(e){this.popup&&!this.popup.isMouseOver&&this.detach();},e.prototype.mouseOutListener=function(e){this.popup.isOpen&&this.$updatePopupPosition();},e.prototype.goTo=function(e){this.popup.goTo(e);},e.prototype.insertMatch=function(e,t){e||(e=this.popup.getData(this.popup.getRow()));if(!e)return  false;if(e.value==="")return this.detach();var n=this.completions,r=this.getCompletionProvider().insertMatch(this.editor,e,n.filterText,t);return this.completions==n&&this.detach(),r},e.prototype.showPopup=function(e,t){this.editor&&this.detach(),this.activated=true,this.editor=e,e.completer!=this&&(e.completer&&e.completer.detach(),e.completer=this),e.on("changeSelection",this.changeListener),e.on("blur",this.blurListener),e.on("mousedown",this.mousedownListener),e.on("mousewheel",this.mousewheelListener),this.updateCompletions(false,t);},e.prototype.getCompletionProvider=function(e){return this.completionProvider||(this.completionProvider=new m(e)),this.completionProvider},e.prototype.gatherCompletions=function(e,t){return this.getCompletionProvider().gatherCompletions(e,t)},e.prototype.updateCompletions=function(t,n){if(t&&this.base&&this.completions){var r=this.editor.getCursorPosition(),i=this.editor.session.getTextRange({start:this.base,end:r});if(i==this.completions.filterText)return;this.completions.setFilter(i);if(!this.completions.filtered.length)return this.detach();if(this.completions.filtered.length==1&&this.completions.filtered[0].value==i&&!this.completions.filtered[0].snippet)return this.detach();this.openPopup(this.editor,i,t);return}if(n&&n.matches){var r=this.editor.getSelectionRange().start;return this.base=this.editor.session.doc.createAnchor(r.row,r.column),this.base.$insertRight=true,this.completions=new g(n.matches),this.getCompletionProvider().completions=this.completions,this.openPopup(this.editor,"",t)}var s=this.editor.getSession(),r=this.editor.getCursorPosition(),i=u.getCompletionPrefix(this.editor);this.base=s.doc.createAnchor(r.row,r.column-i.length),this.base.$insertRight=true;var o={exactMatch:this.exactMatch,ignoreCaption:this.ignoreCaption};this.getCompletionProvider({prefix:i,pos:r}).provideCompletions(this.editor,o,function(n,r,i){var s=r.filtered,o=u.getCompletionPrefix(this.editor);this.$firstOpenTimer.cancel();if(i){if(!s.length){var a=!this.autoShown&&this.emptyMessage;typeof a=="function"&&(a=this.emptyMessage(o));if(a){var f=[{caption:a,value:""}];this.completions=new g(f),this.openPopup(this.editor,o,t),this.popup.renderer.setStyle("ace_loading",false),this.popup.renderer.setStyle("ace_empty-message",true);return}return this.detach()}if(s.length==1&&s[0].value==o&&!s[0].snippet)return this.detach();if(this.autoInsert&&!this.autoShown&&s.length==1)return this.insertMatch(s[0])}this.completions=!i&&this.showLoadingState?new g(e.completionsForLoading.concat(s),r.filterText):r,this.openPopup(this.editor,o,t),this.popup.renderer.setStyle("ace_empty-message",false),this.popup.renderer.setStyle("ace_loading",!i);}.bind(this)),this.showLoadingState&&!this.autoShown&&(!this.popup||!this.popup.isOpen)&&this.$firstOpenTimer.delay(this.stickySelectionDelay/2);},e.prototype.cancelContextMenu=function(){this.editor.$mouseHandler.cancelContextMenu();},e.prototype.updateDocTooltip=function(){var e=this.popup,t=this.completions&&this.completions.filtered,n=t&&(t[e.getHoveredRow()]||t[e.getRow()]),r=null;if(!n||!this.editor||!this.popup.isOpen)return this.hideDocTooltip();var i=this.editor.completers.length;for(var s=0;s<i;s++){var o=this.editor.completers[s];if(o.getDocTooltip&&n.completerId===o.id){r=o.getDocTooltip(n);break}}!r&&typeof n!="string"&&(r=n),typeof r=="string"&&(r={docText:r});if(!r||!r.docHTML&&!r.docText)return this.hideDocTooltip();this.showDocTooltip(r);},e.prototype.showDocTooltip=function(e){this.tooltipNode||(this.tooltipNode=f.createElement("div"),this.tooltipNode.style.margin="0",this.tooltipNode.style.pointerEvents="auto",this.tooltipNode.style.overscrollBehavior="contain",this.tooltipNode.tabIndex=-1,this.tooltipNode.onblur=this.blurListener.bind(this),this.tooltipNode.onclick=this.onTooltipClick.bind(this),this.tooltipNode.id="doc-tooltip",this.tooltipNode.setAttribute("role","tooltip"),this.tooltipNode.addEventListener("wheel",p));var t=this.editor.renderer.theme;this.tooltipNode.className="ace_tooltip ace_doc-tooltip "+(t.isDark?"ace_dark ":"")+(t.cssClass||"");var n=this.tooltipNode;e.docHTML?n.innerHTML=e.docHTML:e.docText&&(n.textContent=e.docText),n.parentNode||this.popup.container.appendChild(this.tooltipNode);var r=this.popup,i=r.container.getBoundingClientRect(),s=400,o=300,u=r.renderer.scrollBar.width||10,a=i.left,l=window.innerWidth-i.right-u,c=r.isTopdown?i.top:window.innerHeight-u-i.bottom,h=[Math.min(l/s,1),Math.min(a/s,1),Math.min(c/o*.9)],d=Math.max.apply(Math,h),v=n.style;v.display="block",d==h[0]?(v.left=i.right+1+"px",v.right="",v.maxWidth=s*d+"px",v.top=i.top+"px",v.bottom="",v.maxHeight=Math.min(window.innerHeight-u-i.top,o)+"px"):d==h[1]?(v.right=window.innerWidth-i.left+"px",v.left="",v.maxWidth=s*d+"px",v.top=i.top+"px",v.bottom="",v.maxHeight=Math.min(window.innerHeight-u-i.top,o)+"px"):d==h[2]&&(v.left=window.innerWidth-i.left+"px",v.maxWidth=Math.min(s,window.innerWidth)+"px",r.isTopdown?(v.top=i.bottom+"px",v.left=i.left+"px",v.right="",v.bottom="",v.maxHeight=Math.min(window.innerHeight-u-i.bottom,o)+"px"):(v.top=r.container.offsetTop-n.offsetHeight+"px",v.left=i.left+"px",v.right="",v.bottom="",v.maxHeight=Math.min(r.container.offsetTop,o)+"px"));},e.prototype.hideDocTooltip=function(){this.tooltipTimer.cancel();if(!this.tooltipNode)return;var e=this.tooltipNode;!this.editor.isFocused()&&document.activeElement==e&&this.editor.focus(),this.tooltipNode=null,e.parentNode&&e.parentNode.removeChild(e);},e.prototype.onTooltipClick=function(e){var t=e.target;while(t&&t!=this.tooltipNode){if(t.nodeName=="A"&&t.href){t.rel="noreferrer",t.target="_blank";break}t=t.parentNode;}},e.prototype.destroy=function(){this.detach();if(this.popup){this.popup.destroy();var e=this.popup.container;e&&e.parentNode&&e.parentNode.removeChild(e);}this.editor&&this.editor.completer==this&&(this.editor.off("destroy",d),this.editor.completer=null),this.inlineRenderer=this.popup=this.editor=null;},e.for=function(t){return t.completer instanceof e?t.completer:(t.completer&&(t.completer.destroy(),t.completer=null),c.get("sharedPopups")?(e.$sharedInstance||(e.$sharedInstance=new e),t.completer=e.$sharedInstance):(t.completer=new e,t.once("destroy",d)),t.completer)},e}();v.prototype.commands={Up:function(e){e.completer.goTo("up");},Down:function(e){e.completer.goTo("down");},"Ctrl-Up|Ctrl-Home":function(e){e.completer.goTo("start");},"Ctrl-Down|Ctrl-End":function(e){e.completer.goTo("end");},Esc:function(e){e.completer.detach();},Return:function(e){return e.completer.insertMatch()},"Shift-Return":function(e){e.completer.insertMatch(null,{deleteSuffix:true});},Tab:function(e){var t=e.completer.insertMatch();if(!!t||!!e.tabstopManager)return t;e.completer.goTo("down");},Backspace:function(e){e.execCommand("backspace");var t=u.getCompletionPrefix(e);!t&&e.completer&&e.completer.detach();},PageUp:function(e){e.completer.popup.gotoPageUp();},PageDown:function(e){e.completer.popup.gotoPageDown();}},v.startCommand={name:"startAutocomplete",exec:function(e,t){var n=v.for(e);n.autoInsert=false,n.autoSelect=true,n.autoShown=false,n.showPopup(e,t),n.cancelContextMenu();},bindKey:"Ctrl-Space|Ctrl-Shift-Space|Alt-Space"};var m=function(){function e(e){this.initialPosition=e,this.active=true;}return e.prototype.insertByIndex=function(e,t,n){return !this.completions||!this.completions.filtered?false:this.insertMatch(e,this.completions.filtered[t],n)},e.prototype.insertMatch=function(e,t,n){if(!t)return  false;e.startOperation({command:{name:"insertMatch"}});if(t.completer&&t.completer.insertMatch)t.completer.insertMatch(e,t);else {if(!this.completions)return  false;var r=this.completions.filterText.length,i=0;t.range&&t.range.start.row===t.range.end.row&&(r-=this.initialPosition.prefix.length,r+=this.initialPosition.pos.column-t.range.start.column,i+=t.range.end.column-this.initialPosition.pos.column);if(r||i){var s;e.selection.getAllRanges?s=e.selection.getAllRanges():s=[e.getSelectionRange()];for(var o=0,u;u=s[o];o++)u.start.column-=r,u.end.column+=i,e.session.remove(u);}t.snippet?l.insertSnippet(e,t.snippet):this.$insertString(e,t),t.completer&&t.completer.onInsert&&typeof t.completer.onInsert=="function"&&t.completer.onInsert(e,t),t.command&&t.command==="startAutocomplete"&&e.execCommand(t.command);}return e.endOperation(),true},e.prototype.$insertString=function(e,t){var n=t.value||t;e.execCommand("insertstring",n);},e.prototype.gatherCompletions=function(e,t){var n=e.getSession(),r=e.getCursorPosition(),i=u.getCompletionPrefix(e),s=[];this.completers=e.completers;var o=e.completers.length;return e.completers.forEach(function(a,f){a.getCompletions(e,n,r,i,function(n,r){a.hideInlinePreview&&(r=r.map(function(e){return Object.assign(e,{hideInlinePreview:a.hideInlinePreview})})),!n&&r&&(s=s.concat(r)),t(null,{prefix:u.getCompletionPrefix(e),matches:s,finished:--o===0});});}),true},e.prototype.provideCompletions=function(e,t,n){var r=function(e){var r=e.prefix,i=e.matches;this.completions=new g(i),t.exactMatch&&(this.completions.exactMatch=true),t.ignoreCaption&&(this.completions.ignoreCaption=true),this.completions.setFilter(r),(e.finished||this.completions.filtered.length)&&n(null,this.completions,e.finished);}.bind(this),i=true,s=null;this.gatherCompletions(e,function(e,t){if(!this.active)return;e&&(n(e,[],true),this.detach());var o=t.prefix;if(o.indexOf(t.prefix)!==0)return;if(i){s=t;return}r(t);}.bind(this)),i=false;if(s){var o=s;s=null,r(o);}},e.prototype.detach=function(){this.active=false,this.completers&&this.completers.forEach(function(e){typeof e.cancel=="function"&&e.cancel();});},e}(),g=function(){function e(e,t){this.all=e,this.filtered=e,this.filterText=t||"",this.exactMatch=false,this.ignoreCaption=false;}return e.prototype.setFilter=function(e){if(e.length>this.filterText&&e.lastIndexOf(this.filterText,0)===0)var t=this.filtered;else var t=this.all;this.filterText=e,t=this.filterCompletions(t,this.filterText),t=t.sort(function(e,t){return t.exactMatch-e.exactMatch||t.$score-e.$score||(e.caption||e.value).localeCompare(t.caption||t.value)});var n=null;t=t.filter(function(e){var t=e.snippet||e.caption||e.value;return t===n?false:(n=t,true)}),this.filtered=t;},e.prototype.filterCompletions=function(e,t){var n=[],r=t.toUpperCase(),i=t.toLowerCase();e:for(var s=0,o;o=e[s];s++){if(o.skipFilter){o.$score=o.score,n.push(o);continue}var u=!this.ignoreCaption&&o.caption||o.value||o.snippet;if(!u)continue;var a=-1,f=0,l=0,c,h;if(this.exactMatch){if(t!==u.substr(0,t.length))continue e}else {var p=u.toLowerCase().indexOf(i);if(p>-1)l=p;else for(var d=0;d<t.length;d++){var v=u.indexOf(i[d],a+1),m=u.indexOf(r[d],a+1);c=v>=0?m<0||v<m?v:m:m;if(c<0)continue e;h=c-a-1,h>0&&(a===-1&&(l+=10),l+=h,f|=1<<d),a=c;}}o.matchMask=f,o.exactMatch=l?0:1,o.$score=(o.score||0)-l,n.push(o);}return n},e}();t.Autocomplete=v,t.CompletionProvider=m,t.FilteredList=g;}),ace.define("ace/marker_group",["require","exports","module"],function(e,t,n){var r=function(){function e(e,t){t&&(this.markerType=t.markerType),this.markers=[],this.session=e,e.addDynamicMarker(this);}return e.prototype.getMarkerAtPosition=function(e){return this.markers.find(function(t){return t.range.contains(e.row,e.column)})},e.prototype.markersComparator=function(e,t){return e.range.start.row-t.range.start.row},e.prototype.setMarkers=function(e){this.markers=e.sort(this.markersComparator).slice(0,this.MAX_MARKERS),this.session._signal("changeBackMarker");},e.prototype.update=function(e,t,n,r){if(!this.markers||!this.markers.length)return;var i=r.firstRow,s=r.lastRow,o,u=0,a=0;for(var f=0;f<this.markers.length;f++){var l=this.markers[f];if(l.range.end.row<i)continue;if(l.range.start.row>s)continue;l.range.start.row===a?u++:(a=l.range.start.row,u=0);if(u>200)continue;var c=l.range.clipRows(i,s);if(c.start.row===c.end.row&&c.start.column===c.end.column)continue;var h=c.toScreenRange(n);if(h.isEmpty()){o=n.getNextFoldLine(c.end.row,o),o&&o.end.row>c.end.row&&(i=o.end.row);continue}this.markerType==="fullLine"?t.drawFullLineMarker(e,h,l.className,r):h.isMultiLine()?this.markerType==="line"?t.drawMultiLineMarker(e,h,l.className,r):t.drawTextMarker(e,h,l.className,r):t.drawSingleLineMarker(e,h,l.className+" ace_br15",r);}},e}();r.prototype.MAX_MARKERS=1e4,t.MarkerGroup=r;}),ace.define("ace/autocomplete/text_completer",["require","exports","module","ace/range"],function(e,t,n){function s(e,t){var n=e.getTextRange(r.fromPoints({row:0,column:0},t));return n.split(i).length-1}function o(e,t){var n=s(e,t),r=e.getValue().split(i),o=Object.create(null),u=r[n];return r.forEach(function(e,t){if(!e||e===u)return;var i=Math.abs(n-t),s=r.length-i;o[e]?o[e]=Math.max(s,o[e]):o[e]=s;}),o}var r=e("../range").Range,i=/[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;t.getCompletions=function(e,t,n,r,i){var s=o(t,n),u=Object.keys(s);i(null,u.map(function(e){return {caption:e,value:e,score:s[e],meta:"local"}}));};}),ace.define("ace/ext/language_tools",["require","exports","module","ace/snippets","ace/autocomplete","ace/config","ace/lib/lang","ace/autocomplete/util","ace/marker_group","ace/autocomplete/text_completer","ace/editor","ace/config"],function(e,t,n){var r=e("../snippets").snippetManager,i=e("../autocomplete").Autocomplete,s=e("../config"),o=e("../lib/lang"),u=e("../autocomplete/util"),a=e("../marker_group").MarkerGroup,f=e("../autocomplete/text_completer"),l={getCompletions:function(e,t,n,r,i){if(t.$mode.completer)return t.$mode.completer.getCompletions(e,t,n,r,i);var s=e.session.getState(n.row),o=t.$mode.getCompletions(s,t,n,r);o=o.map(function(e){return e.completerId=l.id,e}),i(null,o);},id:"keywordCompleter"},c=function(e){var t={};return e.replace(/\${(\d+)(:(.*?))?}/g,function(e,n,r,i){return t[n]=i||""}).replace(/\$(\d+?)/g,function(e,n){return t[n]})},h={getCompletions:function(e,t,n,i,s){var o=[],u=t.getTokenAt(n.row,n.column);u&&u.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/)?o.push("html-tag"):o=r.getActiveScopes(e);var a=r.snippetMap,f=[];o.forEach(function(e){var t=a[e]||[];for(var n=t.length;n--;){var r=t[n],i=r.name||r.tabTrigger;if(!i)continue;f.push({caption:i,snippet:r.content,meta:r.tabTrigger&&!r.name?r.tabTrigger+"\u21e5 ":"snippet",completerId:h.id});}},this),s(null,f);},getDocTooltip:function(e){e.snippet&&!e.docHTML&&(e.docHTML=["<b>",o.escapeHTML(e.caption),"</b>","<hr></hr>",o.escapeHTML(c(e.snippet))].join(""));},id:"snippetCompleter"},p=[h,f,l];t.setCompleters=function(e){p.length=0,e&&p.push.apply(p,e);},t.addCompleter=function(e){p.push(e);},t.textCompleter=f,t.keyWordCompleter=l,t.snippetCompleter=h;var d={name:"expandSnippet",exec:function(e){return r.expandWithTab(e)},bindKey:"Tab"},v=function(e,t){m(t.session.$mode);},m=function(e){typeof e=="string"&&(e=s.$modes[e]);if(!e)return;r.files||(r.files={}),g(e.$id,e.snippetFileId),e.modes&&e.modes.forEach(m);},g=function(e,t){if(!t||!e||r.files[e])return;r.files[e]={},s.loadModule(t,function(t){if(!t)return;r.files[e]=t,!t.snippets&&t.snippetText&&(t.snippets=r.parseSnippetFile(t.snippetText)),r.register(t.snippets||[],t.scope),t.includeScopes&&(r.snippetMap[t.scope].includeScopes=t.includeScopes,t.includeScopes.forEach(function(e){m("ace/mode/"+e);}));});},y=function(e){var t=e.editor,n=t.completer&&t.completer.activated;if(e.command.name==="backspace")n&&!u.getCompletionPrefix(t)&&t.completer.detach();else if(e.command.name==="insertstring"&&!n){b=e;var r=e.editor.$liveAutocompletionDelay;r?w.delay(r):E(e);}},b,w=o.delayedCall(function(){E(b);},0),E=function(e){var t=e.editor,n=u.getCompletionPrefix(t),r=e.args,s=u.triggerAutocomplete(t,r);if(n&&n.length>=t.$liveAutocompletionThreshold||s){var o=i.for(t);o.autoShown=true,o.showPopup(t);}},S=e("../editor").Editor;e("../config").defineOptions(S.prototype,"editor",{enableBasicAutocompletion:{set:function(e){e?(i.for(this),this.completers||(this.completers=Array.isArray(e)?e:p),this.commands.addCommand(i.startCommand)):this.commands.removeCommand(i.startCommand);},value:false},enableLiveAutocompletion:{set:function(e){e?(this.completers||(this.completers=Array.isArray(e)?e:p),this.commands.on("afterExec",y)):this.commands.off("afterExec",y);},value:false},liveAutocompletionDelay:{initialValue:0},liveAutocompletionThreshold:{initialValue:0},enableSnippets:{set:function(e){e?(this.commands.addCommand(d),this.on("changeMode",v),v(null,this)):(this.commands.removeCommand(d),this.off("changeMode",v));},value:false}}),t.MarkerGroup=a;});                (function() {
	                    ace.require(["ace/ext/language_tools"], function(m) {
	                        if (module) {
	                            module.exports = m;
	                        }
	                    });
	                })(); 
} (extLanguage_tools));

const React$y = await importShared('react');
const styles$m = {
    jsonError: {
        border: '1px solid red',
        minHeight: 200,
    },
    jsonNoError: {
        border: '1px solid #00000000',
        minHeight: 200,
    },
};
function Editor(props) {
    return (React$y.createElement(_default, { style: props.error === true ? styles$m.jsonError : props.error === false ? styles$m.jsonNoError : undefined, mode: props.mode || 'json', width: "100%", height: "100%", showPrintMargin: props.editValueMode, showGutter: props.editValueMode, highlightActiveLine: props.editValueMode, defaultValue: props.defaultValue, theme: props.themeType === 'dark' ? 'clouds_midnight' : 'chrome', value: props.value, readOnly: !props.onChange, onChange: newValue => props.onChange?.(newValue), name: props.name || 'UNIQUE_ID_OF_DIV1', fontSize: props.fontSize || 14, setOptions: {
            enableBasicAutocompletion: true,
            enableLiveAutocompletion: true,
            enableSnippets: true,
            showLineNumbers: props.editValueMode,
            tabSize: props.editValueMode ? 2 : undefined,
        }, editorProps: { $blockScrolling: true } }));
}

const React$x = await importShared('react');
const {FormHelperText: FormHelperText$6,FormControl: FormControl$8,Button: Button$8} = await importShared('@mui/material');

const {I18n: I18n$l} = await importShared('@iobroker/adapter-react-v5');
const styles$l = {
    flex: {
        display: 'flex',
    },
    button: {
        height: 48,
        // marginLeft: 4,
        minWidth: 48,
    },
    wrapper: {
        width: 'calc(100vw - 40px)',
        height: 'calc(100vh - 188px)',
    },
};
class ConfigJsonEditor extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const { data, attr } = this.props;
        const value = ConfigGeneric.getValue(data, attr) || '{}';
        this.setState({ value, initialized: true, jsonError: this.validateJson(value) });
    }
    validateJson(value) {
        let jsonError = false;
        if (this.props.schema.validateJson !== false) {
            if (value || !this.props.schema.allowEmpty) {
                try {
                    if (this.props.schema.json5) {
                        lib$1.parse(value);
                    }
                    else {
                        JSON.parse(value);
                    }
                }
                catch (err) {
                    console.log('Error in JSON', err);
                    jsonError = true;
                }
            }
        }
        return jsonError;
    }
    renderItem(_error, disabled /* , defaultValue */) {
        if (!this.state.initialized) {
            return null;
        }
        const { schema, data, attr } = this.props;
        const { value, showSelectId } = this.state;
        const isReadOnly = schema.readOnly === true;
        return (React$x.createElement(FormControl$8, { fullWidth: true, variant: "standard" },
            React$x.createElement("div", { style: styles$l.flex },
                React$x.createElement(Button$8, { color: "grey", disabled: disabled, style: styles$l.button, size: "small", variant: "outlined", onClick: () => this.setState({ showSelectId: true }) }, I18n$l.t('ra_JSON editor'))),
            showSelectId ? (React$x.createElement(CustomModal, { title: this.getText(schema.label), overflowHidden: true, applyDisabled: (this.state.jsonError && this.props.schema.doNotApplyWithError) || isReadOnly, onClose: () => this.setState({ showSelectId: false, value: ConfigGeneric.getValue(data, attr) || {} }), onApply: isReadOnly
                    ? undefined
                    : () => this.setState({ showSelectId: false }, () => this.onChange(attr, value)) },
                React$x.createElement("div", { style: {
                        ...styles$l.wrapper,
                        border: this.state.jsonError ? '2px solid red' : '2px solid transparent',
                    } },
                    React$x.createElement(Editor, { mode: this.props.schema.json5 ? 'json5' : 'json', value: typeof value === 'object' ? JSON.stringify(value) : value, onChange: isReadOnly
                            ? undefined
                            : newValue => this.setState({
                                value: newValue,
                                jsonError: this.validateJson(newValue),
                            }), name: "ConfigJsonEditor", themeType: this.props.oContext.themeType })))) : null,
            schema.help || this.state.jsonError ? (React$x.createElement(FormHelperText$6, null, this.state.jsonError
                ? I18n$l.t('ra_Invalid JSON')
                : this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$w = await importShared('react');

const {InputLabel: InputLabel$6,MenuItem: MenuItem$6,FormHelperText: FormHelperText$5,FormControl: FormControl$7,Select: Select$5} = await importShared('@mui/material');

const {I18n: I18n$k} = await importShared('@iobroker/adapter-react-v5');
const LANGUAGES = [
    {
        value: 'en',
        label: 'English',
    },
    {
        value: 'de',
        label: 'Deutsch',
    },
    {
        value: 'ru',
        label: 'русский',
    },
    {
        value: 'pt',
        label: 'Portugues',
    },
    {
        value: 'nl',
        label: 'Nederlands',
    },
    {
        value: 'fr',
        label: 'français',
    },
    {
        value: 'it',
        label: 'Italiano',
    },
    {
        value: 'es',
        label: 'Espanol',
    },
    {
        value: 'pl',
        label: 'Polski',
    },
    {
        value: 'uk',
        label: 'Український',
    },
    {
        value: 'zh-cn',
        label: '简体中文',
    },
];
class ConfigLanguage extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        const languages = [...LANGUAGES];
        if (this.props.schema.system) {
            languages.unshift({ value: '', label: I18n$k.t('ra_System language') });
        }
        else {
            languages.unshift({ value: '', label: I18n$k.t('ra_none') });
        }
        this.setState({
            value: this.props.schema.system ? value || '' : value || I18n$k.getLanguage(),
            selectOptions: languages,
        });
    }
    renderItem(error, disabled) {
        if (!this.state.selectOptions) {
            return null;
        }
        const item = this.state.selectOptions?.find(it => it.value === this.state.value || (!it.value && !this.state.value));
        return (React$w.createElement(FormControl$7, { fullWidth: true, variant: "standard" },
            this.props.schema.label ? React$w.createElement(InputLabel$6, null, this.getText(this.props.schema.label)) : null,
            React$w.createElement(Select$5, { variant: "standard", error: !!error, disabled: disabled, value: this.state.value || '_', renderValue: () => this.getText(item?.label, this.props.schema.noTranslation), onChange: e => {
                    let { value } = e.target;
                    if (value === '_') {
                        value = '';
                    }
                    this.setState({ value }, () => {
                        const mayBePromise = this.onChange(this.props.attr, value);
                        if (mayBePromise instanceof Promise) {
                            void mayBePromise.catch(err => console.error(err));
                        }
                        if (this.props.schema.changeGuiLanguage) {
                            if (value) {
                                if (value === I18n$k.getLanguage()) {
                                    return;
                                }
                                I18n$k.setLanguage(value);
                                if (this.props.oContext.changeLanguage) {
                                    this.props.oContext.changeLanguage();
                                }
                            }
                            else {
                                void this.props.oContext.socket
                                    .getSystemConfig()
                                    .then((systemConfig) => {
                                    if (systemConfig.common.language === I18n$k.getLanguage()) {
                                        return;
                                    }
                                    if (systemConfig.common.language) {
                                        I18n$k.setLanguage(systemConfig.common.language);
                                        if (this.props.oContext.changeLanguage) {
                                            this.props.oContext.changeLanguage();
                                        }
                                    }
                                })
                                    .catch(e => console.error(`Cannot read system config: ${e}`));
                            }
                        }
                    });
                } }, this.state.selectOptions?.map(it => (React$w.createElement(MenuItem$6, { key: it.value, value: it.value }, it.label)))),
            this.props.schema.help ? (React$w.createElement(FormHelperText$5, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$v = await importShared('react');

const {Button: Button$7,Dialog: Dialog$1,DialogActions: DialogActions$1,DialogContent: DialogContent$1,DialogTitle: DialogTitle$1,LinearProgress: LinearProgress$2,FormControlLabel,Checkbox: Checkbox$3} = await importShared('@mui/material');

const {Check,Close} = await importShared('@mui/icons-material');

const {I18n: I18n$j} = await importShared('@iobroker/adapter-react-v5');
class ConfigLicense extends ConfigGeneric {
    scrollRef;
    constructor(props) {
        super(props);
        this.scrollRef = React$v.createRef();
    }
    scrolledDown() {
        if (!this.scrollRef.current) {
            return false;
        }
        return (this.scrollRef.current.offsetHeight + this.scrollRef.current.scrollTop >=
            this.scrollRef.current.scrollHeight);
    }
    componentDidMount() {
        super.componentDidMount();
        if (!ConfigGeneric.getValue(this.props.data, this.props.attr)) {
            if (this.props.schema.licenseUrl) {
                this.setState({ showLicenseDialog: true, loading: true, scrolledDown: false });
                fetch(this.props.schema.licenseUrl)
                    .then(res => res.text())
                    .then(text => this.setState({ license: text, loading: false }))
                    .catch(e => this.setState({
                    license: e.toString(),
                    loading: false,
                    error: true,
                    scrolledDown: false,
                }));
            }
            else {
                this.setState({ showLicenseDialog: true, scrolledDown: false });
            }
            setTimeout(() => {
                // install scroll handler
                if (this.scrollRef.current) {
                    const scrolledDown = this.scrolledDown();
                    if (!scrolledDown) {
                        this.scrollRef.current.addEventListener('scroll', () => {
                            if (!this.state.scrolledDown && this.scrolledDown()) {
                                this.setState({ scrolledDown: true });
                            }
                        });
                    }
                    else {
                        this.setState({ scrolledDown: true });
                    }
                }
            }, 1000);
        }
    }
    renderItem(_error, disabled /*, defaultValue */) {
        if (!this.state.showLicenseDialog) {
            return null;
        }
        return (React$v.createElement(Dialog$1, { maxWidth: "lg", open: true, onClose: (e, reason) => {
                if (reason !== 'escapeKeyDown' && reason !== 'backdropClick') {
                    this.setState({ showLicenseDialog: false });
                }
            } },
            React$v.createElement(DialogTitle$1, null, this.props.schema.title ? I18n$j.t(this.props.schema.title) : I18n$j.t('ra_License agreement')),
            React$v.createElement(DialogContent$1, null,
                this.props.schema.licenseUrl ? (React$v.createElement(React$v.Fragment, null,
                    this.state.loading ? React$v.createElement(LinearProgress$2, null) : null,
                    React$v.createElement("pre", { ref: this.scrollRef, style: {
                            width: '100%',
                            height: '100%',
                            overflowY: 'auto',
                            fontSize: 14,
                        } }, this.state.license))) : null,
                !this.props.schema.licenseUrl && this.props.schema.texts ? (React$v.createElement("div", { ref: this.scrollRef, style: {
                        width: '100%',
                        height: '100%',
                        overflowY: 'auto',
                        fontSize: 14,
                    } }, this.props.schema.texts.map((text, i) => this.props.schema.noTranslation ? React$v.createElement("p", { key: i }, text) : React$v.createElement("p", { key: i }, I18n$j.t(text))))) : null),
            React$v.createElement(DialogActions$1, null,
                this.props.schema.checkBox ? (React$v.createElement(FormControlLabel, { control: React$v.createElement(Checkbox$3, { disabled: disabled, checked: !!this.state.licenseChecked, onClick: () => this.setState({ licenseChecked: !this.state.licenseChecked }) }), label: I18n$j.t(this.props.schema.checkBox) })) : null,
                React$v.createElement(Button$7, { disabled: disabled ||
                        this.state.loading ||
                        this.state.error ||
                        (this.props.schema.checkBox && !this.state.licenseChecked) ||
                        !this.state.scrolledDown, onClick: () => {
                        this.setState({ showLicenseDialog: false });
                        const mayBePromise = this.onChange(this.props.attr, true);
                        if (mayBePromise instanceof Promise) {
                            mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
                        }
                    }, color: "primary", variant: "contained", startIcon: React$v.createElement(Check, null) }, this.props.schema.agreeText
                    ? I18n$j.t(this.props.schema.agreeText)
                    : I18n$j.t('ra_Accept license')),
                React$v.createElement(Button$7, { onClick: () => {
                        this.setState({ showLicenseDialog: false });
                        setTimeout(() => this.setState({ showLicenseDialog: true }), 2000);
                    }, color: "grey", variant: "contained", startIcon: React$v.createElement(Close, null) }, I18n$j.t('ra_Close')))));
    }
}

const React$u = await importShared('react');

const {Autocomplete: Autocomplete$1,TextField: TextField$d,FormControl: FormControl$6} = await importShared('@mui/material');

const {I18n: I18n$i} = await importShared('@iobroker/adapter-react-v5');
const styles$k = {
    indeterminate: {
        opacity: 0.5,
    },
    control: {
        flexDirection: 'row',
        width: '100%',
    },
};
class ConfigNumber extends ConfigGeneric {
    updateTimeout;
    componentDidMount() {
        super.componentDidMount();
        let _value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        if (_value === null || _value === undefined) {
            _value = '';
        }
        if (Array.isArray(_value) && this.props.oContext.multiEdit) {
            _value = ConfigGeneric.DIFFERENT_VALUE;
            this.setState({ _value, oldValue: _value });
            return;
        }
        this.setState({ _value: _value.toString(), oldValue: _value.toString() });
    }
    static getDerivedStateFromProps(props, state) {
        if ((props.schema.min !== undefined && props.schema.min < 0) ||
            (props.schema.max !== undefined && props.schema.max < 0)) {
            return null;
        }
        const _value = ConfigGeneric.getValue(props.data, props.attr);
        if (props.oContext.multiEdit && state._value === ConfigGeneric.DIFFERENT_VALUE) {
            return { _value: ConfigGeneric.DIFFERENT_VALUE };
        }
        if (_value === null ||
            _value === undefined ||
            state.oldValue === null ||
            state.oldValue === undefined ||
            (_value.toString() !== parseFloat(state._value).toString() &&
                _value.toString() !== state.oldValue.toString())) {
            return { _value };
        }
        return null;
    }
    checkValue(value) {
        if (value === null || value === undefined) {
            return null;
        }
        value = value.toString().trim().replace(',', '.');
        if (value === '-') {
            // User wants to enter a negative number
            return null;
        }
        const f = value === '' ? 0 : parseFloat(value);
        if (value !== '' && Number.isNaN(f)) {
            return 'ra_Not a number';
        }
        if (value !== '' && window.isFinite(f)) {
            if (this.props.schema.min !== undefined && f < this.props.schema.min) {
                return 'ra_Too small';
            }
            if (this.props.schema.max !== undefined && f > this.props.schema.max) {
                return 'ra_Too big';
            }
            if (value === '' || value === '-' || Number.isNaN(f)) {
                return 'ra_Not a number';
            }
            return null;
        }
        return 'ra_Not a number';
    }
    renderItem(error, disabled) {
        const isIndeterminate = Array.isArray(this.state._value) || this.state._value === ConfigGeneric.DIFFERENT_VALUE;
        if (this.state.oldValue !== null && this.state.oldValue !== undefined) {
            if (this.updateTimeout) {
                clearTimeout(this.updateTimeout);
            }
            this.updateTimeout = setTimeout(() => {
                this.updateTimeout = undefined;
                this.setState({ oldValue: null });
            }, 30);
        }
        else if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
            this.updateTimeout = undefined;
        }
        if (isIndeterminate) {
            const autoCompleteOptions = ConfigGeneric.getValue(this.props.data, this.props.attr);
            const arr = autoCompleteOptions
                ?.filter((a) => a || a === 0)
                .map((item) => ({ label: item.toString(), value: item })) || [];
            arr.unshift({ label: I18n$i.t(ConfigGeneric.DIFFERENT_LABEL), value: ConfigGeneric.DIFFERENT_VALUE });
            return (React$u.createElement(Autocomplete$1, { style: styles$k.indeterminate, fullWidth: true, freeSolo: true, value: arr[0], 
                // @ts-expect-error needs investigation if this really has no effect
                getOptionSelected: (option, value) => option.label === value.label, onChange: (_, value) => {
                    const mayBePromise = this.onChange(this.props.attr, value?.value, () => {
                        this.setState({ _value: value?.value, oldValue: this.state._value });
                    });
                    if (mayBePromise instanceof Promise) {
                        mayBePromise.catch(e => console.error(e));
                    }
                }, options: arr, getOptionLabel: (option) => option.label, renderInput: params => (React$u.createElement(TextField$d, { ...params, label: this.getText(this.props.schema.label), variant: "standard", slotProps: {
                        htmlInput: {
                            ...params.inputProps,
                            readOnly: this.props.schema.readOnly || false,
                        },
                        input: {
                            endAdornment: this.props.schema.unit
                                ? this.getText(this.props.schema.unit, this.props.schema.noTranslation)
                                : undefined,
                        },
                    }, error: !!error, placeholder: this.getText(this.props.schema.placeholder), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation), disabled: !!disabled })) }));
        }
        if (!error && this.state._value !== null && this.state._value !== undefined && this.state._value) {
            error = this.checkValue(this.state._value);
            if (error) {
                error = I18n$i.t(error);
            }
        }
        const parsed = parseFloat(this.state._value?.toString().replace(',', '.') || '');
        return (React$u.createElement(FormControl$6, { variant: "standard", style: styles$k.control },
            React$u.createElement(TextField$d, { sx: {
                    '& .up-down': {
                        display: 'none',
                    },
                    '&:hover .up-down': {
                        display: 'block',
                    },
                }, variant: "standard", type: 
                // because some users want to enter "-" first
                Number.isNaN(parsed)
                    ? 'text'
                    : this.props.schema.min !== undefined && this.props.schema.min >= 0
                        ? 'number'
                        : 'text', fullWidth: true, slotProps: {
                    htmlInput: {
                        min: this.props.schema.min,
                        max: this.props.schema.max,
                        step: this.props.schema.step,
                        readOnly: this.props.schema.readOnly || false,
                    },
                    input: {
                        endAdornment: this.props.schema.unit
                            ? this.getText(this.props.schema.unit, this.props.schema.noTranslation)
                            : null,
                    },
                }, value: this.state._value === null || this.state._value === undefined ? '' : this.state._value, error: !!error, disabled: !!disabled, onChange: e => {
                    const _value = e.target.value; // value is always a string and it is validly formatted
                    const _error = this.checkValue(_value);
                    if (_error) {
                        this.onError(this.props.attr, I18n$i.t(_error));
                    }
                    else {
                        this.onError(this.props.attr); // clear error
                    }
                    this.setState({ _value, oldValue: this.state._value }, () => {
                        const parsed = parseFloat(_value.toString().replace(',', '.'));
                        if (!Number.isNaN(parsed)) {
                            void this.onChange(this.props.attr, parsed);
                        }
                        else {
                            void this.onChange(this.props.attr, _value.toString().replace(',', '.'));
                        }
                    });
                }, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: error && typeof error === 'string'
                    ? error
                    : this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) })));
    }
}

const React$t = await importShared('react');

const {Button: Button$6,TextField: TextField$c} = await importShared('@mui/material');

const {CloudUpload} = await importShared('@mui/icons-material');

const {I18n: I18n$h} = await importShared('@iobroker/adapter-react-v5');
class ConfigOAuth2 extends ConfigGeneric {
    authWindow;
    oid;
    url;
    constructor(props) {
        super(props);
        this.state = {
            ...this.state,
            accessTokens: '',
            success: false,
            blocked: false,
            running: false,
            pressed: false,
        };
        this.url = `https://oauth2.iobroker.in/${props.schema.identifier}?redirect=true`;
        if (props.schema.scope) {
            this.url += `&scope=${encodeURIComponent(props.schema.scope)}`;
        }
        this.oid = `${this.props.oContext.adapterName}.${this.props.oContext.instance}.${this.props.schema.saveTokenIn || 'oauth2Tokens'}`;
    }
    async componentDidMount() {
        super.componentDidMount();
        if (window.addEventListener) {
            window.addEventListener('message', this.onMessage, false);
        }
        else {
            window.attachEvent('onmessage', this.onMessage, false);
        }
        await this.props.oContext.socket.subscribeState(this.oid, this.onTokensUpdated);
        // read tokens
        const tokens = await this.props.oContext.socket.getState(this.oid);
        if (tokens) {
            const accessTokens = JSON.parse(tokens.val);
            if (new Date(accessTokens.access_token_expires_on).getTime() > Date.now()) {
                this.setState({ accessTokens: tokens.val });
            }
        }
    }
    onTokensUpdated = (_id, state) => {
        if (state?.val) {
            const accessTokens = JSON.parse(state.val);
            if (new Date(accessTokens.access_token_expires_on).getTime() > Date.now()) {
                if (this.state.accessTokens !== state.val) {
                    this.setState({ accessTokens: state.val });
                }
                return;
            }
        }
        this.setState({ accessTokens: '' });
    };
    componentWillUnmount() {
        super.componentWillUnmount();
        if (window.removeEventListener) {
            window.removeEventListener('message', this.onMessage, false);
        }
        else {
            window.detachEvent('onmessage', this.onMessage, false);
        }
        this.props.oContext.socket.unsubscribeState(this.oid, this.onTokensUpdated);
    }
    saveToken(accessTokens) {
        try {
            if (accessTokens && !accessTokens.startsWith('{')) {
                // convert base64 to string
                accessTokens = atob(accessTokens);
            }
            const accessTokensParsed = JSON.parse(accessTokens);
            if (accessTokensParsed.access_token && accessTokensParsed.refresh_token && accessTokensParsed.expires_in) {
                // Give 10 seconds to user to copy the token
                accessTokensParsed.access_token_expires_on ||= new Date(Date.now() + accessTokensParsed.expires_in * 1000).toISOString();
                this.props.oContext.socket
                    .setState(this.oid, JSON.stringify(accessTokensParsed), true)
                    .catch((e) => console.log(`Error occurred: ${e.toString()}`));
            }
        }
        catch (e) {
            // ignore
            console.warn(e);
        }
    }
    onMessage = (event) => {
        if (event.origin !== 'https://oauth2.iobroker.in') {
            return;
        }
        if ((typeof event.data === 'string' &&
            event.data.startsWith(`${this.props.schema.identifier}-authentication:`)) ||
            (typeof event.message === 'string' &&
                event.message.startsWith(`${this.props.schema.identifier}-authentication:`))) {
            const parts = (event.data || event.message).split(':');
            if (parts[1] === 'success') {
                this.setState({ accessTokens: parts[2], success: true, pressed: false }, () => this.saveToken(this.state.accessTokens));
                // send message to auth window to close it
                this.authWindow?.postMessage('close', event.origin);
                this.authWindow = null;
            }
            else {
                this.props.onError?.(parts[2]);
            }
        }
    };
    onOpenUrl() {
        this.authWindow = window.open(this.url, this.props.schema.identifier);
        if (!this.authWindow || this.authWindow.closed || typeof this.authWindow.closed === 'undefined') {
            this.setState({ blocked: true });
        }
        else {
            this.setState({ pressed: true });
        }
    }
    renderItem() {
        let validTill = '';
        if (this.state.accessTokens) {
            try {
                const accessTokensParsed = JSON.parse(this.state.accessTokens);
                validTill = new Date(accessTokensParsed.access_token_expires_on).toLocaleString();
            }
            catch {
                // ignore
            }
        }
        let label;
        if (this.state.accessTokens) {
            label = this.props.schema.refreshLabel
                ? this.getText(this.props.schema.refreshLabel)
                : I18n$h.t('ra_Renew %s access', this.props.schema.identifier[0].toUpperCase() + this.props.schema.identifier.slice(1));
        }
        else {
            label = this.props.schema.label
                ? this.getText(this.props.schema.label)
                : I18n$h.t('ra_Get %s access', this.props.schema.identifier[0].toUpperCase() + this.props.schema.identifier.slice(1));
        }
        const icon = this.getIcon();
        return (React$t.createElement("div", { style: { width: '100%', margin: '0 0 1rem 0' } },
            React$t.createElement(Button$6, { disabled: this.state.running, endIcon: icon || React$t.createElement(CloudUpload, null), variant: "contained", onClick: () => this.onOpenUrl() }, label),
            this.state.blocked ? (React$t.createElement("div", { style: { color: 'red', fontSize: 16, marginTop: 20 } }, I18n$h.t('ra_Please allow popups in your browser for this page!'))) : null,
            this.state.accessTokens ? (React$t.createElement("div", { style: { color: 'green', fontSize: 16, marginTop: 20 } }, this.props.alive
                ? I18n$h.t('ra_Successfully authorized. Token valid till %s and will be automatically renewed.', validTill)
                : I18n$h.t('ra_Successfully authorized. Token valid till %s but it can expire as the instance is not running.', validTill))) : null,
            this.state.pressed ? (React$t.createElement(React$t.Fragment, null,
                React$t.createElement("div", { style: { width: '100%', margin: '1rem 0 1rem 0' } },
                    React$t.createElement("span", { style: { marginRight: 4 } },
                        `${I18n$h.t('ra_If the button above does not work, you can authorize manually this app by visiting this url')}`,
                        ":"),
                    React$t.createElement("br", null),
                    React$t.createElement("a", { target: this.props.schema.identifier, href: this.url, rel: "noreferrer" }, this.url)),
                React$t.createElement(TextField$c, { value: this.state.accessTokens, label: I18n$h.t('ra_Enter the code from that page here'), variant: "standard", onChange: e => {
                        let accessTokens = e.target.value;
                        if (accessTokens && !accessTokens.startsWith('{')) {
                            // convert base64 to string
                            accessTokens = atob(accessTokens);
                        }
                        try {
                            const accessTokensParsed = JSON.parse(accessTokens);
                            if (accessTokensParsed.access_token) {
                                accessTokensParsed.access_token_expires_on = new Date(Date.now() + (accessTokensParsed.expires_in - 10) * 1000).toISOString();
                                this.setState({ accessTokens: JSON.stringify(accessTokensParsed) }, () => this.saveToken(this.state.accessTokens));
                            }
                        }
                        catch {
                            // ignore
                        }
                    }, fullWidth: true }))) : null));
    }
}

const React$s = await importShared('react');

const {InputLabel: InputLabel$5,FormControl: FormControl$5,Button: Button$5,TextField: TextField$b} = await importShared('@mui/material');

const {DialogSelectID} = await importShared('@iobroker/adapter-react-v5');
const styles$j = {
    flex: {
        display: 'flex',
    },
    button: {
        height: 48,
        marginLeft: 4,
        minWidth: 48,
    },
};
class ConfigObjectId extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const { data, attr } = this.props;
        const value = ConfigGeneric.getValue(data, attr) || '';
        this.setState({ value, initialized: true });
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (!this.state.initialized) {
            return null;
        }
        const socket = this.props.oContext.socket;
        const { schema, attr } = this.props;
        const { value, showSelectId } = this.state;
        return (React$s.createElement(FormControl$5, { fullWidth: true, variant: "standard" },
            schema.label ? React$s.createElement(InputLabel$5, { shrink: true }, this.getText(schema.label)) : null,
            React$s.createElement("div", { style: styles$j.flex },
                React$s.createElement(TextField$b, { variant: "standard", fullWidth: true, value: value, error: !!error, disabled: disabled, placeholder: this.getText(schema.placeholder), label: this.getText(schema.label), helperText: this.renderHelp(schema.help, schema.helpLink, schema.noTranslation), onChange: e => {
                        const value_ = e.target.value;
                        this.setState({ value: value_ }, () => this.onChange(attr, value_));
                    } }),
                React$s.createElement(Button$5, { color: "grey", disabled: disabled, style: styles$j.button, size: "small", variant: "outlined", onClick: () => this.setState({ showSelectId: true }) }, "...")),
            showSelectId ? (React$s.createElement(DialogSelectID, { imagePrefix: this.props.oContext.imagePrefix === undefined ? '../..' : this.props.oContext.imagePrefix, dialogName: `admin.${this.props.oContext.adapterName}`, filterFunc: schema.filterFunc, themeType: this.props.oContext.themeType, theme: this.props.oContext.theme, types: schema.types ? (Array.isArray(schema.types) ? schema.types : [schema.types]) : undefined, customFilter: schema.customFilter, filters: schema.filters, socket: socket, selected: value, root: schema.root, onClose: () => this.setState({ showSelectId: false }), onOk: value_ => this.setState({ showSelectId: false, value: value_ }, () => this.onChange(attr, value_)) })) : null));
    }
}

const React$r = await importShared('react');

const {TextField: TextField$a,IconButton: IconButton$8,InputAdornment: InputAdornment$3} = await importShared('@mui/material');

const {Visibility: Visibility$1,VisibilityOff} = await importShared('@mui/icons-material');

const {I18n: I18n$g} = await importShared('@iobroker/adapter-react-v5');
const styles$i = {
    fullWidth: {
        width: '100%',
        display: 'inline-block',
    },
    halfWidth1: {
        width: 'calc(50% - 5px)',
        display: 'inline-block',
        marginRight: 8,
    },
    halfWidth2: {
        width: 'calc(50% - 5px)',
        display: 'inline-block',
    },
};
const PASSWORD_PLACEHOLDER = '____ppp____';
class ConfigPassword extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        this.setState({
            _repeat: value ? PASSWORD_PLACEHOLDER : '',
            _visible: false,
            value: value ? PASSWORD_PLACEHOLDER : '',
            _notEqual: false,
        });
    }
    onChangePassword(password, repeatPassword) {
        if (password === undefined) {
            password = this.state.value;
        }
        if (repeatPassword === undefined) {
            repeatPassword = this.state._repeat;
        }
        const _notEqual = !!this.props.schema.repeat && repeatPassword !== password;
        this.setState({ value: password, _repeat: repeatPassword, _notEqual }, () => {
            if (_notEqual) {
                this.onError(this.props.attr, I18n$g.t('ra_Passwords are not equal!'));
            }
            else {
                this.onError(this.props.attr); // clear error
                const mayBePromise = this.onChange(this.props.attr, password);
                if (mayBePromise instanceof Promise) {
                    mayBePromise.catch(e => this.onError(this.props.attr, e));
                }
            }
        });
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (this.state._notEqual === undefined) {
            return null;
        }
        const password = (React$r.createElement(TextField$a, { variant: "standard", fullWidth: true, type: this.state._visible && this.state.value !== PASSWORD_PLACEHOLDER ? 'text' : 'password', value: this.state.value, error: !!error || this.state._notEqual, disabled: !!disabled, onChange: e => this.onChangePassword(e.target.value), label: this.getText(this.props.schema.label), slotProps: {
                input: {
                    autoComplete: 'new-password',
                    endAdornment: this.state.value &&
                        this.state.value !== PASSWORD_PLACEHOLDER &&
                        this.props.schema.visible &&
                        !disabled &&
                        !this.props.schema.readOnly ? (React$r.createElement(InputAdornment$3, { position: "end" },
                        React$r.createElement(IconButton$8, { size: "large", tabIndex: -1, onClick: e => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.setState({ _visible: !this.state._visible });
                            }, edge: "end" }, this.state._visible ? React$r.createElement(VisibilityOff, null) : React$r.createElement(Visibility$1, null)))) : undefined,
                },
                htmlInput: {
                    autoComplete: 'new-password',
                    form: { autoComplete: 'off' },
                    maxLength: this.props.schema.maxLength || this.props.schema.max || undefined,
                    readOnly: this.props.schema.readOnly || false,
                },
            }, helperText: this.state._notEqual
                ? I18n$g.t('ra_Passwords are not equal!')
                : this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }));
        if (this.props.schema.repeat && !this.props.schema.readOnly) {
            const passwordRepeat = !this.state._visible ? (React$r.createElement(TextField$a, { variant: "standard", fullWidth: true, type: "password", value: this.state._repeat, error: !!error || this.state._notEqual, disabled: !!disabled, onChange: e => this.onChangePassword(undefined, e.target.value), label: `${this.getText(this.props.schema.label)} (${I18n$g.t('ra_repeat')})`, slotProps: {
                    input: {
                        autoComplete: 'new-password',
                    },
                    htmlInput: {
                        autoComplete: 'new-password',
                        form: { autoComplete: 'off' },
                        maxLength: this.props.schema.maxLength || this.props.schema.max || undefined,
                    },
                }, helperText: this.state._notEqual
                    ? I18n$g.t('ra_Passwords are not equal!')
                    : this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) })) : null;
            return (React$r.createElement("div", { style: styles$i.fullWidth },
                React$r.createElement("div", { style: styles$i.halfWidth1 }, password),
                React$r.createElement("div", { style: styles$i.halfWidth2 }, passwordRepeat)));
        }
        return password;
    }
}

const React$q = await importShared('react');

const {IconButton: IconButton$7,TextField: TextField$9} = await importShared('@mui/material');

const {I18n: I18n$f,IconCopy: IconCopy$3,Utils: Utils$9} = await importShared('@iobroker/adapter-react-v5');
class ConfigPattern extends ConfigGeneric {
    renderItem(_error, disabled) {
        return (React$q.createElement(TextField$9, { variant: "standard", fullWidth: true, disabled: !!disabled, slotProps: {
                input: {
                    endAdornment: this.props.schema.copyToClipboard ? (React$q.createElement(IconButton$7, { tabIndex: -1, size: "small", onClick: () => {
                            Utils$9.copyToClipboard(this.getPattern(this.props.schema.pattern, null, this.props.schema.noTranslation));
                            window.alert(I18n$f.t('ra_Copied'));
                        } },
                        React$q.createElement(IconCopy$3, null))) : undefined,
                },
            }, value: this.getPattern(this.props.schema.pattern, null, true), label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }));
    }
}

const React$p = await importShared('react');

const {TextField: TextField$8} = await importShared('@mui/material');

const {I18n: I18n$e} = await importShared('@iobroker/adapter-react-v5');
const styles$h = {
    warning: {
        '& .Mui-error': {
            color: 'orange',
        },
    },
};
class ConfigPort extends ConfigGeneric {
    updateTimeout;
    async componentDidMount() {
        super.componentDidMount();
        let _value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        if (_value === null || _value === undefined) {
            _value = '';
        }
        this.setState({ _value: _value.toString(), oldValue: _value.toString() });
        // read all instances
        const instances = await this.props.oContext.socket.getAdapterInstances();
        const ownId = `system.adapter.${this.props.oContext.adapterName}.${this.props.oContext.instance}`;
        const instanceObj = (await this.props.oContext.socket.getObject(ownId));
        const ownHostname = instanceObj?.common.host;
        const ports = [];
        instances.forEach(instance => {
            // ignore own instance and instances on another host
            if (!instance || instance._id === ownId || instance.common.host !== ownHostname) {
                return;
            }
            // check port only if bind attribute is present too
            if (!instance.native?.bind) {
                return;
            }
            // if let's encrypt is enabled and update is enabled, then add port to check
            if (instance?.native && instance.native.secure && instance.native.leEnabled && instance.native.leUpdate) {
                const port = parseInt(instance.native.leCheckPort || instance.native.lePort, 10);
                if (port) {
                    ports.push({
                        name: `${instance._id.replace('system.adapter.', '')} (LE)`,
                        port,
                        v6bind: instance.native.bind.includes(':') ? instance.native.bind : instance.native.v6bind,
                        bind: instance.native.bind,
                        enabled: !!instance.common?.enabled,
                    });
                }
            }
            const port = parseInt(instance?.native?.port, 10);
            if (port) {
                ports.push({
                    name: instance._id.replace('system.adapter.', ''),
                    bind: instance.native.bind,
                    v6bind: instance.native.bind.includes(':') ? instance.native.bind : instance.native.v6bind,
                    port,
                    enabled: !!instance.common?.enabled,
                });
            }
        });
        this.setState({ ports });
    }
    static getDerivedStateFromProps(props, state) {
        const _value = ConfigGeneric.getValue(props.data, props.attr);
        if (_value === null ||
            _value === undefined ||
            state.oldValue === null ||
            state.oldValue === undefined ||
            (_value.toString() !== parseInt(state._value, 10).toString() &&
                _value.toString() !== state.oldValue.toString())) {
            return { _value };
        }
        return null;
    }
    checkValue(value) {
        if (value === null || value === undefined) {
            return null;
        }
        const min = this.props.schema.min === undefined ? 20 : this.props.schema.min;
        const max = this.props.schema.max || 0xffff;
        value = value.toString().trim();
        const f = value === '' ? 0 : parseInt(value, 10);
        if (value !== '' && Number.isNaN(f)) {
            return 'ra_Not a number';
        }
        if (value !== '' && window.isFinite(Number(value))) {
            if (f < min) {
                return 'ra_Too small';
            }
            if (f > max) {
                return 'ra_Too big';
            }
            if (value === '' || value === '-' || Number.isNaN(f)) {
                return 'ra_Not a number';
            }
            return null;
        }
        return 'ra_Not a number';
    }
    renderItem(error, disabled) {
        if (this.state.oldValue !== null && this.state.oldValue !== undefined) {
            if (this.updateTimeout) {
                clearTimeout(this.updateTimeout);
            }
            this.updateTimeout = setTimeout(() => {
                this.updateTimeout = undefined;
                this.setState({ oldValue: null });
            }, 30);
        }
        else if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
            this.updateTimeout = undefined;
        }
        const min = this.props.schema.min === undefined ? 20 : this.props.schema.min;
        const max = this.props.schema.max || 0xffff;
        let warning;
        if (this.state.ports) {
            const num = parseInt(this.state._value, 10);
            if (num) {
                // Filter ports that would actually conflict with our configuration
                // A port conflict occurs when:
                // 1. Same port AND (no bind address specified OR bind addresses would conflict)
                // 2. Bind addresses conflict when:
                //    - Both bind to the same specific IP address, OR
                //    - One binds to 0.0.0.0/:: (all interfaces) and the other to any address, OR
                //    - One binds to a specific IP and the other binds to 0.0.0.0/::
                const currentBind = this.props.data.bind;
                const ports = this.state.ports.filter(item => {
                    if (item.port !== num) {
                        return false; // Different port, no conflict
                    }
                    // Same port, check if bind addresses would conflict
                    const itemBind = item.bind;
                    const itemV6bind = item.v6bind;
                    // If current config has no bind address, use old behavior (check all)
                    if (!currentBind) {
                        return true;
                    }
                    // If other adapter has no bind address, assume it could conflict
                    if (!itemBind) {
                        return true;
                    }
                    // Check for IPv4 conflicts
                    if (currentBind === '0.0.0.0' || itemBind === '0.0.0.0') {
                        // One binds to all interfaces, so there's a conflict
                        return true;
                    }
                    // Check for IPv6 conflicts
                    if (currentBind === '::' || itemV6bind === '::') {
                        // One binds to all IPv6 interfaces, so there's a conflict
                        return true;
                    }
                    // Check for exact bind address match
                    if (currentBind === itemBind || currentBind === itemV6bind) {
                        return true;
                    }
                    // Different specific bind addresses, no conflict
                    return false;
                });
                let idx = ports.findIndex(item => item.port === num && item.enabled);
                if (idx !== -1) {
                    // Find the original port info to get the correct name
                    const originalPort = this.state.ports.find(p => p.port === num && p.enabled && ports.some(fp => fp.name === p.name && fp.bind === p.bind));
                    error = I18n$e.t('ra_Port is already used by %s', originalPort?.name || ports[idx].name);
                }
                else {
                    idx = ports.findIndex(item => item.port === num && !item.enabled);
                    if (idx !== -1) {
                        warning = true;
                        const originalPort = this.state.ports.find(p => p.port === num &&
                            !p.enabled &&
                            ports.some(fp => fp.name === p.name && fp.bind === p.bind));
                        error = I18n$e.t('ra_Port could be used by %s', originalPort?.name || ports[idx].name);
                    }
                }
            }
        }
        if (!error && this.state._value !== null && this.state._value !== undefined) {
            error = this.checkValue(this.state._value);
            if (typeof error === 'string') {
                error = I18n$e.t(error);
            }
        }
        return (React$p.createElement(TextField$8, { variant: "standard", type: "number", fullWidth: true, slotProps: {
                htmlInput: {
                    min,
                    max,
                    readOnly: this.props.schema.readOnly || false,
                },
            }, value: this.state._value === null || this.state._value === undefined ? '' : this.state._value, error: !!error, disabled: !!disabled, sx: warning ? styles$h.warning : undefined, onChange: e => {
                const _value = Number(e.target.value.toString().replace(/[^0-9]/g, '')).toString();
                const _error = this.checkValue(_value);
                if (_error) {
                    this.onError(this.props.attr, I18n$e.t(_error));
                }
                else {
                    this.onError(this.props.attr); // clear error
                }
                this.setState({ _value, oldValue: this.state._value }, () => {
                    if (_value.trim() === parseInt(_value, 10).toString()) {
                        const maybePromise = this.onChange(this.props.attr, parseInt(_value, 10) || 0);
                        if (maybePromise instanceof Promise) {
                            maybePromise.catch(err => {
                                console.error(`Cannot set value for ${this.props.attr}: ${err}`);
                            });
                        }
                    }
                });
            }, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: error && typeof error === 'string'
                ? error
                : this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }));
    }
}

const React$o = await importShared('react');

const {InputLabel: InputLabel$4,MenuItem: MenuItem$5,FormHelperText: FormHelperText$4,FormControl: FormControl$4,Select: Select$4} = await importShared('@mui/material');

const {TextWithIcon,I18n: I18n$d} = await importShared('@iobroker/adapter-react-v5');
class ConfigRoom extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        void this.props.oContext.socket
            .getEnums('rooms')
            .then(enums => {
            const selectOptions = Object.keys(enums).map(id => ({
                value: this.props.schema.short ? id.replace('enum.rooms.', '') : id,
                label: this.getText(enums[id].common.name),
                obj: enums[id],
            }));
            if (this.props.schema.allowDeactivate !== false) {
                selectOptions.unshift({ label: I18n$d.t(ConfigGeneric.NONE_LABEL), value: ConfigGeneric.NONE_VALUE });
            }
            this.setState({ value, selectOptions });
        })
            .catch(e => console.error(`Cannot get enums: ${e}`));
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (!this.state.selectOptions) {
            return null;
        }
        const item = this.state.selectOptions.find(it => it.value === this.state.value);
        return (React$o.createElement(FormControl$4, { variant: "standard", fullWidth: true },
            this.props.schema.label ? React$o.createElement(InputLabel$4, null, this.getText(this.props.schema.label)) : null,
            React$o.createElement(Select$4, { variant: "standard", error: !!error, disabled: !!disabled, value: this.state.value || '_', renderValue: () => item ? (item.obj ? (React$o.createElement(TextWithIcon, { value: item.obj, themeType: this.props.oContext.themeType, lang: I18n$d.getLanguage() })) : (item.label)) : (''), onChange: e => {
                    this.setState({ value: e.target.value === '_' ? '' : e.target.value }, () => this.onChange(this.props.attr, this.state.value));
                } }, this.state.selectOptions.map(it => (React$o.createElement(MenuItem$5, { key: it.value, value: it.value, style: it.value === ConfigGeneric.DIFFERENT_VALUE ? { opacity: 0.5 } : {} }, it.obj ? (React$o.createElement(TextWithIcon, { value: it.obj, themeType: this.props.oContext.themeType, lang: I18n$d.getLanguage() })) : (it.label))))),
            this.props.schema.help ? (React$o.createElement(FormHelperText$4, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$n = await importShared('react');

const {InputLabel: InputLabel$3,FormHelperText: FormHelperText$3,FormControl: FormControl$3,Select: Select$3,MenuItem: MenuItem$4,ListSubheader: ListSubheader$1,Chip: Chip$1,ListItemText: ListItemText$1,Checkbox: Checkbox$2} = await importShared('@mui/material');

const {I18n: I18n$c} = await importShared('@iobroker/adapter-react-v5');
const styles$g = {
    noMargin: {
        '&>div': {
            marginTop: 0,
        },
    },
};
class ConfigSelect extends ConfigGeneric {
    initialValue = '';
    componentDidMount() {
        super.componentDidMount();
        let value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        if (this.props.schema.multiple) {
            if (typeof value === 'string') {
                value = [value];
            }
            else if (value === null || value === undefined) {
                value = [];
            }
        }
        const selectOptions = [];
        (this.props.schema.options || []).forEach(item => {
            // if optgroup
            const groupItem = item;
            if (Array.isArray(groupItem.items)) {
                selectOptions.push({
                    label: this.getText(item.label, this.props.schema.noTranslation),
                    value: item.value,
                    group: true,
                    color: item.color,
                });
                groupItem.items.forEach(it => selectOptions.push({
                    label: this.getText(it.label, this.props.schema.noTranslation),
                    value: it.value,
                    hidden: it.hidden,
                    color: item.color,
                }));
            }
            else {
                selectOptions.push({
                    label: this.getText(item.label, this.props.schema.noTranslation),
                    value: item.value,
                    hidden: item.hidden,
                    color: item.color,
                });
            }
        });
        // if __different
        if (Array.isArray(value) && !this.props.schema.multiple) {
            this.initialValue = [...value];
            selectOptions.unshift({
                label: I18n$c.t(ConfigGeneric.DIFFERENT_LABEL),
                value: ConfigGeneric.DIFFERENT_VALUE,
            });
            this.setState({ value: ConfigGeneric.DIFFERENT_VALUE, selectOptions });
        }
        else {
            this.setState({ value, selectOptions });
        }
    }
    _getValue() {
        let value = this.state.value === null || this.state.value === undefined
            ? ConfigGeneric.getValue(this.props.data, this.props.attr)
            : this.state.value;
        if (this.props.schema.multiple) {
            if (typeof value === 'string') {
                value = [value];
            }
            else if (value === null || value === undefined) {
                value = [];
            }
        }
        return value;
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (!this.state.selectOptions) {
            return null;
        }
        const selectOptions = (this.state.selectOptions || []).filter(item => {
            // if optgroup or no hidden function
            if (!item.hidden) {
                return true;
            }
            if (this.props.custom) {
                return !this.executeCustom(item.hidden, this.props.data, this.props.customObj, this.props.oContext.instanceObj, this.props.arrayIndex, this.props.globalData);
            }
            return !this.execute(item.hidden, this.props.schema.default, this.props.data, this.props.arrayIndex, this.props.globalData);
        });
        const value = this._getValue();
        const item = this.props.schema.multiple ? null : selectOptions.find(it => it.value == value); // let "==" be and not ===
        return (React$n.createElement(FormControl$3, { variant: "standard", fullWidth: true, sx: this.props.table !== undefined && styles$g.noMargin, id: `jsonSelect_${this.props.attr}_${this.props.index || this.props.index === 0 ? this.props.index : ''}` },
            this.props.schema.label ? React$n.createElement(InputLabel$3, null, this.getText(this.props.schema.label)) : null,
            React$n.createElement(Select$3, { variant: "standard", error: !!error, multiple: this.props.schema.multiple, disabled: !!disabled, value: value || '_', renderValue: (val) => this.props.schema.multiple ? (React$n.createElement("div", { style: { display: 'flex', flexWrap: 'wrap', gap: 0.5 } }, val.map((v) => {
                    const it = selectOptions.find(_item => _item.value === v);
                    if (it || this.props.schema.showAllValues !== false) {
                        const label = it?.label || v;
                        return (React$n.createElement(Chip$1, { key: v, label: label }));
                    }
                    return null;
                }))) : item?.color ? (React$n.createElement("div", { style: { color: item.color } }, item?.label === undefined ? val : item.label)) : item?.label === undefined ? (val) : (item.label), onChange: e => {
                    this.setState({ value: e.target.value === '_' ? '' : e.target.value }, () => {
                        let mayBePromise;
                        if (this.state.value === ConfigGeneric.DIFFERENT_VALUE) {
                            mayBePromise = this.onChange(this.props.attr, this.initialValue);
                        }
                        else {
                            mayBePromise = this.onChange(this.props.attr, this.state.value);
                        }
                        if (mayBePromise instanceof Promise) {
                            mayBePromise.catch(e => console.error(e));
                        }
                    });
                } }, selectOptions.map((it, i) => {
                if (it.group) {
                    return (React$n.createElement(ListSubheader$1, { key: i, style: { color: it.color } }, it.label));
                }
                return (React$n.createElement(MenuItem$4, { key: i, value: it.value, style: it.value === ConfigGeneric.DIFFERENT_VALUE ? { opacity: 0.5 } : {} },
                    this.props.schema.multiple ? (React$n.createElement(Checkbox$2, { checked: value.includes(it.value), onClick: () => {
                            const _value = JSON.parse(JSON.stringify(this._getValue()));
                            const pos = value.indexOf(it.value);
                            if (pos !== -1) {
                                _value.splice(pos, 1);
                            }
                            else {
                                _value.push(it.value);
                                _value.sort();
                            }
                            this.setState({ value: _value }, () => this.onChange(this.props.attr, _value));
                        } })) : null,
                    React$n.createElement(ListItemText$1, { primary: it.label, style: { color: it.color } })));
            })),
            this.props.schema.help ? (React$n.createElement(FormHelperText$3, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$m = await importShared('react');

const {InputLabel: InputLabel$2,MenuItem: MenuItem$3,FormHelperText: FormHelperText$2,FormControl: FormControl$2,Select: Select$2,TextField: TextField$7,CircularProgress: CircularProgress$1,ListItemText,Checkbox: Checkbox$1,Chip,Box: Box$8,InputAdornment: InputAdornment$2,IconButton: IconButton$6,ListSubheader} = await importShared('@mui/material');

const {Close:CloseIcon$2} = await importShared('@mui/icons-material');

const {I18n: I18n$b} = await importShared('@iobroker/adapter-react-v5');
const styles$f = {
    menuPaper: {
        maxHeight: 800,
    },
};
class ConfigSelectSendTo extends ConfigGeneric {
    initialized = false;
    localContext;
    askInstance() {
        if (this.props.alive) {
            let data = this.props.schema.data;
            if (data === undefined && this.props.schema.jsonData) {
                const dataStr = this.getPattern(this.props.schema.jsonData, null, true);
                try {
                    data = JSON.parse(dataStr);
                }
                catch {
                    console.error(`Cannot parse json data: ${dataStr}`);
                }
            }
            if (data === undefined) {
                data = null;
            }
            this.setState({ running: true }, () => {
                void this.props.oContext.socket
                    .sendTo(`${this.props.oContext.adapterName}.${this.props.oContext.instance}`, this.props.schema.command || 'send', data)
                    .then(list => this.setState({ list, running: false }))
                    .catch(e => {
                    console.error(`Cannot send command: ${e}`);
                });
            });
        }
        else {
            const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
            this.setState({ value, running: false });
        }
    }
    getContext() {
        const localContext = {};
        if (Array.isArray(this.props.schema.alsoDependsOn)) {
            this.props.schema.alsoDependsOn.forEach(attr => (localContext[attr] = ConfigGeneric.getValue(this.props.data, attr)));
        }
        return JSON.stringify(localContext);
    }
    _getValue() {
        let value = this.state.value === null || this.state.value === undefined
            ? ConfigGeneric.getValue(this.props.data, this.props.attr)
            : this.state.value;
        if (this.props.schema.multiple) {
            if (typeof value === 'string') {
                value = [value];
            }
            else if (value === null || value === undefined) {
                value = [];
            }
        }
        return value;
    }
    renderItem(error, disabled /* , defaultValue */) {
        if (this.props.alive) {
            const localContext = this.getContext();
            if (localContext !== this.localContext || !this.initialized) {
                this.localContext = localContext;
                setTimeout(() => this.askInstance(), this.initialized ? 300 : 50);
                this.initialized = true;
            }
        }
        const value = this._getValue();
        if (!this.props.alive || (!this.state.running && !Array.isArray(this.state.list))) {
            if (this.props.schema.multiple || this.props.schema.manual === false) {
                return I18n$b.t('ra_Cannot retrieve options, as instance is offline');
            }
            return (React$m.createElement(TextField$7, { variant: "standard", fullWidth: true, value: value, error: !!error, disabled: !!disabled, onChange: e => {
                    const value_ = e.target.value;
                    this.setState({ value: value_ }, () => this.onChange(this.props.attr, (value_ || '').trim()));
                }, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation), slotProps: {
                    input: {
                        endAdornment: this.state.value && !this.props.schema.noClearButton ? (React$m.createElement(InputAdornment$2, { position: "end" },
                            React$m.createElement(IconButton$6, { tabIndex: -1, size: "small", onClick: () => this.setState({ value: '' }, () => this.onChange(this.props.attr, '')) },
                                React$m.createElement(CloseIcon$2, null)))) : null,
                    },
                } }));
        }
        if (this.state.running) {
            return React$m.createElement(CircularProgress$1, { size: "24" });
        }
        const selectOptions = this.state.list.filter(item => {
            if (!item.hidden) {
                return true;
            }
            if (this.props.custom) {
                return !this.executeCustom(item.hidden, this.props.data, this.props.customObj, this.props.oContext.instanceObj, this.props.arrayIndex, this.props.globalData);
            }
            return !this.execute(item.hidden, this.props.schema.default, this.props.data, this.props.arrayIndex, this.props.globalData);
        });
        const item = selectOptions.find(it => it.value === value);
        return (React$m.createElement(FormControl$2, { variant: "standard", fullWidth: true },
            this.props.schema.label ? React$m.createElement(InputLabel$2, null, this.getText(this.props.schema.label)) : null,
            React$m.createElement(Select$2, { variant: "standard", error: !!error, multiple: this.props.schema.multiple, disabled: !!disabled, 
                // MenuProps={this.props.schema.multiple ? { classes: { paper: this.props.classes.menuPaper } } : undefined}
                sx: {
                    '&.MuiSelect-paper': this.props.schema.multiple ? styles$f.menuPaper : undefined,
                }, value: value, renderValue: (val) => this.props.schema.multiple ? (React$m.createElement(Box$8, { sx: { display: 'flex', flexWrap: 'wrap', gap: 0.5 } }, val.map((v) => {
                    const it = selectOptions.find(_item => _item.value === v);
                    if (it || this.props.schema.showAllValues !== false) {
                        const label = it?.label || v;
                        return (React$m.createElement(Chip, { key: v, label: label }));
                    }
                    return null;
                }))) : (this.getText(item?.label || val, this.props.schema.noTranslation)), onChange: e => {
                    const mayBePromise = this.onChange(this.props.attr, e.target.value);
                    if (mayBePromise instanceof Promise) {
                        mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
                    }
                } }, selectOptions.map((it, i) => {
                if (it.group) {
                    return (React$m.createElement(ListSubheader, { key: i }, this.getText(it.label, this.props.schema.noTranslation)));
                }
                return (React$m.createElement(MenuItem$3, { key: i, value: it.value },
                    this.props.schema.multiple ? (React$m.createElement(Checkbox$1, { checked: value.includes(it.value), onClick: () => {
                            const _value = JSON.parse(JSON.stringify(this._getValue()));
                            const pos = value.indexOf(it.value);
                            if (pos !== -1) {
                                _value.splice(pos, 1);
                            }
                            else {
                                _value.push(it.value);
                                _value.sort();
                            }
                            this.setState({ value: _value }, () => this.onChange(this.props.attr, _value));
                        } })) : null,
                    React$m.createElement(ListItemText, { primary: it.label })));
            })),
            this.props.schema.help ? (React$m.createElement(FormHelperText$2, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$l = await importShared('react');

const {Button: Button$4,CircularProgress} = await importShared('@mui/material');

const {Warning:IconWarning$1,Error:IconError$1,Info:IconInfo$1} = await importShared('@mui/icons-material');

const {DialogConfirm: DialogConfirm$2,DialogError,DialogMessage,I18n: I18n$a} = await importShared('@iobroker/adapter-react-v5');
const styles$e = {
    fullWidth: {
        width: '100%',
    },
};
function ip2int(ip) {
    return ip.split('.').reduce((ipInt, octet) => (ipInt << 8) + parseInt(octet, 10), 0) >>> 0;
}
// copied from iobroker.admin/src-rx/src/Utils.js
function findNetworkAddressOfHost(obj, localIp) {
    const networkInterfaces = obj?.native?.hardware?.networkInterfaces;
    if (!networkInterfaces) {
        return null;
    }
    let hostIp;
    // check ipv4 addresses
    Object.keys(networkInterfaces).forEach(inter => networkInterfaces[inter].forEach((ip) => {
        if (ip.internal) {
            return;
        }
        if (localIp.includes(':') && ip.family !== 'IPv6') {
            return;
        }
        if (localIp.includes('.') && !localIp.match(/[^.\d]/) && ip.family !== 'IPv4') {
            return;
        }
        // if ip4 and not docker or wsl
        if (ip.family === 'IPv4' &&
            !ip.address.startsWith('172') &&
            (localIp === '127.0.0.0' || localIp === 'localhost' || localIp.match(/[^.\d]/))) {
            // if DNS name
            hostIp = ip.address;
        }
        else if (!hostIp) {
            if (ip.family === 'IPv4' &&
                localIp.includes('.') &&
                (ip2int(localIp) & ip2int(ip.netmask)) === (ip2int(ip.address) & ip2int(ip.netmask))) {
                hostIp = ip.address;
            }
            else {
                hostIp = ip.address;
            }
        }
    }));
    // check ipv6 addresses
    if (!hostIp) {
        Object.keys(networkInterfaces).forEach(inter => networkInterfaces[inter].forEach((ip) => {
            if (ip.internal) {
                return;
            }
            if (localIp.includes(':') && ip.family !== 'IPv6') {
                return;
            }
            if (localIp.includes('.') && !localIp.match(/[^.\d]/) && ip.family !== 'IPv4') {
                return;
            }
            if (ip.family === 'IPv6' &&
                (localIp === '127.0.0.0' || localIp === 'localhost' || localIp.match(/[^.\d]/))) {
                // if DNS name
                hostIp = ip.address;
            }
            else if (!hostIp) {
                if (ip.family === 'IPv4' &&
                    localIp.includes('.') &&
                    (ip2int(localIp) & ip2int(ip.netmask)) === (ip2int(ip.address) & ip2int(ip.netmask))) {
                    hostIp = ip.address;
                }
                else {
                    hostIp = ip.address;
                }
            }
        }));
    }
    if (!hostIp) {
        Object.keys(networkInterfaces).forEach(inter => {
            networkInterfaces[inter].forEach((ip) => {
                if (ip.internal) {
                    return;
                }
                if (localIp.includes(':') && ip.family !== 'IPv6') {
                    return;
                }
                if (localIp.includes('.') && !localIp.match(/[^.\d]/) && ip.family !== 'IPv4') {
                    return;
                }
                if (localIp === '127.0.0.0' || localIp === 'localhost' || localIp.match(/[^.\d]/)) {
                    // if DNS name
                    hostIp = ip.address;
                }
                else {
                    hostIp = ip.address;
                }
            });
        });
    }
    if (!hostIp) {
        Object.keys(networkInterfaces).forEach(inter => {
            networkInterfaces[inter].forEach((ip) => {
                if (ip.internal) {
                    return;
                }
                hostIp = ip.address;
            });
        });
    }
    return hostIp;
}
class ConfigSendto extends ConfigGeneric {
    async componentDidMount() {
        super.componentDidMount();
        let hostname = window.location.hostname;
        if (this.props.schema.openUrl) {
            // read admin host
            const adminInstance = await this.props.oContext.socket.getCurrentInstance();
            const instanceObj = await this.props.oContext.socket.getObject(`system.adapter.${adminInstance}`);
            if (instanceObj) {
                const hostObj = await this.props.oContext.socket.getObject(`system.host.${instanceObj?.common?.host}`);
                if (hostObj) {
                    const ip = findNetworkAddressOfHost(hostObj, window.location.hostname);
                    if (ip) {
                        hostname = `${ip}:${window.location.port}`;
                    }
                    else {
                        console.warn(`Cannot find suitable IP in host ${instanceObj.common.host} for ${instanceObj._id}`);
                        return;
                    }
                }
            }
        }
        await new Promise(resolve => {
            this.setState({ _error: '', _message: '', hostname }, resolve);
        });
        if (this.props.schema.onLoaded) {
            this._onClick();
        }
    }
    renderErrorDialog() {
        if (this.state._error) {
            return (React$l.createElement(DialogError, { text: this.state._error, onClose: () => this.setState({ _error: '' }) }));
        }
        return null;
    }
    renderMessageDialog() {
        if (this.state._message) {
            return (React$l.createElement(DialogMessage, { text: this.state._message, onClose: () => this.setState({ _message: '' }) }));
        }
        return null;
    }
    _onClick() {
        this.props.oContext.onCommandRunning(true);
        this.setState({ running: true });
        const _origin = `${window.location.protocol}//${window.location.host}${window.location.pathname.replace(/\/index\.html$/, '')}`;
        const _originIp = `${window.location.protocol}//${this.state.hostname.split(':').length > 3 ? `[${this.state.hostname}]` : this.state.hostname}${window.location.pathname.replace(/\/index\.html$/, '')}`;
        let data = this.props.schema.data;
        if (data === undefined && this.props.schema.jsonData) {
            const dataStr = this.getPattern(this.props.schema.jsonData, {
                _origin,
                _originIp,
                ...this.props.data,
            }, true);
            try {
                data = JSON.parse(dataStr);
            }
            catch {
                console.error(`Cannot parse json data: ${dataStr}`);
            }
        }
        if (data === undefined) {
            data = null;
        }
        if (this.props.schema.openUrl && !data) {
            data = {
                _origin,
                _originIp,
            };
        }
        let timeout;
        if (this.props.schema.timeout) {
            timeout = setTimeout(() => {
                this.props.oContext.onCommandRunning(false);
                this.setState({ _error: I18n$a.t('ra_Request timed out'), running: false });
            }, parseInt(this.props.schema.timeout, 10) || 10000);
        }
        void this.props.oContext.socket
            .sendTo(`${this.props.oContext.adapterName}.${this.props.oContext.instance}`, this.props.schema.command || 'send', data)
            .then(async (response) => {
            if (timeout) {
                clearTimeout(timeout);
                timeout = undefined;
            }
            if (response?.error) {
                if (this.props.schema.error && this.props.schema.error[response.error]) {
                    let error = this.getText(this.props.schema.error[response.error]);
                    response.args?.forEach((arg) => (error = error.replace('%s', arg)));
                    this.setState({ _error: error });
                }
                else {
                    this.setState({
                        _error: response.error
                            ? typeof response.error === 'string'
                                ? I18n$a.t(response.error)
                                : JSON.stringify(response.error)
                            : I18n$a.t('ra_Error'),
                    });
                }
            }
            else {
                if (response?.command) {
                    // If backend requested to refresh the config
                    this.props.oContext.onBackEndCommand?.(response.command);
                    return;
                }
                if (response?.reloadBrowser && this.props.schema.reloadBrowser) {
                    window.location.reload();
                }
                else if (response?.openUrl && this.props.schema.openUrl) {
                    window.open(response.openUrl, response.window || this.props.schema.window || '_blank');
                }
                else if (response?.result && this.props.schema.result?.[response.result]) {
                    let text = this.getText(this.props.schema.result[response.result]);
                    response.args?.forEach((arg) => (text = text.replace('%s', arg)));
                    window.alert(text);
                }
                if (response?.native && this.props.schema.useNative) {
                    for (const [attr, val] of Object.entries(response.native)) {
                        await this.onChangeAsync(attr, val);
                    }
                    setTimeout(() => this.props.oContext.forceUpdate(Object.keys(response.native), this.props.data), 300);
                }
                else if (response?.result) {
                    window.alert(typeof response.result === 'object' ? JSON.stringify(response.result) : response.result);
                }
                else {
                    window.alert(I18n$a.t('ra_Ok'));
                }
                if (response?.saveConfig) {
                    this.props.onChange(null, null, null, true);
                }
            }
        })
            .catch((e) => {
            if (this.props.schema.error && this.props.schema.error[e.toString()]) {
                this.setState({ _error: this.getText(this.props.schema.error[e.toString()]) });
            }
            else {
                this.setState({ _error: I18n$a.t(e.toString()) || I18n$a.t('ra_Error') });
            }
        })
            .then(() => {
            this.props.oContext.onCommandRunning(false);
            this.setState({ running: false });
        });
    }
    renderDialogConfirm() {
        if (!this.state.confirmDialog) {
            return null;
        }
        const confirm = this.state.confirmData || this.props.schema.confirm;
        let icon = null;
        if (confirm.type === 'warning') {
            icon = React$l.createElement(IconWarning$1, null);
        }
        else if (confirm.type === 'error') {
            icon = React$l.createElement(IconError$1, null);
        }
        else if (confirm.type === 'info') {
            icon = React$l.createElement(IconInfo$1, null);
        }
        return (React$l.createElement(DialogConfirm$2, { title: this.getText(confirm.title) || I18n$a.t('ra_Please confirm'), text: this.getText(confirm.text), ok: this.getText(confirm.ok) || I18n$a.t('ra_Ok'), cancel: this.getText(confirm.cancel) || I18n$a.t('ra_Cancel'), icon: icon || undefined, onClose: isOk => this.setState({ confirmDialog: false }, () => isOk && this._onClick()) }));
    }
    renderItem(error, disabled) {
        const icon = this.getIcon();
        return (React$l.createElement("div", { style: styles$e.fullWidth },
            React$l.createElement(Button$4, { variant: this.props.schema.variant || undefined, color: this.props.schema.color || 'grey', style: { ...styles$e.fullWidth, ...(this.props.schema.controlStyle || undefined) }, disabled: disabled || !this.props.alive, startIcon: icon, title: this.props.alive
                    ? this.getText(this.props.schema.title) || ''
                    : I18n$a.t('ra_Instance is not alive'), onClick: () => {
                    if (this.props.schema.confirm) {
                        this.setState({ confirmDialog: true });
                    }
                    else {
                        this._onClick();
                    }
                } },
                this.props.schema.showProcess && this.state.running ? (React$l.createElement(CircularProgress, { size: 20, style: { marginRight: 8 } })) : null,
                this.getText(this.props.schema.label, this.props.schema.noTranslation)),
            this.renderErrorDialog(),
            this.renderMessageDialog()));
    }
}

const React$k = await importShared('react');

const {Button: Button$3} = await importShared('@mui/material');

const {Warning:IconWarning,Error:IconError,Info:IconInfo} = await importShared('@mui/icons-material');

const {DialogConfirm: DialogConfirm$1,I18n: I18n$9} = await importShared('@iobroker/adapter-react-v5');
const styles$d = {
    fullWidth: {
        width: '100%',
    },
};
class ConfigSetState extends ConfigGeneric {
    async _onClick() {
        let val = this.props.schema.val;
        if (typeof val === 'string' && val.includes('${')) {
            val = this.getPattern(val, null, true);
            const obj = await this.props.oContext.socket.getObject(this.props.schema.id);
            if (obj?.common?.type === 'number') {
                val = parseFloat(val);
            }
            else if (obj?.common?.type === 'boolean') {
                // @ts-expect-error val could be anything
                val = val === 'true' || val === true || val === '1' || val === 1;
            }
        }
        const id = (this.props.schema.id || '').replace(/%INSTANCE%/g, (this.props.oContext.instance || 0).toString());
        try {
            await this.props.oContext.socket.setState(id, { val, ack: !!this.props.schema.ack });
            if (this.props.schema.okText) {
                window.alert(this.getText(this.props.schema.okText));
            }
        }
        catch (e) {
            if (this.props.schema.error && this.props.schema.error[e.toString()]) {
                window.alert(this.getText(this.props.schema.error[e.toString()]));
            }
            else {
                window.alert(I18n$9.t(e.toString()) || I18n$9.t('ra_Error'));
            }
        }
    }
    renderDialogConfirm() {
        if (!this.state.confirmDialog) {
            return null;
        }
        const confirm = this.state.confirmData || this.props.schema.confirm;
        let icon = null;
        if (confirm.type === 'warning') {
            icon = React$k.createElement(IconWarning, null);
        }
        else if (confirm.type === 'error') {
            icon = React$k.createElement(IconError, null);
        }
        else if (confirm.type === 'info') {
            icon = React$k.createElement(IconInfo, null);
        }
        return (React$k.createElement(DialogConfirm$1, { title: this.getText(confirm.title) || I18n$9.t('ra_Please confirm'), text: this.getText(confirm.text), ok: this.getText(confirm.ok) || I18n$9.t('ra_Ok'), cancel: this.getText(confirm.cancel) || I18n$9.t('ra_Cancel'), icon: icon, onClose: isOk => this.setState({ confirmDialog: false }, () => isOk && this._onClick()) }));
    }
    renderItem(_error, disabled /* , defaultValue */) {
        const icon = this.getIcon();
        return (React$k.createElement(Button$3, { variant: this.props.schema.variant || undefined, color: this.props.schema.color || 'grey', style: styles$d.fullWidth, disabled: disabled, onClick: async () => {
                if (this.props.schema.confirm) {
                    this.setState({ confirmDialog: true });
                }
                else {
                    await this._onClick();
                }
            }, startIcon: icon || undefined }, this.getText(this.props.schema.label, this.props.schema.noTranslation)));
    }
}

const React$j = await importShared('react');

const {Box: Box$7,Typography: Typography$2,Slider: Slider$1} = await importShared('@mui/material');
const styles$c = {
    fullWidth: {
        width: '100%',
    },
    slider: {
        marginLeft: 10,
        marginRight: 10,
        width: 'calc(100% - 20px)',
    },
};
class ConfigSlider extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const _value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        this.setState({ _value });
    }
    static getDerivedStateFromProps(props, state) {
        if ((props.schema.min !== undefined && props.schema.min < 0) ||
            (props.schema.max !== undefined && props.schema.max < 0)) {
            return null;
        }
        const _value = ConfigGeneric.getValue(props.data, props.attr);
        if (_value === null ||
            _value === undefined ||
            _value.toString() !== parseFloat(state._value).toString()) {
            return { _value };
        }
        return null;
    }
    renderItem(error, disabled /* , defaultValue */) {
        const min = this.props.schema.min || 0;
        const max = this.props.schema.max || 100;
        const unit = this.props.schema.unit
            ? this.getText(this.props.schema.unit, this.props.schema.noTranslation)
            : '';
        const marks = [
            { value: min, label: min + unit },
            { value: max, label: max + unit },
        ];
        return (React$j.createElement(Box$7, { style: styles$c.fullWidth },
            this.props.schema.label ? (React$j.createElement(Typography$2, { gutterBottom: true }, this.getText(this.props.schema.label))) : null,
            React$j.createElement(Slider$1, { style: styles$c.slider, value: this.state._value, getAriaValueText: value => value + unit, step: this.props.schema.step || (max - min) / 100, valueLabelDisplay: "auto", marks: marks, min: min, max: max, disabled: !!disabled, onChange: e => {
                    const _value = e.target.value;
                    this.setState({ _value }, () => this.onChange(this.props.attr, _value));
                } }),
            this.props.schema.help ? (React$j.createElement(Typography$2, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const React$i = await importShared('react');

const {Add,Delete,Edit,Refresh,Search,Wifi,WifiOff,Visibility,LinkOff,Link:LinkIcon,NotListedLocation,PlayArrow,Stop,FastForward,FastRewind,Pause,Lightbulb,Power,Fluorescent,WbIncandescent,Settings,Group,Person,QrCode} = await importShared('@mui/icons-material');

function getIconByName(name, style) {
    if (name === 'edit' || name === 'rename') {
        return React$i.createElement(Edit, { style: style });
    }
    if (name === 'delete') {
        return React$i.createElement(Delete, { style: style });
    }
    if (name === 'refresh') {
        return React$i.createElement(Refresh, { style: style });
    }
    if (name === 'newDevice' || name === 'new' || name === 'add') {
        return React$i.createElement(Add, { style: style });
    }
    if (name === 'discover' || name === 'search') {
        return React$i.createElement(Search, { style: style });
    }
    if (name === 'unpairDevice' || name === 'unpair') {
        return React$i.createElement(LinkOff, { style: style });
    }
    if (name === 'pairDevice' || name === 'pair') {
        return React$i.createElement(LinkIcon, { style: style });
    }
    if (name === 'identify') {
        return React$i.createElement(NotListedLocation, { style: style });
    }
    if (name === 'play') {
        return React$i.createElement(PlayArrow, { style: style });
    }
    if (name === 'stop') {
        return React$i.createElement(Stop, { style: style });
    }
    if (name === 'pause') {
        return React$i.createElement(Pause, { style: style });
    }
    if (name === 'forward' || name === 'next') {
        return React$i.createElement(FastForward, { style: style });
    }
    if (name === 'rewind' || name === 'previous') {
        return React$i.createElement(FastRewind, { style: style });
    }
    if (name === 'lamp' || name === 'light') {
        return React$i.createElement(Lightbulb, { style: style });
    }
    if (name === 'backlight') {
        return React$i.createElement(Fluorescent, { style: style });
    }
    if (name === 'dimmer') {
        return React$i.createElement(WbIncandescent, { style: style });
    }
    if (name === 'socket') {
        return React$i.createElement(Power, { style: style });
    }
    if (name === 'settings') {
        return React$i.createElement(Settings, { style: style });
    }
    if (name === 'users' || name === 'group') {
        return React$i.createElement(Group, { style: style });
    }
    if (name === 'user') {
        return React$i.createElement(Person, { style: style });
    }
    if (name === 'qrcode') {
        return React$i.createElement(QrCode, { style: style });
    }
    if (name === 'connection') {
        return React$i.createElement(Wifi, { style: style });
    }
    if (name === 'no-connection') {
        return React$i.createElement(WifiOff, { style: style });
    }
    if (name === 'visible') {
        return React$i.createElement(Visibility, { style: style });
    }
    return null;
}

const React$h = await importShared('react');

const {TextField: TextField$6,IconButton: IconButton$5,Button: Button$2,Switch,Slider,Box: Box$6,FormControl: FormControl$1,InputLabel: InputLabel$1,Select: Select$1,MenuItem: MenuItem$2} = await importShared('@mui/material');

const {I18n: I18n$8,Icon: Icon$3} = await importShared('@iobroker/adapter-react-v5');
function valueBlinkOnce$1(theme, color) {
    if (typeof color === 'string') {
        return {
            '@keyframes newStateAnimationOnceColor': {
                '0%': {
                    color,
                },
                '100%': {
                    color: theme.palette.mode === 'dark' ? '#fff' : '#000',
                },
            },
            animation: 'newStateAnimationOnceColor 2s ease-in-out',
        };
    }
    return {
        '@keyframes newStateAnimationOnce': {
            '0%': {
                color: '#00f900',
            },
            '80%': {
                color: theme.palette.mode === 'dark' ? '#518851' : '#008000',
            },
            '100%': {
                color: theme.palette.mode === 'dark' ? '#fff' : '#000',
            },
        },
        animation: 'newStateAnimationOnce 2s ease-in-out',
    };
}
class ConfigState extends ConfigGeneric {
    controlTimeout = null;
    delayedUpdate = {
        timer: null,
        value: null,
    };
    getObjectID() {
        let oid = (this.props.schema.oid || '').toString();
        if (oid.includes('${')) {
            oid = this.getPattern(oid, null, true);
        }
        if (this.props.schema.foreign) {
            return oid;
        }
        return `${this.props.schema.system ? 'system.adapter.' : ''}${this.props.oContext.adapterName}.${this.props.oContext.instance || 0}.${oid}`;
    }
    async componentDidMount() {
        super.componentDidMount();
        const obj = (await this.props.oContext.socket.getObject(this.getObjectID()));
        if (obj?.common?.states && !this.props.schema.options) {
            // Normalize states to object
            if (Array.isArray(obj?.common?.states)) {
                // convert array to object
                const states = {};
                obj.common.states.forEach((state, index) => {
                    states[index.toString()] = state;
                });
                obj.common.states = states;
            }
            if (!Object.keys(obj.common.states).length) {
                obj.common.states = undefined; // remove empty states
            }
        }
        const controlType = this.props.schema.control || this.detectType(obj);
        try {
            const state = await this.props.oContext.socket.getState(this.getObjectID());
            this.setState({ stateValue: state ? state.val : null, controlType, obj }, async () => {
                await this.props.oContext.socket.subscribeState(this.getObjectID(), this.onStateChanged);
            });
        }
        catch (e) {
            console.error(`Cannot get state ${this.getObjectID()}: ${e}`);
            this.setState({ controlType, obj });
        }
    }
    componentWillUnmount() {
        super.componentWillUnmount();
        this.props.oContext.socket.unsubscribeState(this.getObjectID(), this.onStateChanged);
        if (this.delayedUpdate.timer) {
            clearTimeout(this.delayedUpdate.timer);
            this.delayedUpdate.timer = null;
        }
        if (this.controlTimeout) {
            clearTimeout(this.controlTimeout);
            this.controlTimeout = null;
            this.props.oContext.socket
                .setState(this.getObjectID(), this.state.stateValue, false)
                .catch((e) => console.error(`Cannot control value: ${e.toString()}`));
        }
    }
    onStateChanged = (_id, state) => {
        let val = state ? state.val : null;
        if (this.state.controlType === 'button' || this.state.controlType === 'switch') {
            val = !!val;
            if (this.state.stateValue !== val) {
                this.setState({ stateValue: val });
            }
        }
        else if (val !== null && (this.state.controlType === 'slider' || this.state.controlType === 'number')) {
            val = parseFloat(val);
            console.log(`${Date.now()} Received new value: ${val}`);
            if (val !== this.state.stateValue) {
                if (this.delayedUpdate.timer) {
                    clearTimeout(this.delayedUpdate.timer);
                    this.delayedUpdate.timer = null;
                }
                this.delayedUpdate.value = val;
                this.delayedUpdate.timer = setTimeout(() => {
                    this.setState({ stateValue: this.delayedUpdate.value });
                }, 500);
            }
            else if (this.delayedUpdate.timer) {
                clearTimeout(this.delayedUpdate.timer);
                this.delayedUpdate.timer = null;
            }
        }
        else if (this.state.stateValue.toString() !== val.toString()) {
            this.setState({ stateValue: val });
        }
    };
    detectType(obj) {
        obj ||= {};
        obj.common ||= {};
        // read an object
        if (obj.common.type === 'boolean') {
            if (this.props.schema.controlled !== false) {
                if (obj.common.read === false || this.props.schema.controlled === true) {
                    return 'button';
                }
                if (obj.common.write || this.props.schema.controlled === true) {
                    return 'switch';
                }
            }
            return 'text';
        }
        if (obj.common.type === 'number' && this.props.schema.controlled !== false) {
            if (obj.common.write || this.props.schema.controlled === true) {
                if (obj.common.states || this.props.schema.options) {
                    return 'select';
                }
                if (obj.common.max !== undefined) {
                    return 'slider';
                }
                return 'input';
            }
            return 'text';
        }
        if (obj.common.write && this.props.schema.controlled !== false) {
            if (obj.common.states || this.props.schema.options) {
                return 'select';
            }
            return 'input';
        }
        return 'text';
    }
    getNormalizedStates() {
        let states;
        if (this.props.schema.options) {
            states = this.props.schema.options.map(state => {
                if (typeof state === 'string') {
                    return { value: state, label: this.getText(state, this.props.schema.noTranslation) };
                }
                return {
                    value: state.value,
                    label: this.getText(state.label, this.props.schema.noTranslation),
                    color: state.color,
                };
            });
        }
        else if (this.state.obj.common.states) {
            states = [];
            Object.keys(this.state.obj.common.states).forEach(key => {
                states.push({
                    value: key,
                    label: this.getText(this.state.obj.common.states[key], this.props.schema.noTranslation),
                });
            });
        }
        else {
            states = [];
        }
        return states;
    }
    renderItem(_error, disabled /*, defaultValue */) {
        if (!this.state.obj) {
            return null;
        }
        let content;
        if (this.state.controlType === 'select' ||
            (!this.state.controlType &&
                (this.state.obj.common.type === 'number' || this.state.obj.common.type === 'string') &&
                this.state.obj.common.write !== false &&
                (this.props.schema.options || this.state.obj.common.states))) {
            const states = this.getNormalizedStates();
            const item = states.find(it => it.value === this.state.stateValue);
            content = (React$h.createElement(FormControl$1, { fullWidth: true },
                React$h.createElement(InputLabel$1, null,
                    "$",
                    this.getText(this.props.schema.label)),
                React$h.createElement(Select$1, { value: this.state.stateValue, disabled: !!this.props.schema.readOnly || disabled, onChange: e => {
                        this.setState({ stateValue: e.target.value }, () => {
                            let value = this.state.stateValue;
                            if (this.state.obj.common.type === 'number') {
                                value = parseFloat(value.toString().replace(',', '.'));
                            }
                            void this.props.oContext.socket.setState(this.getObjectID(), value, false);
                        });
                    }, renderValue: (val) => item?.color ? React$h.createElement("div", { style: { color: item.color } }, item.label) : val }, states.map(item => (React$h.createElement(MenuItem$2, { key: (item.value ?? '').toString(), value: item.value, style: { color: item.color } },
                    "$",
                    item.label))))));
        }
        else if (this.state.controlType === 'button' ||
            (!this.state.controlType &&
                this.state.obj.common.type === 'boolean' &&
                ((this.state.obj.common.write && this.state.obj.common.read === false) ||
                    this.state.obj.common.role?.includes('button')))) {
            let icon = null;
            if (this.props.schema.falseImage) {
                icon = getIconByName(this.props.schema.falseImage);
            }
            const text = this.getText(this.props.schema.falseText || this.props.schema.label, this.props.schema.noTranslation);
            if (!text && icon) {
                content = (React$h.createElement(IconButton$5, { style: this.props.schema.falseTextStyle, disabled: !!this.props.schema.readOnly, onClick: async () => {
                        if (this.props.schema.confirm) {
                            this.setState({
                                confirmDialog: true,
                                confirmCallback: async (result) => {
                                    if (result) {
                                        await this.props.oContext.socket.setState(this.getObjectID(), this.props.schema.buttonValue !== undefined
                                            ? this.props.schema.buttonValue
                                            : true, false);
                                    }
                                },
                            });
                        }
                        else {
                            await this.props.oContext.socket.setState(this.getObjectID(), this.props.schema.buttonValue !== undefined ? this.props.schema.buttonValue : true, false);
                        }
                    } }, icon));
            }
            else {
                content = (React$h.createElement(Button$2, { variant: this.props.schema.variant || 'contained', startIcon: icon, style: this.props.schema.falseTextStyle, disabled: disabled || !!this.props.schema.readOnly, onClick: async () => {
                        if (this.props.schema.confirm) {
                            this.setState({
                                confirmDialog: true,
                                confirmCallback: async (result) => {
                                    if (result) {
                                        await this.props.oContext.socket.setState(this.getObjectID(), this.props.schema.buttonValue !== undefined
                                            ? this.props.schema.buttonValue
                                            : true, false);
                                    }
                                },
                            });
                        }
                        else {
                            await this.props.oContext.socket.setState(this.getObjectID(), this.props.schema.buttonValue !== undefined ? this.props.schema.buttonValue : true, false);
                        }
                    } }, text || this.getObjectID().split('.').pop()));
            }
        }
        else if (this.state.controlType === 'input' ||
            (!this.state.controlType && this.state.obj.common.write && this.state.obj.common.type === 'string')) {
            content = (React$h.createElement("div", { style: { width: '100%', display: 'flex', flexDirection: 'row', gap: 8, alignItems: 'baseline' } },
                React$h.createElement(TextField$6, { style: { flex: 1 }, value: this.state.stateValue, variant: "standard", disabled: !!this.props.schema.readOnly || disabled, slotProps: {
                        input: {
                            endAdornment: this.getText(this.props.schema.unit, this.props.schema.noTranslation) ||
                                this.state.obj.common.unit ||
                                undefined,
                        },
                        htmlInput: {
                            readOnly: !!this.props.schema.readOnly,
                        },
                    }, onKeyUp: e => {
                        if (this.props.schema.setOnEnterKey && e.key === 'Enter') {
                            void this.props.oContext.socket.setState(this.getObjectID(), this.state.stateValue, false);
                        }
                    }, onChange: e => {
                        this.setState({ stateValue: e.target.value }, () => {
                            if (this.props.schema.setOnEnterKey || this.props.schema.showEnterButton) {
                                return;
                            }
                            if (this.controlTimeout) {
                                clearTimeout(this.controlTimeout);
                            }
                            this.controlTimeout = setTimeout(async () => {
                                this.controlTimeout = null;
                                let value = this.state.stateValue;
                                if (this.state.obj.common.type === 'number') {
                                    value = parseFloat(value.toString().replace(',', '.'));
                                }
                                await this.props.oContext.socket.setState(this.getObjectID(), value, false);
                            }, this.props.schema.controlDelay || 0);
                        });
                    }, label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }),
                this.props.schema.showEnterButton && !this.props.schema.readOnly && (React$h.createElement(Button$2, { variant: "outlined", disabled: disabled, onClick: () => {
                        void this.props.oContext.socket.setState(this.getObjectID(), this.state.stateValue, false);
                    } }, this.getText(typeof this.props.schema.showEnterButton === 'string'
                    ? this.props.schema.showEnterButton
                    : 'Set')))));
        }
        else {
            let fontSize;
            if (this.props.schema.size === 'normal') {
                fontSize = 16;
            }
            else if (this.props.schema.size === 'large') {
                fontSize = 20;
            }
            else if (typeof this.props.schema.size === 'number') {
                fontSize = this.props.schema.size;
            }
            let label = this.getText(this.props.schema.label, this.props.schema.noTranslation);
            const divStyle = {
                display: 'flex',
                alignItems: 'center',
                fontSize: fontSize || '1rem',
                gap: 8,
            };
            if (!this.props.schema.narrow) {
                divStyle.width = '100%';
                divStyle.justifyContent = 'space-between';
            }
            if (label.trim()) {
                if (!label.trim().endsWith(':') && this.props.schema.addColon) {
                    label = `${label.trim()}:`;
                }
            }
            let blinkStyle;
            if (this.props.schema.blinkOnUpdate) {
                blinkStyle = valueBlinkOnce$1(this.props.oContext.theme, this.props.schema.blinkOnUpdate);
            }
            let labelIcon;
            if (this.props.schema.labelIcon) {
                labelIcon = (React$h.createElement(Icon$3, { src: this.props.schema.labelIcon, style: { marginRight: 4 } }));
            }
            let labelControl;
            if (label && labelIcon) {
                labelControl = (React$h.createElement("div", { style: { whiteSpace: 'nowrap' } },
                    labelIcon,
                    label));
            }
            else if (label) {
                labelControl = React$h.createElement("div", { style: { whiteSpace: 'nowrap' } }, label);
            }
            else if (labelIcon) {
                labelControl = labelIcon;
            }
            if (this.state.controlType === 'switch' ||
                (!this.state.controlType &&
                    this.state.obj.common.type === 'boolean' &&
                    ((this.state.obj.common.write && this.state.obj.common.read !== false) ||
                        this.state.obj.common.role?.includes('switch')))) {
                let iconFalse = null;
                const textFalse = this.getText(this.props.schema.falseText, this.props.schema.noTranslation);
                if (this.props.schema.falseImage) {
                    iconFalse = getIconByName(this.props.schema.falseImage, textFalse ? { marginLeft: 8 } : undefined);
                }
                let iconTrue = null;
                const textTrue = this.getText(this.props.schema.trueText, this.props.schema.noTranslation);
                if (this.props.schema.trueImage) {
                    iconTrue = getIconByName(this.props.schema.trueImage, textTrue ? { marginRight: 8 } : undefined);
                }
                content = (React$h.createElement(Switch, { checked: !!this.state.stateValue, disabled: !!this.props.schema.readOnly || disabled, onChange: async () => {
                        if (this.props.schema.confirm) {
                            this.setState({
                                confirmDialog: true,
                                confirmCallback: async (result) => {
                                    if (result) {
                                        await this.props.oContext.socket.setState(this.getObjectID(), !this.state.stateValue, false);
                                    }
                                },
                            });
                        }
                        else {
                            await this.props.oContext.socket.setState(this.getObjectID(), !this.state.stateValue, false);
                        }
                    } }));
                if (textFalse || iconFalse || textTrue || iconTrue) {
                    content = (React$h.createElement("div", { style: { display: 'flex', alignItems: 'center', fontSize: 14 } },
                        React$h.createElement("span", { style: this.props.schema.falseTextStyle },
                            textFalse,
                            iconFalse),
                        content,
                        React$h.createElement("span", { style: this.props.schema.trueTextStyle },
                            iconTrue,
                            textTrue)));
                }
                if (labelControl) {
                    content = (React$h.createElement("div", { style: divStyle },
                        labelControl,
                        content));
                }
            }
            else if (this.state.controlType === 'slider' ||
                (!this.state.controlType &&
                    this.state.obj.common.type === 'number' &&
                    ((this.state.obj.common.write &&
                        (this.state.obj.common.max !== undefined || this.state.obj.common.unit === '%')) ||
                        this.state.obj.common.role?.includes('slider') ||
                        this.state.obj.common.role?.includes('dimmer') ||
                        this.state.obj.common.role?.includes('blind')))) {
                let iconFalse = null;
                const textFalse = this.getText(this.props.schema.falseText, this.props.schema.noTranslation);
                if (this.props.schema.falseImage) {
                    iconFalse = getIconByName(this.props.schema.falseImage, textFalse ? { marginLeft: 8 } : undefined);
                }
                let iconTrue = null;
                const textTrue = this.getText(this.props.schema.trueText, this.props.schema.noTranslation);
                if (this.props.schema.trueImage) {
                    iconTrue = getIconByName(this.props.schema.trueImage, textTrue ? { marginRight: 8 } : undefined);
                }
                const min = this.props.schema.min === undefined ? this.state.obj.common.min || 0 : this.props.schema.min;
                const max = this.props.schema.max === undefined
                    ? this.state.obj.common.max === undefined
                        ? 100
                        : this.state.obj.common.max
                    : this.props.schema.max;
                const step = this.props.schema.step === undefined ? this.state.obj.common.step || 1 : this.props.schema.step;
                content = (React$h.createElement(Slider, { style: { width: '100%', flexGrow: 1 }, min: min, max: max, disabled: !!this.props.schema.readOnly || disabled, step: step, value: this.state.stateValue, valueLabelDisplay: "auto", valueLabelFormat: (value) => `${value}${this.getText(this.props.schema.unit, this.props.schema.noTranslation) || this.state.obj.common.unit || ''}`, onChange: (_e, value) => {
                        this.setState({ stateValue: value }, () => {
                            if (this.controlTimeout) {
                                clearTimeout(this.controlTimeout);
                            }
                            this.controlTimeout = setTimeout(async () => {
                                console.log(`${Date.now()} Send new value: ${this.state.stateValue}`);
                                this.controlTimeout = null;
                                await this.props.oContext.socket.setState(this.getObjectID(), this.state.stateValue, false);
                            }, this.props.schema.controlDelay || 0);
                        });
                    } }));
                if (textFalse || iconFalse || textTrue || iconTrue) {
                    content = (React$h.createElement("div", { style: {
                            display: 'flex',
                            width: '100%',
                            flexGrow: 1,
                            alignItems: 'center',
                        } },
                        React$h.createElement("span", { style: { marginRight: 16, ...this.props.schema.falseTextStyle } },
                            textFalse,
                            iconFalse),
                        content,
                        React$h.createElement("span", { style: { marginLeft: 16, ...this.props.schema.trueTextStyle } },
                            iconTrue,
                            textTrue)));
                }
                if (labelControl) {
                    content = (React$h.createElement("div", { style: divStyle },
                        labelControl,
                        content));
                }
            }
            else if (this.state.obj.common.type === 'number' &&
                this.state.obj.common.write &&
                !this.state.controlType) {
                // Auto-detection of the type
                const min = this.props.schema.min === undefined
                    ? this.state.obj.common.min === undefined
                        ? undefined
                        : this.state.obj.common.min
                    : this.props.schema.min;
                const max = this.props.schema.max === undefined
                    ? this.state.obj.common.max === undefined
                        ? undefined
                        : this.state.obj.common.max
                    : this.props.schema.max;
                const step = this.props.schema.step === undefined
                    ? this.state.obj.common.step === undefined
                        ? undefined
                        : this.state.obj.common.step
                    : this.props.schema.step;
                content = (React$h.createElement(TextField$6, { variant: "standard", style: { width: '100%' }, value: this.state.stateValue, type: "number", disabled: !!this.props.schema.readOnly || disabled, slotProps: {
                        htmlInput: { min, max, step, readOnly: !!this.props.schema.readOnly },
                        input: {
                            endAdornment: this.getText(this.props.schema.unit, this.props.schema.noTranslation) ||
                                this.state.obj.common.unit ||
                                undefined,
                        },
                    }, onChange: e => {
                        this.setState({ stateValue: e.target.value }, () => {
                            if (this.controlTimeout) {
                                clearTimeout(this.controlTimeout);
                            }
                            this.controlTimeout = setTimeout(async () => {
                                this.controlTimeout = null;
                                const val = parseFloat(this.state.stateValue);
                                await this.props.oContext.socket.setState(this.getObjectID(), val, false);
                            }, this.props.schema.controlDelay || 0);
                        });
                    }, label: this.getText(this.props.schema.label, this.props.schema.noTranslation), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }));
            }
            else if (this.state.obj.common.type === 'boolean') {
                let icon = null;
                let text;
                let style;
                if (!this.state.stateValue) {
                    text = this.getText(this.props.schema.falseText, this.props.schema.noTranslation);
                    if (this.props.schema.falseImage) {
                        icon = getIconByName(this.props.schema.falseImage, text ? { marginLeft: 8 } : undefined);
                    }
                    style = this.props.schema.falseTextStyle;
                }
                else {
                    text = this.getText(this.props.schema.trueText, this.props.schema.noTranslation);
                    if (this.props.schema.trueImage) {
                        icon = getIconByName(this.props.schema.falseImage, text ? { marginRight: 8 } : undefined);
                    }
                    style = this.props.schema.trueTextStyle;
                }
                style = Object.assign(divStyle, style);
                content = (React$h.createElement("div", { style: style },
                    labelControl,
                    React$h.createElement(Box$6, { style: { display: 'flex', alignItems: 'center', gap: 8 }, sx: blinkStyle, key: this.props.schema.blinkOnUpdate ? text : undefined },
                        icon,
                        text || (this.state.stateValue ? I18n$8.t('ra_true') : I18n$8.t('ra_false')))));
            }
            else {
                // text or HTML
                const unit = this.getText(this.props.schema.unit, this.props.schema.noTranslation) || this.state.obj.common.unit;
                let mappedValue = this.state.stateValue;
                // if options or states are defined, map the value to the label
                if (mappedValue !== null &&
                    mappedValue !== undefined &&
                    (this.props.schema.options || this.state.obj.common.states)) {
                    const states = this.getNormalizedStates();
                    const state = states.find(s => s.value === mappedValue);
                    if (state) {
                        mappedValue = state.label;
                    }
                }
                let value;
                let key;
                if (this.state.controlType === 'html') {
                    key = (mappedValue || '').toString();
                    value = React$h.createElement("span", { dangerouslySetInnerHTML: { __html: mappedValue } });
                }
                else if (this.state.stateValue === null) {
                    value = 'null';
                    key = value;
                }
                else if (this.state.stateValue === undefined) {
                    value = 'undefined';
                    key = value;
                }
                else {
                    value = mappedValue.toString();
                    key = value;
                }
                content = (React$h.createElement("div", { style: divStyle },
                    labelControl,
                    React$h.createElement("div", { style: { display: 'flex', alignItems: 'baseline', gap: 4 } },
                        React$h.createElement(Box$6, { sx: blinkStyle, key: this.props.schema.blinkOnUpdate ? key : undefined }, value),
                        unit ? React$h.createElement("span", { style: { opacity: 0.7, fontSize: 'smaller' } }, unit) : null)));
            }
        }
        return content;
    }
}

const React$g = await importShared('react');

const {Box: Box$5} = await importShared('@mui/material');

const {Utils: Utils$8} = await importShared('@iobroker/adapter-react-v5');
const styles$b = {
    fullWidth: (theme) => ({
        width: '100%',
        backgroundColor: theme.palette.mode === 'dark' ? '#FFF' : '#000',
        borderStyle: 'hidden',
    }),
    primary: (theme) => ({
        backgroundColor: theme.palette.primary.main,
    }),
    secondary: (theme) => ({
        backgroundColor: theme.palette.secondary.main,
    }),
};
class ConfigStaticDivider extends ConfigGeneric {
    renderItem() {
        return (React$g.createElement(Box$5, { component: "hr", sx: Utils$8.getStyle(this.props.oContext.theme, styles$b.fullWidth, this.props.schema.color === 'primary'
                ? styles$b.primary
                : this.props.schema.color === 'secondary'
                    ? styles$b.secondary
                    : {
                        backgroundColor: this.props.schema.color ||
                            (this.props.oContext.themeType === 'dark' ? '#333' : '#ddd'),
                    }, {
                height: this.props.schema.color ? this.props.schema.height || 2 : this.props.schema.height || 1,
            }) }));
    }
}

const React$f = await importShared('react');

const {Box: Box$4} = await importShared('@mui/material');
const styles$a = {
    header: (theme) => ({
        width: '100%',
        background: theme.palette.primary.main,
        color: theme.palette.primary.contrastText,
        padding: '4px !important',
        borderRadius: '3px',
        marginBlockEnd: 0,
        marginBlockStart: 0,
    }),
};
class ConfigStaticHeader extends ConfigGeneric {
    renderItem( /* error: string, disabled: boolean, defaultValue */) {
        let component = 'h5';
        switch ((this.props.schema.size || 5).toString()) {
            case '1':
                component = 'h1';
                break;
            case '2':
                component = 'h2';
                break;
            case '3':
                component = 'h3';
                break;
            case '4':
                component = 'h4';
                break;
            case '5':
            default:
                component = 'h5';
                break;
        }
        return (React$f.createElement(Box$4, { component: component, sx: styles$a.header }, this.getText(this.props.schema.label || this.props.schema.text, this.props.schema.noTranslation)));
    }
}

const React$e = await importShared('react');
class ConfigStaticImage extends ConfigGeneric {
    renderItem( /* error: string, disabled: boolean, defaultValue */) {
        let src = this.props.schema.src;
        if (src &&
            !src.startsWith('.') &&
            !src.startsWith('http') &&
            !src.startsWith(`adapter/${this.props.oContext.adapterName}/`) &&
            !src.startsWith(`./adapter/${this.props.oContext.adapterName}/`)) {
            src = `adapter/${this.props.oContext.adapterName}/${src}`;
        }
        return (React$e.createElement("img", { src: src, style: { cursor: this.props.schema.href ? 'pointer' : undefined, width: '100%', height: '100%' }, onClick: this.props.schema.href
                ? () => this.props.schema.href && window.open(this.props.schema.href, '_blank')
                : null, alt: "" }));
    }
}

const React$d = await importShared('react');

const {Box: Box$3,Checkbox} = await importShared('@mui/material');

const {ContentCopy} = await importShared('@mui/icons-material');

const {I18n: I18n$7,Icon: Icon$2,Utils: Utils$7} = await importShared('@iobroker/adapter-react-v5');
function valueBlinkOnce(theme, force, color) {
    if (typeof color === 'string') {
        return {
            '@keyframes newValueAnimationOnceColor': {
                '0%': {
                    color: force ? `${color} !important` : color,
                },
                '100%': {
                    color: theme.palette.mode === 'dark'
                        ? force
                            ? '#fff !important'
                            : '#fff'
                        : force
                            ? '#000 !important'
                            : '#000',
                },
            },
            animation: 'newValueAnimationOnceColor 2s ease-in-out',
        };
    }
    return {
        '@keyframes newValueAnimationOnce': {
            '0%': {
                color: force ? `#00f900 !important` : '#00f900',
            },
            '80%': {
                color: theme.palette.mode === 'dark'
                    ? force
                        ? `#518851 !important`
                        : '#518851'
                    : force
                        ? `#008000 !important`
                        : '#008000',
            },
            '100%': {
                color: theme.palette.mode === 'dark'
                    ? force
                        ? '#fff !important'
                        : '#fff'
                    : force
                        ? '#000 !important'
                        : '#000',
            },
        },
        animation: 'newValueAnimationOnce 2s ease-in-out',
    };
}
function valueBlink(theme, color) {
    if (typeof color === 'string') {
        return {
            '@keyframes blinkAnimationColor': {
                '0%': {
                    color,
                },
                '100%': {
                    color: theme.palette.mode === 'dark' ? '#fff' : '#000',
                },
            },
            animation: 'blinkAnimationColor 2s ease-in-out infinite',
        };
    }
    return {
        '@keyframes blinkAnimation': {
            '0%': {
                color: '#00f900',
            },
            '80%': {
                color: theme.palette.mode === 'dark' ? '#518851' : '#008000',
            },
            '100%': {
                color: theme.palette.mode === 'dark' ? '#fff' : '#000',
            },
        },
        animation: 'blinkAnimation 2s ease-in-out infinite',
    };
}
const styles$9 = {
    label: {
        fontWeight: 'bold',
        whiteSpace: 'nowrap',
    },
    valueImage: {
        maxHeight: '100%',
    },
    valueAndUnit: {
        display: 'flex',
        gap: 4,
        alignItems: 'baseline',
    },
    value: {},
    unit: {
        fontSize: 'smaller',
        opacity: 0.7,
    },
};
class ConfigStaticInfo extends ConfigGeneric {
    renderItem(_error) {
        let label = this.getText(this.props.schema.text || this.props.schema.label, this.props.schema.noTranslation);
        if (this.props.schema.addColon && typeof label === 'string' && !label.trim().endsWith(':')) {
            label = `${label.trim()}:`;
        }
        if (label &&
            (label.includes('<a ') || label.includes('<br') || label.includes('<b>') || label.includes('<i>'))) {
            label = Utils$7.renderTextWithA(label);
        }
        let fontSize;
        if (this.props.schema.size === 'normal') {
            fontSize = 16;
        }
        else if (this.props.schema.size === 'large') {
            fontSize = 20;
        }
        else if (typeof this.props.schema.size === 'number') {
            fontSize = this.props.schema.size;
        }
        const divStyle = {
            width: '100%',
            height: '100%',
            display: 'flex',
            alignItems: 'center',
            position: 'relative',
            fontSize,
        };
        if (this.props.schema.narrow) {
            divStyle.gap = 8;
        }
        else {
            divStyle.justifyContent = 'space-between';
        }
        let value;
        let valueTxt;
        if (this.props.schema.data && typeof this.props.schema.data === 'object' && this.props.schema.data.en) {
            valueTxt = this.getText(this.props.schema.data);
        }
        else if (typeof this.props.schema.data === 'object' ||
            this.props.schema.data === undefined ||
            this.props.schema.data === null) {
            valueTxt = JSON.stringify(this.props.schema.data);
        }
        else if (typeof this.props.schema.data === 'number') {
            valueTxt = this.props.schema.data.toString();
            if (this.props.oContext.isFloatComma) {
                valueTxt = valueTxt.replace('.', ',');
            }
        }
        else if (!this.props.schema.booleanAsCheckbox || typeof this.props.schema.data !== 'boolean') {
            valueTxt = this.props.schema.data.toString();
        }
        let multiLine = false;
        if (this.props.schema.booleanAsCheckbox && typeof this.props.schema.data === 'boolean') {
            value = (React$d.createElement(Checkbox, { checked: !!value, disabled: true, size: this.props.schema.size === 'small'
                    ? 'small'
                    : this.props.schema.size === 'large'
                        ? 'large'
                        : undefined }));
        }
        else if (valueTxt.startsWith('data:image/')) {
            value = (React$d.createElement("div", { style: { ...styles$9.value, ...styles$9.valueImage, ...(this.props.schema.styleValue || undefined) } },
                React$d.createElement(Icon$2, { src: valueTxt })));
        }
        else {
            const valStyle = { ...styles$9.value, ...(this.props.schema.styleValue || undefined) };
            if (this.props.schema.html) {
                value = (React$d.createElement("div", { style: valStyle, dangerouslySetInnerHTML: { __html: valueTxt } }));
            }
            else {
                if (Array.isArray(this.props.schema.data)) {
                    multiLine = true;
                    value = (React$d.createElement("div", { style: valStyle }, this.props.schema.data.map((it, i) => (React$d.createElement("div", { key: i }, typeof it === 'object' || it === null || it === undefined
                        ? JSON.stringify(it)
                        : it)))));
                }
                else {
                    if (valueTxt.includes('\n')) {
                        multiLine = true;
                        value = React$d.createElement("div", { style: valStyle }, Utils$7.renderTextWithA(valueTxt));
                    }
                    else {
                        value = React$d.createElement("div", { style: valStyle }, valueTxt);
                    }
                }
            }
        }
        if (this.props.schema.blinkOnUpdate && this.props.schema.blink) {
            const style1 = valueBlinkOnce(this.props.oContext.theme, true, this.props.schema.blinkOnUpdate);
            const style2 = valueBlink(this.props.oContext.theme, this.props.schema.blink);
            value = (React$d.createElement(Box$3, { key: valueTxt, sx: { ...style1, ...style2 } }, value));
        }
        else if (this.props.schema.blinkOnUpdate) {
            const style = valueBlinkOnce(this.props.oContext.theme, false, this.props.schema.blinkOnUpdate);
            value = (React$d.createElement(Box$3, { key: valueTxt, sx: style }, value));
        }
        else if (this.props.schema.blink) {
            const style = valueBlink(this.props.oContext.theme, this.props.schema.blink);
            value = React$d.createElement(Box$3, { sx: style }, value);
        }
        if (this.props.schema.unit) {
            value = (React$d.createElement("div", { style: styles$9.valueAndUnit },
                value,
                React$d.createElement("div", { style: { ...styles$9.unit, ...(this.props.schema.styleUnit || undefined) } }, this.getText(this.props.schema.unit, this.props.schema.noTranslation))));
        }
        let labelIcon;
        if (this.props.schema.labelIcon) {
            labelIcon = (React$d.createElement(Icon$2, { src: this.props.schema.labelIcon, style: { marginRight: 4 } }));
        }
        let copyButton;
        if (this.props.schema.copyToClipboard) {
            copyButton = (React$d.createElement(ContentCopy, { className: "staticCopyButton", style: {
                    position: 'absolute',
                    top: 'calc(50% - 12px)',
                    right: 0,
                    cursor: 'pointer',
                }, onClick: () => {
                    Utils$7.copyToClipboard(valueTxt);
                    window.alert(I18n$7.t('ra_Copied'));
                } }));
        }
        const boxStyle = {
            '& .staticCopyButton': {
                display: 'none',
            },
            '& .staticCopyButton:action': {
                transform: 'scale(0.9)',
            },
            '&:hover .staticCopyButton': {
                display: 'block',
            },
        };
        if (this.props.schema.highlight) {
            boxStyle['&:hover'] = {
                backgroundColor: this.props.oContext.themeType === 'dark' ? '#51515180' : '#b8b8b880',
            };
        }
        if (multiLine) {
            divStyle.alignItems = 'top';
        }
        return (React$d.createElement(Box$3, { component: "div", style: divStyle, sx: boxStyle },
            React$d.createElement("div", { style: { ...styles$9.label, ...(this.props.schema.styleLabel || undefined) } },
                labelIcon,
                label),
            value,
            copyButton));
    }
}

const React$c = await importShared('react');

const {Box: Box$2,Button: Button$1} = await importShared('@mui/material');

const {Utils: Utils$6} = await importShared('@iobroker/adapter-react-v5');
const styles$8 = {
    fullWidth: {
        height: '100%',
        width: '100%',
    },
    link: (theme) => ({
        textDecoration: 'underline',
        color: theme.palette.mode === 'dark' ? '#4dabf5' : '#254e72',
        cursor: 'pointer',
    }),
};
// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
function onLink(href, target, instanceId) {
    let _target;
    let url = '';
    if (!href) {
        url = `#tab-instances/config/${instanceId}`;
        _target = target || '_self';
    }
    else if (href.toString().startsWith('#')) {
        _target = target || '_self';
        url = href;
    }
    else if (href.toString().startsWith('/')) {
        _target = target || '_self';
        url = href;
    }
    else if (href.startsWith('http://') || href.startsWith('https://')) {
        _target = target || '_blank';
        url = href;
    }
    else {
        url = `#tab-instances/config/${instanceId}/${href}`;
        _target = target || '_self';
    }
    if (_target === '_self') {
        // close dialog
        setTimeout((_url) => {
            if (_url.startsWith('#')) {
                window.location.hash = _url;
            }
            else if (_url.startsWith('/')) {
                url = `${window.location.protocol}:${window.location.host}${url}`;
            }
            else if (_url.startsWith('http://') || _url.startsWith('https://')) {
                window.location.href = _url;
            }
        }, 100, url);
    }
    else {
        if (url.startsWith('#')) {
            url = `${window.location.protocol}:${window.location.host}${window.location.pathname}${url}`;
        }
        else if (url.startsWith('/')) {
            url = `${window.location.protocol}:${window.location.host}${url}`;
        }
        window.open(url, _target);
    }
}
class ConfigStaticText extends ConfigGeneric {
    renderItem(_error, disabled /* , defaultValue */) {
        if (this.props.schema.button) {
            const icon = this.getIcon();
            return (React$c.createElement(Button$1, { variant: this.props.schema.variant || undefined, color: this.props.schema.color || 'grey', style: { ...styles$8.fullWidth, ...(this.props.schema.controlStyle || undefined) }, disabled: disabled, startIcon: icon, onClick: this.props.schema.href
                    ? () => {
                        // calculate one more time just before call
                        const href = this.props.schema.href
                            ? this.getText(this.props.schema.href, true)
                            : null;
                        if (href) {
                            if (this.props.oContext.onBackEndCommand) {
                                this.props.oContext.onBackEndCommand({
                                    command: 'link',
                                    url: href,
                                    target: this.props.schema.target,
                                    close: this.props.schema.close,
                                });
                            }
                            else {
                                onLink(href, this.props.schema.target, `${this.props.oContext.adapterName}.${this.props.oContext.instance}`);
                            }
                        }
                    }
                    : null }, this.getText(this.props.schema.text || this.props.schema.label, this.props.schema.noTranslation)));
        }
        let text = this.getText(this.props.schema.text || this.props.schema.label, this.props.schema.noTranslation);
        if (text && (text.includes('<a ') || text.includes('<br') || text.includes('<b>') || text.includes('<i>'))) {
            text = Utils$6.renderTextWithA(text);
        }
        return (React$c.createElement(Box$2, { component: "span", style: { ...(this.props.schema.controlStyle || undefined) }, sx: this.props.schema.href ? styles$8.link : undefined, onClick: this.props.schema.href
                ? () => {
                    // calculate one more time just before call
                    const href = this.props.schema.href ? this.getText(this.props.schema.href, true) : null;
                    if (href) {
                        if (this.props.oContext.onBackEndCommand) {
                            this.props.oContext.onBackEndCommand({
                                command: 'link',
                                url: href,
                                target: this.props.schema.target || '_blank',
                                close: this.props.schema.close,
                            });
                        }
                        else {
                            onLink(href, this.props.schema.target || '_blank', `${this.props.oContext.adapterName}.${this.props.oContext.instance}`);
                        }
                    }
                }
                : null }, text));
    }
}

const React$b = await importShared('react');
const {createRef} = React$b;
const {Accordion: Accordion$1,AccordionDetails: AccordionDetails$1,AccordionSummary: AccordionSummary$1,Button,Card,Dialog,DialogActions,DialogContent,DialogTitle,Grid2: Grid2$1,IconButton: IconButton$4,InputAdornment: InputAdornment$1,Paper,Table,TableBody,TableCell,TableContainer,TableHead,TableRow,TableSortLabel,TextField: TextField$5,Toolbar: Toolbar$1,Tooltip: Tooltip$1,Typography: Typography$1,FormHelperText: FormHelperText$1} = await importShared('@mui/material');

const {Add:AddIcon,Delete:DeleteIcon,Close:CloseIcon$1,ArrowUpward:UpIcon,ArrowDownward:DownIcon,FilterAlt:IconFilterOn,FilterAltOff:IconFilterOff,ContentCopy:CopyContentIcon,Download:ExportIcon,Warning:ErrorIcon$1,UploadFile:ImportIcon,Close:IconClose,ExpandMore:ExpandMoreIcon$1} = await importShared('@mui/icons-material');

const {I18n: I18n$6} = await importShared('@iobroker/adapter-react-v5');
const MAX_SIZE = 1024 * 1024; // 1MB
const styles$7 = {
    paper: {
        width: '100%',
        marginBottom: 16,
        backgroundColor: 'rgba(255, 255, 255, 0.1)',
    },
    headerText: {
        width: '100%',
    },
    table: {
        minWidth: 750,
    },
    label: {
        display: 'flex',
        justifyContent: 'space-between',
    },
    // highlight: (theme: IobTheme): React.CSSProperties => (theme.palette.mode === 'light'
    //     ? {
    //         color: theme.palette.secondary.main,
    //         // backgroundColor: lighten(theme.palette.secondary.light, 0.85),
    //     }
    //     : {
    //         color: theme.palette.text.primary,
    //         backgroundColor: theme.palette.secondary.dark,
    //     }),
    title: {
        flex: '1 1 100%',
    },
    rootTool: {
        paddingLeft: 16,
        paddingRight: 8,
    },
    silver: {
        opacity: 0.2,
    },
    flex: {
        display: 'flex',
        alignItems: 'baseline',
    },
    filteredOut: {
        padding: 10,
        display: 'flex',
        textAlign: 'center',
    },
    buttonEmpty: {
        width: 34,
        display: 'inline-block',
    },
    buttonCell: {
        whiteSpace: 'nowrap',
    },
    dropZone: {
        width: '100%',
        height: 100,
        position: 'relative',
    },
    dropZoneEmpty: {},
    uploadDiv: {
        position: 'relative',
        width: '100%',
        minHeight: 300,
        opacity: 0.9,
        marginTop: 30,
        cursor: 'pointer',
        outline: 'none',
    },
    uploadDivDragging: {
        opacity: 1,
        background: 'rgba(128,255,128,0.1)',
    },
    uploadCenterDiv: {
        margin: 5,
        border: '3px dashed grey',
        borderRadius: 5,
        width: 'calc(100% - 10px)',
        height: 'calc(100% - 10px)',
        minHeight: 300,
        position: 'relative',
        display: 'flex',
    },
    uploadCenterIcon: {
        paddingTop: 10,
        width: 48,
        height: 48,
    },
    uploadCenterText: {
        fontSize: 16,
    },
    uploadCenterTextAndIcon: {
        textAlign: 'center',
        position: 'absolute',
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
    },
    tooltip: {
        pointerEvents: 'none',
    },
};
function objectToArray(object, nameOfFirstAttr, nameOfSecondAttr) {
    nameOfFirstAttr = nameOfFirstAttr || 'key';
    const array = [];
    Object.keys(object).forEach(key => {
        const item = {};
        item[nameOfFirstAttr] = key;
        if (nameOfSecondAttr) {
            item[nameOfSecondAttr] = object[key];
            array.push(item);
        }
        else {
            array.push(Object.assign(item, object[key]));
        }
    });
    return array;
}
function arrayToObject(array, nameOfFirstAttr, nameOfSecondAttr) {
    nameOfFirstAttr = nameOfFirstAttr || 'key';
    const object = {};
    array.forEach((row) => {
        let key = row[nameOfFirstAttr];
        if (key === null || key === undefined) {
            key = '';
        }
        delete row[nameOfFirstAttr];
        if (nameOfSecondAttr) {
            object[key] = row[nameOfSecondAttr];
        }
        else {
            object[key] = row;
        }
    });
    return object;
}
function encrypt$1(secret, value) {
    let result = '';
    for (let i = 0; i < value.length; i++) {
        result += String.fromCharCode(secret[i % secret.length].charCodeAt(0) ^ value.charCodeAt(i));
    }
    return result;
}
function decrypt$1(secret, value) {
    let result = '';
    for (let i = 0; i < value.length; i++) {
        result += String.fromCharCode(secret[i % secret.length].charCodeAt(0) ^ value.charCodeAt(i));
    }
    return result;
}
class ConfigTable extends ConfigGeneric {
    filterRefs;
    typingTimer = null;
    resizeTimeout = null;
    secret = 'Zgfr56gFe87jJOM';
    refDiv;
    constructor(props) {
        super(props);
        this.filterRefs = {};
        this.props.schema.items = this.props.schema.items || [];
        this.props.schema.items.forEach((el) => {
            if (el.filter) {
                this.filterRefs[el.attr] = createRef();
            }
        });
        this.refDiv = React$b.createRef();
    }
    /**
     * React lifecycle hook, called once as component is mounted
     */
    async componentDidMount() {
        super.componentDidMount();
        const _value = ConfigGeneric.getValue(this.props.data, this.props.attr) || [];
        let value;
        // if the list is given as an object
        if (this.props.schema.objKeyName) {
            value = objectToArray(_value, this.props.schema.objKeyName, this.props.schema.objValueName);
        }
        else {
            value = _value;
        }
        if (!Array.isArray(value)) {
            value = [];
        }
        if (this.props.schema.encryptedAttributes) {
            const systemConfig = await this.props.oContext.socket.getCompactSystemConfig();
            this.secret = systemConfig?.native.secret || this.secret;
            _value.forEach((el) => {
                this.props.schema.encryptedAttributes.forEach((attr) => {
                    if (el[attr]) {
                        el[attr] = decrypt$1(this.secret, el[attr]);
                    }
                });
            });
        }
        this.setState({
            value,
            visibleValue: null,
            orderBy: /* this.props.schema.items.length ? this.props.schema.items[0].attr : */ '',
            order: 'asc',
            iteration: 0,
            filterOn: [],
            width: 0,
            tableErrors: {},
        }, () => this.validateUniqueProps());
    }
    componentWillUnmount() {
        if (this.typingTimer) {
            clearTimeout(this.typingTimer);
            this.typingTimer = null;
        }
        if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = null;
        }
        super.componentWillUnmount();
    }
    itemTable(attrItem, data, idx) {
        const { schema } = this.props;
        const schemaForAttribute = schema.items?.find((el) => el.attr === attrItem);
        if (!schemaForAttribute) {
            return null;
        }
        const schemaItem = {
            items: {
                [attrItem]: schemaForAttribute,
            },
        };
        return (React$b.createElement(ConfigPanel, { oContext: this.props.oContext, alive: this.props.alive, arrayIndex: idx, changed: this.props.changed, common: this.props.common, expertMode: this.props.expertMode, custom: true, data: data, globalData: this.props.data, index: idx + this.state.iteration, onChange: (attr, valueChange) => {
                const newObj = JSON.parse(JSON.stringify(this.state.value));
                newObj[idx][attr] = valueChange;
                this.setState({ value: newObj }, () => {
                    this.validateUniqueProps();
                    this.onChangeWrapper(newObj, true);
                });
            }, onError: this.onTableRowError(idx), originalData: this.props.originalData, schema: schemaItem, table: true, themeName: this.props.themeName }));
    }
    /**
     * Validate that columns configured in `uniqueColumns` have unique values
     */
    validateUniqueProps() {
        if (!this.props.schema.uniqueColumns) {
            return;
        }
        let firstErrorColumn = null;
        let firstErrorValue = null;
        // Validate all columns and collect errors
        for (const uniqueCol of this.props.schema.uniqueColumns) {
            const allVals = [];
            const found = this.state.value.find(entry => {
                const val = entry[uniqueCol];
                if (allVals.includes(val)) {
                    // Store the first error we encounter
                    if (!firstErrorColumn) {
                        firstErrorColumn = uniqueCol;
                        firstErrorValue = val;
                    }
                    this.onError(uniqueCol, 'is not unique');
                    return true;
                }
                allVals.push(val);
                return false;
            });
            // Clear error for this column if no duplicates found
            if (!found) {
                this.onError(uniqueCol, null);
            }
        }
        // Set error message based on the first error found (or clear if no errors)
        if (firstErrorColumn) {
            this.setState({
                errorMessage: I18n$6.t('Non-allowed duplicate entry "%s" in column "%s"', firstErrorValue, firstErrorColumn),
            });
        }
        else {
            this.setState({ errorMessage: '' });
        }
    }
    /**
     * Handle errors from table row components
     */
    onTableRowError = (rowIndex) => (attr, error) => {
        const newTableErrors = { ...this.state.tableErrors };
        if (!newTableErrors[rowIndex]) {
            newTableErrors[rowIndex] = {};
        }
        if (!error) {
            delete newTableErrors[rowIndex][attr];
            // Clean up empty row error objects
            if (Object.keys(newTableErrors[rowIndex]).length === 0) {
                delete newTableErrors[rowIndex];
            }
        }
        else {
            newTableErrors[rowIndex][attr] = error;
        }
        this.setState({ tableErrors: newTableErrors });
        // Forward error to parent component
        this.props.onError(attr, error);
    };
    static descendingComparator(a, b, orderBy) {
        if (b[orderBy] < a[orderBy]) {
            return -1;
        }
        if (b[orderBy] > a[orderBy]) {
            return 1;
        }
        return 0;
    }
    static getComparator(order, orderBy) {
        return order === 'desc'
            ? (a, b) => ConfigTable.descendingComparator(a, b, orderBy)
            : (a, b) => -ConfigTable.descendingComparator(a, b, orderBy);
    }
    static getFilterValue(el) {
        return el?.current?.children[0]?.children[0]?.value;
    }
    static setFilterValue(el, filterValue) {
        return (el.current.children[0].children[0].value = filterValue);
    }
    handleRequestSort = (property, orderCheck = false) => {
        const { order, orderBy } = this.state;
        //if (orderBy || 'asc') {
        const isAsc = orderBy === property && order === 'asc';
        const newOrder = orderCheck ? order : isAsc ? 'desc' : 'asc';
        const newValue = this.stableSort(newOrder, property);
        // update only if value is really changed
        if (JSON.stringify(newValue) !== JSON.stringify(this.state.value)) {
            this.setState({ value: newValue, order: newOrder, orderBy: property, iteration: this.state.iteration + 10000 }, () => this.applyFilter(false, newValue));
        }
        //}
    };
    stableSort = (order, orderBy) => {
        const { value } = this.state;
        const comparator = ConfigTable.getComparator(order, orderBy);
        const stabilizedThis = value.map((el, index) => ({ el, index }));
        stabilizedThis.sort((a, b) => {
            const order_ = comparator(a.el, b.el);
            if (order_ !== 0) {
                return order_;
            }
            return a.index - b.index;
        });
        return stabilizedThis.map(el => el.el);
    };
    renderShowHideFilter(headCell) {
        if (!headCell.filter) {
            return null;
        }
        return (React$b.createElement(IconButton$4, { title: I18n$6.t('ra_Show/hide filter input'), size: "small", onClick: () => {
                const filterOn = [...this.state.filterOn];
                const pos = this.state.filterOn.indexOf(headCell.attr);
                if (pos === -1) {
                    filterOn.push(headCell.attr);
                }
                else {
                    filterOn.splice(pos, 1);
                }
                this.setState({ filterOn }, () => {
                    if (pos && ConfigTable.getFilterValue(this.filterRefs[headCell.attr])) {
                        ConfigTable.setFilterValue(this.filterRefs[headCell.attr], '');
                        this.applyFilter();
                    }
                });
            } }, this.state.filterOn.includes(headCell.attr) ? React$b.createElement(IconFilterOff, null) : React$b.createElement(IconFilterOn, null)));
    }
    renderImportExportButtons(schema) {
        return (React$b.createElement(React$b.Fragment, null,
            !schema.noDelete && schema.import ? (React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Import data from %s file', 'CSV'), slotProps: { popper: { sx: styles$7.tooltip } } },
                React$b.createElement(IconButton$4, { size: "small", onClick: () => this.setState({ showImportDialog: true }) },
                    React$b.createElement(ImportIcon, null)))) : null,
            schema.export ? (React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Export data to %s file', 'CSV'), slotProps: { popper: { sx: styles$7.tooltip } } },
                React$b.createElement(IconButton$4, { size: "small", onClick: () => this.onExport() },
                    React$b.createElement(ExportIcon, null)))) : null,
            schema.noDelete ? null : (React$b.createElement(IconButton$4, { disabled: true, size: "small" },
                React$b.createElement(DeleteIcon, null)))));
    }
    renderAddButton(doAnyFilterSet) {
        return (React$b.createElement(Tooltip$1, { title: doAnyFilterSet ? I18n$6.t('ra_Cannot add items with set filter') : I18n$6.t('ra_Add row'), slotProps: { popper: { sx: styles$7.tooltip } } },
            React$b.createElement("span", null,
                React$b.createElement(IconButton$4, { size: "small", color: "primary", disabled: !!doAnyFilterSet && !this.props.schema.allowAddByFilter, onClick: this.onAdd },
                    React$b.createElement(AddIcon, null)))));
    }
    enhancedTableHead(buttonsWidth, doAnyFilterSet) {
        const { schema } = this.props;
        const { order, orderBy } = this.state;
        return (React$b.createElement(TableHead, null,
            React$b.createElement(TableRow, null,
                schema.items?.map((headCell, i) => this.renderOneFilter({
                    schema,
                    style: { width: headCell.width },
                    showAddButton: !i && !schema.noDelete,
                    headCell,
                    order,
                    orderBy,
                    index: i,
                    doAnyFilterSet,
                })),
                !schema.noDelete && (React$b.createElement(TableCell, { style: {
                        paddingLeft: 20,
                        paddingRight: 20,
                        width: buttonsWidth,
                        textAlign: 'right',
                    }, padding: "checkbox" }, this.renderImportExportButtons(schema))))));
    }
    onDelete = (index) => () => {
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        newValue.splice(index, 1);
        // Clear errors for deleted row and shift remaining error indices
        const newTableErrors = { ...this.state.tableErrors };
        // Clear errors for the deleted row
        if (newTableErrors[index]) {
            // Clear all errors for this row from parent
            Object.keys(newTableErrors[index]).forEach(attr => {
                this.props.onError(attr, undefined);
            });
            delete newTableErrors[index];
        }
        // Shift error indices for rows after the deleted one
        const shiftedErrors = {};
        Object.keys(newTableErrors).forEach(rowIndexStr => {
            const rowIndex = parseInt(rowIndexStr, 10);
            if (rowIndex > index) {
                // Move errors from rowIndex to rowIndex - 1
                shiftedErrors[rowIndex - 1] = newTableErrors[rowIndex];
            }
            else {
                // Keep errors at same index for rows before deleted row
                shiftedErrors[rowIndex] = newTableErrors[rowIndex];
            }
        });
        this.setState({
            value: newValue,
            iteration: this.state.iteration + 10_000,
            tableErrors: shiftedErrors,
        }, () => this.applyFilter(false, null, () => this.onChangeWrapper(newValue)));
    };
    onExport() {
        const { schema } = this.props;
        const { value } = this.state;
        const cols = schema.items.map((it) => it.attr);
        const lines = [cols.join(';')];
        value.forEach(row => {
            const line = [];
            schema.items.forEach((it) => {
                if (row[it.attr] && typeof row[it.attr] === 'string' && row[it.attr].includes(';')) {
                    line.push(`"${row[it.attr]}"`);
                }
                else {
                    line.push(row[it.attr] === undefined || row[it.attr] === null ? '' : row[it.attr]);
                }
            });
            lines.push(line.join(';'));
        });
        const el = document.createElement('a');
        el.setAttribute('href', `data:text/csv;charset=utf-8,${encodeURIComponent(lines.join('\n'))}`);
        const now = new Date();
        el.setAttribute('download', `${now.getFullYear()}_${(now.getMonth() + 1).toString().padStart(2, '0')}_${now.getDate().toString().padStart(2, '0')}_${this.props.oContext.adapterName}.${this.props.oContext.instance}_${this.props.attr}.csv`);
        el.style.display = 'none';
        document.body.appendChild(el);
        el.click();
        document.body.removeChild(el);
    }
    onImport(text) {
        const lines = text.split('\n').map((line) => line.replace('\r', '').trim());
        // the first line is header
        const { schema } = this.props;
        const header = lines
            .shift()
            .split(';')
            .filter(it => it && schema.items.find((it2) => it2.attr === it));
        const values = [];
        lines.forEach((line) => {
            const parts = line.split(';');
            const obj = {};
            for (let p = 0; p < parts.length; p++) {
                let value = parts[p];
                if (value.startsWith('"')) {
                    value = value.substring(1);
                    while (p < parts.length && !value.endsWith('"')) {
                        value += `;${parts[++p]}`;
                    }
                    value = value.substring(0, value.length - 1);
                }
                let val = value;
                if (value === 'true') {
                    val = true;
                }
                else if (value === 'false') {
                    val = false;
                }
                else if (window.isFinite(value)) {
                    const attr = this.props.schema.items.find((it) => it.attr === header[p]);
                    if (attr && attr.type === 'number') {
                        // if a type of attribute is a "number"
                        val = parseFloat(value);
                    }
                    else {
                        val = value;
                    }
                }
                else {
                    val = value;
                }
                obj[header[p]] = val;
            }
            values.push(obj);
        });
        if (values.length) {
            if (this.state.value?.length) {
                this.setState({ showTypeOfImportDialog: values, showImportDialog: false });
            }
            else {
                this.setState({ value: values, showImportDialog: false });
            }
        }
        else {
            window.alert('ra_No data found in file');
        }
    }
    onClone = (index) => () => {
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        const cloned = JSON.parse(JSON.stringify(newValue[index]));
        if (typeof this.props.schema.clone === 'string' && typeof cloned[this.props.schema.clone] === 'string') {
            let i = 1;
            let text = cloned[this.props.schema.clone];
            const pattern = text.match(/(\d+)$/);
            if (pattern) {
                text = text.replace(pattern[0], '');
                i = parseInt(pattern[0], 10) + 1;
            }
            else {
                text += '_';
            }
            while (newValue.find((it) => it[this.props.schema.clone] === text + i.toString())) {
                i++;
            }
            cloned[this.props.schema.clone] = `${cloned[this.props.schema.clone]}_${i}`;
        }
        newValue.splice(index, 0, cloned);
        this.setState({ value: newValue, iteration: this.state.iteration + 10000 }, () => this.applyFilter(false, null, () => this.onChangeWrapper(newValue)));
    };
    onChangeWrapper = (newValue, updateVisible) => {
        if (this.typingTimer) {
            clearTimeout(this.typingTimer);
        }
        this.typingTimer = setTimeout((value, _updateVisible) => {
            this.typingTimer = null;
            let mayBePromise;
            if (this.props.schema.encryptedAttributes) {
                const _value = JSON.parse(JSON.stringify(value));
                _value.forEach((el) => {
                    this.props.schema.encryptedAttributes.forEach((attr) => {
                        if (el[attr]) {
                            el[attr] = encrypt$1(this.secret, el[attr]);
                        }
                    });
                });
                if (this.props.schema.objKeyName) {
                    const objValue = arrayToObject(_value, this.props.schema.objKeyName, this.props.schema.objValueName);
                    mayBePromise = this.onChange(this.props.attr, objValue);
                }
                else {
                    mayBePromise = this.onChange(this.props.attr, _value);
                }
            }
            else if (this.props.schema.objKeyName) {
                const objValue = arrayToObject(JSON.parse(JSON.stringify(value)), this.props.schema.objKeyName, this.props.schema.objValueName);
                mayBePromise = this.onChange(this.props.attr, objValue);
            }
            else {
                mayBePromise = this.onChange(this.props.attr, value);
            }
            if (mayBePromise instanceof Promise) {
                mayBePromise.catch(e => console.error(`Cannot save: ${e}`));
            }
            if (_updateVisible) {
                this.applyFilter(false, value);
                this.handleRequestSort(this.state.orderBy, true);
            }
        }, 300, newValue, updateVisible);
    };
    onAdd = () => {
        const { schema } = this.props;
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        const newItem = schema.items?.reduce((accumulator, currentValue) => {
            let defaultValue;
            if (currentValue.defaultFunc) {
                if (this.props.custom) {
                    defaultValue = currentValue.defaultFunc
                        ? this.executeCustom(currentValue.defaultFunc, this.props.data, this.props.customObj, this.props.oContext.instanceObj, newValue.length, this.props.data)
                        : this.props.schema.default;
                }
                else {
                    defaultValue = currentValue.defaultFunc
                        ? this.execute(currentValue.defaultFunc, this.props.schema.default, this.props.data, newValue.length, this.props.data)
                        : this.props.schema.default;
                }
            }
            else {
                defaultValue = currentValue.default === undefined ? null : currentValue.default;
            }
            accumulator[currentValue.attr] = defaultValue;
            return accumulator;
        }, {});
        newValue.push(newItem);
        this.setState({ value: newValue }, () => this.applyFilter(false, null, () => this.onChangeWrapper(newValue)));
    };
    isAnyFilterSet() {
        return !!Object.keys(this.filterRefs).find(attr => ConfigTable.getFilterValue(this.filterRefs[attr]));
    }
    applyFilter = (clear, value, cb) => {
        value = value || this.state.value;
        let visibleValue = value.map((_, i) => i);
        Object.keys(this.filterRefs).forEach(attr => {
            let valueInputRef = ConfigTable.getFilterValue(this.filterRefs[attr]);
            if (!clear && valueInputRef) {
                valueInputRef = valueInputRef.toLowerCase();
                visibleValue = visibleValue.filter(idx => value[idx] && value[idx][attr] && value[idx][attr].toLowerCase().includes(valueInputRef));
            }
            else if (this.filterRefs[attr].current) {
                ConfigTable.setFilterValue(this.filterRefs[attr], '');
            }
        });
        if (visibleValue.length === value.length) {
            visibleValue = null;
        }
        if (visibleValue === null && this.state.visibleValue === null) {
            if (cb) {
                cb();
            }
            return;
        }
        if (JSON.stringify(visibleValue) !== JSON.stringify(this.state.visibleValue)) {
            this.setState({ visibleValue }, () => cb && cb());
        }
        else if (cb) {
            cb();
        }
    };
    onMoveUp(idx) {
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        const item = newValue[idx];
        newValue.splice(idx, 1);
        newValue.splice(idx - 1, 0, item);
        this.setState({ value: newValue, iteration: this.state.iteration + 10000 }, () => this.applyFilter(false, null, () => this.onChangeWrapper(newValue)));
    }
    onMoveDown(idx) {
        const newValue = JSON.parse(JSON.stringify(this.state.value));
        const item = newValue[idx];
        newValue.splice(idx, 1);
        newValue.splice(idx + 1, 0, item);
        this.setState({ value: newValue, iteration: this.state.iteration + 10000 }, () => this.applyFilter(false, null, () => this.onChangeWrapper(newValue)));
    }
    onDrop(acceptedFiles) {
        const file = acceptedFiles[0];
        const reader = new FileReader();
        reader.onabort = () => console.log('file reading was aborted');
        reader.onerror = () => console.log('file reading has failed');
        reader.onload = () => {
            if (file.size > MAX_SIZE) {
                window.alert(I18n$6.t('ra_File is too big. Max %sk allowed. Try use SVG.', Math.round(MAX_SIZE / 1024)));
                return;
            }
            const text = new Uint8Array(reader.result).reduce((data, byte) => data + String.fromCharCode(byte), '');
            this.onImport(text);
        };
        reader.readAsArrayBuffer(file);
    }
    showTypeOfImportDialog() {
        if (!this.state.showTypeOfImportDialog) {
            return null;
        }
        return (React$b.createElement(Dialog, { open: true, onClose: () => this.setState({ showTypeOfImportDialog: false }), maxWidth: "md" },
            React$b.createElement(DialogTitle, null, I18n$6.t('ra_Append or replace?')),
            React$b.createElement(DialogContent, null, I18n$6.t('ra_Append %s entries or replace existing?', this.state.showTypeOfImportDialog.length)),
            React$b.createElement(DialogActions, null,
                React$b.createElement(Button, { variant: "contained", color: "primary", autoFocus: true, onClick: () => {
                        const value = JSON.parse(JSON.stringify(this.state.value));
                        this.state.showTypeOfImportDialog.forEach((obj) => value.push(obj));
                        this.setState({
                            value,
                            iteration: this.state.iteration + 10000,
                            showTypeOfImportDialog: false,
                        }, () => this.applyFilter(false, null, () => this.onChangeWrapper(value)));
                    } }, I18n$6.t('ra_Append')),
                React$b.createElement(Button, { variant: "contained", color: "secondary", autoFocus: true, onClick: () => {
                        const value = this.state.showTypeOfImportDialog;
                        this.setState({
                            value,
                            iteration: this.state.iteration + 10000,
                            showTypeOfImportDialog: false,
                        }, () => this.applyFilter(false, null, () => this.onChangeWrapper(value)));
                    } }, I18n$6.t('ra_Replace')))));
    }
    showImportDialog() {
        if (!this.state.showImportDialog) {
            return null;
        }
        return (React$b.createElement(Dialog, { open: true, onClose: () => this.setState({ showImportDialog: false }), sx: {
                '& .MuiDialog-paper': {
                    minHeight: 500,
                },
            }, maxWidth: "md", fullWidth: true },
            React$b.createElement(DialogTitle, null, I18n$6.t('ra_Import from %s', 'CSV')),
            React$b.createElement(DialogContent, null,
                React$b.createElement(Dropzone, { multiple: false, accept: { 'text/csv': ['.csv'] }, maxSize: MAX_SIZE, onDragEnter: () => this.setState({ uploadFile: 'dragging' }), onDragLeave: () => this.setState({ uploadFile: true }), onDrop: (acceptedFiles, errors) => {
                        this.setState({ uploadFile: false });
                        if (!acceptedFiles.length) {
                            window.alert((errors &&
                                errors[0] &&
                                errors[0].errors &&
                                errors[0].errors[0] &&
                                errors[0].errors[0].message) ||
                                I18n$6.t('ra_Cannot upload'));
                        }
                        else {
                            this.onDrop(acceptedFiles);
                        }
                    } }, ({ getRootProps, getInputProps }) => (React$b.createElement("div", { style: {
                        ...styles$7.uploadDiv,
                        ...(this.state.uploadFile === 'dragging' ? styles$7.uploadDivDragging : undefined),
                        ...styles$7.dropZone,
                        ...(!this.state.icon ? styles$7.dropZoneEmpty : undefined),
                    }, ...getRootProps() },
                    React$b.createElement("input", { ...getInputProps() }),
                    React$b.createElement("div", { style: styles$7.uploadCenterDiv },
                        React$b.createElement("div", { style: styles$7.uploadCenterTextAndIcon },
                            React$b.createElement(ImportIcon, { style: styles$7.uploadCenterIcon }),
                            React$b.createElement("div", { style: styles$7.uploadCenterText }, this.state.uploadFile === 'dragging'
                                ? I18n$6.t('ra_Drop file here')
                                : I18n$6.t('ra_Place your files here or click here to open the browse dialog')))))))),
            React$b.createElement(DialogActions, null,
                React$b.createElement(Button, { variant: "contained", onClick: () => this.setState({ showImportDialog: false }), color: "primary", startIcon: React$b.createElement(IconClose, null) }, I18n$6.t('Cancel')))));
    }
    renderOneFilter(props) {
        return (React$b.createElement(TableCell, { key: `${props.headCell.attr}_${props.index}`, style: props.style, align: "left", sortDirection: props.orderBy === props.headCell.attr ? props.order : false },
            React$b.createElement("div", { style: {
                    ...styles$7.flex,
                    ...(props.schema.showFirstAddOnTop ? { flexDirection: 'column' } : undefined),
                } },
                props.showAddButton ? this.renderAddButton(props.doAnyFilterSet) : null,
                props.headCell.sort && (React$b.createElement(TableSortLabel, { active: true, style: props.orderBy !== props.headCell.attr ? styles$7.silver : undefined, direction: props.orderBy === props.headCell.attr ? props.order : 'asc', onClick: () => this.handleRequestSort(props.headCell.attr) })),
                props.headCell.filter && this.state.filterOn.includes(props.headCell.attr) ? (React$b.createElement(TextField$5, { variant: "standard", ref: this.filterRefs[props.headCell.attr], onChange: () => this.applyFilter(), title: I18n$6.t('ra_You can filter entries by entering here some text'), slotProps: {
                        input: {
                            endAdornment: ConfigTable.getFilterValue(this.filterRefs[props.headCell.attr]) && (React$b.createElement(InputAdornment$1, { position: "end" },
                                React$b.createElement(IconButton$4, { size: "small", tabIndex: -1, onClick: () => {
                                        ConfigTable.setFilterValue(this.filterRefs[props.headCell.attr], '');
                                        this.applyFilter();
                                    } },
                                    React$b.createElement(CloseIcon$1, null)))),
                        },
                    }, fullWidth: true, placeholder: this.getText(props.headCell.title) })) : (React$b.createElement("span", { style: styles$7.headerText }, this.getText(props.headCell.title))),
                this.renderShowHideFilter(props.headCell))));
    }
    enhancedFilterCard() {
        const { schema } = this.props;
        const { order, orderBy } = this.state;
        let tdStyle;
        if (this.props.schema.compact) {
            tdStyle = { paddingTop: 1, paddingBottom: 1 };
        }
        const importExportVisible = (!schema.noDelete && schema.import) || schema.export;
        if (importExportVisible || schema.items.find(item => item.sort || item.filter)) {
            return (React$b.createElement(Grid2$1, { size: {
                    xs: schema.xs || 12, // if xs is not defined, take the full width
                    sm: schema.sm || undefined,
                    md: schema.md || undefined,
                    lg: schema.lg || undefined,
                    xl: schema.xl || undefined,
                } },
                React$b.createElement(Card, null,
                    React$b.createElement(Paper, { style: styles$7.paper },
                        React$b.createElement(Accordion$1, { style: styles$7.paper },
                            React$b.createElement(AccordionSummary$1, { expandIcon: React$b.createElement(ExpandMoreIcon$1, null) },
                                React$b.createElement(Typography$1, null, I18n$6.t('ra_Filter and Data Actions'))),
                            React$b.createElement(AccordionDetails$1, null,
                                React$b.createElement(Table, null,
                                    React$b.createElement(TableBody, null,
                                        schema.items?.find(item => item.sort || item.filter) &&
                                            schema.items.map((headCell, i) => (React$b.createElement(TableRow, { key: `${headCell.attr}_${i}` }, this.renderOneFilter({
                                                schema,
                                                style: tdStyle,
                                                showAddButton: false,
                                                headCell,
                                                order,
                                                orderBy,
                                                index: i,
                                                doAnyFilterSet: false,
                                            })))),
                                        importExportVisible ? (React$b.createElement(TableRow, null,
                                            React$b.createElement(TableCell, { align: "left", style: tdStyle },
                                                React$b.createElement("span", { style: styles$7.headerText }, I18n$6.t('ra_Actions'))),
                                            React$b.createElement(TableCell, { style: tdStyle }, this.renderImportExportButtons(schema)))) : null))))))));
        }
        return null;
    }
    enhancedBottomCard() {
        const { schema } = this.props;
        let tdStyle;
        if (this.props.schema.compact) {
            tdStyle = { paddingTop: 1, paddingBottom: 1 };
        }
        const doAnyFilterSet = this.isAnyFilterSet();
        return (React$b.createElement(Grid2$1, { size: {
                xs: schema.xs || 12, // if xs is not defined, take the full width
                sm: schema.sm || undefined,
                md: schema.md || undefined,
                lg: schema.lg || undefined,
                xl: schema.xl || undefined,
            } },
            React$b.createElement(Card, null,
                React$b.createElement(Paper, { style: styles$7.paper },
                    React$b.createElement(Table, null,
                        React$b.createElement(TableBody, null,
                            React$b.createElement(TableRow, null,
                                React$b.createElement(TableCell, { colSpan: schema.items.length + 1, style: tdStyle }, this.renderAddButton(doAnyFilterSet)))))))));
    }
    renderCards() {
        const { schema } = this.props;
        let { visibleValue } = this.state;
        let tdStyle;
        if (this.props.schema.compact) {
            tdStyle = { paddingTop: 1, paddingBottom: 1 };
        }
        visibleValue ||= this.state.value.map((_, i) => i);
        const doAnyFilterSet = this.isAnyFilterSet();
        return (React$b.createElement(Grid2$1, { container: true },
            this.showImportDialog(),
            this.showTypeOfImportDialog(),
            this.enhancedFilterCard(),
            visibleValue.map((idx, i) => (React$b.createElement(Grid2$1, { key: `${idx}_${i}`, size: {
                    xs: schema.xs || 12, // if xs is not defined, take the full width
                    sm: schema.sm || undefined,
                    md: schema.md || undefined,
                    lg: schema.lg || undefined,
                    xl: schema.xl || undefined,
                } },
                React$b.createElement(Card, null,
                    React$b.createElement(Paper, { style: styles$7.paper },
                        React$b.createElement(Table, null,
                            React$b.createElement(TableBody, null,
                                schema.items?.map((headCell) => (React$b.createElement(TableRow, { key: `${headCell.attr}_${idx}` },
                                    React$b.createElement(TableCell, { align: "left", style: tdStyle },
                                        React$b.createElement("span", { style: styles$7.headerText }, this.getText(headCell.title))),
                                    React$b.createElement(TableCell, { align: "left", style: tdStyle }, this.itemTable(headCell.attr, this.state.value[idx], idx))))),
                                !schema.noDelete && (React$b.createElement(TableRow, null,
                                    React$b.createElement(TableCell, { align: "left", style: tdStyle },
                                        React$b.createElement("span", { style: styles$7.headerText }, this.getText('Actions'))),
                                    React$b.createElement(TableCell, { align: "left", style: tdStyle },
                                        !doAnyFilterSet && !this.state.orderBy ? (React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Move up'), slotProps: { popper: { sx: styles$7.tooltip } } },
                                            React$b.createElement("span", null,
                                                React$b.createElement(IconButton$4, { size: "small", onClick: () => this.onMoveUp(idx), disabled: i === 0 },
                                                    React$b.createElement(UpIcon, null))))) : null,
                                        !doAnyFilterSet && !this.state.orderBy ? (React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Move down'), slotProps: { popper: { sx: styles$7.tooltip } } },
                                            React$b.createElement("span", null,
                                                React$b.createElement(IconButton$4, { size: "small", onClick: () => this.onMoveDown(idx), disabled: i === visibleValue.length - 1 },
                                                    React$b.createElement(DownIcon, null))))) : null,
                                        React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Delete current row'), slotProps: { popper: { sx: styles$7.tooltip } } },
                                            React$b.createElement(IconButton$4, { size: "small", onClick: this.onDelete(idx) },
                                                React$b.createElement(DeleteIcon, null))),
                                        this.props.schema.clone ? (React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Clone current row'), slotProps: { popper: { sx: styles$7.tooltip } } },
                                            React$b.createElement(IconButton$4, { size: "small", onClick: this.onClone(idx) },
                                                React$b.createElement(CopyContentIcon, null)))) : null)))))))))),
            this.enhancedBottomCard()));
    }
    renderTable() {
        const { schema } = this.props;
        let { visibleValue } = this.state;
        visibleValue = visibleValue || this.state.value.map((_, i) => i);
        const doAnyFilterSet = this.isAnyFilterSet();
        let tdStyle;
        if (this.props.schema.compact) {
            tdStyle = { paddingTop: 1, paddingBottom: 1 };
        }
        return (React$b.createElement(Paper, { style: styles$7.paper },
            this.showImportDialog(),
            this.showTypeOfImportDialog(),
            schema.label ? (React$b.createElement("div", { style: styles$7.label },
                React$b.createElement(Toolbar$1, { variant: "dense", style: styles$7.rootTool },
                    React$b.createElement(Typography$1, { style: styles$7.title, variant: "h6", id: "tableTitle", component: "div" }, this.getText(schema.label))))) : null,
            React$b.createElement(TableContainer, null,
                React$b.createElement(Table, { style: styles$7.table, size: "small" },
                    this.enhancedTableHead(!doAnyFilterSet && !this.state.orderBy ? 120 : 64, doAnyFilterSet),
                    React$b.createElement(TableBody, null,
                        visibleValue.map((idx, i) => (React$b.createElement(TableRow, { hover: true, key: `${idx}_${i}` },
                            schema.items?.map((headCell) => (React$b.createElement(TableCell, { key: `${headCell.attr}_${idx}`, align: "left", style: tdStyle }, this.itemTable(headCell.attr, this.state.value[idx], idx)))),
                            !schema.noDelete && (React$b.createElement(TableCell, { align: "left", style: { ...tdStyle, ...styles$7.buttonCell } },
                                !doAnyFilterSet && !this.state.orderBy ? (i ? (React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Move up'), slotProps: { popper: { sx: styles$7.tooltip } } },
                                    React$b.createElement(IconButton$4, { size: "small", onClick: () => this.onMoveUp(idx) },
                                        React$b.createElement(UpIcon, null)))) : (React$b.createElement("div", { style: styles$7.buttonEmpty }))) : null,
                                !doAnyFilterSet && !this.state.orderBy ? (i < visibleValue.length - 1 ? (React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Move down'), slotProps: { popper: { sx: styles$7.tooltip } } },
                                    React$b.createElement(IconButton$4, { size: "small", onClick: () => this.onMoveDown(idx) },
                                        React$b.createElement(DownIcon, null)))) : (React$b.createElement("div", { style: styles$7.buttonEmpty }))) : null,
                                React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Delete current row'), slotProps: { popper: { sx: styles$7.tooltip } } },
                                    React$b.createElement(IconButton$4, { size: "small", onClick: this.onDelete(idx) },
                                        React$b.createElement(DeleteIcon, null))),
                                this.props.schema.clone ? (React$b.createElement(Tooltip$1, { title: I18n$6.t('ra_Clone current row'), slotProps: { popper: { sx: styles$7.tooltip } } },
                                    React$b.createElement(IconButton$4, { size: "small", onClick: this.onClone(idx) },
                                        React$b.createElement(CopyContentIcon, null)))) : null))))),
                        !schema.noDelete && visibleValue.length >= (schema.showSecondAddAt || 5) ? (React$b.createElement(TableRow, null,
                            React$b.createElement(TableCell, { colSpan: schema.items.length + 1, style: { ...tdStyle } }, this.renderAddButton(doAnyFilterSet)))) : null)),
                !visibleValue.length && this.state.value.length ? (React$b.createElement("div", { style: styles$7.filteredOut },
                    React$b.createElement(Typography$1, { style: styles$7.title, variant: "h6", id: "tableTitle", component: "div" },
                        I18n$6.t('ra_All items are filtered out'),
                        React$b.createElement(IconButton$4, { size: "small", onClick: () => this.applyFilter(true) },
                            React$b.createElement(CloseIcon$1, null))))) : null),
            schema.help ? (React$b.createElement(FormHelperText$1, { style: { paddingLeft: 16 } }, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null,
            this.state.errorMessage ? (React$b.createElement("div", { style: { display: 'flex', padding: '5px' } },
                React$b.createElement(ErrorIcon$1, { color: "error" }),
                React$b.createElement("span", { style: { color: 'red', alignSelf: 'center' } }, this.state.errorMessage))) : null));
    }
    componentDidUpdate() {
        if (this.refDiv.current?.clientWidth && this.refDiv.current.clientWidth !== this.state.width) {
            if (this.resizeTimeout) {
                clearTimeout(this.resizeTimeout);
            }
            this.resizeTimeout = setTimeout(() => {
                this.resizeTimeout = null;
                this.setState({ width: this.refDiv.current?.clientWidth });
            }, 50);
        }
    }
    getCurrentBreakpoint() {
        if (!this.state.width) {
            return 'md';
        }
        if (this.state.width < 600) {
            return 'xs';
        }
        if (this.state.width < 900) {
            return 'sm';
        }
        if (this.state.width < 1200) {
            return 'md';
        }
        if (this.state.width < 1536) {
            return 'lg';
        }
        return 'xl';
    }
    renderItem( /* error, disabled, defaultValue */) {
        const { schema } = this.props;
        if (!this.state.value || !Array.isArray(this.state.value)) {
            return null;
        }
        const currentBreakpoint = this.getCurrentBreakpoint();
        let content;
        if (currentBreakpoint && (schema.useCardFor || ['xs']).includes(currentBreakpoint)) {
            content = this.renderCards();
        }
        else {
            content = this.renderTable();
        }
        return (React$b.createElement("div", { ref: this.refDiv, style: { width: '100%' } }, content));
    }
}

const React$a = await importShared('react');

const {Autocomplete,TextField: TextField$4,TextareaAutosize,InputAdornment,IconButton: IconButton$3} = await importShared('@mui/material');

const {Close:CloseIcon} = await importShared('@mui/icons-material');

const {I18n: I18n$5,IconCopy: IconCopy$2,Utils: Utils$5} = await importShared('@iobroker/adapter-react-v5');
const styles$6 = {
    indeterminate: {
        opacity: 0.5,
    },
    label: {
        width: '100%',
        fontSize: 14,
        marginBottom: 2,
    },
    helper: {
        width: '100%',
        fontSize: 12,
    },
    error: {
        width: '100%',
        fontSize: 12,
        color: '#FF0000',
    },
};
class ConfigText extends ConfigGeneric {
    updateTimeout = null;
    componentDidMount() {
        super.componentDidMount();
        let value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        if (Array.isArray(value) && this.props.oContext.multiEdit) {
            value = ConfigGeneric.DIFFERENT_VALUE;
            this.setState({ value, oldValue: value, jsonError: false });
            return;
        }
        this.setState({ value, oldValue: value, jsonError: this.validateJson(value) });
    }
    validateJson(value) {
        let jsonError = false;
        if (this.props.schema.validateJson) {
            if (value || !this.props.schema.allowEmpty) {
                try {
                    JSON.parse(value);
                }
                catch (err) {
                    console.log('Error in JSON', err);
                    jsonError = true;
                }
            }
        }
        return jsonError;
    }
    static getDerivedStateFromProps(props, state) {
        if (props.oContext.multiEdit && state.value === ConfigGeneric.DIFFERENT_VALUE) {
            return { value: ConfigGeneric.DIFFERENT_VALUE };
        }
        let value = ConfigGeneric.getValue(props.data, props.attr);
        if (value !== null && value !== undefined) {
            value = value.toString();
        }
        if (value === null || value === undefined || (value !== state.value && value !== state.oldValue)) {
            return { value };
        }
        return null;
    }
    renderItem(error, disabled) {
        const isIndeterminate = Array.isArray(this.state.value) || this.state.value === ConfigGeneric.DIFFERENT_VALUE;
        if (this.props.schema.time) {
            // show read-only time
            let time = '';
            if (typeof this.state.value === 'number') {
                // If the value is a number, it is a timestamp.
                if (this.state.value && this.state.value < 946659600000) {
                    // If the value is less than 2000-01-01, it is a timestamp in seconds.
                    time = new Date(this.state.value * 1000).toLocaleString();
                }
                else {
                    time = new Date(this.state.value).toLocaleString();
                }
            }
            else if (typeof this.state.value === 'string') {
                // If the value is a string, it is a date string.
                time = new Date(this.state.value).toLocaleString();
            }
            return (React$a.createElement(TextField$4, { variant: "standard", fullWidth: true, value: time, error: !!error || !!this.state.jsonError, disabled: !!disabled, slotProps: {
                    htmlInput: {
                        readOnly: true,
                    },
                }, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }));
        }
        if (this.state.oldValue !== null && this.state.oldValue !== undefined) {
            if (this.updateTimeout) {
                clearTimeout(this.updateTimeout);
            }
            this.updateTimeout = setTimeout(() => {
                this.updateTimeout = null;
                this.setState({ oldValue: null });
            }, 30);
        }
        else if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
            this.updateTimeout = null;
        }
        if (isIndeterminate) {
            const autoCompleteOptions = ConfigGeneric.getValue(this.props.data, this.props.attr);
            const arr = autoCompleteOptions
                ?.filter((a) => a || a === 0)
                .map((item) => ({ label: item.toString() || '', value: item })) || [];
            arr.unshift({ label: I18n$5.t(ConfigGeneric.DIFFERENT_LABEL), value: ConfigGeneric.DIFFERENT_VALUE });
            return (React$a.createElement(Autocomplete, { style: styles$6.indeterminate, fullWidth: true, value: arr[0], 
                // getOptionSelected={(option, value) => option.label === value.label}
                onChange: (_, value) => {
                    const val = value ? value.value : '';
                    const mayBePromise = this.onChange(this.props.attr, val, () => {
                        this.setState({ value: val, oldValue: val, jsonError: this.validateJson(value) });
                    });
                    if (mayBePromise instanceof Promise) {
                        mayBePromise.catch(e => console.error(`Cannot set value: ${e}`));
                    }
                }, options: arr, getOptionLabel: option => option.label, renderInput: params => (React$a.createElement(TextField$4, { variant: "standard", ...params, error: !!error, placeholder: this.getText(this.props.schema.placeholder), slotProps: {
                        htmlInput: {
                            ...params.inputProps,
                            maxLength: this.props.schema.maxLength || this.props.schema.max || undefined,
                            readOnly: this.props.schema.readOnly || false,
                        },
                    }, label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation), disabled: !!disabled })) }));
        }
        let actionButton;
        let actionButtonStyle;
        if ((this.props.schema.readOnly || disabled) && this.props.schema.copyToClipboard) {
            if (this.props.schema.minRows > 1) {
                actionButtonStyle = {
                    position: 'absolute',
                    right: 3,
                    top: 20,
                    zIndex: 1000,
                };
            }
            actionButton = (React$a.createElement(IconButton$3, { tabIndex: -1, style: actionButtonStyle, size: "small", onClick: () => {
                    Utils$5.copyToClipboard(this.state.value);
                    window.alert(I18n$5.t('ra_Copied'));
                } },
                React$a.createElement(IconCopy$2, null)));
        }
        else if (!this.props.schema.readOnly && !disabled && this.state.value && !this.props.schema.noClearButton) {
            if (this.props.schema.minRows > 1) {
                actionButtonStyle = {
                    position: 'absolute',
                    right: 3,
                    top: 20,
                    zIndex: 1000,
                };
            }
            actionButton = (React$a.createElement(IconButton$3, { style: actionButtonStyle, size: "small", tabIndex: -1, onClick: () => this.setState({ value: '', oldValue: this.state.value }, () => this.onChange(this.props.attr, '')) },
                React$a.createElement(CloseIcon, null)));
            if (this.props.schema.minRows <= 1) {
                actionButton = React$a.createElement(InputAdornment, { position: "end" }, actionButton);
            }
        }
        if (this.props.schema.minRows > 1) {
            const helper = this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation);
            return (React$a.createElement("div", { style: { width: '100%', position: 'relative' } },
                this.props.schema.label ? (React$a.createElement("div", { style: styles$6.label }, this.getText(this.props.schema.label))) : null,
                React$a.createElement(TextareaAutosize
                // variant="standard"
                , { 
                    // variant="standard"
                    style: {
                        width: '100%',
                        resize: 'vertical',
                        backgroundColor: this.props.oContext.themeType === 'dark' ? '#363636' : '#cccccc',
                        color: this.props.oContext.themeType === 'dark' ? '#fff' : '#111',
                    }, minRows: this.props.schema.minRows, maxRows: this.props.schema.maxRows, value: this.state.value === null || this.state.value === undefined ? '' : this.state.value, disabled: !!disabled, readOnly: this.props.schema.readOnly || false, onChange: e => {
                        const value = e.target.value;
                        this.setState({ value, oldValue: this.state.value, jsonError: this.validateJson(value) }, () => this.onChange(this.props.attr, value || ''));
                    }, placeholder: this.getText(this.props.schema.placeholder) }),
                helper || error || this.state.jsonError ? (React$a.createElement("div", { style: error ? styles$6.error : styles$6.helper }, error || (this.state.jsonError ? I18n$5.t('ra_Invalid JSON') : helper))) : null));
        }
        return (React$a.createElement(TextField$4, { variant: "standard", fullWidth: true, value: this.state.value === null || this.state.value === undefined ? '' : this.state.value, error: !!error || !!this.state.jsonError, disabled: !!disabled, slotProps: {
                htmlInput: {
                    maxLength: this.props.schema.maxLength || this.props.schema.max || undefined,
                    readOnly: this.props.schema.readOnly || false,
                },
                input: {
                    endAdornment: actionButton,
                },
            }, onChange: e => {
                const value = e.target.value;
                this.setState({ value, oldValue: this.state.value, jsonError: this.validateJson(value) }, () => this.onChange(this.props.attr, value));
            }, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: this.state.jsonError
                ? I18n$5.t('ra_Invalid JSON')
                : this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }));
    }
}

const React$9 = await importShared('react');

const {TextField: TextField$3,IconButton: IconButton$2} = await importShared('@mui/material');

const {I18n: I18n$4,Icon: Icon$1,IconCopy: IconCopy$1,Utils: Utils$4} = await importShared('@iobroker/adapter-react-v5');
const styles$5 = {
    fullWidth: {
        width: '100%',
    },
};
class ConfigTextSendTo extends ConfigGeneric {
    initialized = false;
    localContext;
    askInstance() {
        if (this.props.alive) {
            let data = this.props.schema.data;
            if (data === undefined && this.props.schema.jsonData) {
                const dataStr = this.getPattern(this.props.schema.jsonData, null, true);
                try {
                    data = JSON.parse(dataStr);
                }
                catch {
                    console.error(`Cannot parse json data: ${dataStr}`);
                }
            }
            if (data === undefined) {
                data = null;
            }
            void this.props.oContext.socket
                .sendTo(`${this.props.oContext.adapterName}.${this.props.oContext.instance}`, this.props.schema.command || 'send', data)
                .then(result => {
                if (typeof result === 'object') {
                    const _data = result;
                    this.setState({
                        text: _data.text || '',
                        style: _data.style,
                        icon: _data.icon,
                        iconStyle: _data.iconStyle,
                    });
                }
                else if (typeof result === 'string') {
                    this.setState({ text: result || '' });
                }
            })
                .catch(e => console.error(`Cannot send command: ${e}`));
        }
    }
    getLocalContext() {
        const localContext = {};
        if (Array.isArray(this.props.schema.alsoDependsOn)) {
            this.props.schema.alsoDependsOn.forEach(attr => (localContext[attr] = ConfigGeneric.getValue(this.props.data, attr)));
        }
        return JSON.stringify(localContext);
    }
    renderItem( /* error, disabled, defaultValue */) {
        if (this.props.alive) {
            const localContext = this.getLocalContext();
            if (localContext !== this.localContext || !this.initialized) {
                this.localContext = localContext;
                setTimeout(() => this.askInstance(), this.initialized ? 300 : 50);
                this.initialized = true;
            }
        }
        if (this.state.text === undefined) {
            return null;
        }
        let icon = null;
        if (this.state.icon) {
            icon = getIconByName(this.state.icon, {
                marginRight: this.state.text ? 8 : undefined,
                ...(this.state.iconStyle || undefined),
            });
            if (!icon) {
                icon = (React$9.createElement(Icon$1, { src: this.state.icon, style: { marginRight: this.state.text ? 8 : undefined, ...(this.state.iconStyle || undefined) } }));
            }
        }
        if (this.props.schema.container === 'text') {
            return (React$9.createElement(TextField$3, { variant: "standard", fullWidth: true, slotProps: {
                    input: {
                        endAdornment: this.props.schema.copyToClipboard ? (React$9.createElement(IconButton$2, { tabIndex: -1, size: "small", onClick: () => {
                                Utils$4.copyToClipboard(this.state.text);
                                window.alert(I18n$4.t('ra_Copied'));
                            } },
                            React$9.createElement(IconCopy$1, null))) : undefined,
                    },
                }, value: this.state.text, label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }));
        }
        return (React$9.createElement("div", { style: { ...styles$5.fullWidth, ...(this.state.style || undefined) } },
            icon,
            this.props.schema.container === 'html' ? (React$9.createElement("span", { dangerouslySetInnerHTML: { __html: this.state.text || '' } })) : (this.state.text)));
    }
}

const React$8 = await importShared('react');
class ConfigTimePicker extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        this.setState({ value });
    }
    renderItem(_error, disabled) {
        // the format could be 'HH:mm:ss' or 'HH:mm'
        const shortFormat = this.props.schema.returnFormat !== 'HH:mm:ss';
        const value = new Date(Date.parse(`Thu, 01 Jan 1970 ${this.state.value || '00:00:00'}`));
        return (React$8.createElement(TimePicker, { sx: theme => ({
                width: '100%',
                borderBottom: `1px solid ${theme.palette.text.primary}`,
                '& fieldset': {
                    display: 'none',
                },
                '& input': {
                    padding: `${theme.spacing(1.5)} 0 4px 0`,
                },
                '& .MuiInputAdornment-root': {
                    marginLeft: 0,
                    marginTop: 1, // it is already in spaces
                },
                '& label': {
                    transform: 'translate(0px, -9px) scale(0.75)',
                },
            }), ampm: this.props.oContext.systemConfig.dateFormat.includes('/'), timeSteps: this.props.schema.timeSteps || this.props.schema.timesteps || { hours: 1, minutes: 5, seconds: 5 }, format: this.props.schema.format || 'HH:mm:ss', disabled: !!disabled, value: value, onChange: (newValue) => {
                let strValue;
                strValue =
                    newValue instanceof Date
                        ? newValue.toTimeString().split(' ')[0]
                        : newValue.toTimeString();
                if (shortFormat) {
                    strValue = strValue.split(':').slice(0, 2).join(':');
                }
                this.setState({ value: strValue }, () => this.onChange(this.props.attr, this.state.value));
            }, views: this.props.schema.views || ['hours', 'minutes', 'seconds'], label: this.getText(this.props.schema.label) }));
    }
}

const React$7 = await importShared('react');

const {TextField: TextField$2} = await importShared('@mui/material');
function convertID2Topic(id, namespace) {
    let topic;
    if (namespace && id.substring(0, namespace.length) === namespace) {
        topic = id.substring(namespace.length + 1);
    }
    else {
        topic = id;
    }
    topic = topic.replace(/\./g, '/').replace(/_/g, ' ');
    return topic;
}
class ConfigTopic extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        if (!value && this.props.customObj?._id) {
            const topic = convertID2Topic(this.props.customObj._id, `${this.props.oContext.adapterName}.${this.props.oContext.instance}`);
            this.setState({ value: topic });
        }
        else {
            this.setState({ value: value || '' });
        }
    }
    renderItem(error, disabled /* , defaultValue */) {
        return (React$7.createElement(TextField$2, { variant: "standard", fullWidth: true, slotProps: {
                htmlInput: {
                    maxLength: this.props.schema.maxLength || this.props.schema.max || undefined,
                },
            }, value: this.state.value, error: !!error, disabled: disabled, placeholder: this.getText(this.props.schema.placeholder), label: this.getText(this.props.schema.label), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation), onChange: e => {
                const value = e.target.value;
                this.setState({ value }, () => this.onChange(this.props.attr, value));
            } }));
    }
}

const React$6 = await importShared('react');

const {TextField: TextField$1,IconButton: IconButton$1} = await importShared('@mui/material');

const {ContentCopy:IconCopy} = await importShared('@mui/icons-material');

const {Utils: Utils$3,I18n: I18n$3} = await importShared('@iobroker/adapter-react-v5');
class ConfigUUID extends ConfigGeneric {
    async componentDidMount() {
        super.componentDidMount();
        const uuidObj = await this.props.oContext.socket.getObject('system.meta.uuid');
        this.setState({ uuid: uuidObj?.native?.uuid || 'unknown' });
    }
    renderItem(error, disabled) {
        return (React$6.createElement(TextField$1, { variant: "standard", fullWidth: true, error: !!error, disabled: !!disabled, slotProps: {
                htmlInput: { readOnly: true },
                input: {
                    endAdornment: (React$6.createElement(IconButton$1, { tabIndex: -1, onClick: () => {
                            Utils$3.copyToClipboard(this.state.uuid);
                            window.alert(I18n$3.t('ra_Copied %s', this.state.uuid));
                        } },
                        React$6.createElement(IconCopy, null))),
                },
            }, value: this.state.uuid || '', label: this.getText(this.props.schema.label) || I18n$3.t('ra_Serial number (UUID)'), helperText: this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation) }));
    }
}

const React$5 = await importShared('react');

const {InputLabel,TextField,MenuItem: MenuItem$1,FormHelperText,FormControl,Select} = await importShared('@mui/material');

const {Icon,Utils: Utils$2,I18n: I18n$2} = await importShared('@iobroker/adapter-react-v5');
const styles$4 = {
    icon: {
        width: 16,
        height: 16,
        marginRight: 8,
    },
};
class ConfigUser extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        this.props.oContext.socket
            .getUsers()
            .then(users => {
            const _users = {};
            const lang = I18n$2.getLanguage();
            if (this.props.schema.short) {
                users.forEach(user => (_users[user._id] = {
                    color: user.common?.color,
                    icon: user.common?.icon,
                    name: Utils$2.getObjectNameFromObj(user, lang),
                }));
            }
            else {
                users.forEach(user => (_users[user._id.replace(/^system\.user\./, '')] = {
                    color: user.common?.color,
                    icon: user.common?.icon,
                    name: Utils$2.getObjectNameFromObj(user, lang),
                }));
            }
            this.setState({ users: _users });
        })
            .catch(e => console.error(`Cannot get users: ${e}`));
    }
    renderItem(error, disabled /* , defaultValue */) {
        const value = ConfigGeneric.getValue(this.props.data, this.props.attr);
        return (React$5.createElement(FormControl, { variant: "standard", fullWidth: true },
            this.state.users && this.props.schema.label ? (React$5.createElement(InputLabel, null, this.getText(this.props.schema.label))) : null,
            !this.state.users ? (React$5.createElement(TextField, { variant: "standard", error: !!error, disabled: !!disabled, value: value, onChange: e => this.onChange(this.props.attr, e.target.value), label: this.getText(this.props.schema.label) })) : (React$5.createElement(Select, { variant: "standard", error: !!error, disabled: !!disabled, value: value, renderValue: val => (React$5.createElement("span", null,
                    this.state.users && this.state.users[val]?.icon ? (React$5.createElement(Icon, { src: this.state.users && this.state.users[val]?.icon, style: styles$4.icon })) : null,
                    (this.state.users && this.state.users[val]?.name) || val || '')), style: {
                    color: (this.state.users && this.state.users[value]?.color) || undefined,
                    backgroundColor: Utils$2.getInvertedColor(this.state.users && this.state.users[value]?.color, this.props.oContext.themeType),
                }, onChange: e => this.onChange(this.props.attr, e.target.value) }, this.state.users &&
                Object.keys(this.state.users).map(id => (React$5.createElement(MenuItem$1, { style: {
                        color: this.state.users[id].color || undefined,
                        backgroundColor: Utils$2.getInvertedColor(this.state.users[id].color, this.props.oContext.themeType),
                    }, key: id, value: id },
                    this.state.users[id].icon ? (React$5.createElement(Icon, { src: this.state.users[id].icon, style: styles$4.icon })) : null,
                    this.state.users[id].name))))),
            this.props.schema.help ? (React$5.createElement(FormHelperText, null, this.renderHelp(this.props.schema.help, this.props.schema.helpLink, this.props.schema.noTranslation))) : null));
    }
}

const scriptRel = (function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
})();const assetsURL = function(dep, importerUrl) { return new URL(dep, importerUrl).href };const seen = {};const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (true && deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i = links.length - 1; i >= 0; i--) {
            const link2 = links[i];
            if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};

const React$4 = await importShared('react');
class ConfigQrCode extends ConfigGeneric {
    async componentDidMount() {
        super.componentDidMount();
        // lazy load of qrcode
        const module = await __vitePreload(() => import('../index-BMomc5KY.js').then(n => n.i),true?[]:void 0,import.meta.url);
        this.setState({ QRCode: module.default });
    }
    renderItem() {
        const QRCodeComponent = this.state.QRCode;
        if (!QRCodeComponent) {
            return null;
        }
        return (React$4.createElement(QRCodeComponent, { value: this.props.schema.data, size: this.props.schema.size, fgColor: this.props.schema.fgColor, bgColor: this.props.schema.bgColor, level: this.props.schema.level }));
    }
}

const React$3 = await importShared('react');

const {Grid2,Accordion,AccordionSummary,AccordionDetails,Typography,Box: Box$1} = await importShared('@mui/material');

const {ExpandMore:ExpandMoreIcon} = await importShared('@mui/icons-material');

const {Utils: Utils$1} = await importShared('@iobroker/adapter-react-v5');
const components = {
    accordion: ConfigAccordion,
    alive: ConfigAlive,
    autocomplete: ConfigAutocomplete,
    autocompleteSendTo: ConfigAutocompleteSendTo,
    certCollection: ConfigCertCollection,
    certificate: ConfigCertificateSelect,
    certificates: ConfigCertificates,
    checkbox: ConfigCheckbox,
    checkDocker: ConfigCheckDocker,
    checkLicense: ConfigCheckLicense,
    chip: ConfigChip, // deprecated. Use "chips"
    chips: ConfigChip,
    color: ConfigColor,
    coordinates: ConfigCoordinates,
    cron: ConfigCRON,
    custom: ConfigCustom,
    datePicker: ConfigDatePicker,
    deviceManager: ConfigDeviceManager,
    divider: ConfigStaticDivider,
    file: ConfigFile,
    fileSelector: ConfigFileSelector,
    func: ConfigFunc,
    header: ConfigStaticHeader,
    image: ConfigImageUpload,
    imageSendTo: ConfigImageSendTo,
    infoBox: ConfigInfoBox,
    instance: ConfigInstanceSelect,
    interface: ConfigInterface,
    ip: ConfigIP,
    jsonEditor: ConfigJsonEditor,
    language: ConfigLanguage,
    license: ConfigLicense,
    number: ConfigNumber,
    oauth2: ConfigOAuth2,
    objectId: ConfigObjectId,
    password: ConfigPassword,
    pattern: ConfigPattern,
    port: ConfigPort,
    qrCode: ConfigQrCode,
    room: ConfigRoom,
    select: ConfigSelect,
    selectSendTo: ConfigSelectSendTo,
    // @deprecated Use "sendTo"
    sendto: ConfigSendto,
    sendTo: ConfigSendto,
    setState: ConfigSetState,
    slider: ConfigSlider,
    state: ConfigState,
    staticImage: ConfigStaticImage,
    staticInfo: ConfigStaticInfo,
    staticLink: ConfigStaticText,
    staticText: ConfigStaticText,
    table: ConfigTable,
    text: ConfigText,
    textSendTo: ConfigTextSendTo,
    timePicker: ConfigTimePicker,
    topic: ConfigTopic,
    uuid: ConfigUUID,
    user: ConfigUser,
};
const styles$3 = {
    fullWidth: {
        width: '100%',
        // height: '100%',
    },
    paper: {
        margin: 1,
        width: 'auto !important',
        overflowY: 'auto',
        paddingBottom: 1,
    },
    paperWithIcons: {
        height: 'calc(100vh - 259px) !important',
    },
    paperWithoutIcons: {
        height: 'calc(100vh - 235px) !important',
    },
    padding: {
        padding: '10px',
    },
    heading: {},
    primary: (theme) => ({
        backgroundColor: theme.palette.primary.main,
        color: theme.palette.mode === 'dark' ? 'inherit' : '#FFF',
    }),
    secondary: (theme) => ({
        backgroundColor: theme.palette.secondary.main,
    }),
};
class ConfigPanel extends ConfigGeneric {
    componentDidMount() {
        super.componentDidMount();
        if (this.props.schema?.collapsable) {
            this.setState({
                expanded: (window._localStorage || window.localStorage).getItem(`${this.props.oContext.adapterName}.${this.props.attr}`) === 'true',
            });
        }
    }
    renderItems(items, disabled) {
        return items
            ? Object.keys(items).map(attr => {
                if (this.props.oContext.multiEdit && items[attr].noMultiEdit) {
                    return null;
                }
                const type = items[attr].type || 'panel';
                let ItemComponent;
                let socket = 'Use this.props.oContext.socket!';
                if (type === 'custom') {
                    // name
                    // url
                    if (items[attr].url) {
                        ItemComponent = ConfigCustom;
                    }
                    else if (this.props.oContext.customs && this.props.oContext.customs[items[attr].component]) {
                        ItemComponent = this.props.oContext.customs[items[attr].component];
                    }
                    else {
                        console.error(`Cannot find custom component: ${items[attr].component}`);
                        ItemComponent = ConfigGeneric;
                    }
                    socket = this.props.oContext.socket;
                }
                else if (type === 'panel') {
                    ItemComponent = ConfigPanel;
                }
                else {
                    ItemComponent = components[type] || ConfigGeneric;
                }
                return (React$3.createElement(ItemComponent
                // @ts-expect-error Temporary work-around, till all custom components will not migrate to oContext
                , { 
                    // @ts-expect-error Temporary work-around, till all custom components will not migrate to oContext
                    socket: socket, globalData: this.props.globalData, oContext: this.props.oContext, key: `${attr}_${this.props.index === undefined ? '' : this.props.index}`, index: this.props.index, changed: this.props.changed, arrayIndex: this.props.arrayIndex, expertMode: this.props.expertMode, commandRunning: this.props.commandRunning, style: styles$3.panel, common: this.props.common, alive: this.props.alive, themeName: this.props.themeName, data: this.props.data, originalData: this.props.originalData, onError: this.props.onError, onChange: this.props.onChange, disabled: disabled, customObj: this.props.customObj, custom: this.props.custom, schema: items[attr], attr: attr, table: this.props.table }));
            })
            : null;
    }
    render() {
        const schema = this.props.schema;
        if (!schema) {
            return null;
        }
        const { disabled, hidden } = this.calculate(schema);
        const items = this.props.schema.items;
        const schemaStyle = this.props.schema.style || {};
        if (hidden) {
            if (schema.hideOnlyControl) {
                const item = (React$3.createElement(Grid2, { size: {
                        xs: schema.xs || undefined,
                        sm: schema.sm || undefined,
                        md: schema.md || undefined,
                        lg: schema.lg || undefined,
                        xl: schema.xl || undefined,
                    }, sx: Utils$1.getStyle(this.props.oContext.theme, { marginBottom: 0, textAlign: 'left' /* marginRight: 8, */ }, schemaStyle, this.props.oContext.themeType === 'dark' && schema.darkStyle) }));
                if (schema.newLine) {
                    return (React$3.createElement(React$3.Fragment, null,
                        React$3.createElement("div", { style: { flexBasis: '100%', height: 0 } }),
                        item));
                }
                return item;
            }
            return null;
        }
        if (this.props.table) {
            return this.renderItems(items, disabled);
        }
        if (this.props.custom) {
            return (React$3.createElement(Grid2, { key: `${this.props.attr}_${this.props.index}`, container: true, style: styles$3.fullWidth, columnSpacing: 2, rowSpacing: 1, sx: schemaStyle }, this.renderItems(items, disabled)));
        }
        let content;
        if (schema.collapsable) {
            content = (React$3.createElement(Accordion, { key: `${this.props.attr}_${this.props.index}`, style: styles$3.fullWidth, expanded: !!this.state.expanded, onChange: () => {
                    (window._localStorage || window.localStorage).setItem(`${this.props.oContext.adapterName}.${this.props.attr}`, this.state.expanded ? 'false' : 'true');
                    this.setState({ expanded: !this.state.expanded });
                } },
                React$3.createElement(AccordionSummary, { expandIcon: React$3.createElement(ExpandMoreIcon, null), sx: Utils$1.getStyle(this.props.oContext.theme, schemaStyle, this.props.oContext.themeType && schema.darkStyle, schema.color === 'primary'
                        ? styles$3.primary
                        : schema.color === 'secondary' && styles$3.secondary, { width: '100%' }) },
                    React$3.createElement(Typography, { style: styles$3.heading }, this.getText(schema.label))),
                React$3.createElement(AccordionDetails, null,
                    React$3.createElement(Grid2, { container: true, columnSpacing: 2, rowSpacing: 1, sx: { ...schemaStyle, width: '100%', padding: '10px' } }, this.renderItems(items, disabled)))));
        }
        else {
            const sx = Utils$1.getStyle(this.props.oContext.theme, this.props.style, schemaStyle, { width: '100%' }, this.props.isParentTab && styles$3.paper, this.props.isParentTab &&
                (this.props.withoutSaveButtons
                    ? this.props.withIcons
                        ? { height: 'calc(100% - 88px) !important' }
                        : { height: 'calc(100% - 64px) !important' }
                    : this.props.withIcons
                        ? styles$3.paperWithIcons
                        : styles$3.paperWithoutIcons));
            content = (React$3.createElement(Box$1, { component: "div", key: `${this.props.attr}_${this.props.index}`, className: this.props.className, sx: sx },
                React$3.createElement(Grid2, { container: true, columnSpacing: 2, rowSpacing: 1, sx: Utils$1.getStyle(this.props.oContext.theme, { width: '100%' }, this.props.isParentTab && styles$3.padding, this.props.schema.innerStyle) }, this.renderItems(items, disabled))));
        }
        if (!this.props.isParentTab) {
            const item = (React$3.createElement(Grid2, { title: this.getText(schema.tooltip), size: {
                    xs: schema.xs || undefined,
                    sm: schema.sm || undefined,
                    md: schema.md || undefined,
                    lg: schema.lg || undefined,
                    xl: schema.xl || undefined,
                }, sx: { marginBottom: 0, /* marginRight: 8, */ textAlign: 'left', ...schemaStyle } }, content));
            if (schema.newLine) {
                return (React$3.createElement(React$3.Fragment, null,
                    React$3.createElement("div", { style: { flexBasis: '100%', height: 0 } }),
                    item));
            }
            return item;
        }
        return content;
    }
}

const React$2 = await importShared('react');

const {Tabs,Tab,IconButton,Toolbar,Menu,MenuItem,ListItemIcon,Box} = await importShared('@mui/material');

const {Menu:MenuIcon,Error:ErrorIcon} = await importShared('@mui/icons-material');
const styles$2 = {
    tabs: {
        height: '100%',
        width: '100%',
    },
    panel: {
        width: '100%',
        display: 'block',
    },
    panelWithIcons: {
        height: 'calc(100% - 72px)',
    },
    panelWithoutIcons: {
        height: 'calc(100% - 48px)',
    },
};
class ConfigTabs extends ConfigGeneric {
    resizeTimeout = null;
    refDiv;
    constructor(props) {
        super(props);
        let tab;
        if (this.props.root) {
            // read the path from hash
            // #tab-instances/config/system.adapter.ping.0/<TAB-NAME-OR-INDEX>
            const hash = (window.location.hash || '').replace(/^#/, '').split('/');
            if (hash.length >= 3 && hash[1] === 'config') {
                const tabS = hash[3];
                const tabN = parseInt(tabS, 10);
                if (tabS && tabN.toString() === tabS) {
                    if (tabN >= 0 && tabN < Object.keys(this.props.schema.items).length) {
                        tab = Object.keys(this.props.schema.items)[tabN];
                    }
                }
                else if (tabS && Object.keys(this.props.schema.items).includes(tabS)) {
                    tab = tabS;
                }
                // install on hash change handler
                window.addEventListener('hashchange', this.onHashTabsChanged, false);
            }
        }
        if (tab === undefined) {
            tab =
                (window._localStorage || window.localStorage).getItem(`${this.props.dialogName || 'App'}.${this.props.oContext.adapterName}`) || Object.keys(this.props.schema.items)[0];
            if (!Object.keys(this.props.schema.items).includes(tab)) {
                tab = Object.keys(this.props.schema.items)[0];
            }
        }
        this.refDiv = React$2.createRef();
        Object.assign(this.state, { tab, width: 0, openMenu: null, tabErrors: {} });
    }
    onTabError = (attr, error) => {
        const currentTab = this.state.tab;
        if (!currentTab) {
            // Forward to parent if no current tab
            this.props.onError(attr, error);
            return;
        }
        const newTabErrors = { ...this.state.tabErrors };
        if (!newTabErrors[currentTab]) {
            newTabErrors[currentTab] = {};
        }
        if (!error) {
            delete newTabErrors[currentTab][attr];
            // Clean up empty tab error objects
            if (Object.keys(newTabErrors[currentTab]).length === 0) {
                delete newTabErrors[currentTab];
            }
        }
        else {
            newTabErrors[currentTab][attr] = error;
        }
        this.setState({ tabErrors: newTabErrors });
        // Also forward to parent
        this.props.onError(attr, error);
    };
    hasTabErrors = (tabName) => {
        return !!(this.state.tabErrors[tabName] && Object.keys(this.state.tabErrors[tabName]).length > 0);
    };
    componentWillUnmount() {
        if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = null;
        }
        window.removeEventListener('hashchange', this.onHashTabsChanged, false);
        super.componentWillUnmount();
    }
    onHashTabsChanged = () => {
        const hash = (window.location.hash || '').replace(/^#/, '').split('/');
        if (hash.length > 3 && hash[1] === 'config') {
            const tabS = hash[3];
            const tabN = parseInt(tabS, 10);
            let tab;
            if (tabN.toString() === tabS) {
                if (tabN >= 0 && tabN < Object.keys(this.props.schema.items).length) {
                    tab = Object.keys(this.props.schema.items)[tabN];
                }
            }
            else if (Object.keys(this.props.schema.items).includes(tabS)) {
                tab = tabS;
            }
            if (tab !== undefined && tab !== this.state.tab) {
                (window._localStorage || window.localStorage).setItem(`${this.props.dialogName || 'App'}.${this.props.oContext.adapterName}`, tab);
                this.setState({ tab });
            }
        }
    };
    getCurrentBreakpoint() {
        if (!this.state.width) {
            return 'md';
        }
        if (!this.state.initialBreakpoint) {
            let initialBreakpoint;
            if (this.state.width < 600) {
                initialBreakpoint = 'xs';
            }
            else if (this.state.width < 900) {
                initialBreakpoint = 'sm';
            }
            else if (this.state.width < 1200) {
                initialBreakpoint = 'md';
            }
            else if (this.state.width < 1536) {
                initialBreakpoint = 'lg';
            }
            else {
                initialBreakpoint = 'xl';
            }
            // Remember initial breakpoint and do not change it anymore
            setTimeout(() => {
                this.setState({ initialBreakpoint });
            }, 50);
            return initialBreakpoint;
        }
        return this.state.initialBreakpoint;
    }
    componentDidUpdate() {
        if (!this.state.initialBreakpoint &&
            this.refDiv.current?.clientWidth &&
            this.refDiv.current.clientWidth !== this.state.width) {
            if (this.resizeTimeout) {
                clearTimeout(this.resizeTimeout);
            }
            this.resizeTimeout = setTimeout(() => {
                this.resizeTimeout = null;
                this.setState({ width: this.refDiv.current?.clientWidth });
            }, 50);
        }
    }
    onMenuChange(tab) {
        (window._localStorage || window.localStorage).setItem(`${this.props.dialogName || 'App'}.${this.props.oContext.adapterName}`, tab);
        this.setState({ tab }, () => {
            if (this.props.root) {
                const hash = (window.location.hash || '').split('/');
                if (hash.length >= 3 && hash[1] === 'config') {
                    hash[3] = this.state.tab;
                    window.location.hash = hash.join('/');
                }
            }
        });
    }
    render() {
        const items = this.props.schema.items;
        let withIcons = false;
        const elements = [];
        Object.keys(items).map(name => {
            let disabled;
            if (items[name].expertMode && !this.props.expertMode) {
                return;
            }
            if (this.props.custom) {
                const hidden = this.executeCustom(items[name].hidden, this.props.data, this.props.customObj, this.props.oContext.instanceObj, this.props.index, this.props.globalData);
                if (hidden) {
                    return;
                }
                disabled = this.executeCustom(items[name].disabled, this.props.data, this.props.customObj, this.props.oContext.instanceObj, this.props.index, this.props.globalData);
            }
            else {
                const hidden = this.execute(items[name].hidden, false, this.props.data, this.props.index, this.props.globalData);
                if (hidden) {
                    return;
                }
                disabled = this.execute(items[name].disabled, false, this.props.data, this.props.index, this.props.globalData);
            }
            const icon = this.getIcon(items[name].icon);
            withIcons = withIcons || !!icon;
            elements.push({ icon, disabled, label: this.getText(items[name].label), name });
        });
        if (!elements.find(item => item.name === this.state.tab)) {
            // Select the first tab if the current tab is not available
            setTimeout(() => this.setState({ tab: elements[0].name }), 50);
        }
        const currentBreakpoint = this.getCurrentBreakpoint();
        let tabs;
        if (currentBreakpoint === 'xs' && elements.length > 2) {
            tabs = (React$2.createElement(Toolbar, { style: {
                    top: 2,
                    backgroundColor: this.props.oContext.themeType === 'dark' ? '#222' : '#DDD',
                }, variant: "dense" },
                React$2.createElement(IconButton, { onClick: (event) => this.setState({ openMenu: event.currentTarget }) },
                    React$2.createElement(MenuIcon, null)),
                this.state.openMenu ? (React$2.createElement(Menu, { open: true, anchorEl: this.state.openMenu, onClose: () => this.setState({ openMenu: null }) }, elements.map(el => {
                    const hasErrors = this.hasTabErrors(el.name);
                    return (React$2.createElement(MenuItem, { disabled: el.disabled, key: el.name, onClick: () => {
                            this.setState({ openMenu: null }, () => this.onMenuChange(el.name));
                        }, selected: el.name === this.state.tab, sx: hasErrors ? { color: 'error.main' } : undefined },
                        withIcons ? React$2.createElement(ListItemIcon, null, el.icon) : null,
                        React$2.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 0.5, width: '100%' } },
                            el.label,
                            hasErrors && React$2.createElement(ErrorIcon, { sx: { fontSize: 16, color: 'error.main' } }))));
                }))) : null));
        }
        else {
            tabs = (React$2.createElement(Tabs, { variant: "scrollable", scrollButtons: "auto", style: this.props.schema.tabsStyle, value: this.state.tab, onChange: (_e, tab) => this.onMenuChange(tab) }, elements.map(el => {
                const hasErrors = this.hasTabErrors(el.name);
                const label = hasErrors ? (React$2.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 0.5 } },
                    el.label,
                    React$2.createElement(ErrorIcon, { sx: { fontSize: 16, color: 'error.main' } }))) : (el.label);
                return (React$2.createElement(Tab, { id: el.name, wrapped: true, disabled: el.disabled, key: el.name, value: el.name, iconPosition: this.props.schema.iconPosition || 'start', icon: el.icon, label: label, sx: hasErrors ? { '& .MuiTab-wrapper': { color: 'error.main' } } : undefined }));
            })));
        }
        return (React$2.createElement("div", { style: styles$2.tabs, ref: this.refDiv },
            tabs,
            React$2.createElement(ConfigPanel, { oContext: this.props.oContext, withoutSaveButtons: this.props.withoutSaveButtons, isParentTab: true, changed: this.props.changed, key: this.state.tab, expertMode: this.props.expertMode, index: 1001, arrayIndex: this.props.arrayIndex, globalData: this.props.globalData, commandRunning: this.props.commandRunning, style: {
                    ...styles$2.panel,
                    ...(withIcons ? styles$2.panelWithIcons : styles$2.panelWithoutIcons),
                }, common: this.props.common, alive: this.props.alive, themeName: this.props.themeName, data: this.props.data, originalData: this.props.originalData, onChange: this.props.onChange, onError: this.onTabError, customObj: this.props.customObj, custom: this.props.custom, schema: items[this.state.tab], table: this.props.table, withIcons: withIcons })));
    }
}

const React$1 = await importShared('react');
const {Component} = React$1;

const {LinearProgress: LinearProgress$1} = await importShared('@mui/material');

const {I18n: I18n$1} = await importShared('@iobroker/adapter-react-v5');
const styles$1 = {
    root: {
        width: '100%',
        height: '100%',
    },
};
class JsonConfigComponent extends Component {
    forceUpdateHandlers;
    errorTimeout = null;
    errorCached = null;
    oContext;
    constructor(props) {
        super(props);
        this.state = {
            originalData: JSON.stringify(this.props.data),
            changed: false,
            errors: {},
            updateData: this.props.updateData || 0,
            systemConfig: null,
            alive: false,
            commandRunning: false,
            schema: JSON.parse(JSON.stringify(this.props.schema)),
        };
        this.forceUpdateHandlers = {};
        this.buildDependencies(this.state.schema);
        this.readData();
    }
    static getDerivedStateFromProps(props, state) {
        if (props.updateData !== state.updateData) {
            return {
                updateData: props.updateData,
                originalData: JSON.stringify(props.data),
                schema: JSON.parse(JSON.stringify(props.schema)),
            };
        }
        return null;
    }
    static async loadI18n(socket, i18n, adapterName) {
        if (i18n === true || (i18n && typeof i18n === 'string')) {
            const lang = I18n$1.getLanguage();
            const path = typeof i18n === 'string' ? i18n : 'i18n';
            let exists = await socket.fileExists(`${adapterName}.admin`, `${path}/${lang}.json`);
            let fileName;
            if (exists) {
                fileName = `${path}/${lang}.json`;
            }
            else {
                exists = await socket.fileExists(`${adapterName}.admin`, `${path}/${lang}/translations.json`);
                if (exists) {
                    fileName = `${path}/${lang}/translations.json`;
                }
                else if (lang !== 'en') {
                    // fallback to english
                    exists = await socket.fileExists(`${adapterName}.admin`, `${path}/en.json`);
                    if (exists) {
                        fileName = `${path}/en.json`;
                    }
                    else {
                        exists = await socket.fileExists(`${adapterName}.admin`, `${path}/en/translations.json`);
                        if (exists) {
                            fileName = `${path}/en/translations.json`;
                        }
                    }
                }
            }
            if (fileName) {
                const jsonFile = await socket.readFile(`${adapterName}.admin`, fileName);
                let jsonStr;
                if (jsonFile.file !== undefined) {
                    jsonStr = jsonFile.file;
                }
                else {
                    // @ts-expect-error deprecated
                    jsonStr = jsonFile;
                }
                try {
                    const json = JSON.parse(jsonStr);
                    // apply file to I18n
                    I18n$1.extendTranslations(json, lang);
                }
                catch (e) {
                    console.error(`Cannot parse language file "${adapterName}.admin/${fileName}: ${e}`);
                    return '';
                }
                return fileName;
            }
            console.warn(`Cannot find i18n for ${adapterName} / ${fileName}`);
            return '';
        }
        if (i18n && typeof i18n === 'object') {
            I18n$1.extendTranslations(i18n);
            return '';
        }
        return '';
    }
    onCommandRunning = (commandRunning) => this.setState({ commandRunning });
    readData() {
        void this.props.socket
            .getCompactSystemConfig()
            .then(systemConfig => this.props.socket
            .getState(`system.adapter.${this.props.adapterName}.${this.props.instance}.alive`)
            .then(state => this.setState({ systemConfig: systemConfig.common, alive: !!(state && state.val) }, () => {
            this.updateContext(true);
            if (!this.props.custom) {
                void this.props.socket.subscribeState(`system.adapter.${this.props.adapterName}.${this.props.instance}.alive`, this.onAlive);
            }
        })))
            .catch(e => console.error(`Cannot read system config: ${e}`));
    }
    onAlive = (_id, state) => {
        if (!!state?.val !== this.state.alive) {
            this.setState({ alive: !!state?.val });
        }
    };
    onChange = (attrOrData, value, cb, saveConfig) => {
        if (this.props.onValueChange) {
            this.props.onValueChange(attrOrData, value, saveConfig);
            if (cb) {
                cb();
            }
        }
        else if (attrOrData && this.props.onChange) {
            const newState = {
                changed: JSON.stringify(attrOrData) !== this.state.originalData,
            };
            this.setState(newState, () => {
                this.props.onChange(attrOrData, newState.changed, saveConfig);
                if (cb) {
                    cb();
                }
            });
        }
        else if (saveConfig) {
            this.props.onChange(null, null, saveConfig);
        }
    };
    onError = (attr, error) => {
        this.errorCached = this.errorCached || JSON.parse(JSON.stringify(this.state.errors));
        const errors = this.errorCached;
        if (error) {
            errors[attr] = error;
        }
        else {
            delete errors[attr];
        }
        if (this.errorTimeout) {
            clearTimeout(this.errorTimeout);
        }
        if (JSON.stringify(errors) !== JSON.stringify(this.state.errors)) {
            this.errorTimeout = setTimeout(() => this.setState({ errors: this.errorCached }, () => {
                this.errorTimeout = null;
                this.errorCached = null;
                this.props.onError(!!Object.keys(this.state.errors).length);
            }), 50);
        }
        else {
            this.errorCached = null;
        }
    };
    flatten(schema, _list) {
        _list = _list || {};
        if (schema.items) {
            Object.keys(schema.items).forEach(attr => {
                _list[attr] = schema.items[attr];
                this.flatten(schema.items[attr], _list);
            });
        }
        return _list;
    }
    buildDependencies(schema) {
        const attrs = this.flatten(schema);
        Object.keys(attrs).forEach(attr => {
            if (attrs[attr].confirm?.alsoDependsOn) {
                attrs[attr].confirm?.alsoDependsOn.forEach((dep) => {
                    if (!attrs[dep]) {
                        console.error(`[JsonConfigComponent] Attribute ${dep} does not exist!`);
                        if (dep.startsWith('data.')) {
                            console.warn(`[JsonConfigComponent] please use "${dep.replace(/^data\./, '')}" instead of "${dep}"`);
                        }
                    }
                    else {
                        attrs[dep].confirmDependsOn = attrs[dep].confirmDependsOn || [];
                        const depObj = { ...attrs[attr], attr };
                        if (depObj.confirm) {
                            depObj.confirm.cancel = 'Undo';
                        }
                        attrs[dep].confirmDependsOn.push(depObj);
                    }
                });
            }
            if (attrs[attr].onChange?.alsoDependsOn) {
                attrs[attr].onChange?.alsoDependsOn.forEach((dep) => {
                    if (!attrs[dep]) {
                        console.error(`[JsonConfigComponent] Attribute ${dep} does not exist!`);
                        if (dep.startsWith('data.')) {
                            console.warn(`[JsonConfigComponent] please use "${dep.replace(/^data\./, '')}" instead of "${dep}"`);
                        }
                    }
                    else {
                        attrs[dep].onChangeDependsOn = attrs[dep].onChangeDependsOn || [];
                        const depObj = { ...attrs[attr], attr };
                        attrs[dep].onChangeDependsOn.push(depObj);
                    }
                });
            }
            if (attrs[attr].hidden?.alsoDependsOn) {
                attrs[attr].hidden?.alsoDependsOn.forEach((dep) => {
                    if (!attrs[dep]) {
                        console.error(`[JsonConfigComponent] Attribute ${dep} does not exist!`);
                        if (dep.startsWith('data.')) {
                            console.warn(`[JsonConfigComponent] please use "${dep.replace(/^data\./, '')}" instead of "${dep}"`);
                        }
                    }
                    else {
                        attrs[dep].hiddenDependsOn = attrs[dep].hiddenDependsOn || [];
                        const depObj = { ...attrs[attr], attr };
                        attrs[dep].hiddenDependsOn.push(depObj);
                    }
                });
            }
            if (attrs[attr].label?.alsoDependsOn) {
                attrs[attr].label?.alsoDependsOn.forEach((dep) => {
                    if (!attrs[dep]) {
                        console.error(`[JsonConfigComponent] Attribute ${dep} does not exist!`);
                        if (dep.startsWith('data.')) {
                            console.warn(`[JsonConfigComponent] please use "${dep.replace(/^data\./, '')}" instead of "${dep}"`);
                        }
                    }
                    else {
                        attrs[dep].labelDependsOn = attrs[dep].labelDependsOn || [];
                        const depObj = { ...attrs[attr], attr };
                        attrs[dep].labelDependsOn.push(depObj);
                    }
                });
            }
            if (attrs[attr].help?.alsoDependsOn) {
                attrs[attr].help?.alsoDependsOn.forEach((dep) => {
                    if (!attrs[dep]) {
                        console.error(`[JsonConfigComponent] Attribute ${dep} does not exist!`);
                        if (dep.startsWith('data.')) {
                            console.warn(`[JsonConfigComponent] please use "${dep.replace(/^data\./, '')}" instead of "${dep}"`);
                        }
                    }
                    else {
                        attrs[dep].helpDependsOn = attrs[dep].helpDependsOn || [];
                        const depObj = { ...attrs[attr], attr };
                        attrs[dep].helpDependsOn.push(depObj);
                    }
                });
            }
        });
    }
    updateContext(forceUpdate) {
        this.oContext = {
            DeviceManager: this.props.DeviceManager,
            adapterName: this.props.adapterName,
            changeLanguage: this.changeLanguage,
            common: this.props.common,
            customs: this.props.customs,
            dateFormat: this.props.dateFormat,
            embedded: this.props.embedded,
            forceUpdate: this.forceAttrUpdate,
            imagePrefix: this.props.imagePrefix,
            instance: this.props.instance,
            instanceObj: this.props.instanceObj,
            isFloatComma: this.props.isFloatComma,
            multiEdit: this.props.multiEdit,
            onBackEndCommand: this.props.onBackEndCommand,
            onCommandRunning: this.onCommandRunning,
            onValueChange: this.props.onValueChange,
            registerOnForceUpdate: this.registerOnForceUpdate,
            socket: this.props.socket,
            systemConfig: this.state.systemConfig,
            theme: this.props.theme,
            // could be changed dynamically
            themeType: this.props.themeType,
            _themeName: this.props.themeName,
            updateData: this.state.updateData,
        };
        if (forceUpdate) {
            this.forceUpdate();
        }
    }
    renderItem(item) {
        if (item.type === 'tabs') {
            return (React$1.createElement(ConfigTabs, { withoutSaveButtons: this.props.withoutSaveButtons, oContext: this.oContext, alive: this.state.alive, changed: this.state.changed, commandRunning: this.state.commandRunning, common: this.props.common, custom: this.props.custom, customObj: this.props.customObj, data: this.props.data, onChange: this.onChange, onError: (attr, error) => this.onError(attr, error), originalData: JSON.parse(this.state.originalData), root: true, schema: item, expertMode: this.props.expertMode, themeName: this.props.themeName }));
        }
        if (item.type === 'panel' ||
            // @ts-expect-error type could be empty
            !item.type) {
            return (React$1.createElement(ConfigPanel, { withoutSaveButtons: this.props.withoutSaveButtons, oContext: this.oContext, alive: this.state.alive, changed: this.state.changed, commandRunning: this.state.commandRunning, common: this.props.common, custom: this.props.custom, customObj: this.props.customObj, data: this.props.data, expertMode: this.props.expertMode, index: 1000, isParentTab: !this.props.embedded && !this.props.withoutSaveButtons, onChange: this.onChange, onError: (attr, error) => this.onError(attr, error), originalData: JSON.parse(this.state.originalData), root: true, schema: item, themeName: this.props.themeName }));
        }
        console.error(`Unknown item type in root: ${JSON.stringify(item)}`);
        return null;
    }
    changeLanguage = () => {
        this.forceUpdate();
    };
    forceAttrUpdate = (attr, data) => {
        if (Array.isArray(attr)) {
            attr.forEach(a => this.forceUpdateHandlers[a] && this.forceUpdateHandlers[a](data));
        }
        else if (this.forceUpdateHandlers[attr]) {
            this.forceUpdateHandlers[attr](data);
        }
    };
    registerOnForceUpdate = (attr, cb) => {
        if (cb) {
            this.forceUpdateHandlers[attr] = cb;
        }
        else if (this.forceUpdateHandlers[attr]) {
            delete this.forceUpdateHandlers[attr];
        }
    };
    render() {
        if (!this.state.systemConfig || !this.oContext) {
            return React$1.createElement(LinearProgress$1, null);
        }
        if (this.oContext._themeName !== this.props.themeName) {
            this.oContext._themeName = this.props.themeName;
            setTimeout(() => this.updateContext(true), 0);
        }
        return (React$1.createElement("div", { style: {
                ...(!this.props.embedded || this.props.withoutSaveButtons ? styles$1.root : undefined),
                ...this.props.style,
                ...this.state.schema.style,
            } }, this.renderItem(this.state.schema)));
    }
}

const React = await importShared('react');
const {Fab,Tooltip,LinearProgress} = await importShared('@mui/material');

const {Publish:PublishIcon} = await importShared('@mui/icons-material');

const {I18n,Router,SaveCloseButtons,Theme,DialogConfirm,Utils} = await importShared('@iobroker/adapter-react-v5');
const styles = {
    root: {
        width: '100%',
        height: '100%',
        overflow: 'hidden',
        position: 'relative',
    },
    scroll: {
        height: 'calc(100% - 48px)',
        overflowY: 'auto',
    },
    exportImportButtons: {
        position: 'absolute',
        top: 5,
        right: 0,
        zIndex: 3,
    },
    button: {
        marginRight: '5px',
    },
    tooltip: {
        pointerEvents: 'none',
    },
};
/**
 * Decrypt the password/value with given key
 *
 * @param key - Secret key
 * @param value - value to decrypt
 */
function decryptLegacy(key, value) {
    let result = '';
    for (let i = 0; i < value.length; i++) {
        result += String.fromCharCode(key[i % key.length].charCodeAt(0) ^ value.charCodeAt(i));
    }
    return result;
}
/**
 * Encrypt the password/value with given key
 *
 * @param key - Secret key
 * @param value - value to encrypt
 */
function encryptLegacy(key, value) {
    let result = '';
    for (let i = 0; i < value.length; i++) {
        result += String.fromCharCode(key[i % key.length].charCodeAt(0) ^ value.charCodeAt(i));
    }
    return result;
}
/**
 * Decrypt the password/value with given key
 *  Usage:
 *  ```js
 *     function load(settings, onChange) {
 *          if (settings.password) {
 *              settings.password = decrypt(systemSecret, settings.password);
 *              // same as
 *              settings.password = decrypt(settings.password);
 *          }
 *          // ...
 *     }
 *  ```
 *
 * @param key - Secret key
 * @param value - value to decrypt
 */
function decrypt(key, value) {
    if (typeof value !== 'string') {
        return value;
    }
    // if not encrypted as aes-192 or key not a valid 48-digit hex -> fallback
    if (!value.startsWith('$/aes-192-cbc:') || !/^[0-9a-f]{48}$/.test(key)) {
        return decryptLegacy(key, value);
    }
    // algorithm:iv:encryptedValue
    const textParts = value.split(':', 3);
    const _key = window.CryptoJS.enc.Hex.parse(key);
    const iv = window.CryptoJS.enc.Hex.parse(textParts[1]);
    const cipherParams = window.CryptoJS.lib.CipherParams.create({
        ciphertext: window.CryptoJS.enc.Hex.parse(textParts[2]),
    });
    const decryptedBinary = window.CryptoJS.AES.decrypt(cipherParams, _key, { iv });
    return window.CryptoJS.enc.Utf8.stringify(decryptedBinary);
}
/**
 * Encrypt the password/value with given key
 *  Usage:
 *  ```
 *     function save(callback) {
 *          ...
 *          if (obj.password) {
 *              obj.password = encrypt(systemSecret, obj.password);
 *              // same as
 *              obj.password = decrypt(obj.password);
 *          }
 *          ...
 *    }
 *  ```
 *
 * @param key - Secret key
 * @param value - value to encrypt
 * @param _iv - optional initial vector for tests
 */
function encrypt(key, value, _iv) {
    if (typeof value !== 'string') {
        return value;
    }
    if (!/^[0-9a-f]{48}$/.test(key)) {
        // key length is not matching for AES-192-CBC or key is no valid hex - fallback to old encryption
        return encryptLegacy(key, value);
    }
    let iv;
    {
        iv = window.CryptoJS.lib.WordArray.random(128 / 8);
    }
    const _key = window.CryptoJS.enc.Hex.parse(key);
    const encrypted = window.CryptoJS.AES.encrypt(value, _key, { iv }).ciphertext;
    return `$/aes-192-cbc:${window.CryptoJS.enc.Hex.stringify(iv)}:${encrypted}`;
}
function loadScript(src, id) {
    if (!document.getElementById(id)) {
        return new Promise(resolve => {
            const script = document.createElement('script');
            script.setAttribute('id', id);
            script.onload = resolve;
            script.src = src;
            document.getElementsByTagName('head')[0].appendChild(script);
        });
    }
    return document.getElementById(id)?.onload;
}
let JsonConfig$1 = class JsonConfig extends Router {
    fileSubscribed = [];
    fileLangSubscribed = '';
    secret;
    constructor(props) {
        super(props);
        this.state = {
            updateData: 0,
            changed: false,
            confirmDialog: false,
            theme: Theme(props.themeName), // buttons require special theme
            saveConfigDialog: false,
            hash: '_',
        };
        this.secret = props.secret || '';
        void this.getInstanceObject().then(obj => this.getConfigFile().then(schema => 
        // load language
        JsonConfigComponent.loadI18n(this.props.socket, schema?.i18n, this.props.adapterName).then((langFileName) => {
            if (langFileName) {
                // subscribe on changes
                if (!this.fileLangSubscribed) {
                    this.fileLangSubscribed = langFileName;
                    void this.props.socket.subscribeFiles(`${this.props.adapterName}.admin`, this.fileLangSubscribed, this.onFileChange);
                }
            }
            if (obj) {
                this.setState({
                    schema,
                    data: obj.native,
                    common: obj.common,
                    hash: MD5(JSON.stringify(schema)).toString(),
                });
            }
            else {
                window.alert(`Instance system.adapter.${this.props.adapterName}.${this.props.instance} not found!`);
            }
        })));
    }
    componentWillUnmount() {
        super.componentWillUnmount();
        if (this.fileSubscribed.length) {
            this.props.socket.unsubscribeFiles(`${this.props.adapterName}.admin`, this.fileSubscribed, this.onFileChange);
            this.fileSubscribed = [];
        }
        if (this.fileLangSubscribed) {
            this.props.socket.unsubscribeFiles(`${this.props.adapterName}.admin`, this.fileLangSubscribed, this.onFileChange);
            this.fileLangSubscribed = '';
        }
    }
    handleFileSelect = (evt) => {
        const f = evt.target.files[0];
        if (f) {
            const r = new FileReader();
            r.onload = (e) => {
                if (!e.target) {
                    return;
                }
                const contents = e.target.result;
                try {
                    const data = JSON.parse(contents);
                    this.setState({ data, changed: JSON.stringify(data) !== JSON.stringify(this.state.originalData) });
                }
                catch {
                    window.alert(I18n.t('[JsonConfig] Failed to parse JSON file'));
                }
            };
            r.readAsText(f);
        }
        else {
            window.alert(I18n.t('[JsonConfig] Failed to open JSON File'));
        }
    };
    getExportImportButtons() {
        return (React.createElement("div", { style: styles.exportImportButtons },
            React.createElement(Tooltip, { title: this.props.t('Import settings from JSON file'), slotProps: { popper: { sx: styles.tooltip } } },
                React.createElement(Fab, { size: "small", sx: { '&.MuiFab-root': styles.button }, onClick: () => {
                        const input = document.createElement('input');
                        input.setAttribute('type', 'file');
                        input.setAttribute('id', 'files');
                        // @ts-expect-error check
                        input.setAttribute('opacity', 0);
                        input.addEventListener('change', e => this.handleFileSelect(e), false);
                        input.click();
                    } },
                    React.createElement(PublishIcon, null))),
            React.createElement(Tooltip, { title: this.props.t('Export setting to JSON file'), slotProps: { popper: { sx: styles.tooltip } } },
                React.createElement(Fab, { size: "small", sx: { '&.MuiFab-root': styles.button }, onClick: () => {
                        if (!this.state.data) {
                            return;
                        }
                        Utils.generateFile(`${this.props.adapterName}.${this.props.instance}.json`, this.state.data);
                    } },
                    React.createElement(PublishIcon, { style: { transform: 'rotate(180deg)' } })))));
    }
    onFileChange = async (id, fileName, size) => {
        if (id === `${this.props.adapterName}.admin` && size) {
            if (fileName === this.fileLangSubscribed) {
                try {
                    await JsonConfigComponent.loadI18n(this.props.socket, this.state.schema?.i18n, this.props.adapterName);
                    this.setState({ hash: `${this.state.hash}1` });
                }
                catch {
                    // ignore errors
                }
            }
            else if (this.fileSubscribed.includes(fileName)) {
                try {
                    const schema = await this.getConfigFile(this.fileSubscribed[0]);
                    this.setState({ schema, hash: MD5(JSON.stringify(schema)).toString() });
                }
                catch {
                    // ignore errors
                }
            }
        }
    };
    async getInstanceObject() {
        try {
            const obj = await this.props.socket.getObject(`system.adapter.${this.props.adapterName}.${this.props.instance}`);
            // decode all native attributes listed in obj.encryptedNative
            if (Array.isArray(obj.encryptedNative)) {
                if (!this.secret) {
                    const systemConfig = await this.props.socket.getSystemConfig();
                    await loadScript('../../lib/js/crypto-js/crypto-js.js', 'crypto-js');
                    this.secret = systemConfig.native.secret;
                }
                obj.encryptedNative?.forEach(attr => {
                    if (obj.native[attr]) {
                        obj.native[attr] = decrypt(this.secret, obj.native[attr]);
                    }
                });
                return obj;
            }
            return obj;
        }
        catch (e) {
            window.alert(`[JsonConfig] Cannot read instance object: ${e}`);
        }
        return null;
    }
    renderDialogConfirm() {
        if (!this.state.confirmDialog) {
            return null;
        }
        return (React.createElement(DialogConfirm, { title: I18n.t('ra_Please confirm'), text: I18n.t('ra_Some data are not stored. Discard?'), ok: I18n.t('ra_Discard'), cancel: I18n.t('ra_Cancel'), onClose: (isYes) => this.setState({ confirmDialog: false }, () => isYes && Router.doNavigate(null)) }));
    }
    async scanForInclude(json, filePaths) {
        if (typeof json['#include'] === 'string') {
            // load file
            const data = await this._getConfigFile(json['#include'], [...filePaths]);
            delete json['#include'];
            if (data) {
                // merge data
                json = { ...json, ...data };
            }
            return json;
        }
        const keys = Object.keys(json);
        for (let k = 0; k < keys.length; k++) {
            if (json[keys[k]] && typeof json[keys[k]] === 'object') {
                json[keys[k]] = await this.scanForInclude(json[keys[k]], filePaths);
            }
        }
        return json;
    }
    async getConfigFile(fileName) {
        return this._getConfigFile(fileName);
    }
    async _getConfigFile(fileName, _filePaths) {
        fileName = fileName || 'jsonConfig.json5';
        _filePaths = _filePaths || [];
        if (_filePaths.includes(fileName)) {
            window.alert(`[JsonConfig] Circular reference in file: ${fileName} => ${_filePaths.join(' => ')}`);
            return null;
        }
        _filePaths.push(fileName);
        try {
            const exist = await this.props.socket.fileExists(`${this.props.adapterName}.admin`, fileName);
            if (!exist) {
                fileName = 'jsonConfig.json';
            }
            const data = await this.props.socket.readFile(`${this.props.adapterName}.admin`, fileName);
            let content = '';
            let file = '';
            if (data.file !== undefined) {
                file = data.file;
            }
            if (typeof file === 'string') {
                content = file;
                // @ts-expect-error revisit
            }
            else if (file.type === 'Buffer') {
                let binary = '';
                // @ts-expect-error revisit
                const bytes = new Uint8Array(file.data);
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                content = binary;
            }
            // subscribe on changes
            if (!this.fileSubscribed.includes(fileName)) {
                this.fileSubscribed.push(fileName);
                await this.props.socket.subscribeFiles(`${this.props.adapterName}.admin`, fileName, this.onFileChange);
            }
            try {
                // detect #include attr
                return (await this.scanForInclude(lib$1.parse(content), _filePaths));
            }
            catch (e) {
                window.alert('[JsonConfig] Cannot parse json5 config!');
                console.log(e);
            }
        }
        catch (e1) {
            if (!this.state.schema) {
                window.alert(`[JsonConfig] Cannot read file "${fileName}: ${e1}`);
            }
        }
        return null;
    }
    renderSaveConfigDialog() {
        if (!this.state.saveConfigDialog) {
            return null;
        }
        return (React.createElement(DialogConfirm, { title: I18n.t('ra_Please confirm'), text: I18n.t('Save configuration?'), ok: I18n.t('ra_Save'), cancel: I18n.t('ra_Cancel'), onClose: (isYes) => this.setState({ saveConfigDialog: false }, () => isYes && this.onSave(true)) }));
    }
    findAttr(attr, schema) {
        schema = schema || this.state.schema;
        if (schema?.items) {
            if (attr in schema.items) {
                return schema.items[attr];
            }
            for (const _item of Object.values(schema.items)) {
                const item = this.findAttr(attr, _item);
                if (item) {
                    return item;
                }
            }
        }
        return null;
    }
    // this function is called recursively and trims all text fields, that must be trimmed
    postProcessing(data, attr, schema) {
        schema = schema || this.state.schema;
        if (!data) {
            // should not happen
            console.error(`Data is empty in postProcessing: ${attr}, ${JSON.stringify(schema)}`);
            return;
        }
        const dataAttr = data[attr];
        if (schema.items) {
            if (schema.type === 'table') {
                const table = dataAttr;
                if (!Array.isArray(table)) {
                    return;
                }
                for (const entry of table) {
                    for (const tItem of schema.items) {
                        this.postProcessing(entry, tItem.attr, tItem);
                    }
                }
            }
            else {
                for (const [_attr, item] of Object.entries(schema.items)) {
                    if (item.type === 'panel' ||
                        item.type === 'tabs' ||
                        item.type === 'accordion') {
                        return;
                    }
                    this.postProcessing(data, _attr, item);
                }
            }
        }
        else if (attr && typeof dataAttr === 'string') {
            // postprocessing
            if (schema.type === 'text') {
                if (schema.trim !== false) {
                    data[attr] = dataAttr.trim();
                }
            }
            else if (schema.type === 'ip') {
                // should not happen
                data[attr] = dataAttr.trim();
            }
            else if (schema.type === 'number') {
                const dataVal = parseFloat(dataAttr.toString().replace(',', '.'));
                if (schema.min !== undefined && dataVal < schema.min) {
                    data[attr] = schema.min;
                }
                else if (schema.max !== undefined && dataVal > schema.max) {
                    data[attr] = schema.max;
                }
                else {
                    data[attr] = dataVal;
                }
            }
            else if (schema.type === 'port') {
                const dataVal = parseInt(dataAttr.toString(), 10);
                if (schema.min !== undefined && dataVal < schema.min) {
                    data[attr] = schema.min;
                }
                else if (schema.max !== undefined && dataVal > schema.max) {
                    data[attr] = schema.max;
                }
                if (data[attr] !== 0 && dataVal < 20) {
                    data[attr] = 20;
                }
                else if (dataVal > 0xffff) {
                    data[attr] = 0xffff;
                }
                else {
                    data[attr] = dataVal;
                }
            }
            else if (schema.type === 'checkbox') {
                // should not happen
                data[attr] =
                    data[attr] === true ||
                        data[attr] === 'true' ||
                        data[attr] === 'on' ||
                        data[attr] === 1 ||
                        data[attr] === '1';
            }
        }
    }
    async onSave(doSave, close) {
        if (doSave) {
            const obj = await this.getInstanceObject();
            if (!obj) {
                console.error('Something went wrong: may be no connection?');
                window.alert('Something went wrong: may be no connection?');
                return;
            }
            if (!this.state.data || !this.state.schema) {
                return;
            }
            const doNotSaveAttributes = {};
            for (const attr of Object.keys(this.state.data)) {
                const item = this.findAttr(attr);
                if ((!item || !item.doNotSave || item.type === 'state') && !attr.startsWith('_')) {
                    ConfigGeneric.setValue(obj.native, attr, this.state.data[attr]);
                }
                else {
                    ConfigGeneric.setValue(obj.native, attr, null);
                    doNotSaveAttributes[attr] = this.state.data[attr];
                }
            }
            try {
                const encryptedObj = JSON.parse(JSON.stringify(obj));
                // encode all native attributes listed in obj.encryptedNative
                if (Array.isArray(encryptedObj.encryptedNative)) {
                    await loadScript('../../lib/js/crypto-js/crypto-js.js', 'crypto-js');
                    for (const attr of encryptedObj.encryptedNative) {
                        if (encryptedObj.native[attr]) {
                            encryptedObj.native[attr] = encrypt(this.secret, encryptedObj.native[attr]);
                        }
                    }
                }
                await this.props.socket.setObject(encryptedObj._id, encryptedObj);
            }
            catch (e) {
                window.alert(`[JsonConfig] Cannot set object: ${e}`);
            }
            /** We want to preserve the doNotSaveAttributes too, just not save it */
            const nativeWithNonSaved = { ...obj.native, ...doNotSaveAttributes };
            console.log(nativeWithNonSaved);
            this.setState({
                changed: false,
                data: nativeWithNonSaved,
                updateData: this.state.updateData + 1,
                originalData: nativeWithNonSaved,
            }, () => close && Router.doNavigate(null));
        }
        else if (this.state.changed) {
            this.setState({ confirmDialog: true });
        }
        else {
            Router.doNavigate(null);
        }
    }
    componentDidUpdate(_prevProps, prevState) {
        if (prevState.changed !== this.state.changed) {
            this.props.configStored(!this.state.changed);
        }
    }
    /**
     * Validate the JSON config once on mount
     */
    async componentDidMount() {
        const link = `${window.location.protocol}//${window.location.host}${window.location.pathname}validate_config/${this.props.adapterName}`;
        console.log(`fetch ${link}`);
        await fetch(link);
    }
    render() {
        if (!this.state.data || !this.state.schema) {
            return React.createElement(LinearProgress, null);
        }
        return (React.createElement("div", { style: styles.root },
            this.renderDialogConfirm(),
            this.getExportImportButtons(),
            this.renderSaveConfigDialog(),
            React.createElement(JsonConfigComponent, { key: this.state.hash, style: styles.scroll, socket: this.props.socket, themeName: this.props.themeName, themeType: this.props.themeType, adapterName: this.props.adapterName, instance: this.props.instance, isFloatComma: this.props.isFloatComma, dateFormat: this.props.dateFormat, schema: this.state.schema, common: this.state.common, expertMode: this.props.expertMode, data: this.state.data, updateData: this.state.updateData, onError: error => this.setState({ error }), onChange: (data, changed, saveConfigDialog) => {
                    if (saveConfigDialog && this.state.error) {
                        window.alert(I18n.t('Cannot save configuration because of error in configuration'));
                        saveConfigDialog = false;
                    }
                    if (saveConfigDialog && !this.state.changed && !changed) {
                        saveConfigDialog = false;
                    }
                    if (data) {
                        this.setState({ data, changed, saveConfigDialog });
                    }
                    else if (saveConfigDialog !== undefined) {
                        this.setState({ saveConfigDialog });
                    }
                }, DeviceManager: this.props.DeviceManager, theme: this.state.theme }),
            React.createElement(SaveCloseButtons, { isIFrame: false, dense: true, paddingLeft: 0, newReact: true, theme: this.state.theme, noTextOnButtons: this.props.width === 'xs' || this.props.width === 'sm' || this.props.width === 'md', changed: !!(this.state.error || this.state.changed), error: !!this.state.error, onSave: (close) => this.onSave(true, close), onClose: () => this.onSave(false) })));
    }
};

export { ConfigGeneric, ConfigPanel, JsonConfig$1 as JsonConfig, JsonConfigComponent };
